//
// This is the grammar specification from the Final Draft of the generic spec.
//
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2007 IBM Corporation.
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Eclipse Public License v1.0
// which accompanies this distribution, and is available at
// http://www.eclipse.org/legal/epl-v10.html
//
//Contributors:
//    Philippe Charles (pcharles@us.ibm.com) - initial API and implementation

////////////////////////////////////////////////////////////////////////////////

package java


    //#line 128 "btParserTemplateF.gi
 
import (
. "github.com/A-LPG/LPG-go-runtime/lpg2"
)

    //#line 18 "GJavaParser.g



    //#line 136 "btParserTemplateF.gi

type  JavaParser  struct{
    prsStream   *PrsStream
    btParser *BacktrackingParser
    unimplementedSymbolsWarning  bool
    prsTable  ParseTable
}
func NewJavaParser(lexStream ILexStream) (*JavaParser,error){
    my := new(JavaParser)
    my.prsTable = &JavaParserprs{}
    my.prsStream =  NewPrsStream(lexStream)
    my.unimplementedSymbolsWarning  = false
    var e error
    my.btParser,e =  NewBacktrackingParser(nil, my.prsTable,  my,nil) 
    if e == nil{
        if lexStream != nil{
            err := my.Reset(lexStream)
            if err != nil {
                return nil, err
            }
        }
        return  my,nil
    }
    var _,ok = e.(*NotBacktrackParseTableException)
    if ok{
        e = NewNotBacktrackParseTableException("Regenerate %prs_type.go with -BACKTRACK option")
        return  nil,e
    }
    _,ok = e.(*BadParseSymFileException)
    if ok{
        e= NewBadParseSymFileException("Bad Parser Symbol File -- %sym_type.go")
        return  nil,e
    }
    return nil,e
}
    

func (my *JavaParser)  GetParseTable() ParseTable{ 
    return my.prsTable 
}

func (my *JavaParser)  GetParser() *BacktrackingParser{
    return my.btParser 
}

func (my *JavaParser)  SetResult( object interface{}) {
    my.btParser.SetSym1(object)
}
func (my *JavaParser) GetRhsSym(i int) interface{} { 
    return my.btParser.GetSym(i) 
}

func (my *JavaParser)  GetRhsTokenIndex(i int)int {
    return my.btParser.GetToken(i)
    }
func (my *JavaParser)  GetRhsIToken(i int) IToken{
    return my.prsStream.GetIToken(my.GetRhsTokenIndex(i)) 
}

func (my *JavaParser)  GetRhsFirstTokenIndex(i int)int { 
return my.btParser.GetFirstTokenAt(i)
    }
func (my *JavaParser)  GetRhsFirstIToken(i int) IToken{
    return my.prsStream.GetIToken(my.GetRhsFirstTokenIndex(i)) 
    }

func (my *JavaParser)  GetRhsLastTokenIndex(i int)int {
    return my.btParser.GetLastTokenAt(i) 
    }
func (my *JavaParser)  GetRhsLastIToken(i int) IToken{ 
return my.prsStream.GetIToken(my.GetRhsLastTokenIndex(i)) 
}

func (my *JavaParser)  GetLeftSpan() int{ 
    return my.btParser.GetFirstToken() 
}
func (my *JavaParser)  GetLeftIToken() IToken {
    return my.prsStream.GetIToken(my.GetLeftSpan())
}

func (my *JavaParser)  GetRightSpan() int{
    return my.btParser.GetLastToken() 
}
func (my *JavaParser)  GetRightIToken()IToken {
    return my.prsStream.GetIToken(my.GetRightSpan())
}

func (my *JavaParser)  GetRhsErrorTokenIndex(i int)int{
    var index = my.btParser.GetToken(i)
    var err = my.prsStream.GetIToken(index)
    var _,ok = err.(*ErrorToken)
    if ok {
        return index
    }else{
        return 0
    }
}
func (my *JavaParser)  GetRhsErrorIToken(i int) *ErrorToken{
    var index = my.btParser.GetToken(i)
    var err = my.prsStream.GetIToken(index)
    var token,_ = err.(*ErrorToken)
    return token
}

func (my *JavaParser)  Reset(lexStream ILexStream ) error{
    my.prsStream = NewPrsStream(lexStream)
    err := my.btParser.Reset(my.prsStream,nil,nil,nil)
    if err != nil {
        return err
    }
    var ex = my.prsStream.RemapTerminalSymbols(my.OrderedTerminalSymbols(), my.prsTable.GetEoftSymbol())
    if ex == nil{
        return nil
    }
    var _,ok = ex.(*NullExportedSymbolsException)
    if ok {
        return ex
    }
    _,ok = ex.(*NullTerminalSymbolsException)
    if ok {
        return ex
    }
    var e *UnimplementedTerminalsException
    e,ok = ex.(*UnimplementedTerminalsException)
    if ok {
        if my.unimplementedSymbolsWarning {
            var unimplemented_symbols = e.GetSymbols()
            println("The Lexer will not scan the following token(s):")
            var i int = 0
            for ; i < unimplemented_symbols.Size() ;i++{
                var id = unimplemented_symbols.Get(i)
                println("    " + JavaParsersym.OrderedTerminalSymbols[id])
            }
            println()
        }
        return  ex
    }
    _,ok = ex.(*UndefinedEofSymbolException)
    if ok {
        return NewUndefinedEofSymbolException("The Lexer does not implement the Eof symbol " +
        JavaParsersym.OrderedTerminalSymbols[my.prsTable.GetEoftSymbol()])
    }
    return ex
}


func (my *JavaParser)  NumTokenKinds()int {
        return JavaParsersym.NumTokenKinds 
}
func (my *JavaParser)  OrderedTerminalSymbols()[]string {
    return JavaParsersym.OrderedTerminalSymbols
}
func (my *JavaParser)  GetTokenKindName(kind int) string{
        return JavaParsersym.OrderedTerminalSymbols[kind] 
}
func (my *JavaParser)  GetEOFTokenKind() int{
    return my.prsTable.GetEoftSymbol()
    }
func (my *JavaParser)  GetIPrsStream() IPrsStream{
    return my.prsStream
    }
func (my *JavaParser) Parser() (interface{}, error) {
    return my.ParserWithMonitor(0,nil)
}
func (my *JavaParser) ParserWithMonitor(error_repair_count int ,  monitor Monitor) (interface{}, error){

    my.btParser.SetMonitor(monitor)
    
    var ast,ex= my.btParser.FuzzyParseEntry(0, error_repair_count)
    if ex == nil{
        return ast,ex
    }
    var e,ok= ex.(*BadParseException)
    if ok{
        my.prsStream.ResetTo(e.ErrorToken) // point to error token

        var diagnoseParser = NewDiagnoseParser(my.prsStream, my.prsTable,0,0,nil)
        diagnoseParser.Diagnose(e.ErrorToken)
    }
    return ast,ex
}
//
// Additional entry points, if any
//

    
func (my *JavaParser)  ParseClassBodyDeclarationsopt(error_repair_count int,monitor Monitor) (interface{}, error){
    my.btParser.SetMonitor(monitor)
    
    var ast,ex = my.btParser.FuzzyParseEntry(JavaParsersym.TK_ClassBodyDeclarationsoptMarker, error_repair_count)
    if nil != ex  {
        var e,ok= ex.(*BadParseException)
        if ok{
            my.prsStream.ResetTo(e.ErrorToken) // point to error token

            var diagnoseParser = NewDiagnoseParser(my.prsStream, my.prsTable, 0,0,nil)
            diagnoseParser.DiagnoseEntry(JavaParsersym.TK_ClassBodyDeclarationsoptMarker, e.ErrorToken)
        }
        return nil,ex
    }
    return ast,nil
}

    
func (my *JavaParser)  ParseLPGUserAction(error_repair_count int,monitor Monitor) (interface{}, error){
    my.btParser.SetMonitor(monitor)
    
    var ast,ex = my.btParser.FuzzyParseEntry(JavaParsersym.TK_LPGUserActionMarker, error_repair_count)
    if nil != ex  {
        var e,ok= ex.(*BadParseException)
        if ok{
            my.prsStream.ResetTo(e.ErrorToken) // point to error token

            var diagnoseParser = NewDiagnoseParser(my.prsStream, my.prsTable, 0,0,nil)
            diagnoseParser.DiagnoseEntry(JavaParsersym.TK_LPGUserActionMarker, e.ErrorToken)
        }
        return nil,ex
    }
    return ast,nil
}


    //#line 186 "GJavaParser.g


    
    //#line 326 "btParserTemplateF.gi

   
    func (my *JavaParser)  RuleAction(ruleNumber int){
        switch ruleNumber{

            //
            // Rule 3:  identifier ::= IDENTIFIER
            //
            case 3: {
               //#line 185 "GJavaParser.g"
                my.SetResult(
                    //#line 185 GJavaParser.g
                    Newidentifier(my, my.GetRhsIToken(1)),
                //#line 185 GJavaParser.g
                )
                break
            }
            //
            // Rule 4:  LPGUserAction ::= BlockStatementsopt
            //
            case 4:
                break
            //
            // Rule 5:  LPGUserAction ::= $BeginAction BlockStatementsopt $EndAction
            //
            case 5: {
               //#line 191 "GJavaParser.g"
                my.SetResult(
                    //#line 191 GJavaParser.g
                    NewLPGUserAction0(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 191 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 191 GJavaParser.g
                                      AnyCastToIBlockStatementsopt(my.GetRhsSym(2)),
                                      //#line 191 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 191 GJavaParser.g
                )
                break
            }
            //
            // Rule 6:  LPGUserAction ::= $BeginJava BlockStatementsopt $EndJava
            //
            case 6: {
               //#line 192 "GJavaParser.g"
                my.SetResult(
                    //#line 192 GJavaParser.g
                    NewLPGUserAction1(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 192 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 192 GJavaParser.g
                                      AnyCastToIBlockStatementsopt(my.GetRhsSym(2)),
                                      //#line 192 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 192 GJavaParser.g
                )
                break
            }
            //
            // Rule 7:  LPGUserAction ::= $NoAction
            //
            case 7: {
               //#line 193 "GJavaParser.g"
                my.SetResult(
                    //#line 193 GJavaParser.g
                    NewLPGUserAction2(my.GetRhsIToken(1)),
                //#line 193 GJavaParser.g
                )
                break
            }
            //
            // Rule 8:  LPGUserAction ::= $NullAction
            //
            case 8: {
               //#line 194 "GJavaParser.g"
                my.SetResult(
                    //#line 194 GJavaParser.g
                    NewLPGUserAction3(my.GetRhsIToken(1)),
                //#line 194 GJavaParser.g
                )
                break
            }
            //
            // Rule 9:  LPGUserAction ::= $BadAction
            //
            case 9: {
               //#line 195 "GJavaParser.g"
                my.SetResult(
                    //#line 195 GJavaParser.g
                    NewLPGUserAction4(my.GetRhsIToken(1)),
                //#line 195 GJavaParser.g
                )
                break
            }
            //
            // Rule 10:  Type ::= PrimitiveType
            //
            case 10:
                break
            //
            // Rule 11:  Type ::= ReferenceType
            //
            case 11:
                break
            //
            // Rule 12:  PrimitiveType ::= NumericType
            //
            case 12:
                break
            //
            // Rule 13:  PrimitiveType ::= boolean
            //
            case 13: {
               //#line 204 "GJavaParser.g"
                my.SetResult(
                    //#line 204 GJavaParser.g
                    NewPrimitiveType(my.GetRhsIToken(1)),
                //#line 204 GJavaParser.g
                )
                break
            }
            //
            // Rule 14:  NumericType ::= IntegralType
            //
            case 14:
                break
            //
            // Rule 15:  NumericType ::= FloatingPointType
            //
            case 15:
                break
            //
            // Rule 16:  IntegralType ::= byte
            //
            case 16: {
               //#line 209 "GJavaParser.g"
                my.SetResult(
                    //#line 209 GJavaParser.g
                    NewIntegralType0(my.GetRhsIToken(1)),
                //#line 209 GJavaParser.g
                )
                break
            }
            //
            // Rule 17:  IntegralType ::= short
            //
            case 17: {
               //#line 210 "GJavaParser.g"
                my.SetResult(
                    //#line 210 GJavaParser.g
                    NewIntegralType1(my.GetRhsIToken(1)),
                //#line 210 GJavaParser.g
                )
                break
            }
            //
            // Rule 18:  IntegralType ::= int
            //
            case 18: {
               //#line 211 "GJavaParser.g"
                my.SetResult(
                    //#line 211 GJavaParser.g
                    NewIntegralType2(my.GetRhsIToken(1)),
                //#line 211 GJavaParser.g
                )
                break
            }
            //
            // Rule 19:  IntegralType ::= long
            //
            case 19: {
               //#line 212 "GJavaParser.g"
                my.SetResult(
                    //#line 212 GJavaParser.g
                    NewIntegralType3(my.GetRhsIToken(1)),
                //#line 212 GJavaParser.g
                )
                break
            }
            //
            // Rule 20:  IntegralType ::= char
            //
            case 20: {
               //#line 213 "GJavaParser.g"
                my.SetResult(
                    //#line 213 GJavaParser.g
                    NewIntegralType4(my.GetRhsIToken(1)),
                //#line 213 GJavaParser.g
                )
                break
            }
            //
            // Rule 21:  FloatingPointType ::= float
            //
            case 21: {
               //#line 215 "GJavaParser.g"
                my.SetResult(
                    //#line 215 GJavaParser.g
                    NewFloatingPointType0(my.GetRhsIToken(1)),
                //#line 215 GJavaParser.g
                )
                break
            }
            //
            // Rule 22:  FloatingPointType ::= double
            //
            case 22: {
               //#line 216 "GJavaParser.g"
                my.SetResult(
                    //#line 216 GJavaParser.g
                    NewFloatingPointType1(my.GetRhsIToken(1)),
                //#line 216 GJavaParser.g
                )
                break
            }
            //
            // Rule 23:  ReferenceType ::= ClassOrInterfaceType
            //
            case 23:
                break
            //
            // Rule 24:  ReferenceType ::= TypeVariable
            //
            case 24:
                break
            //
            // Rule 25:  ReferenceType ::= ArrayType
            //
            case 25:
                break
            //
            // Rule 26:  ClassOrInterfaceType ::= ClassType
            //
            case 26:
                break
            //
            // Rule 27:  ClassType ::= TypeName TypeArgumentsopt
            //
            case 27: {
               //#line 228 "GJavaParser.g"
                my.SetResult(
                    //#line 228 GJavaParser.g
                    NewClassType(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 228 GJavaParser.g
                                 my.GetRhsSym(1).(ITypeName),
                                 //#line 228 GJavaParser.g
                                 AnyCastToTypeArguments(my.GetRhsSym(2))),
                //#line 228 GJavaParser.g
                )
                break
            }
            //
            // Rule 28:  InterfaceType ::= TypeName TypeArgumentsopt
            //
            case 28: {
               //#line 230 "GJavaParser.g"
                my.SetResult(
                    //#line 230 GJavaParser.g
                    NewInterfaceType(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 230 GJavaParser.g
                                     my.GetRhsSym(1).(ITypeName),
                                     //#line 230 GJavaParser.g
                                     AnyCastToTypeArguments(my.GetRhsSym(2))),
                //#line 230 GJavaParser.g
                )
                break
            }
            //
            // Rule 29:  TypeName ::= identifier
            //
            case 29:
                break
            //
            // Rule 30:  TypeName ::= TypeName . identifier
            //
            case 30: {
               //#line 233 "GJavaParser.g"
                my.SetResult(
                    //#line 233 GJavaParser.g
                    NewTypeName(my.GetLeftIToken(), my.GetRightIToken(),
                                //#line 233 GJavaParser.g
                                my.GetRhsSym(1).(ITypeName),
                                //#line 233 GJavaParser.g
                                NewAstToken(my.GetRhsIToken(2)),
                                //#line 233 GJavaParser.g
                                my.GetRhsSym(3).(*identifier)),
                //#line 233 GJavaParser.g
                )
                break
            }
            //
            // Rule 31:  ClassName ::= TypeName
            //
            case 31:
                break
            //
            // Rule 32:  TypeVariable ::= identifier
            //
            case 32:
                break
            //
            // Rule 33:  ArrayType ::= Type [ ]
            //
            case 33: {
               //#line 239 "GJavaParser.g"
                my.SetResult(
                    //#line 239 GJavaParser.g
                    NewArrayType(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 239 GJavaParser.g
                                 my.GetRhsSym(1).(IType),
                                 //#line 239 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(2)),
                                 //#line 239 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(3))),
                //#line 239 GJavaParser.g
                )
                break
            }
            //
            // Rule 34:  TypeParameter ::= TypeVariable TypeBoundopt
            //
            case 34: {
               //#line 241 "GJavaParser.g"
                my.SetResult(
                    //#line 241 GJavaParser.g
                    NewTypeParameter(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 241 GJavaParser.g
                                     my.GetRhsSym(1).(*identifier),
                                     //#line 241 GJavaParser.g
                                     AnyCastToTypeBound(my.GetRhsSym(2))),
                //#line 241 GJavaParser.g
                )
                break
            }
            //
            // Rule 35:  TypeBound ::= extends ClassOrInterfaceType AdditionalBoundListopt
            //
            case 35: {
               //#line 243 "GJavaParser.g"
                my.SetResult(
                    //#line 243 GJavaParser.g
                    NewTypeBound(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 243 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(1)),
                                 //#line 243 GJavaParser.g
                                 my.GetRhsSym(2).(*ClassType),
                                 //#line 243 GJavaParser.g
                                 AnyCastToIAdditionalBoundListopt(my.GetRhsSym(3))),
                //#line 243 GJavaParser.g
                )
                break
            }
            //
            // Rule 36:  AdditionalBoundList ::= AdditionalBound
            //
            case 36:
                break
            //
            // Rule 37:  AdditionalBoundList ::= AdditionalBoundList AdditionalBound
            //
            case 37: {
               //#line 246 "GJavaParser.g"
                my.SetResult(
                    //#line 246 GJavaParser.g
                    NewAdditionalBoundList(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 246 GJavaParser.g
                                           my.GetRhsSym(1).(IAdditionalBoundList),
                                           //#line 246 GJavaParser.g
                                           my.GetRhsSym(2).(*AdditionalBound)),
                //#line 246 GJavaParser.g
                )
                break
            }
            //
            // Rule 38:  AdditionalBound ::= & InterfaceType
            //
            case 38: {
               //#line 248 "GJavaParser.g"
                my.SetResult(
                    //#line 248 GJavaParser.g
                    NewAdditionalBound(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 248 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 248 GJavaParser.g
                                       my.GetRhsSym(2).(*InterfaceType)),
                //#line 248 GJavaParser.g
                )
                break
            }
            //
            // Rule 39:  TypeArguments ::= < ActualTypeArgumentList >
            //
            case 39: {
               //#line 250 "GJavaParser.g"
                my.SetResult(
                    //#line 250 GJavaParser.g
                    NewTypeArguments(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 250 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(1)),
                                     //#line 250 GJavaParser.g
                                     my.GetRhsSym(2).(IActualTypeArgumentList),
                                     //#line 250 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(3))),
                //#line 250 GJavaParser.g
                )
                break
            }
            //
            // Rule 40:  ActualTypeArgumentList ::= ActualTypeArgument
            //
            case 40:
                break
            //
            // Rule 41:  ActualTypeArgumentList ::= ActualTypeArgumentList , ActualTypeArgument
            //
            case 41: {
               //#line 253 "GJavaParser.g"
                my.SetResult(
                    //#line 253 GJavaParser.g
                    NewActualTypeArgumentList(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 253 GJavaParser.g
                                              my.GetRhsSym(1).(IActualTypeArgumentList),
                                              //#line 253 GJavaParser.g
                                              NewAstToken(my.GetRhsIToken(2)),
                                              //#line 253 GJavaParser.g
                                              my.GetRhsSym(3).(IActualTypeArgument)),
                //#line 253 GJavaParser.g
                )
                break
            }
            //
            // Rule 42:  ActualTypeArgument ::= ReferenceType
            //
            case 42:
                break
            //
            // Rule 43:  ActualTypeArgument ::= Wildcard
            //
            case 43:
                break
            //
            // Rule 44:  Wildcard ::= ? WildcardBoundsOpt
            //
            case 44: {
               //#line 258 "GJavaParser.g"
                my.SetResult(
                    //#line 258 GJavaParser.g
                    NewWildcard(my.GetLeftIToken(), my.GetRightIToken(),
                                //#line 258 GJavaParser.g
                                NewAstToken(my.GetRhsIToken(1)),
                                //#line 258 GJavaParser.g
                                AnyCastToIWildcardBoundsOpt(my.GetRhsSym(2))),
                //#line 258 GJavaParser.g
                )
                break
            }
            //
            // Rule 45:  WildcardBounds ::= extends ReferenceType
            //
            case 45: {
               //#line 260 "GJavaParser.g"
                my.SetResult(
                    //#line 260 GJavaParser.g
                    NewWildcardBounds0(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 260 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 260 GJavaParser.g
                                       my.GetRhsSym(2).(IReferenceType)),
                //#line 260 GJavaParser.g
                )
                break
            }
            //
            // Rule 46:  WildcardBounds ::= super ReferenceType
            //
            case 46: {
               //#line 261 "GJavaParser.g"
                my.SetResult(
                    //#line 261 GJavaParser.g
                    NewWildcardBounds1(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 261 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 261 GJavaParser.g
                                       my.GetRhsSym(2).(IReferenceType)),
                //#line 261 GJavaParser.g
                )
                break
            }
            //
            // Rule 47:  PackageName ::= identifier
            //
            case 47:
                break
            //
            // Rule 48:  PackageName ::= PackageName . identifier
            //
            case 48: {
               //#line 268 "GJavaParser.g"
                my.SetResult(
                    //#line 268 GJavaParser.g
                    NewPackageName(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 268 GJavaParser.g
                                   my.GetRhsSym(1).(IPackageName),
                                   //#line 268 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(2)),
                                   //#line 268 GJavaParser.g
                                   my.GetRhsSym(3).(*identifier)),
                //#line 268 GJavaParser.g
                )
                break
            }
            //
            // Rule 49:  ExpressionName ::= identifier
            //
            case 49:
                break
            //
            // Rule 50:  ExpressionName ::= AmbiguousName . identifier
            //
            case 50: {
               //#line 277 "GJavaParser.g"
                my.SetResult(
                    //#line 277 GJavaParser.g
                    NewExpressionName(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 277 GJavaParser.g
                                      my.GetRhsSym(1).(IAmbiguousName),
                                      //#line 277 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(2)),
                                      //#line 277 GJavaParser.g
                                      my.GetRhsSym(3).(*identifier)),
                //#line 277 GJavaParser.g
                )
                break
            }
            //
            // Rule 51:  MethodName ::= identifier
            //
            case 51:
                break
            //
            // Rule 52:  MethodName ::= AmbiguousName . identifier
            //
            case 52: {
               //#line 280 "GJavaParser.g"
                my.SetResult(
                    //#line 280 GJavaParser.g
                    NewMethodName(my.GetLeftIToken(), my.GetRightIToken(),
                                  //#line 280 GJavaParser.g
                                  my.GetRhsSym(1).(IAmbiguousName),
                                  //#line 280 GJavaParser.g
                                  NewAstToken(my.GetRhsIToken(2)),
                                  //#line 280 GJavaParser.g
                                  my.GetRhsSym(3).(*identifier)),
                //#line 280 GJavaParser.g
                )
                break
            }
            //
            // Rule 53:  PackageOrTypeName ::= identifier
            //
            case 53:
                break
            //
            // Rule 54:  PackageOrTypeName ::= PackageOrTypeName . identifier
            //
            case 54: {
               //#line 283 "GJavaParser.g"
                my.SetResult(
                    //#line 283 GJavaParser.g
                    NewPackageOrTypeName(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 283 GJavaParser.g
                                         my.GetRhsSym(1).(IPackageOrTypeName),
                                         //#line 283 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 283 GJavaParser.g
                                         my.GetRhsSym(3).(*identifier)),
                //#line 283 GJavaParser.g
                )
                break
            }
            //
            // Rule 55:  AmbiguousName ::= identifier
            //
            case 55:
                break
            //
            // Rule 56:  AmbiguousName ::= AmbiguousName . identifier
            //
            case 56: {
               //#line 286 "GJavaParser.g"
                my.SetResult(
                    //#line 286 GJavaParser.g
                    NewAmbiguousName(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 286 GJavaParser.g
                                     my.GetRhsSym(1).(IAmbiguousName),
                                     //#line 286 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(2)),
                                     //#line 286 GJavaParser.g
                                     my.GetRhsSym(3).(*identifier)),
                //#line 286 GJavaParser.g
                )
                break
            }
            //
            // Rule 57:  CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt
            //
            case 57: {
               //#line 290 "GJavaParser.g"
                my.SetResult(
                    //#line 290 GJavaParser.g
                    NewCompilationUnit(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 290 GJavaParser.g
                                       AnyCastToPackageDeclaration(my.GetRhsSym(1)),
                                       //#line 290 GJavaParser.g
                                       AnyCastToIImportDeclarationsopt(my.GetRhsSym(2)),
                                       //#line 290 GJavaParser.g
                                       AnyCastToITypeDeclarationsopt(my.GetRhsSym(3))),
                //#line 290 GJavaParser.g
                )
                break
            }
            //
            // Rule 58:  ImportDeclarations ::= ImportDeclaration
            //
            case 58:
                break
            //
            // Rule 59:  ImportDeclarations ::= ImportDeclarations ImportDeclaration
            //
            case 59: {
               //#line 293 "GJavaParser.g"
                my.SetResult(
                    //#line 293 GJavaParser.g
                    NewImportDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 293 GJavaParser.g
                                          my.GetRhsSym(1).(IImportDeclarations),
                                          //#line 293 GJavaParser.g
                                          my.GetRhsSym(2).(IImportDeclaration)),
                //#line 293 GJavaParser.g
                )
                break
            }
            //
            // Rule 60:  TypeDeclarations ::= TypeDeclaration
            //
            case 60:
                break
            //
            // Rule 61:  TypeDeclarations ::= TypeDeclarations TypeDeclaration
            //
            case 61: {
               //#line 296 "GJavaParser.g"
                my.SetResult(
                    //#line 296 GJavaParser.g
                    NewTypeDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 296 GJavaParser.g
                                        my.GetRhsSym(1).(ITypeDeclarations),
                                        //#line 296 GJavaParser.g
                                        my.GetRhsSym(2).(ITypeDeclaration)),
                //#line 296 GJavaParser.g
                )
                break
            }
            //
            // Rule 62:  PackageDeclaration ::= Annotationsopt package PackageName ;
            //
            case 62: {
               //#line 298 "GJavaParser.g"
                my.SetResult(
                    //#line 298 GJavaParser.g
                    NewPackageDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 298 GJavaParser.g
                                          AnyCastToIAnnotationsopt(my.GetRhsSym(1)),
                                          //#line 298 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 298 GJavaParser.g
                                          my.GetRhsSym(3).(IPackageName),
                                          //#line 298 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(4))),
                //#line 298 GJavaParser.g
                )
                break
            }
            //
            // Rule 63:  ImportDeclaration ::= SingleTypeImportDeclaration
            //
            case 63:
                break
            //
            // Rule 64:  ImportDeclaration ::= TypeImportOnDemandDeclaration
            //
            case 64:
                break
            //
            // Rule 65:  ImportDeclaration ::= SingleStaticImportDeclaration
            //
            case 65:
                break
            //
            // Rule 66:  ImportDeclaration ::= StaticImportOnDemandDeclaration
            //
            case 66:
                break
            //
            // Rule 67:  SingleTypeImportDeclaration ::= import TypeName ;
            //
            case 67: {
               //#line 305 "GJavaParser.g"
                my.SetResult(
                    //#line 305 GJavaParser.g
                    NewSingleTypeImportDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                   //#line 305 GJavaParser.g
                                                   NewAstToken(my.GetRhsIToken(1)),
                                                   //#line 305 GJavaParser.g
                                                   my.GetRhsSym(2).(ITypeName),
                                                   //#line 305 GJavaParser.g
                                                   NewAstToken(my.GetRhsIToken(3))),
                //#line 305 GJavaParser.g
                )
                break
            }
            //
            // Rule 68:  TypeImportOnDemandDeclaration ::= import PackageOrTypeName . * ;
            //
            case 68: {
               //#line 307 "GJavaParser.g"
                my.SetResult(
                    //#line 307 GJavaParser.g
                    NewTypeImportOnDemandDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                     //#line 307 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(1)),
                                                     //#line 307 GJavaParser.g
                                                     my.GetRhsSym(2).(IPackageOrTypeName),
                                                     //#line 307 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(3)),
                                                     //#line 307 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(4)),
                                                     //#line 307 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(5))),
                //#line 307 GJavaParser.g
                )
                break
            }
            //
            // Rule 69:  SingleStaticImportDeclaration ::= import static TypeName . identifier ;
            //
            case 69: {
               //#line 309 "GJavaParser.g"
                my.SetResult(
                    //#line 309 GJavaParser.g
                    NewSingleStaticImportDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                     //#line 309 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(1)),
                                                     //#line 309 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(2)),
                                                     //#line 309 GJavaParser.g
                                                     my.GetRhsSym(3).(ITypeName),
                                                     //#line 309 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(4)),
                                                     //#line 309 GJavaParser.g
                                                     my.GetRhsSym(5).(*identifier),
                                                     //#line 309 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(6))),
                //#line 309 GJavaParser.g
                )
                break
            }
            //
            // Rule 70:  StaticImportOnDemandDeclaration ::= import static TypeName . * ;
            //
            case 70: {
               //#line 311 "GJavaParser.g"
                my.SetResult(
                    //#line 311 GJavaParser.g
                    NewStaticImportOnDemandDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(1)),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(2)),
                                                       //#line 311 GJavaParser.g
                                                       my.GetRhsSym(3).(ITypeName),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(4)),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(5)),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(6))),
                //#line 311 GJavaParser.g
                )
                break
            }
            //
            // Rule 71:  TypeDeclaration ::= ClassDeclaration
            //
            case 71:
                break
            //
            // Rule 72:  TypeDeclaration ::= InterfaceDeclaration
            //
            case 72:
                break
            //
            // Rule 73:  TypeDeclaration ::= ;
            //
            case 73: {
               //#line 315 "GJavaParser.g"
                my.SetResult(
                    //#line 315 GJavaParser.g
                    NewTypeDeclaration(my.GetRhsIToken(1)),
                //#line 315 GJavaParser.g
                )
                break
            }
            //
            // Rule 74:  ClassDeclaration ::= NormalClassDeclaration
            //
            case 74:
                break
            //
            // Rule 75:  ClassDeclaration ::= EnumDeclaration
            //
            case 75:
                break
            //
            // Rule 76:  NormalClassDeclaration ::= ClassModifiersopt class identifier TypeParametersopt Superopt Interfacesopt ClassBody
            //
            case 76: {
               //#line 322 "GJavaParser.g"
                my.SetResult(
                    //#line 322 GJavaParser.g
                    NewNormalClassDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 322 GJavaParser.g
                                              AnyCastToIClassModifiersopt(my.GetRhsSym(1)),
                                              //#line 322 GJavaParser.g
                                              NewAstToken(my.GetRhsIToken(2)),
                                              //#line 322 GJavaParser.g
                                              my.GetRhsSym(3).(*identifier),
                                              //#line 322 GJavaParser.g
                                              AnyCastToTypeParameters(my.GetRhsSym(4)),
                                              //#line 322 GJavaParser.g
                                              AnyCastToSuper(my.GetRhsSym(5)),
                                              //#line 322 GJavaParser.g
                                              AnyCastToInterfaces(my.GetRhsSym(6)),
                                              //#line 322 GJavaParser.g
                                              my.GetRhsSym(7).(*ClassBody)),
                //#line 322 GJavaParser.g
                )
                break
            }
            //
            // Rule 77:  ClassModifiers ::= ClassModifier
            //
            case 77:
                break
            //
            // Rule 78:  ClassModifiers ::= ClassModifiers ClassModifier
            //
            case 78: {
               //#line 325 "GJavaParser.g"
                my.SetResult(
                    //#line 325 GJavaParser.g
                    NewClassModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 325 GJavaParser.g
                                      my.GetRhsSym(1).(IClassModifiers),
                                      //#line 325 GJavaParser.g
                                      my.GetRhsSym(2).(IClassModifier)),
                //#line 325 GJavaParser.g
                )
                break
            }
            //
            // Rule 79:  ClassModifier ::= Annotation
            //
            case 79:
                break
            //
            // Rule 80:  ClassModifier ::= public
            //
            case 80: {
               //#line 328 "GJavaParser.g"
                my.SetResult(
                    //#line 328 GJavaParser.g
                    NewClassModifier0(my.GetRhsIToken(1)),
                //#line 328 GJavaParser.g
                )
                break
            }
            //
            // Rule 81:  ClassModifier ::= protected
            //
            case 81: {
               //#line 329 "GJavaParser.g"
                my.SetResult(
                    //#line 329 GJavaParser.g
                    NewClassModifier1(my.GetRhsIToken(1)),
                //#line 329 GJavaParser.g
                )
                break
            }
            //
            // Rule 82:  ClassModifier ::= private
            //
            case 82: {
               //#line 330 "GJavaParser.g"
                my.SetResult(
                    //#line 330 GJavaParser.g
                    NewClassModifier2(my.GetRhsIToken(1)),
                //#line 330 GJavaParser.g
                )
                break
            }
            //
            // Rule 83:  ClassModifier ::= abstract
            //
            case 83: {
               //#line 331 "GJavaParser.g"
                my.SetResult(
                    //#line 331 GJavaParser.g
                    NewClassModifier3(my.GetRhsIToken(1)),
                //#line 331 GJavaParser.g
                )
                break
            }
            //
            // Rule 84:  ClassModifier ::= static
            //
            case 84: {
               //#line 332 "GJavaParser.g"
                my.SetResult(
                    //#line 332 GJavaParser.g
                    NewClassModifier4(my.GetRhsIToken(1)),
                //#line 332 GJavaParser.g
                )
                break
            }
            //
            // Rule 85:  ClassModifier ::= final
            //
            case 85: {
               //#line 333 "GJavaParser.g"
                my.SetResult(
                    //#line 333 GJavaParser.g
                    NewClassModifier5(my.GetRhsIToken(1)),
                //#line 333 GJavaParser.g
                )
                break
            }
            //
            // Rule 86:  ClassModifier ::= strictfp
            //
            case 86: {
               //#line 334 "GJavaParser.g"
                my.SetResult(
                    //#line 334 GJavaParser.g
                    NewClassModifier6(my.GetRhsIToken(1)),
                //#line 334 GJavaParser.g
                )
                break
            }
            //
            // Rule 87:  TypeParameters ::= < TypeParameterList >
            //
            case 87: {
               //#line 336 "GJavaParser.g"
                my.SetResult(
                    //#line 336 GJavaParser.g
                    NewTypeParameters(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 336 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 336 GJavaParser.g
                                      my.GetRhsSym(2).(ITypeParameterList),
                                      //#line 336 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 336 GJavaParser.g
                )
                break
            }
            //
            // Rule 88:  TypeParameterList ::= TypeParameter
            //
            case 88:
                break
            //
            // Rule 89:  TypeParameterList ::= TypeParameterList , TypeParameter
            //
            case 89: {
               //#line 339 "GJavaParser.g"
                my.SetResult(
                    //#line 339 GJavaParser.g
                    NewTypeParameterList(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 339 GJavaParser.g
                                         my.GetRhsSym(1).(ITypeParameterList),
                                         //#line 339 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 339 GJavaParser.g
                                         my.GetRhsSym(3).(*TypeParameter)),
                //#line 339 GJavaParser.g
                )
                break
            }
            //
            // Rule 90:  Super ::= extends ClassType
            //
            case 90: {
               //#line 341 "GJavaParser.g"
                my.SetResult(
                    //#line 341 GJavaParser.g
                    NewSuper(my.GetLeftIToken(), my.GetRightIToken(),
                             //#line 341 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(1)),
                             //#line 341 GJavaParser.g
                             my.GetRhsSym(2).(*ClassType)),
                //#line 341 GJavaParser.g
                )
                break
            }
            //
            // Rule 91:  Interfaces ::= implements InterfaceTypeList
            //
            case 91: {
               //#line 348 "GJavaParser.g"
                my.SetResult(
                    //#line 348 GJavaParser.g
                    NewInterfaces(my.GetLeftIToken(), my.GetRightIToken(),
                                  //#line 348 GJavaParser.g
                                  NewAstToken(my.GetRhsIToken(1)),
                                  //#line 348 GJavaParser.g
                                  my.GetRhsSym(2).(IInterfaceTypeList)),
                //#line 348 GJavaParser.g
                )
                break
            }
            //
            // Rule 92:  InterfaceTypeList ::= InterfaceType
            //
            case 92:
                break
            //
            // Rule 93:  InterfaceTypeList ::= InterfaceTypeList , InterfaceType
            //
            case 93: {
               //#line 351 "GJavaParser.g"
                my.SetResult(
                    //#line 351 GJavaParser.g
                    NewInterfaceTypeList(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 351 GJavaParser.g
                                         my.GetRhsSym(1).(IInterfaceTypeList),
                                         //#line 351 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 351 GJavaParser.g
                                         my.GetRhsSym(3).(*InterfaceType)),
                //#line 351 GJavaParser.g
                )
                break
            }
            //
            // Rule 94:  ClassBody ::= { ClassBodyDeclarationsopt }
            //
            case 94: {
               //#line 358 "GJavaParser.g"
                my.SetResult(
                    //#line 358 GJavaParser.g
                    NewClassBody(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 358 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(1)),
                                 //#line 358 GJavaParser.g
                                 AnyCastToIClassBodyDeclarationsopt(my.GetRhsSym(2)),
                                 //#line 358 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(3))),
                //#line 358 GJavaParser.g
                )
                break
            }
            //
            // Rule 95:  ClassBodyDeclarations ::= ClassBodyDeclaration
            //
            case 95:
                break
            //
            // Rule 96:  ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
            //
            case 96: {
               //#line 361 "GJavaParser.g"
                my.SetResult(
                    //#line 361 GJavaParser.g
                    NewClassBodyDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 361 GJavaParser.g
                                             my.GetRhsSym(1).(IClassBodyDeclarations),
                                             //#line 361 GJavaParser.g
                                             my.GetRhsSym(2).(IClassBodyDeclaration)),
                //#line 361 GJavaParser.g
                )
                break
            }
            //
            // Rule 97:  ClassBodyDeclaration ::= ClassMemberDeclaration
            //
            case 97:
                break
            //
            // Rule 98:  ClassBodyDeclaration ::= InstanceInitializer
            //
            case 98:
                break
            //
            // Rule 99:  ClassBodyDeclaration ::= StaticInitializer
            //
            case 99:
                break
            //
            // Rule 100:  ClassBodyDeclaration ::= ConstructorDeclaration
            //
            case 100:
                break
            //
            // Rule 101:  ClassMemberDeclaration ::= FieldDeclaration
            //
            case 101:
                break
            //
            // Rule 102:  ClassMemberDeclaration ::= MethodDeclaration
            //
            case 102:
                break
            //
            // Rule 103:  ClassMemberDeclaration ::= ClassDeclaration
            //
            case 103:
                break
            //
            // Rule 104:  ClassMemberDeclaration ::= InterfaceDeclaration
            //
            case 104:
                break
            //
            // Rule 105:  ClassMemberDeclaration ::= ;
            //
            case 105: {
               //#line 372 "GJavaParser.g"
                my.SetResult(
                    //#line 372 GJavaParser.g
                    NewClassMemberDeclaration(my.GetRhsIToken(1)),
                //#line 372 GJavaParser.g
                )
                break
            }
            //
            // Rule 106:  FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ;
            //
            case 106: {
               //#line 374 "GJavaParser.g"
                my.SetResult(
                    //#line 374 GJavaParser.g
                    NewFieldDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 374 GJavaParser.g
                                        AnyCastToIFieldModifiersopt(my.GetRhsSym(1)),
                                        //#line 374 GJavaParser.g
                                        my.GetRhsSym(2).(IType),
                                        //#line 374 GJavaParser.g
                                        my.GetRhsSym(3).(IVariableDeclarators),
                                        //#line 374 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(4))),
                //#line 374 GJavaParser.g
                )
                break
            }
            //
            // Rule 107:  VariableDeclarators ::= VariableDeclarator
            //
            case 107:
                break
            //
            // Rule 108:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
            //
            case 108: {
               //#line 377 "GJavaParser.g"
                my.SetResult(
                    //#line 377 GJavaParser.g
                    NewVariableDeclarators(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 377 GJavaParser.g
                                           my.GetRhsSym(1).(IVariableDeclarators),
                                           //#line 377 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 377 GJavaParser.g
                                           my.GetRhsSym(3).(IVariableDeclarator)),
                //#line 377 GJavaParser.g
                )
                break
            }
            //
            // Rule 109:  VariableDeclarator ::= VariableDeclaratorId
            //
            case 109:
                break
            //
            // Rule 110:  VariableDeclarator ::= VariableDeclaratorId = VariableInitializer
            //
            case 110: {
               //#line 380 "GJavaParser.g"
                my.SetResult(
                    //#line 380 GJavaParser.g
                    NewVariableDeclarator(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 380 GJavaParser.g
                                          my.GetRhsSym(1).(IVariableDeclaratorId),
                                          //#line 380 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 380 GJavaParser.g
                                          my.GetRhsSym(3).(IVariableInitializer)),
                //#line 380 GJavaParser.g
                )
                break
            }
            //
            // Rule 111:  VariableDeclaratorId ::= identifier
            //
            case 111:
                break
            //
            // Rule 112:  VariableDeclaratorId ::= VariableDeclaratorId [ ]
            //
            case 112: {
               //#line 383 "GJavaParser.g"
                my.SetResult(
                    //#line 383 GJavaParser.g
                    NewVariableDeclaratorId(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 383 GJavaParser.g
                                            my.GetRhsSym(1).(IVariableDeclaratorId),
                                            //#line 383 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(2)),
                                            //#line 383 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(3))),
                //#line 383 GJavaParser.g
                )
                break
            }
            //
            // Rule 113:  VariableInitializer ::= Expression
            //
            case 113:
                break
            //
            // Rule 114:  VariableInitializer ::= ArrayInitializer
            //
            case 114:
                break
            //
            // Rule 115:  FieldModifiers ::= FieldModifier
            //
            case 115:
                break
            //
            // Rule 116:  FieldModifiers ::= FieldModifiers FieldModifier
            //
            case 116: {
               //#line 389 "GJavaParser.g"
                my.SetResult(
                    //#line 389 GJavaParser.g
                    NewFieldModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 389 GJavaParser.g
                                      my.GetRhsSym(1).(IFieldModifiers),
                                      //#line 389 GJavaParser.g
                                      my.GetRhsSym(2).(IFieldModifier)),
                //#line 389 GJavaParser.g
                )
                break
            }
            //
            // Rule 117:  FieldModifier ::= Annotation
            //
            case 117:
                break
            //
            // Rule 118:  FieldModifier ::= public
            //
            case 118: {
               //#line 392 "GJavaParser.g"
                my.SetResult(
                    //#line 392 GJavaParser.g
                    NewFieldModifier0(my.GetRhsIToken(1)),
                //#line 392 GJavaParser.g
                )
                break
            }
            //
            // Rule 119:  FieldModifier ::= protected
            //
            case 119: {
               //#line 393 "GJavaParser.g"
                my.SetResult(
                    //#line 393 GJavaParser.g
                    NewFieldModifier1(my.GetRhsIToken(1)),
                //#line 393 GJavaParser.g
                )
                break
            }
            //
            // Rule 120:  FieldModifier ::= private
            //
            case 120: {
               //#line 394 "GJavaParser.g"
                my.SetResult(
                    //#line 394 GJavaParser.g
                    NewFieldModifier2(my.GetRhsIToken(1)),
                //#line 394 GJavaParser.g
                )
                break
            }
            //
            // Rule 121:  FieldModifier ::= static
            //
            case 121: {
               //#line 395 "GJavaParser.g"
                my.SetResult(
                    //#line 395 GJavaParser.g
                    NewFieldModifier3(my.GetRhsIToken(1)),
                //#line 395 GJavaParser.g
                )
                break
            }
            //
            // Rule 122:  FieldModifier ::= final
            //
            case 122: {
               //#line 396 "GJavaParser.g"
                my.SetResult(
                    //#line 396 GJavaParser.g
                    NewFieldModifier4(my.GetRhsIToken(1)),
                //#line 396 GJavaParser.g
                )
                break
            }
            //
            // Rule 123:  FieldModifier ::= transient
            //
            case 123: {
               //#line 397 "GJavaParser.g"
                my.SetResult(
                    //#line 397 GJavaParser.g
                    NewFieldModifier5(my.GetRhsIToken(1)),
                //#line 397 GJavaParser.g
                )
                break
            }
            //
            // Rule 124:  FieldModifier ::= volatile
            //
            case 124: {
               //#line 398 "GJavaParser.g"
                my.SetResult(
                    //#line 398 GJavaParser.g
                    NewFieldModifier6(my.GetRhsIToken(1)),
                //#line 398 GJavaParser.g
                )
                break
            }
            //
            // Rule 125:  MethodDeclaration ::= MethodHeader MethodBody
            //
            case 125: {
               //#line 400 "GJavaParser.g"
                my.SetResult(
                    //#line 400 GJavaParser.g
                    NewMethodDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 400 GJavaParser.g
                                         my.GetRhsSym(1).(*MethodHeader),
                                         //#line 400 GJavaParser.g
                                         my.GetRhsSym(2).(IMethodBody)),
                //#line 400 GJavaParser.g
                )
                break
            }
            //
            // Rule 126:  MethodHeader ::= MethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt
            //
            case 126: {
               //#line 402 "GJavaParser.g"
                my.SetResult(
                    //#line 402 GJavaParser.g
                    NewMethodHeader(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 402 GJavaParser.g
                                    AnyCastToIMethodModifiersopt(my.GetRhsSym(1)),
                                    //#line 402 GJavaParser.g
                                    AnyCastToTypeParameters(my.GetRhsSym(2)),
                                    //#line 402 GJavaParser.g
                                    my.GetRhsSym(3).(IResultType),
                                    //#line 402 GJavaParser.g
                                    my.GetRhsSym(4).(IMethodDeclarator),
                                    //#line 402 GJavaParser.g
                                    AnyCastToThrows(my.GetRhsSym(5))),
                //#line 402 GJavaParser.g
                )
                break
            }
            //
            // Rule 127:  ResultType ::= Type
            //
            case 127:
                break
            //
            // Rule 128:  ResultType ::= void
            //
            case 128: {
               //#line 405 "GJavaParser.g"
                my.SetResult(
                    //#line 405 GJavaParser.g
                    NewResultType(my.GetRhsIToken(1)),
                //#line 405 GJavaParser.g
                )
                break
            }
            //
            // Rule 129:  MethodDeclarator ::= identifier ( FormalParameterListopt )
            //
            case 129: {
               //#line 407 "GJavaParser.g"
                my.SetResult(
                    //#line 407 GJavaParser.g
                    NewMethodDeclarator0(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 407 GJavaParser.g
                                         my.GetRhsSym(1).(*identifier),
                                         //#line 407 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 407 GJavaParser.g
                                         AnyCastToIFormalParameterListopt(my.GetRhsSym(3)),
                                         //#line 407 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(4))),
                //#line 407 GJavaParser.g
                )
                break
            }
            //
            // Rule 130:  MethodDeclarator ::= MethodDeclarator [ ]
            //
            case 130: {
               //#line 409 "GJavaParser.g"
                my.SetResult(
                    //#line 409 GJavaParser.g
                    NewMethodDeclarator1(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 409 GJavaParser.g
                                         my.GetRhsSym(1).(IMethodDeclarator),
                                         //#line 409 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 409 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(3))),
                //#line 409 GJavaParser.g
                )
                break
            }
            //
            // Rule 131:  FormalParameterList ::= LastFormalParameter
            //
            case 131:
                break
            //
            // Rule 132:  FormalParameterList ::= FormalParameters , LastFormalParameter
            //
            case 132: {
               //#line 412 "GJavaParser.g"
                my.SetResult(
                    //#line 412 GJavaParser.g
                    NewFormalParameterList(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 412 GJavaParser.g
                                           my.GetRhsSym(1).(IFormalParameters),
                                           //#line 412 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 412 GJavaParser.g
                                           my.GetRhsSym(3).(*LastFormalParameter)),
                //#line 412 GJavaParser.g
                )
                break
            }
            //
            // Rule 133:  FormalParameters ::= FormalParameter
            //
            case 133:
                break
            //
            // Rule 134:  FormalParameters ::= FormalParameters , FormalParameter
            //
            case 134: {
               //#line 415 "GJavaParser.g"
                my.SetResult(
                    //#line 415 GJavaParser.g
                    NewFormalParameters(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 415 GJavaParser.g
                                        my.GetRhsSym(1).(IFormalParameters),
                                        //#line 415 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 415 GJavaParser.g
                                        my.GetRhsSym(3).(*FormalParameter)),
                //#line 415 GJavaParser.g
                )
                break
            }
            //
            // Rule 135:  FormalParameter ::= VariableModifiersopt Type VariableDeclaratorId
            //
            case 135: {
               //#line 417 "GJavaParser.g"
                my.SetResult(
                    //#line 417 GJavaParser.g
                    NewFormalParameter(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 417 GJavaParser.g
                                       AnyCastToIVariableModifiersopt(my.GetRhsSym(1)),
                                       //#line 417 GJavaParser.g
                                       my.GetRhsSym(2).(IType),
                                       //#line 417 GJavaParser.g
                                       my.GetRhsSym(3).(IVariableDeclaratorId)),
                //#line 417 GJavaParser.g
                )
                break
            }
            //
            // Rule 136:  VariableModifiers ::= VariableModifier
            //
            case 136:
                break
            //
            // Rule 137:  VariableModifiers ::= VariableModifiers VariableModifier
            //
            case 137: {
               //#line 420 "GJavaParser.g"
                my.SetResult(
                    //#line 420 GJavaParser.g
                    NewVariableModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 420 GJavaParser.g
                                         my.GetRhsSym(1).(IVariableModifiers),
                                         //#line 420 GJavaParser.g
                                         my.GetRhsSym(2).(IVariableModifier)),
                //#line 420 GJavaParser.g
                )
                break
            }
            //
            // Rule 138:  VariableModifier ::= final
            //
            case 138: {
               //#line 422 "GJavaParser.g"
                my.SetResult(
                    //#line 422 GJavaParser.g
                    NewVariableModifier(my.GetRhsIToken(1)),
                //#line 422 GJavaParser.g
                )
                break
            }
            //
            // Rule 139:  VariableModifier ::= Annotations
            //
            case 139:
                break
            //
            // Rule 140:  LastFormalParameter ::= VariableModifiersopt Type ...opt VariableDeclaratorId
            //
            case 140: {
               //#line 425 "GJavaParser.g"
                my.SetResult(
                    //#line 425 GJavaParser.g
                    NewLastFormalParameter(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 425 GJavaParser.g
                                           AnyCastToIVariableModifiersopt(my.GetRhsSym(1)),
                                           //#line 425 GJavaParser.g
                                           my.GetRhsSym(2).(IType),
                                           //#line 425 GJavaParser.g
                                           AnyCastToEllipsisopt(my.GetRhsSym(3)),
                                           //#line 425 GJavaParser.g
                                           my.GetRhsSym(4).(IVariableDeclaratorId)),
                //#line 425 GJavaParser.g
                )
                break
            }
            //
            // Rule 141:  MethodModifiers ::= MethodModifier
            //
            case 141:
                break
            //
            // Rule 142:  MethodModifiers ::= MethodModifiers MethodModifier
            //
            case 142: {
               //#line 434 "GJavaParser.g"
                my.SetResult(
                    //#line 434 GJavaParser.g
                    NewMethodModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 434 GJavaParser.g
                                       my.GetRhsSym(1).(IMethodModifiers),
                                       //#line 434 GJavaParser.g
                                       my.GetRhsSym(2).(IMethodModifier)),
                //#line 434 GJavaParser.g
                )
                break
            }
            //
            // Rule 143:  MethodModifier ::= Annotations
            //
            case 143:
                break
            //
            // Rule 144:  MethodModifier ::= public
            //
            case 144: {
               //#line 437 "GJavaParser.g"
                my.SetResult(
                    //#line 437 GJavaParser.g
                    NewMethodModifier0(my.GetRhsIToken(1)),
                //#line 437 GJavaParser.g
                )
                break
            }
            //
            // Rule 145:  MethodModifier ::= protected
            //
            case 145: {
               //#line 438 "GJavaParser.g"
                my.SetResult(
                    //#line 438 GJavaParser.g
                    NewMethodModifier1(my.GetRhsIToken(1)),
                //#line 438 GJavaParser.g
                )
                break
            }
            //
            // Rule 146:  MethodModifier ::= private
            //
            case 146: {
               //#line 439 "GJavaParser.g"
                my.SetResult(
                    //#line 439 GJavaParser.g
                    NewMethodModifier2(my.GetRhsIToken(1)),
                //#line 439 GJavaParser.g
                )
                break
            }
            //
            // Rule 147:  MethodModifier ::= abstract
            //
            case 147: {
               //#line 440 "GJavaParser.g"
                my.SetResult(
                    //#line 440 GJavaParser.g
                    NewMethodModifier3(my.GetRhsIToken(1)),
                //#line 440 GJavaParser.g
                )
                break
            }
            //
            // Rule 148:  MethodModifier ::= static
            //
            case 148: {
               //#line 441 "GJavaParser.g"
                my.SetResult(
                    //#line 441 GJavaParser.g
                    NewMethodModifier4(my.GetRhsIToken(1)),
                //#line 441 GJavaParser.g
                )
                break
            }
            //
            // Rule 149:  MethodModifier ::= final
            //
            case 149: {
               //#line 442 "GJavaParser.g"
                my.SetResult(
                    //#line 442 GJavaParser.g
                    NewMethodModifier5(my.GetRhsIToken(1)),
                //#line 442 GJavaParser.g
                )
                break
            }
            //
            // Rule 150:  MethodModifier ::= synchronized
            //
            case 150: {
               //#line 443 "GJavaParser.g"
                my.SetResult(
                    //#line 443 GJavaParser.g
                    NewMethodModifier6(my.GetRhsIToken(1)),
                //#line 443 GJavaParser.g
                )
                break
            }
            //
            // Rule 151:  MethodModifier ::= native
            //
            case 151: {
               //#line 444 "GJavaParser.g"
                my.SetResult(
                    //#line 444 GJavaParser.g
                    NewMethodModifier7(my.GetRhsIToken(1)),
                //#line 444 GJavaParser.g
                )
                break
            }
            //
            // Rule 152:  MethodModifier ::= strictfp
            //
            case 152: {
               //#line 445 "GJavaParser.g"
                my.SetResult(
                    //#line 445 GJavaParser.g
                    NewMethodModifier8(my.GetRhsIToken(1)),
                //#line 445 GJavaParser.g
                )
                break
            }
            //
            // Rule 153:  Throws ::= throws ExceptionTypeList
            //
            case 153: {
               //#line 447 "GJavaParser.g"
                my.SetResult(
                    //#line 447 GJavaParser.g
                    NewThrows(my.GetLeftIToken(), my.GetRightIToken(),
                              //#line 447 GJavaParser.g
                              NewAstToken(my.GetRhsIToken(1)),
                              //#line 447 GJavaParser.g
                              my.GetRhsSym(2).(IExceptionTypeList)),
                //#line 447 GJavaParser.g
                )
                break
            }
            //
            // Rule 154:  ExceptionTypeList ::= ExceptionType
            //
            case 154:
                break
            //
            // Rule 155:  ExceptionTypeList ::= ExceptionTypeList , ExceptionType
            //
            case 155: {
               //#line 450 "GJavaParser.g"
                my.SetResult(
                    //#line 450 GJavaParser.g
                    NewExceptionTypeList(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 450 GJavaParser.g
                                         my.GetRhsSym(1).(IExceptionTypeList),
                                         //#line 450 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 450 GJavaParser.g
                                         my.GetRhsSym(3).(IExceptionType)),
                //#line 450 GJavaParser.g
                )
                break
            }
            //
            // Rule 156:  ExceptionType ::= ClassType
            //
            case 156:
                break
            //
            // Rule 157:  ExceptionType ::= TypeVariable
            //
            case 157:
                break
            //
            // Rule 158:  MethodBody ::= Block
            //
            case 158:
                break
            //
            // Rule 159:  MethodBody ::= ;
            //
            case 159: {
               //#line 456 "GJavaParser.g"
                my.SetResult(
                    //#line 456 GJavaParser.g
                    NewMethodBody(my.GetRhsIToken(1)),
                //#line 456 GJavaParser.g
                )
                break
            }
            //
            // Rule 160:  InstanceInitializer ::= Block
            //
            case 160:
                break
            //
            // Rule 161:  StaticInitializer ::= static Block
            //
            case 161: {
               //#line 460 "GJavaParser.g"
                my.SetResult(
                    //#line 460 GJavaParser.g
                    NewStaticInitializer(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 460 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(1)),
                                         //#line 460 GJavaParser.g
                                         my.GetRhsSym(2).(*Block)),
                //#line 460 GJavaParser.g
                )
                break
            }
            //
            // Rule 162:  ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator Throwsopt ConstructorBody
            //
            case 162: {
               //#line 462 "GJavaParser.g"
                my.SetResult(
                    //#line 462 GJavaParser.g
                    NewConstructorDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 462 GJavaParser.g
                                              AnyCastToIConstructorModifiersopt(my.GetRhsSym(1)),
                                              //#line 462 GJavaParser.g
                                              my.GetRhsSym(2).(*ConstructorDeclarator),
                                              //#line 462 GJavaParser.g
                                              AnyCastToThrows(my.GetRhsSym(3)),
                                              //#line 462 GJavaParser.g
                                              my.GetRhsSym(4).(*ConstructorBody)),
                //#line 462 GJavaParser.g
                )
                break
            }
            //
            // Rule 163:  ConstructorDeclarator ::= TypeParametersopt SimpleTypeName ( FormalParameterListopt )
            //
            case 163: {
               //#line 464 "GJavaParser.g"
                my.SetResult(
                    //#line 464 GJavaParser.g
                    NewConstructorDeclarator(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 464 GJavaParser.g
                                             AnyCastToTypeParameters(my.GetRhsSym(1)),
                                             //#line 464 GJavaParser.g
                                             my.GetRhsSym(2).(*identifier),
                                             //#line 464 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(3)),
                                             //#line 464 GJavaParser.g
                                             AnyCastToIFormalParameterListopt(my.GetRhsSym(4)),
                                             //#line 464 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(5))),
                //#line 464 GJavaParser.g
                )
                break
            }
            //
            // Rule 164:  SimpleTypeName ::= identifier
            //
            case 164:
                break
            //
            // Rule 165:  ConstructorModifiers ::= ConstructorModifier
            //
            case 165:
                break
            //
            // Rule 166:  ConstructorModifiers ::= ConstructorModifiers ConstructorModifier
            //
            case 166: {
               //#line 469 "GJavaParser.g"
                my.SetResult(
                    //#line 469 GJavaParser.g
                    NewConstructorModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 469 GJavaParser.g
                                            my.GetRhsSym(1).(IConstructorModifiers),
                                            //#line 469 GJavaParser.g
                                            my.GetRhsSym(2).(IConstructorModifier)),
                //#line 469 GJavaParser.g
                )
                break
            }
            //
            // Rule 167:  ConstructorModifier ::= Annotations
            //
            case 167:
                break
            //
            // Rule 168:  ConstructorModifier ::= public
            //
            case 168: {
               //#line 472 "GJavaParser.g"
                my.SetResult(
                    //#line 472 GJavaParser.g
                    NewConstructorModifier0(my.GetRhsIToken(1)),
                //#line 472 GJavaParser.g
                )
                break
            }
            //
            // Rule 169:  ConstructorModifier ::= protected
            //
            case 169: {
               //#line 473 "GJavaParser.g"
                my.SetResult(
                    //#line 473 GJavaParser.g
                    NewConstructorModifier1(my.GetRhsIToken(1)),
                //#line 473 GJavaParser.g
                )
                break
            }
            //
            // Rule 170:  ConstructorModifier ::= private
            //
            case 170: {
               //#line 474 "GJavaParser.g"
                my.SetResult(
                    //#line 474 GJavaParser.g
                    NewConstructorModifier2(my.GetRhsIToken(1)),
                //#line 474 GJavaParser.g
                )
                break
            }
            //
            // Rule 171:  ConstructorBody ::= { ExplicitConstructorInvocationopt BlockStatementsopt }
            //
            case 171: {
               //#line 476 "GJavaParser.g"
                my.SetResult(
                    //#line 476 GJavaParser.g
                    NewConstructorBody(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 476 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 476 GJavaParser.g
                                       AnyCastToIExplicitConstructorInvocationopt(my.GetRhsSym(2)),
                                       //#line 476 GJavaParser.g
                                       AnyCastToIBlockStatementsopt(my.GetRhsSym(3)),
                                       //#line 476 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(4))),
                //#line 476 GJavaParser.g
                )
                break
            }
            //
            // Rule 172:  ExplicitConstructorInvocation ::= TypeArgumentsopt this ( ArgumentListopt ) ;
            //
            case 172: {
               //#line 478 "GJavaParser.g"
                my.SetResult(
                    //#line 478 GJavaParser.g
                    NewExplicitConstructorInvocation0(my.GetLeftIToken(), my.GetRightIToken(),
                                                      //#line 478 GJavaParser.g
                                                      AnyCastToTypeArguments(my.GetRhsSym(1)),
                                                      //#line 478 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(2)),
                                                      //#line 478 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(3)),
                                                      //#line 478 GJavaParser.g
                                                      AnyCastToIArgumentListopt(my.GetRhsSym(4)),
                                                      //#line 478 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(5)),
                                                      //#line 478 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(6))),
                //#line 478 GJavaParser.g
                )
                break
            }
            //
            // Rule 173:  ExplicitConstructorInvocation ::= TypeArgumentsopt super ( ArgumentListopt ) ;
            //
            case 173: {
               //#line 479 "GJavaParser.g"
                my.SetResult(
                    //#line 479 GJavaParser.g
                    NewExplicitConstructorInvocation1(my.GetLeftIToken(), my.GetRightIToken(),
                                                      //#line 479 GJavaParser.g
                                                      AnyCastToTypeArguments(my.GetRhsSym(1)),
                                                      //#line 479 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(2)),
                                                      //#line 479 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(3)),
                                                      //#line 479 GJavaParser.g
                                                      AnyCastToIArgumentListopt(my.GetRhsSym(4)),
                                                      //#line 479 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(5)),
                                                      //#line 479 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(6))),
                //#line 479 GJavaParser.g
                )
                break
            }
            //
            // Rule 174:  ExplicitConstructorInvocation ::= Primary . TypeArgumentsopt super ( ArgumentListopt ) ;
            //
            case 174: {
               //#line 480 "GJavaParser.g"
                my.SetResult(
                    //#line 480 GJavaParser.g
                    NewExplicitConstructorInvocation2(my.GetLeftIToken(), my.GetRightIToken(),
                                                      //#line 480 GJavaParser.g
                                                      my.GetRhsSym(1).(IPrimary),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(2)),
                                                      //#line 480 GJavaParser.g
                                                      AnyCastToTypeArguments(my.GetRhsSym(3)),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(4)),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(5)),
                                                      //#line 480 GJavaParser.g
                                                      AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(7)),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(8))),
                //#line 480 GJavaParser.g
                )
                break
            }
            //
            // Rule 175:  EnumDeclaration ::= ClassModifiersopt enum identifier Interfacesopt EnumBody
            //
            case 175: {
               //#line 482 "GJavaParser.g"
                my.SetResult(
                    //#line 482 GJavaParser.g
                    NewEnumDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 482 GJavaParser.g
                                       AnyCastToIClassModifiersopt(my.GetRhsSym(1)),
                                       //#line 482 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(2)),
                                       //#line 482 GJavaParser.g
                                       my.GetRhsSym(3).(*identifier),
                                       //#line 482 GJavaParser.g
                                       AnyCastToInterfaces(my.GetRhsSym(4)),
                                       //#line 482 GJavaParser.g
                                       my.GetRhsSym(5).(*EnumBody)),
                //#line 482 GJavaParser.g
                )
                break
            }
            //
            // Rule 176:  EnumBody ::= { EnumConstantsopt ,opt EnumBodyDeclarationsopt }
            //
            case 176: {
               //#line 484 "GJavaParser.g"
                my.SetResult(
                    //#line 484 GJavaParser.g
                    NewEnumBody(my.GetLeftIToken(), my.GetRightIToken(),
                                //#line 484 GJavaParser.g
                                NewAstToken(my.GetRhsIToken(1)),
                                //#line 484 GJavaParser.g
                                AnyCastToIEnumConstantsopt(my.GetRhsSym(2)),
                                //#line 484 GJavaParser.g
                                AnyCastToCommaopt(my.GetRhsSym(3)),
                                //#line 484 GJavaParser.g
                                AnyCastToEnumBodyDeclarations(my.GetRhsSym(4)),
                                //#line 484 GJavaParser.g
                                NewAstToken(my.GetRhsIToken(5))),
                //#line 484 GJavaParser.g
                )
                break
            }
            //
            // Rule 177:  EnumConstants ::= EnumConstant
            //
            case 177:
                break
            //
            // Rule 178:  EnumConstants ::= EnumConstants , EnumConstant
            //
            case 178: {
               //#line 487 "GJavaParser.g"
                my.SetResult(
                    //#line 487 GJavaParser.g
                    NewEnumConstants(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 487 GJavaParser.g
                                     my.GetRhsSym(1).(IEnumConstants),
                                     //#line 487 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(2)),
                                     //#line 487 GJavaParser.g
                                     my.GetRhsSym(3).(IEnumConstant)),
                //#line 487 GJavaParser.g
                )
                break
            }
            //
            // Rule 179:  EnumConstant ::= Annotationsopt identifier Argumentsopt ClassBodyopt
            //
            case 179: {
               //#line 489 "GJavaParser.g"
                my.SetResult(
                    //#line 489 GJavaParser.g
                    NewEnumConstant(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 489 GJavaParser.g
                                    AnyCastToIAnnotationsopt(my.GetRhsSym(1)),
                                    //#line 489 GJavaParser.g
                                    my.GetRhsSym(2).(*identifier),
                                    //#line 489 GJavaParser.g
                                    AnyCastToArguments(my.GetRhsSym(3)),
                                    //#line 489 GJavaParser.g
                                    AnyCastToClassBody(my.GetRhsSym(4))),
                //#line 489 GJavaParser.g
                )
                break
            }
            //
            // Rule 180:  Arguments ::= ( ArgumentListopt )
            //
            case 180: {
               //#line 491 "GJavaParser.g"
                my.SetResult(
                    //#line 491 GJavaParser.g
                    NewArguments(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 491 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(1)),
                                 //#line 491 GJavaParser.g
                                 AnyCastToIArgumentListopt(my.GetRhsSym(2)),
                                 //#line 491 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(3))),
                //#line 491 GJavaParser.g
                )
                break
            }
            //
            // Rule 181:  EnumBodyDeclarations ::= ; ClassBodyDeclarationsopt
            //
            case 181: {
               //#line 493 "GJavaParser.g"
                my.SetResult(
                    //#line 493 GJavaParser.g
                    NewEnumBodyDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 493 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(1)),
                                            //#line 493 GJavaParser.g
                                            AnyCastToIClassBodyDeclarationsopt(my.GetRhsSym(2))),
                //#line 493 GJavaParser.g
                )
                break
            }
            //
            // Rule 182:  InterfaceDeclaration ::= NormalInterfaceDeclaration
            //
            case 182:
                break
            //
            // Rule 183:  InterfaceDeclaration ::= AnnotationTypeDeclaration
            //
            case 183:
                break
            //
            // Rule 184:  NormalInterfaceDeclaration ::= InterfaceModifiersopt interface identifier TypeParametersopt ExtendsInterfacesopt InterfaceBody
            //
            case 184: {
               //#line 500 "GJavaParser.g"
                my.SetResult(
                    //#line 500 GJavaParser.g
                    NewNormalInterfaceDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                  //#line 500 GJavaParser.g
                                                  AnyCastToIInterfaceModifiersopt(my.GetRhsSym(1)),
                                                  //#line 500 GJavaParser.g
                                                  NewAstToken(my.GetRhsIToken(2)),
                                                  //#line 500 GJavaParser.g
                                                  my.GetRhsSym(3).(*identifier),
                                                  //#line 500 GJavaParser.g
                                                  AnyCastToTypeParameters(my.GetRhsSym(4)),
                                                  //#line 500 GJavaParser.g
                                                  AnyCastToIExtendsInterfacesopt(my.GetRhsSym(5)),
                                                  //#line 500 GJavaParser.g
                                                  my.GetRhsSym(6).(*InterfaceBody)),
                //#line 500 GJavaParser.g
                )
                break
            }
            //
            // Rule 185:  InterfaceModifiers ::= InterfaceModifier
            //
            case 185:
                break
            //
            // Rule 186:  InterfaceModifiers ::= InterfaceModifiers InterfaceModifier
            //
            case 186: {
               //#line 503 "GJavaParser.g"
                my.SetResult(
                    //#line 503 GJavaParser.g
                    NewInterfaceModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 503 GJavaParser.g
                                          my.GetRhsSym(1).(IInterfaceModifiers),
                                          //#line 503 GJavaParser.g
                                          my.GetRhsSym(2).(IInterfaceModifier)),
                //#line 503 GJavaParser.g
                )
                break
            }
            //
            // Rule 187:  InterfaceModifier ::= Annotation
            //
            case 187:
                break
            //
            // Rule 188:  InterfaceModifier ::= public
            //
            case 188: {
               //#line 506 "GJavaParser.g"
                my.SetResult(
                    //#line 506 GJavaParser.g
                    NewInterfaceModifier0(my.GetRhsIToken(1)),
                //#line 506 GJavaParser.g
                )
                break
            }
            //
            // Rule 189:  InterfaceModifier ::= protected
            //
            case 189: {
               //#line 507 "GJavaParser.g"
                my.SetResult(
                    //#line 507 GJavaParser.g
                    NewInterfaceModifier1(my.GetRhsIToken(1)),
                //#line 507 GJavaParser.g
                )
                break
            }
            //
            // Rule 190:  InterfaceModifier ::= private
            //
            case 190: {
               //#line 508 "GJavaParser.g"
                my.SetResult(
                    //#line 508 GJavaParser.g
                    NewInterfaceModifier2(my.GetRhsIToken(1)),
                //#line 508 GJavaParser.g
                )
                break
            }
            //
            // Rule 191:  InterfaceModifier ::= abstract
            //
            case 191: {
               //#line 509 "GJavaParser.g"
                my.SetResult(
                    //#line 509 GJavaParser.g
                    NewInterfaceModifier3(my.GetRhsIToken(1)),
                //#line 509 GJavaParser.g
                )
                break
            }
            //
            // Rule 192:  InterfaceModifier ::= static
            //
            case 192: {
               //#line 510 "GJavaParser.g"
                my.SetResult(
                    //#line 510 GJavaParser.g
                    NewInterfaceModifier4(my.GetRhsIToken(1)),
                //#line 510 GJavaParser.g
                )
                break
            }
            //
            // Rule 193:  InterfaceModifier ::= strictfp
            //
            case 193: {
               //#line 511 "GJavaParser.g"
                my.SetResult(
                    //#line 511 GJavaParser.g
                    NewInterfaceModifier5(my.GetRhsIToken(1)),
                //#line 511 GJavaParser.g
                )
                break
            }
            //
            // Rule 194:  ExtendsInterfaces ::= extends InterfaceType
            //
            case 194: {
               //#line 513 "GJavaParser.g"
                my.SetResult(
                    //#line 513 GJavaParser.g
                    NewExtendsInterfaces0(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 513 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(1)),
                                          //#line 513 GJavaParser.g
                                          my.GetRhsSym(2).(*InterfaceType)),
                //#line 513 GJavaParser.g
                )
                break
            }
            //
            // Rule 195:  ExtendsInterfaces ::= ExtendsInterfaces , InterfaceType
            //
            case 195: {
               //#line 514 "GJavaParser.g"
                my.SetResult(
                    //#line 514 GJavaParser.g
                    NewExtendsInterfaces1(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 514 GJavaParser.g
                                          my.GetRhsSym(1).(IExtendsInterfaces),
                                          //#line 514 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 514 GJavaParser.g
                                          my.GetRhsSym(3).(*InterfaceType)),
                //#line 514 GJavaParser.g
                )
                break
            }
            //
            // Rule 196:  InterfaceBody ::= { InterfaceMemberDeclarationsopt }
            //
            case 196: {
               //#line 521 "GJavaParser.g"
                my.SetResult(
                    //#line 521 GJavaParser.g
                    NewInterfaceBody(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 521 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(1)),
                                     //#line 521 GJavaParser.g
                                     AnyCastToIInterfaceMemberDeclarationsopt(my.GetRhsSym(2)),
                                     //#line 521 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(3))),
                //#line 521 GJavaParser.g
                )
                break
            }
            //
            // Rule 197:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
            //
            case 197:
                break
            //
            // Rule 198:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
            //
            case 198: {
               //#line 524 "GJavaParser.g"
                my.SetResult(
                    //#line 524 GJavaParser.g
                    NewInterfaceMemberDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                                   //#line 524 GJavaParser.g
                                                   my.GetRhsSym(1).(IInterfaceMemberDeclarations),
                                                   //#line 524 GJavaParser.g
                                                   my.GetRhsSym(2).(IInterfaceMemberDeclaration)),
                //#line 524 GJavaParser.g
                )
                break
            }
            //
            // Rule 199:  InterfaceMemberDeclaration ::= ConstantDeclaration
            //
            case 199:
                break
            //
            // Rule 200:  InterfaceMemberDeclaration ::= AbstractMethodDeclaration
            //
            case 200:
                break
            //
            // Rule 201:  InterfaceMemberDeclaration ::= ClassDeclaration
            //
            case 201:
                break
            //
            // Rule 202:  InterfaceMemberDeclaration ::= InterfaceDeclaration
            //
            case 202:
                break
            //
            // Rule 203:  InterfaceMemberDeclaration ::= ;
            //
            case 203: {
               //#line 530 "GJavaParser.g"
                my.SetResult(
                    //#line 530 GJavaParser.g
                    NewInterfaceMemberDeclaration(my.GetRhsIToken(1)),
                //#line 530 GJavaParser.g
                )
                break
            }
            //
            // Rule 204:  ConstantDeclaration ::= ConstantModifiersopt Type VariableDeclarators
            //
            case 204: {
               //#line 532 "GJavaParser.g"
                my.SetResult(
                    //#line 532 GJavaParser.g
                    NewConstantDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 532 GJavaParser.g
                                           AnyCastToIConstantModifiersopt(my.GetRhsSym(1)),
                                           //#line 532 GJavaParser.g
                                           my.GetRhsSym(2).(IType),
                                           //#line 532 GJavaParser.g
                                           my.GetRhsSym(3).(IVariableDeclarators)),
                //#line 532 GJavaParser.g
                )
                break
            }
            //
            // Rule 205:  ConstantModifiers ::= ConstantModifier
            //
            case 205:
                break
            //
            // Rule 206:  ConstantModifiers ::= ConstantModifiers ConstantModifier
            //
            case 206: {
               //#line 535 "GJavaParser.g"
                my.SetResult(
                    //#line 535 GJavaParser.g
                    NewConstantModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 535 GJavaParser.g
                                         my.GetRhsSym(1).(IConstantModifiers),
                                         //#line 535 GJavaParser.g
                                         my.GetRhsSym(2).(IConstantModifier)),
                //#line 535 GJavaParser.g
                )
                break
            }
            //
            // Rule 207:  ConstantModifier ::= Annotation
            //
            case 207:
                break
            //
            // Rule 208:  ConstantModifier ::= public
            //
            case 208: {
               //#line 538 "GJavaParser.g"
                my.SetResult(
                    //#line 538 GJavaParser.g
                    NewConstantModifier0(my.GetRhsIToken(1)),
                //#line 538 GJavaParser.g
                )
                break
            }
            //
            // Rule 209:  ConstantModifier ::= static
            //
            case 209: {
               //#line 539 "GJavaParser.g"
                my.SetResult(
                    //#line 539 GJavaParser.g
                    NewConstantModifier1(my.GetRhsIToken(1)),
                //#line 539 GJavaParser.g
                )
                break
            }
            //
            // Rule 210:  ConstantModifier ::= final
            //
            case 210: {
               //#line 540 "GJavaParser.g"
                my.SetResult(
                    //#line 540 GJavaParser.g
                    NewConstantModifier2(my.GetRhsIToken(1)),
                //#line 540 GJavaParser.g
                )
                break
            }
            //
            // Rule 211:  AbstractMethodDeclaration ::= AbstractMethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt ;
            //
            case 211: {
               //#line 542 "GJavaParser.g"
                my.SetResult(
                    //#line 542 GJavaParser.g
                    NewAbstractMethodDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 542 GJavaParser.g
                                                 AnyCastToIAbstractMethodModifiersopt(my.GetRhsSym(1)),
                                                 //#line 542 GJavaParser.g
                                                 AnyCastToTypeParameters(my.GetRhsSym(2)),
                                                 //#line 542 GJavaParser.g
                                                 my.GetRhsSym(3).(IResultType),
                                                 //#line 542 GJavaParser.g
                                                 my.GetRhsSym(4).(IMethodDeclarator),
                                                 //#line 542 GJavaParser.g
                                                 AnyCastToThrows(my.GetRhsSym(5)),
                                                 //#line 542 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(6))),
                //#line 542 GJavaParser.g
                )
                break
            }
            //
            // Rule 212:  AbstractMethodModifiers ::= AbstractMethodModifier
            //
            case 212:
                break
            //
            // Rule 213:  AbstractMethodModifiers ::= AbstractMethodModifiers AbstractMethodModifier
            //
            case 213: {
               //#line 545 "GJavaParser.g"
                my.SetResult(
                    //#line 545 GJavaParser.g
                    NewAbstractMethodModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 545 GJavaParser.g
                                               my.GetRhsSym(1).(IAbstractMethodModifiers),
                                               //#line 545 GJavaParser.g
                                               my.GetRhsSym(2).(IAbstractMethodModifier)),
                //#line 545 GJavaParser.g
                )
                break
            }
            //
            // Rule 214:  AbstractMethodModifier ::= Annotations
            //
            case 214:
                break
            //
            // Rule 215:  AbstractMethodModifier ::= public
            //
            case 215: {
               //#line 548 "GJavaParser.g"
                my.SetResult(
                    //#line 548 GJavaParser.g
                    NewAbstractMethodModifier0(my.GetRhsIToken(1)),
                //#line 548 GJavaParser.g
                )
                break
            }
            //
            // Rule 216:  AbstractMethodModifier ::= abstract
            //
            case 216: {
               //#line 549 "GJavaParser.g"
                my.SetResult(
                    //#line 549 GJavaParser.g
                    NewAbstractMethodModifier1(my.GetRhsIToken(1)),
                //#line 549 GJavaParser.g
                )
                break
            }
            //
            // Rule 217:  AnnotationTypeDeclaration ::= InterfaceModifiersopt @ interface identifier AnnotationTypeBody
            //
            case 217: {
               //#line 551 "GJavaParser.g"
                my.SetResult(
                    //#line 551 GJavaParser.g
                    NewAnnotationTypeDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 551 GJavaParser.g
                                                 AnyCastToIInterfaceModifiersopt(my.GetRhsSym(1)),
                                                 //#line 551 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 551 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(3)),
                                                 //#line 551 GJavaParser.g
                                                 my.GetRhsSym(4).(*identifier),
                                                 //#line 551 GJavaParser.g
                                                 my.GetRhsSym(5).(*AnnotationTypeBody)),
                //#line 551 GJavaParser.g
                )
                break
            }
            //
            // Rule 218:  AnnotationTypeBody ::= { AnnotationTypeElementDeclarationsopt }
            //
            case 218: {
               //#line 553 "GJavaParser.g"
                my.SetResult(
                    //#line 553 GJavaParser.g
                    NewAnnotationTypeBody(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 553 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(1)),
                                          //#line 553 GJavaParser.g
                                          AnyCastToIAnnotationTypeElementDeclarationsopt(my.GetRhsSym(2)),
                                          //#line 553 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 553 GJavaParser.g
                )
                break
            }
            //
            // Rule 219:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclaration
            //
            case 219:
                break
            //
            // Rule 220:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
            //
            case 220: {
               //#line 556 "GJavaParser.g"
                my.SetResult(
                    //#line 556 GJavaParser.g
                    NewAnnotationTypeElementDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                                         //#line 556 GJavaParser.g
                                                         my.GetRhsSym(1).(IAnnotationTypeElementDeclarations),
                                                         //#line 556 GJavaParser.g
                                                         my.GetRhsSym(2).(IAnnotationTypeElementDeclaration)),
                //#line 556 GJavaParser.g
                )
                break
            }
            //
            // Rule 221:  AnnotationTypeElementDeclaration ::= AbstractMethodModifiersopt Type identifier ( ) DefaultValueopt ;
            //
            case 221: {
               //#line 558 "GJavaParser.g"
                my.SetResult(
                    //#line 558 GJavaParser.g
                    NewAnnotationTypeElementDeclaration0(my.GetLeftIToken(), my.GetRightIToken(),
                                                         //#line 558 GJavaParser.g
                                                         AnyCastToIAbstractMethodModifiersopt(my.GetRhsSym(1)),
                                                         //#line 558 GJavaParser.g
                                                         my.GetRhsSym(2).(IType),
                                                         //#line 558 GJavaParser.g
                                                         my.GetRhsSym(3).(*identifier),
                                                         //#line 558 GJavaParser.g
                                                         NewAstToken(my.GetRhsIToken(4)),
                                                         //#line 558 GJavaParser.g
                                                         NewAstToken(my.GetRhsIToken(5)),
                                                         //#line 558 GJavaParser.g
                                                         AnyCastToDefaultValue(my.GetRhsSym(6)),
                                                         //#line 558 GJavaParser.g
                                                         NewAstToken(my.GetRhsIToken(7))),
                //#line 558 GJavaParser.g
                )
                break
            }
            //
            // Rule 222:  AnnotationTypeElementDeclaration ::= ConstantDeclaration
            //
            case 222:
                break
            //
            // Rule 223:  AnnotationTypeElementDeclaration ::= ClassDeclaration
            //
            case 223:
                break
            //
            // Rule 224:  AnnotationTypeElementDeclaration ::= InterfaceDeclaration
            //
            case 224:
                break
            //
            // Rule 225:  AnnotationTypeElementDeclaration ::= EnumDeclaration
            //
            case 225:
                break
            //
            // Rule 226:  AnnotationTypeElementDeclaration ::= AnnotationTypeDeclaration
            //
            case 226:
                break
            //
            // Rule 227:  AnnotationTypeElementDeclaration ::= ;
            //
            case 227: {
               //#line 564 "GJavaParser.g"
                my.SetResult(
                    //#line 564 GJavaParser.g
                    NewAnnotationTypeElementDeclaration1(my.GetRhsIToken(1)),
                //#line 564 GJavaParser.g
                )
                break
            }
            //
            // Rule 228:  DefaultValue ::= default ElementValue
            //
            case 228: {
               //#line 566 "GJavaParser.g"
                my.SetResult(
                    //#line 566 GJavaParser.g
                    NewDefaultValue(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 566 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 566 GJavaParser.g
                                    my.GetRhsSym(2).(IElementValue)),
                //#line 566 GJavaParser.g
                )
                break
            }
            //
            // Rule 229:  Annotations ::= Annotation
            //
            case 229:
                break
            //
            // Rule 230:  Annotations ::= Annotations Annotation
            //
            case 230: {
               //#line 569 "GJavaParser.g"
                my.SetResult(
                    //#line 569 GJavaParser.g
                    NewAnnotations(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 569 GJavaParser.g
                                   my.GetRhsSym(1).(IAnnotations),
                                   //#line 569 GJavaParser.g
                                   my.GetRhsSym(2).(IAnnotation)),
                //#line 569 GJavaParser.g
                )
                break
            }
            //
            // Rule 231:  Annotation ::= NormalAnnotation
            //
            case 231:
                break
            //
            // Rule 232:  Annotation ::= MarkerAnnotation
            //
            case 232:
                break
            //
            // Rule 233:  Annotation ::= SingleElementAnnotation
            //
            case 233:
                break
            //
            // Rule 234:  NormalAnnotation ::= @ TypeName ( ElementValuePairsopt )
            //
            case 234: {
               //#line 575 "GJavaParser.g"
                my.SetResult(
                    //#line 575 GJavaParser.g
                    NewNormalAnnotation(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 575 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 575 GJavaParser.g
                                        my.GetRhsSym(2).(ITypeName),
                                        //#line 575 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3)),
                                        //#line 575 GJavaParser.g
                                        AnyCastToIElementValuePairsopt(my.GetRhsSym(4)),
                                        //#line 575 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(5))),
                //#line 575 GJavaParser.g
                )
                break
            }
            //
            // Rule 235:  ElementValuePairs ::= ElementValuePair
            //
            case 235:
                break
            //
            // Rule 236:  ElementValuePairs ::= ElementValuePairs , ElementValuePair
            //
            case 236: {
               //#line 578 "GJavaParser.g"
                my.SetResult(
                    //#line 578 GJavaParser.g
                    NewElementValuePairs(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 578 GJavaParser.g
                                         my.GetRhsSym(1).(IElementValuePairs),
                                         //#line 578 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 578 GJavaParser.g
                                         my.GetRhsSym(3).(*ElementValuePair)),
                //#line 578 GJavaParser.g
                )
                break
            }
            //
            // Rule 237:  ElementValuePair ::= SimpleName = ElementValue
            //
            case 237: {
               //#line 580 "GJavaParser.g"
                my.SetResult(
                    //#line 580 GJavaParser.g
                    NewElementValuePair(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 580 GJavaParser.g
                                        my.GetRhsSym(1).(*identifier),
                                        //#line 580 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 580 GJavaParser.g
                                        my.GetRhsSym(3).(IElementValue)),
                //#line 580 GJavaParser.g
                )
                break
            }
            //
            // Rule 238:  SimpleName ::= identifier
            //
            case 238:
                break
            //
            // Rule 239:  ElementValue ::= ConditionalExpression
            //
            case 239:
                break
            //
            // Rule 240:  ElementValue ::= Annotation
            //
            case 240:
                break
            //
            // Rule 241:  ElementValue ::= ElementValueArrayInitializer
            //
            case 241:
                break
            //
            // Rule 242:  ElementValueArrayInitializer ::= { ElementValuesopt ,opt }
            //
            case 242: {
               //#line 588 "GJavaParser.g"
                my.SetResult(
                    //#line 588 GJavaParser.g
                    NewElementValueArrayInitializer(my.GetLeftIToken(), my.GetRightIToken(),
                                                    //#line 588 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(1)),
                                                    //#line 588 GJavaParser.g
                                                    AnyCastToIElementValuesopt(my.GetRhsSym(2)),
                                                    //#line 588 GJavaParser.g
                                                    AnyCastToCommaopt(my.GetRhsSym(3)),
                                                    //#line 588 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(4))),
                //#line 588 GJavaParser.g
                )
                break
            }
            //
            // Rule 243:  ElementValues ::= ElementValue
            //
            case 243:
                break
            //
            // Rule 244:  ElementValues ::= ElementValues , ElementValue
            //
            case 244: {
               //#line 591 "GJavaParser.g"
                my.SetResult(
                    //#line 591 GJavaParser.g
                    NewElementValues(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 591 GJavaParser.g
                                     my.GetRhsSym(1).(IElementValues),
                                     //#line 591 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(2)),
                                     //#line 591 GJavaParser.g
                                     my.GetRhsSym(3).(IElementValue)),
                //#line 591 GJavaParser.g
                )
                break
            }
            //
            // Rule 245:  MarkerAnnotation ::= @ TypeName
            //
            case 245: {
               //#line 593 "GJavaParser.g"
                my.SetResult(
                    //#line 593 GJavaParser.g
                    NewMarkerAnnotation(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 593 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 593 GJavaParser.g
                                        my.GetRhsSym(2).(ITypeName)),
                //#line 593 GJavaParser.g
                )
                break
            }
            //
            // Rule 246:  SingleElementAnnotation ::= @ TypeName ( ElementValue )
            //
            case 246: {
               //#line 595 "GJavaParser.g"
                my.SetResult(
                    //#line 595 GJavaParser.g
                    NewSingleElementAnnotation(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 595 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(1)),
                                               //#line 595 GJavaParser.g
                                               my.GetRhsSym(2).(ITypeName),
                                               //#line 595 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(3)),
                                               //#line 595 GJavaParser.g
                                               my.GetRhsSym(4).(IElementValue),
                                               //#line 595 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(5))),
                //#line 595 GJavaParser.g
                )
                break
            }
            //
            // Rule 247:  ArrayInitializer ::= { VariableInitializersopt ,opt }
            //
            case 247: {
               //#line 599 "GJavaParser.g"
                my.SetResult(
                    //#line 599 GJavaParser.g
                    NewArrayInitializer(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 599 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 599 GJavaParser.g
                                        AnyCastToIVariableInitializersopt(my.GetRhsSym(2)),
                                        //#line 599 GJavaParser.g
                                        AnyCastToCommaopt(my.GetRhsSym(3)),
                                        //#line 599 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(4))),
                //#line 599 GJavaParser.g
                )
                break
            }
            //
            // Rule 248:  VariableInitializers ::= VariableInitializer
            //
            case 248:
                break
            //
            // Rule 249:  VariableInitializers ::= VariableInitializers , VariableInitializer
            //
            case 249: {
               //#line 602 "GJavaParser.g"
                my.SetResult(
                    //#line 602 GJavaParser.g
                    NewVariableInitializers(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 602 GJavaParser.g
                                            my.GetRhsSym(1).(IVariableInitializers),
                                            //#line 602 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(2)),
                                            //#line 602 GJavaParser.g
                                            my.GetRhsSym(3).(IVariableInitializer)),
                //#line 602 GJavaParser.g
                )
                break
            }
            //
            // Rule 250:  Block ::= { BlockStatementsopt }
            //
            case 250: {
               //#line 618 "GJavaParser.g"
                my.SetResult(
                    //#line 618 GJavaParser.g
                    NewBlock(my.GetLeftIToken(), my.GetRightIToken(),
                             //#line 618 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(1)),
                             //#line 618 GJavaParser.g
                             AnyCastToIBlockStatementsopt(my.GetRhsSym(2)),
                             //#line 618 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(3))),
                //#line 618 GJavaParser.g
                )
                break
            }
            //
            // Rule 251:  BlockStatements ::= BlockStatement
            //
            case 251:
                break
            //
            // Rule 252:  BlockStatements ::= BlockStatements BlockStatement
            //
            case 252: {
               //#line 621 "GJavaParser.g"
                my.SetResult(
                    //#line 621 GJavaParser.g
                    NewBlockStatements(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 621 GJavaParser.g
                                       my.GetRhsSym(1).(IBlockStatements),
                                       //#line 621 GJavaParser.g
                                       my.GetRhsSym(2).(IBlockStatement)),
                //#line 621 GJavaParser.g
                )
                break
            }
            //
            // Rule 253:  BlockStatement ::= LocalVariableDeclarationStatement
            //
            case 253:
                break
            //
            // Rule 254:  BlockStatement ::= ClassDeclaration
            //
            case 254:
                break
            //
            // Rule 255:  BlockStatement ::= Statement
            //
            case 255:
                break
            //
            // Rule 256:  LocalVariableDeclarationStatement ::= LocalVariableDeclaration ;
            //
            case 256: {
               //#line 627 "GJavaParser.g"
                my.SetResult(
                    //#line 627 GJavaParser.g
                    NewLocalVariableDeclarationStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                                         //#line 627 GJavaParser.g
                                                         my.GetRhsSym(1).(*LocalVariableDeclaration),
                                                         //#line 627 GJavaParser.g
                                                         NewAstToken(my.GetRhsIToken(2))),
                //#line 627 GJavaParser.g
                )
                break
            }
            //
            // Rule 257:  LocalVariableDeclaration ::= VariableModifiersopt Type VariableDeclarators
            //
            case 257: {
               //#line 629 "GJavaParser.g"
                my.SetResult(
                    //#line 629 GJavaParser.g
                    NewLocalVariableDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 629 GJavaParser.g
                                                AnyCastToIVariableModifiersopt(my.GetRhsSym(1)),
                                                //#line 629 GJavaParser.g
                                                my.GetRhsSym(2).(IType),
                                                //#line 629 GJavaParser.g
                                                my.GetRhsSym(3).(IVariableDeclarators)),
                //#line 629 GJavaParser.g
                )
                break
            }
            //
            // Rule 258:  Statement ::= StatementWithoutTrailingSubstatement
            //
            case 258:
                break
            //
            // Rule 259:  Statement ::= LabeledStatement
            //
            case 259:
                break
            //
            // Rule 260:  Statement ::= IfThenStatement
            //
            case 260:
                break
            //
            // Rule 261:  Statement ::= IfThenElseStatement
            //
            case 261:
                break
            //
            // Rule 262:  Statement ::= WhileStatement
            //
            case 262:
                break
            //
            // Rule 263:  Statement ::= ForStatement
            //
            case 263:
                break
            //
            // Rule 264:  StatementWithoutTrailingSubstatement ::= Block
            //
            case 264:
                break
            //
            // Rule 265:  StatementWithoutTrailingSubstatement ::= EmptyStatement
            //
            case 265:
                break
            //
            // Rule 266:  StatementWithoutTrailingSubstatement ::= ExpressionStatement
            //
            case 266:
                break
            //
            // Rule 267:  StatementWithoutTrailingSubstatement ::= AssertStatement
            //
            case 267:
                break
            //
            // Rule 268:  StatementWithoutTrailingSubstatement ::= SwitchStatement
            //
            case 268:
                break
            //
            // Rule 269:  StatementWithoutTrailingSubstatement ::= DoStatement
            //
            case 269:
                break
            //
            // Rule 270:  StatementWithoutTrailingSubstatement ::= BreakStatement
            //
            case 270:
                break
            //
            // Rule 271:  StatementWithoutTrailingSubstatement ::= ContinueStatement
            //
            case 271:
                break
            //
            // Rule 272:  StatementWithoutTrailingSubstatement ::= ReturnStatement
            //
            case 272:
                break
            //
            // Rule 273:  StatementWithoutTrailingSubstatement ::= SynchronizedStatement
            //
            case 273:
                break
            //
            // Rule 274:  StatementWithoutTrailingSubstatement ::= ThrowStatement
            //
            case 274:
                break
            //
            // Rule 275:  StatementWithoutTrailingSubstatement ::= TryStatement
            //
            case 275:
                break
            //
            // Rule 276:  StatementNoShortIf ::= StatementWithoutTrailingSubstatement
            //
            case 276:
                break
            //
            // Rule 277:  StatementNoShortIf ::= LabeledStatementNoShortIf
            //
            case 277:
                break
            //
            // Rule 278:  StatementNoShortIf ::= IfThenElseStatementNoShortIf
            //
            case 278:
                break
            //
            // Rule 279:  StatementNoShortIf ::= WhileStatementNoShortIf
            //
            case 279:
                break
            //
            // Rule 280:  StatementNoShortIf ::= ForStatementNoShortIf
            //
            case 280:
                break
            //
            // Rule 281:  IfThenStatement ::= if ( Expression ) Statement
            //
            case 281: {
               //#line 672 "GJavaParser.g"
                my.SetResult(
                    //#line 672 GJavaParser.g
                    NewIfThenStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 672 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 672 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(2)),
                                       //#line 672 GJavaParser.g
                                       my.GetRhsSym(3).(IExpression),
                                       //#line 672 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(4)),
                                       //#line 672 GJavaParser.g
                                       my.GetRhsSym(5).(IStatement)),
                //#line 672 GJavaParser.g
                )
                break
            }
            //
            // Rule 282:  IfThenElseStatement ::= if ( Expression ) StatementNoShortIf else Statement
            //
            case 282: {
               //#line 674 "GJavaParser.g"
                my.SetResult(
                    //#line 674 GJavaParser.g
                    NewIfThenElseStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 674 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(1)),
                                           //#line 674 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 674 GJavaParser.g
                                           my.GetRhsSym(3).(IExpression),
                                           //#line 674 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(4)),
                                           //#line 674 GJavaParser.g
                                           my.GetRhsSym(5).(IStatementNoShortIf),
                                           //#line 674 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(6)),
                                           //#line 674 GJavaParser.g
                                           my.GetRhsSym(7).(IStatement)),
                //#line 674 GJavaParser.g
                )
                break
            }
            //
            // Rule 283:  IfThenElseStatementNoShortIf ::= if ( Expression ) StatementNoShortIf else StatementNoShortIf
            //
            case 283: {
               //#line 676 "GJavaParser.g"
                my.SetResult(
                    //#line 676 GJavaParser.g
                    NewIfThenElseStatementNoShortIf(my.GetLeftIToken(), my.GetRightIToken(),
                                                    //#line 676 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(1)),
                                                    //#line 676 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(2)),
                                                    //#line 676 GJavaParser.g
                                                    my.GetRhsSym(3).(IExpression),
                                                    //#line 676 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(4)),
                                                    //#line 676 GJavaParser.g
                                                    my.GetRhsSym(5).(IStatementNoShortIf),
                                                    //#line 676 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(6)),
                                                    //#line 676 GJavaParser.g
                                                    my.GetRhsSym(7).(IStatementNoShortIf)),
                //#line 676 GJavaParser.g
                )
                break
            }
            //
            // Rule 284:  EmptyStatement ::= ;
            //
            case 284: {
               //#line 678 "GJavaParser.g"
                my.SetResult(
                    //#line 678 GJavaParser.g
                    NewEmptyStatement(my.GetRhsIToken(1)),
                //#line 678 GJavaParser.g
                )
                break
            }
            //
            // Rule 285:  LabeledStatement ::= identifier : Statement
            //
            case 285: {
               //#line 680 "GJavaParser.g"
                my.SetResult(
                    //#line 680 GJavaParser.g
                    NewLabeledStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 680 GJavaParser.g
                                        my.GetRhsSym(1).(*identifier),
                                        //#line 680 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 680 GJavaParser.g
                                        my.GetRhsSym(3).(IStatement)),
                //#line 680 GJavaParser.g
                )
                break
            }
            //
            // Rule 286:  LabeledStatementNoShortIf ::= identifier : StatementNoShortIf
            //
            case 286: {
               //#line 682 "GJavaParser.g"
                my.SetResult(
                    //#line 682 GJavaParser.g
                    NewLabeledStatementNoShortIf(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 682 GJavaParser.g
                                                 my.GetRhsSym(1).(*identifier),
                                                 //#line 682 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 682 GJavaParser.g
                                                 my.GetRhsSym(3).(IStatementNoShortIf)),
                //#line 682 GJavaParser.g
                )
                break
            }
            //
            // Rule 287:  ExpressionStatement ::= StatementExpression ;
            //
            case 287: {
               //#line 684 "GJavaParser.g"
                my.SetResult(
                    //#line 684 GJavaParser.g
                    NewExpressionStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 684 GJavaParser.g
                                           my.GetRhsSym(1).(IStatementExpression),
                                           //#line 684 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2))),
                //#line 684 GJavaParser.g
                )
                break
            }
            //
            // Rule 288:  StatementExpression ::= Assignment
            //
            case 288:
                break
            //
            // Rule 289:  StatementExpression ::= PreIncrementExpression
            //
            case 289:
                break
            //
            // Rule 290:  StatementExpression ::= PreDecrementExpression
            //
            case 290:
                break
            //
            // Rule 291:  StatementExpression ::= PostIncrementExpression
            //
            case 291:
                break
            //
            // Rule 292:  StatementExpression ::= PostDecrementExpression
            //
            case 292:
                break
            //
            // Rule 293:  StatementExpression ::= MethodInvocation
            //
            case 293:
                break
            //
            // Rule 294:  StatementExpression ::= ClassInstanceCreationExpression
            //
            case 294:
                break
            //
            // Rule 295:  AssertStatement ::= assert Expression ;
            //
            case 295: {
               //#line 703 "GJavaParser.g"
                my.SetResult(
                    //#line 703 GJavaParser.g
                    NewAssertStatement0(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 703 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 703 GJavaParser.g
                                        my.GetRhsSym(2).(IExpression),
                                        //#line 703 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3))),
                //#line 703 GJavaParser.g
                )
                break
            }
            //
            // Rule 296:  AssertStatement ::= assert Expression : Expression ;
            //
            case 296: {
               //#line 704 "GJavaParser.g"
                my.SetResult(
                    //#line 704 GJavaParser.g
                    NewAssertStatement1(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 704 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 704 GJavaParser.g
                                        my.GetRhsSym(2).(IExpression),
                                        //#line 704 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3)),
                                        //#line 704 GJavaParser.g
                                        my.GetRhsSym(4).(IExpression),
                                        //#line 704 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(5))),
                //#line 704 GJavaParser.g
                )
                break
            }
            //
            // Rule 297:  SwitchStatement ::= switch ( Expression ) SwitchBlock
            //
            case 297: {
               //#line 706 "GJavaParser.g"
                my.SetResult(
                    //#line 706 GJavaParser.g
                    NewSwitchStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 706 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 706 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(2)),
                                       //#line 706 GJavaParser.g
                                       my.GetRhsSym(3).(IExpression),
                                       //#line 706 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(4)),
                                       //#line 706 GJavaParser.g
                                       my.GetRhsSym(5).(*SwitchBlock)),
                //#line 706 GJavaParser.g
                )
                break
            }
            //
            // Rule 298:  SwitchBlock ::= { SwitchBlockStatementGroupsopt SwitchLabelsopt }
            //
            case 298: {
               //#line 708 "GJavaParser.g"
                my.SetResult(
                    //#line 708 GJavaParser.g
                    NewSwitchBlock(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 708 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(1)),
                                   //#line 708 GJavaParser.g
                                   AnyCastToISwitchBlockStatementGroupsopt(my.GetRhsSym(2)),
                                   //#line 708 GJavaParser.g
                                   AnyCastToISwitchLabelsopt(my.GetRhsSym(3)),
                                   //#line 708 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(4))),
                //#line 708 GJavaParser.g
                )
                break
            }
            //
            // Rule 299:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroup
            //
            case 299:
                break
            //
            // Rule 300:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup
            //
            case 300: {
               //#line 711 "GJavaParser.g"
                my.SetResult(
                    //#line 711 GJavaParser.g
                    NewSwitchBlockStatementGroups(my.GetLeftIToken(), my.GetRightIToken(),
                                                  //#line 711 GJavaParser.g
                                                  my.GetRhsSym(1).(ISwitchBlockStatementGroups),
                                                  //#line 711 GJavaParser.g
                                                  my.GetRhsSym(2).(*SwitchBlockStatementGroup)),
                //#line 711 GJavaParser.g
                )
                break
            }
            //
            // Rule 301:  SwitchBlockStatementGroup ::= SwitchLabels BlockStatements
            //
            case 301: {
               //#line 713 "GJavaParser.g"
                my.SetResult(
                    //#line 713 GJavaParser.g
                    NewSwitchBlockStatementGroup(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 713 GJavaParser.g
                                                 my.GetRhsSym(1).(ISwitchLabels),
                                                 //#line 713 GJavaParser.g
                                                 my.GetRhsSym(2).(IBlockStatements)),
                //#line 713 GJavaParser.g
                )
                break
            }
            //
            // Rule 302:  SwitchLabels ::= SwitchLabel
            //
            case 302:
                break
            //
            // Rule 303:  SwitchLabels ::= SwitchLabels SwitchLabel
            //
            case 303: {
               //#line 716 "GJavaParser.g"
                my.SetResult(
                    //#line 716 GJavaParser.g
                    NewSwitchLabels(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 716 GJavaParser.g
                                    my.GetRhsSym(1).(ISwitchLabels),
                                    //#line 716 GJavaParser.g
                                    my.GetRhsSym(2).(ISwitchLabel)),
                //#line 716 GJavaParser.g
                )
                break
            }
            //
            // Rule 304:  SwitchLabel ::= case ConstantExpression :
            //
            case 304: {
               //#line 718 "GJavaParser.g"
                my.SetResult(
                    //#line 718 GJavaParser.g
                    NewSwitchLabel0(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 718 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 718 GJavaParser.g
                                    my.GetRhsSym(2).(IConstantExpression),
                                    //#line 718 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(3))),
                //#line 718 GJavaParser.g
                )
                break
            }
            //
            // Rule 305:  SwitchLabel ::= case EnumConstant :
            //
            case 305: {
               //#line 719 "GJavaParser.g"
                my.SetResult(
                    //#line 719 GJavaParser.g
                    NewSwitchLabel1(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 719 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 719 GJavaParser.g
                                    my.GetRhsSym(2).(IEnumConstant),
                                    //#line 719 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(3))),
                //#line 719 GJavaParser.g
                )
                break
            }
            //
            // Rule 306:  SwitchLabel ::= default :
            //
            case 306: {
               //#line 720 "GJavaParser.g"
                my.SetResult(
                    //#line 720 GJavaParser.g
                    NewSwitchLabel2(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 720 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 720 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2))),
                //#line 720 GJavaParser.g
                )
                break
            }
            //
            // Rule 307:  EnumConstant ::= identifier
            //
            case 307:
                break
            //
            // Rule 308:  WhileStatement ::= while ( Expression ) Statement
            //
            case 308: {
               //#line 724 "GJavaParser.g"
                my.SetResult(
                    //#line 724 GJavaParser.g
                    NewWhileStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 724 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 724 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(2)),
                                      //#line 724 GJavaParser.g
                                      my.GetRhsSym(3).(IExpression),
                                      //#line 724 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(4)),
                                      //#line 724 GJavaParser.g
                                      my.GetRhsSym(5).(IStatement)),
                //#line 724 GJavaParser.g
                )
                break
            }
            //
            // Rule 309:  WhileStatementNoShortIf ::= while ( Expression ) StatementNoShortIf
            //
            case 309: {
               //#line 726 "GJavaParser.g"
                my.SetResult(
                    //#line 726 GJavaParser.g
                    NewWhileStatementNoShortIf(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 726 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(1)),
                                               //#line 726 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2)),
                                               //#line 726 GJavaParser.g
                                               my.GetRhsSym(3).(IExpression),
                                               //#line 726 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(4)),
                                               //#line 726 GJavaParser.g
                                               my.GetRhsSym(5).(IStatementNoShortIf)),
                //#line 726 GJavaParser.g
                )
                break
            }
            //
            // Rule 310:  DoStatement ::= do Statement while ( Expression ) ;
            //
            case 310: {
               //#line 728 "GJavaParser.g"
                my.SetResult(
                    //#line 728 GJavaParser.g
                    NewDoStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(1)),
                                   //#line 728 GJavaParser.g
                                   my.GetRhsSym(2).(IStatement),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(3)),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(4)),
                                   //#line 728 GJavaParser.g
                                   my.GetRhsSym(5).(IExpression),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(6)),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(7))),
                //#line 728 GJavaParser.g
                )
                break
            }
            //
            // Rule 311:  ForStatement ::= BasicForStatement
            //
            case 311:
                break
            //
            // Rule 312:  ForStatement ::= EnhancedForStatement
            //
            case 312:
                break
            //
            // Rule 313:  BasicForStatement ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement
            //
            case 313: {
               //#line 733 "GJavaParser.g"
                my.SetResult(
                    //#line 733 GJavaParser.g
                    NewBasicForStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(1)),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 733 GJavaParser.g
                                         AnyCastToIForInitopt(my.GetRhsSym(3)),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(4)),
                                         //#line 733 GJavaParser.g
                                         AnyCastToIExpressionopt(my.GetRhsSym(5)),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(6)),
                                         //#line 733 GJavaParser.g
                                         AnyCastToIForUpdateopt(my.GetRhsSym(7)),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(8)),
                                         //#line 733 GJavaParser.g
                                         my.GetRhsSym(9).(IStatement)),
                //#line 733 GJavaParser.g
                )
                break
            }
            //
            // Rule 314:  ForStatementNoShortIf ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) StatementNoShortIf
            //
            case 314: {
               //#line 735 "GJavaParser.g"
                my.SetResult(
                    //#line 735 GJavaParser.g
                    NewForStatementNoShortIf(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(1)),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 735 GJavaParser.g
                                             AnyCastToIForInitopt(my.GetRhsSym(3)),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(4)),
                                             //#line 735 GJavaParser.g
                                             AnyCastToIExpressionopt(my.GetRhsSym(5)),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(6)),
                                             //#line 735 GJavaParser.g
                                             AnyCastToIForUpdateopt(my.GetRhsSym(7)),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(8)),
                                             //#line 735 GJavaParser.g
                                             my.GetRhsSym(9).(IStatementNoShortIf)),
                //#line 735 GJavaParser.g
                )
                break
            }
            //
            // Rule 315:  ForInit ::= StatementExpressionList
            //
            case 315:
                break
            //
            // Rule 316:  ForInit ::= LocalVariableDeclaration
            //
            case 316:
                break
            //
            // Rule 317:  ForUpdate ::= StatementExpressionList
            //
            case 317:
                break
            //
            // Rule 318:  StatementExpressionList ::= StatementExpression
            //
            case 318:
                break
            //
            // Rule 319:  StatementExpressionList ::= StatementExpressionList , StatementExpression
            //
            case 319: {
               //#line 743 "GJavaParser.g"
                my.SetResult(
                    //#line 743 GJavaParser.g
                    NewStatementExpressionList(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 743 GJavaParser.g
                                               my.GetRhsSym(1).(IStatementExpressionList),
                                               //#line 743 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2)),
                                               //#line 743 GJavaParser.g
                                               my.GetRhsSym(3).(IStatementExpression)),
                //#line 743 GJavaParser.g
                )
                break
            }
            //
            // Rule 320:  EnhancedForStatement ::= for ( FormalParameter : Expression ) Statement
            //
            case 320: {
               //#line 745 "GJavaParser.g"
                my.SetResult(
                    //#line 745 GJavaParser.g
                    NewEnhancedForStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 745 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(1)),
                                            //#line 745 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(2)),
                                            //#line 745 GJavaParser.g
                                            my.GetRhsSym(3).(*FormalParameter),
                                            //#line 745 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(4)),
                                            //#line 745 GJavaParser.g
                                            my.GetRhsSym(5).(IExpression),
                                            //#line 745 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(6)),
                                            //#line 745 GJavaParser.g
                                            my.GetRhsSym(7).(IStatement)),
                //#line 745 GJavaParser.g
                )
                break
            }
            //
            // Rule 321:  BreakStatement ::= break identifieropt ;
            //
            case 321: {
               //#line 747 "GJavaParser.g"
                my.SetResult(
                    //#line 747 GJavaParser.g
                    NewBreakStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 747 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 747 GJavaParser.g
                                      AnyCastToidentifier(my.GetRhsSym(2)),
                                      //#line 747 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 747 GJavaParser.g
                )
                break
            }
            //
            // Rule 322:  ContinueStatement ::= continue identifieropt ;
            //
            case 322: {
               //#line 749 "GJavaParser.g"
                my.SetResult(
                    //#line 749 GJavaParser.g
                    NewContinueStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 749 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(1)),
                                         //#line 749 GJavaParser.g
                                         AnyCastToidentifier(my.GetRhsSym(2)),
                                         //#line 749 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(3))),
                //#line 749 GJavaParser.g
                )
                break
            }
            //
            // Rule 323:  ReturnStatement ::= return Expressionopt ;
            //
            case 323: {
               //#line 751 "GJavaParser.g"
                my.SetResult(
                    //#line 751 GJavaParser.g
                    NewReturnStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 751 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 751 GJavaParser.g
                                       AnyCastToIExpressionopt(my.GetRhsSym(2)),
                                       //#line 751 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(3))),
                //#line 751 GJavaParser.g
                )
                break
            }
            //
            // Rule 324:  ThrowStatement ::= throw Expression ;
            //
            case 324: {
               //#line 753 "GJavaParser.g"
                my.SetResult(
                    //#line 753 GJavaParser.g
                    NewThrowStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 753 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 753 GJavaParser.g
                                      my.GetRhsSym(2).(IExpression),
                                      //#line 753 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 753 GJavaParser.g
                )
                break
            }
            //
            // Rule 325:  SynchronizedStatement ::= synchronized ( Expression ) Block
            //
            case 325: {
               //#line 755 "GJavaParser.g"
                my.SetResult(
                    //#line 755 GJavaParser.g
                    NewSynchronizedStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 755 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(1)),
                                             //#line 755 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 755 GJavaParser.g
                                             my.GetRhsSym(3).(IExpression),
                                             //#line 755 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(4)),
                                             //#line 755 GJavaParser.g
                                             my.GetRhsSym(5).(*Block)),
                //#line 755 GJavaParser.g
                )
                break
            }
            //
            // Rule 326:  TryStatement ::= try Block Catches
            //
            case 326: {
               //#line 757 "GJavaParser.g"
                my.SetResult(
                    //#line 757 GJavaParser.g
                    NewTryStatement0(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 757 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(1)),
                                     //#line 757 GJavaParser.g
                                     my.GetRhsSym(2).(*Block),
                                     //#line 757 GJavaParser.g
                                     my.GetRhsSym(3).(ICatches)),
                //#line 757 GJavaParser.g
                )
                break
            }
            //
            // Rule 327:  TryStatement ::= try Block Catchesopt Finally
            //
            case 327: {
               //#line 758 "GJavaParser.g"
                my.SetResult(
                    //#line 758 GJavaParser.g
                    NewTryStatement1(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 758 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(1)),
                                     //#line 758 GJavaParser.g
                                     my.GetRhsSym(2).(*Block),
                                     //#line 758 GJavaParser.g
                                     AnyCastToICatchesopt(my.GetRhsSym(3)),
                                     //#line 758 GJavaParser.g
                                     my.GetRhsSym(4).(*Finally)),
                //#line 758 GJavaParser.g
                )
                break
            }
            //
            // Rule 328:  Catches ::= CatchClause
            //
            case 328:
                break
            //
            // Rule 329:  Catches ::= Catches CatchClause
            //
            case 329: {
               //#line 761 "GJavaParser.g"
                my.SetResult(
                    //#line 761 GJavaParser.g
                    NewCatches(my.GetLeftIToken(), my.GetRightIToken(),
                               //#line 761 GJavaParser.g
                               my.GetRhsSym(1).(ICatches),
                               //#line 761 GJavaParser.g
                               my.GetRhsSym(2).(*CatchClause)),
                //#line 761 GJavaParser.g
                )
                break
            }
            //
            // Rule 330:  CatchClause ::= catch ( FormalParameter ) Block
            //
            case 330: {
               //#line 763 "GJavaParser.g"
                my.SetResult(
                    //#line 763 GJavaParser.g
                    NewCatchClause(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 763 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(1)),
                                   //#line 763 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(2)),
                                   //#line 763 GJavaParser.g
                                   my.GetRhsSym(3).(*FormalParameter),
                                   //#line 763 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(4)),
                                   //#line 763 GJavaParser.g
                                   my.GetRhsSym(5).(*Block)),
                //#line 763 GJavaParser.g
                )
                break
            }
            //
            // Rule 331:  Finally ::= finally Block
            //
            case 331: {
               //#line 765 "GJavaParser.g"
                my.SetResult(
                    //#line 765 GJavaParser.g
                    NewFinally(my.GetLeftIToken(), my.GetRightIToken(),
                               //#line 765 GJavaParser.g
                               NewAstToken(my.GetRhsIToken(1)),
                               //#line 765 GJavaParser.g
                               my.GetRhsSym(2).(*Block)),
                //#line 765 GJavaParser.g
                )
                break
            }
            //
            // Rule 332:  Primary ::= PrimaryNoNewArray
            //
            case 332:
                break
            //
            // Rule 333:  Primary ::= ArrayCreationExpression
            //
            case 333:
                break
            //
            // Rule 334:  PrimaryNoNewArray ::= Literal
            //
            case 334:
                break
            //
            // Rule 335:  PrimaryNoNewArray ::= Type . class
            //
            case 335: {
               //#line 781 "GJavaParser.g"
                my.SetResult(
                    //#line 781 GJavaParser.g
                    NewPrimaryNoNewArray0(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 781 GJavaParser.g
                                          my.GetRhsSym(1).(IType),
                                          //#line 781 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 781 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 781 GJavaParser.g
                )
                break
            }
            //
            // Rule 336:  PrimaryNoNewArray ::= void . class
            //
            case 336: {
               //#line 782 "GJavaParser.g"
                my.SetResult(
                    //#line 782 GJavaParser.g
                    NewPrimaryNoNewArray1(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 782 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(1)),
                                          //#line 782 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 782 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 782 GJavaParser.g
                )
                break
            }
            //
            // Rule 337:  PrimaryNoNewArray ::= this
            //
            case 337: {
               //#line 783 "GJavaParser.g"
                my.SetResult(
                    //#line 783 GJavaParser.g
                    NewPrimaryNoNewArray2(my.GetRhsIToken(1)),
                //#line 783 GJavaParser.g
                )
                break
            }
            //
            // Rule 338:  PrimaryNoNewArray ::= ClassName . this
            //
            case 338: {
               //#line 784 "GJavaParser.g"
                my.SetResult(
                    //#line 784 GJavaParser.g
                    NewPrimaryNoNewArray3(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 784 GJavaParser.g
                                          my.GetRhsSym(1).(IClassName),
                                          //#line 784 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 784 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 784 GJavaParser.g
                )
                break
            }
            //
            // Rule 339:  PrimaryNoNewArray ::= ( Expression )
            //
            case 339: {
               //#line 785 "GJavaParser.g"
                my.SetResult(
                    //#line 785 GJavaParser.g
                    NewPrimaryNoNewArray4(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 785 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(1)),
                                          //#line 785 GJavaParser.g
                                          my.GetRhsSym(2).(IExpression),
                                          //#line 785 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 785 GJavaParser.g
                )
                break
            }
            //
            // Rule 340:  PrimaryNoNewArray ::= ClassInstanceCreationExpression
            //
            case 340:
                break
            //
            // Rule 341:  PrimaryNoNewArray ::= FieldAccess
            //
            case 341:
                break
            //
            // Rule 342:  PrimaryNoNewArray ::= MethodInvocation
            //
            case 342:
                break
            //
            // Rule 343:  PrimaryNoNewArray ::= ArrayAccess
            //
            case 343:
                break
            //
            // Rule 344:  Literal ::= IntegerLiteral
            //
            case 344: {
               //#line 791 "GJavaParser.g"
                my.SetResult(
                    //#line 791 GJavaParser.g
                    NewLiteral0(my.GetRhsIToken(1)),
                //#line 791 GJavaParser.g
                )
                break
            }
            //
            // Rule 345:  Literal ::= LongLiteral
            //
            case 345: {
               //#line 792 "GJavaParser.g"
                my.SetResult(
                    //#line 792 GJavaParser.g
                    NewLiteral1(my.GetRhsIToken(1)),
                //#line 792 GJavaParser.g
                )
                break
            }
            //
            // Rule 346:  Literal ::= FloatingPointLiteral
            //
            case 346: {
               //#line 793 "GJavaParser.g"
                my.SetResult(
                    //#line 793 GJavaParser.g
                    NewLiteral2(my.GetRhsIToken(1)),
                //#line 793 GJavaParser.g
                )
                break
            }
            //
            // Rule 347:  Literal ::= DoubleLiteral
            //
            case 347: {
               //#line 794 "GJavaParser.g"
                my.SetResult(
                    //#line 794 GJavaParser.g
                    NewLiteral3(my.GetRhsIToken(1)),
                //#line 794 GJavaParser.g
                )
                break
            }
            //
            // Rule 348:  Literal ::= BooleanLiteral
            //
            case 348:
                break
            //
            // Rule 349:  Literal ::= CharacterLiteral
            //
            case 349: {
               //#line 796 "GJavaParser.g"
                my.SetResult(
                    //#line 796 GJavaParser.g
                    NewLiteral4(my.GetRhsIToken(1)),
                //#line 796 GJavaParser.g
                )
                break
            }
            //
            // Rule 350:  Literal ::= StringLiteral
            //
            case 350: {
               //#line 797 "GJavaParser.g"
                my.SetResult(
                    //#line 797 GJavaParser.g
                    NewLiteral5(my.GetRhsIToken(1)),
                //#line 797 GJavaParser.g
                )
                break
            }
            //
            // Rule 351:  Literal ::= null
            //
            case 351: {
               //#line 798 "GJavaParser.g"
                my.SetResult(
                    //#line 798 GJavaParser.g
                    NewLiteral6(my.GetRhsIToken(1)),
                //#line 798 GJavaParser.g
                )
                break
            }
            //
            // Rule 352:  BooleanLiteral ::= true
            //
            case 352: {
               //#line 800 "GJavaParser.g"
                my.SetResult(
                    //#line 800 GJavaParser.g
                    NewBooleanLiteral0(my.GetRhsIToken(1)),
                //#line 800 GJavaParser.g
                )
                break
            }
            //
            // Rule 353:  BooleanLiteral ::= false
            //
            case 353: {
               //#line 801 "GJavaParser.g"
                my.SetResult(
                    //#line 801 GJavaParser.g
                    NewBooleanLiteral1(my.GetRhsIToken(1)),
                //#line 801 GJavaParser.g
                )
                break
            }
            //
            // Rule 354:  ClassInstanceCreationExpression ::= new TypeArgumentsopt ClassOrInterfaceType TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
            //
            case 354: {
               //#line 808 "GJavaParser.g"
                my.SetResult(
                    //#line 808 GJavaParser.g
                    NewClassInstanceCreationExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                                        //#line 808 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(1)),
                                                        //#line 808 GJavaParser.g
                                                        AnyCastToTypeArguments(my.GetRhsSym(2)),
                                                        //#line 808 GJavaParser.g
                                                        my.GetRhsSym(3).(*ClassType),
                                                        //#line 808 GJavaParser.g
                                                        AnyCastToTypeArguments(my.GetRhsSym(4)),
                                                        //#line 808 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(5)),
                                                        //#line 808 GJavaParser.g
                                                        AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                                        //#line 808 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(7)),
                                                        //#line 808 GJavaParser.g
                                                        AnyCastToClassBody(my.GetRhsSym(8))),
                //#line 808 GJavaParser.g
                )
                break
            }
            //
            // Rule 355:  ClassInstanceCreationExpression ::= Primary . new TypeArgumentsopt identifier TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
            //
            case 355: {
               //#line 809 "GJavaParser.g"
                my.SetResult(
                    //#line 809 GJavaParser.g
                    NewClassInstanceCreationExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                                        //#line 809 GJavaParser.g
                                                        my.GetRhsSym(1).(IPrimary),
                                                        //#line 809 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(2)),
                                                        //#line 809 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(3)),
                                                        //#line 809 GJavaParser.g
                                                        AnyCastToTypeArguments(my.GetRhsSym(4)),
                                                        //#line 809 GJavaParser.g
                                                        my.GetRhsSym(5).(*identifier),
                                                        //#line 809 GJavaParser.g
                                                        AnyCastToTypeArguments(my.GetRhsSym(6)),
                                                        //#line 809 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(7)),
                                                        //#line 809 GJavaParser.g
                                                        AnyCastToIArgumentListopt(my.GetRhsSym(8)),
                                                        //#line 809 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(9)),
                                                        //#line 809 GJavaParser.g
                                                        AnyCastToClassBody(my.GetRhsSym(10))),
                //#line 809 GJavaParser.g
                )
                break
            }
            //
            // Rule 356:  ArgumentList ::= Expression
            //
            case 356:
                break
            //
            // Rule 357:  ArgumentList ::= ArgumentList , Expression
            //
            case 357: {
               //#line 813 "GJavaParser.g"
                my.SetResult(
                    //#line 813 GJavaParser.g
                    NewArgumentList(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 813 GJavaParser.g
                                    my.GetRhsSym(1).(IArgumentList),
                                    //#line 813 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 813 GJavaParser.g
                                    my.GetRhsSym(3).(IExpression)),
                //#line 813 GJavaParser.g
                )
                break
            }
            //
            // Rule 358:  ArrayCreationExpression ::= new PrimitiveType DimExprs Dimsopt
            //
            case 358: {
               //#line 823 "GJavaParser.g"
                my.SetResult(
                    //#line 823 GJavaParser.g
                    NewArrayCreationExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 823 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(1)),
                                                //#line 823 GJavaParser.g
                                                my.GetRhsSym(2).(IPrimitiveType),
                                                //#line 823 GJavaParser.g
                                                my.GetRhsSym(3).(IDimExprs),
                                                //#line 823 GJavaParser.g
                                                AnyCastToIDimsopt(my.GetRhsSym(4))),
                //#line 823 GJavaParser.g
                )
                break
            }
            //
            // Rule 359:  ArrayCreationExpression ::= new ClassOrInterfaceType DimExprs Dimsopt
            //
            case 359: {
               //#line 824 "GJavaParser.g"
                my.SetResult(
                    //#line 824 GJavaParser.g
                    NewArrayCreationExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 824 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(1)),
                                                //#line 824 GJavaParser.g
                                                my.GetRhsSym(2).(*ClassType),
                                                //#line 824 GJavaParser.g
                                                my.GetRhsSym(3).(IDimExprs),
                                                //#line 824 GJavaParser.g
                                                AnyCastToIDimsopt(my.GetRhsSym(4))),
                //#line 824 GJavaParser.g
                )
                break
            }
            //
            // Rule 360:  ArrayCreationExpression ::= new PrimitiveType Dims ArrayInitializer
            //
            case 360: {
               //#line 825 "GJavaParser.g"
                my.SetResult(
                    //#line 825 GJavaParser.g
                    NewArrayCreationExpression2(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 825 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(1)),
                                                //#line 825 GJavaParser.g
                                                my.GetRhsSym(2).(IPrimitiveType),
                                                //#line 825 GJavaParser.g
                                                my.GetRhsSym(3).(IDims),
                                                //#line 825 GJavaParser.g
                                                my.GetRhsSym(4).(*ArrayInitializer)),
                //#line 825 GJavaParser.g
                )
                break
            }
            //
            // Rule 361:  ArrayCreationExpression ::= new ClassOrInterfaceType Dims ArrayInitializer
            //
            case 361: {
               //#line 826 "GJavaParser.g"
                my.SetResult(
                    //#line 826 GJavaParser.g
                    NewArrayCreationExpression3(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 826 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(1)),
                                                //#line 826 GJavaParser.g
                                                my.GetRhsSym(2).(*ClassType),
                                                //#line 826 GJavaParser.g
                                                my.GetRhsSym(3).(IDims),
                                                //#line 826 GJavaParser.g
                                                my.GetRhsSym(4).(*ArrayInitializer)),
                //#line 826 GJavaParser.g
                )
                break
            }
            //
            // Rule 362:  DimExprs ::= DimExpr
            //
            case 362:
                break
            //
            // Rule 363:  DimExprs ::= DimExprs DimExpr
            //
            case 363: {
               //#line 829 "GJavaParser.g"
                my.SetResult(
                    //#line 829 GJavaParser.g
                    NewDimExprs(my.GetLeftIToken(), my.GetRightIToken(),
                                //#line 829 GJavaParser.g
                                my.GetRhsSym(1).(IDimExprs),
                                //#line 829 GJavaParser.g
                                my.GetRhsSym(2).(*DimExpr)),
                //#line 829 GJavaParser.g
                )
                break
            }
            //
            // Rule 364:  DimExpr ::= [ Expression ]
            //
            case 364: {
               //#line 831 "GJavaParser.g"
                my.SetResult(
                    //#line 831 GJavaParser.g
                    NewDimExpr(my.GetLeftIToken(), my.GetRightIToken(),
                               //#line 831 GJavaParser.g
                               NewAstToken(my.GetRhsIToken(1)),
                               //#line 831 GJavaParser.g
                               my.GetRhsSym(2).(IExpression),
                               //#line 831 GJavaParser.g
                               NewAstToken(my.GetRhsIToken(3))),
                //#line 831 GJavaParser.g
                )
                break
            }
            //
            // Rule 365:  Dims ::= [ ]
            //
            case 365: {
               //#line 833 "GJavaParser.g"
                my.SetResult(
                    //#line 833 GJavaParser.g
                    NewDims0(my.GetLeftIToken(), my.GetRightIToken(),
                             //#line 833 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(1)),
                             //#line 833 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(2))),
                //#line 833 GJavaParser.g
                )
                break
            }
            //
            // Rule 366:  Dims ::= Dims [ ]
            //
            case 366: {
               //#line 834 "GJavaParser.g"
                my.SetResult(
                    //#line 834 GJavaParser.g
                    NewDims1(my.GetLeftIToken(), my.GetRightIToken(),
                             //#line 834 GJavaParser.g
                             my.GetRhsSym(1).(IDims),
                             //#line 834 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(2)),
                             //#line 834 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(3))),
                //#line 834 GJavaParser.g
                )
                break
            }
            //
            // Rule 367:  FieldAccess ::= Primary . identifier
            //
            case 367: {
               //#line 836 "GJavaParser.g"
                my.SetResult(
                    //#line 836 GJavaParser.g
                    NewFieldAccess0(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 836 GJavaParser.g
                                    my.GetRhsSym(1).(IPrimary),
                                    //#line 836 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 836 GJavaParser.g
                                    my.GetRhsSym(3).(*identifier)),
                //#line 836 GJavaParser.g
                )
                break
            }
            //
            // Rule 368:  FieldAccess ::= super . identifier
            //
            case 368: {
               //#line 837 "GJavaParser.g"
                my.SetResult(
                    //#line 837 GJavaParser.g
                    NewFieldAccess1(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 837 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 837 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 837 GJavaParser.g
                                    my.GetRhsSym(3).(*identifier)),
                //#line 837 GJavaParser.g
                )
                break
            }
            //
            // Rule 369:  FieldAccess ::= ClassName . super . identifier
            //
            case 369: {
               //#line 838 "GJavaParser.g"
                my.SetResult(
                    //#line 838 GJavaParser.g
                    NewFieldAccess2(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 838 GJavaParser.g
                                    my.GetRhsSym(1).(IClassName),
                                    //#line 838 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 838 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(3)),
                                    //#line 838 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(4)),
                                    //#line 838 GJavaParser.g
                                    my.GetRhsSym(5).(*identifier)),
                //#line 838 GJavaParser.g
                )
                break
            }
            //
            // Rule 370:  MethodInvocation ::= MethodName ( ArgumentListopt )
            //
            case 370: {
               //#line 840 "GJavaParser.g"
                my.SetResult(
                    //#line 840 GJavaParser.g
                    NewMethodInvocation0(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 840 GJavaParser.g
                                         my.GetRhsSym(1).(IMethodName),
                                         //#line 840 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 840 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(3)),
                                         //#line 840 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(4))),
                //#line 840 GJavaParser.g
                )
                break
            }
            //
            // Rule 371:  MethodInvocation ::= Primary . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 371: {
               //#line 841 "GJavaParser.g"
                my.SetResult(
                    //#line 841 GJavaParser.g
                    NewMethodInvocation1(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 841 GJavaParser.g
                                         my.GetRhsSym(1).(IPrimary),
                                         //#line 841 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 841 GJavaParser.g
                                         AnyCastToTypeArguments(my.GetRhsSym(3)),
                                         //#line 841 GJavaParser.g
                                         my.GetRhsSym(4).(*identifier),
                                         //#line 841 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(5)),
                                         //#line 841 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                         //#line 841 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(7))),
                //#line 841 GJavaParser.g
                )
                break
            }
            //
            // Rule 372:  MethodInvocation ::= super . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 372: {
               //#line 842 "GJavaParser.g"
                my.SetResult(
                    //#line 842 GJavaParser.g
                    NewMethodInvocation2(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 842 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(1)),
                                         //#line 842 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 842 GJavaParser.g
                                         AnyCastToTypeArguments(my.GetRhsSym(3)),
                                         //#line 842 GJavaParser.g
                                         my.GetRhsSym(4).(*identifier),
                                         //#line 842 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(5)),
                                         //#line 842 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                         //#line 842 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(7))),
                //#line 842 GJavaParser.g
                )
                break
            }
            //
            // Rule 373:  MethodInvocation ::= ClassName . super . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 373: {
               //#line 843 "GJavaParser.g"
                my.SetResult(
                    //#line 843 GJavaParser.g
                    NewMethodInvocation3(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 843 GJavaParser.g
                                         my.GetRhsSym(1).(IClassName),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(3)),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(4)),
                                         //#line 843 GJavaParser.g
                                         AnyCastToTypeArguments(my.GetRhsSym(5)),
                                         //#line 843 GJavaParser.g
                                         my.GetRhsSym(6).(*identifier),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(7)),
                                         //#line 843 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(8)),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(9))),
                //#line 843 GJavaParser.g
                )
                break
            }
            //
            // Rule 374:  MethodInvocation ::= TypeName . TypeArguments identifier ( ArgumentListopt )
            //
            case 374: {
               //#line 844 "GJavaParser.g"
                my.SetResult(
                    //#line 844 GJavaParser.g
                    NewMethodInvocation4(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 844 GJavaParser.g
                                         my.GetRhsSym(1).(ITypeName),
                                         //#line 844 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 844 GJavaParser.g
                                         my.GetRhsSym(3).(*TypeArguments),
                                         //#line 844 GJavaParser.g
                                         my.GetRhsSym(4).(*identifier),
                                         //#line 844 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(5)),
                                         //#line 844 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                         //#line 844 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(7))),
                //#line 844 GJavaParser.g
                )
                break
            }
            //
            // Rule 375:  ArrayAccess ::= ExpressionName [ Expression ]
            //
            case 375: {
               //#line 852 "GJavaParser.g"
                my.SetResult(
                    //#line 852 GJavaParser.g
                    NewArrayAccess0(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 852 GJavaParser.g
                                    my.GetRhsSym(1).(IExpressionName),
                                    //#line 852 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 852 GJavaParser.g
                                    my.GetRhsSym(3).(IExpression),
                                    //#line 852 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(4))),
                //#line 852 GJavaParser.g
                )
                break
            }
            //
            // Rule 376:  ArrayAccess ::= PrimaryNoNewArray [ Expression ]
            //
            case 376: {
               //#line 853 "GJavaParser.g"
                my.SetResult(
                    //#line 853 GJavaParser.g
                    NewArrayAccess1(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 853 GJavaParser.g
                                    my.GetRhsSym(1).(IPrimaryNoNewArray),
                                    //#line 853 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 853 GJavaParser.g
                                    my.GetRhsSym(3).(IExpression),
                                    //#line 853 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(4))),
                //#line 853 GJavaParser.g
                )
                break
            }
            //
            // Rule 377:  PostfixExpression ::= Primary
            //
            case 377:
                break
            //
            // Rule 378:  PostfixExpression ::= ExpressionName
            //
            case 378:
                break
            //
            // Rule 379:  PostfixExpression ::= PostIncrementExpression
            //
            case 379:
                break
            //
            // Rule 380:  PostfixExpression ::= PostDecrementExpression
            //
            case 380:
                break
            //
            // Rule 381:  PostIncrementExpression ::= PostfixExpression ++
            //
            case 381: {
               //#line 860 "GJavaParser.g"
                my.SetResult(
                    //#line 860 GJavaParser.g
                    NewPostIncrementExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 860 GJavaParser.g
                                               my.GetRhsSym(1).(IPostfixExpression),
                                               //#line 860 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2))),
                //#line 860 GJavaParser.g
                )
                break
            }
            //
            // Rule 382:  PostDecrementExpression ::= PostfixExpression --
            //
            case 382: {
               //#line 862 "GJavaParser.g"
                my.SetResult(
                    //#line 862 GJavaParser.g
                    NewPostDecrementExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 862 GJavaParser.g
                                               my.GetRhsSym(1).(IPostfixExpression),
                                               //#line 862 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2))),
                //#line 862 GJavaParser.g
                )
                break
            }
            //
            // Rule 383:  UnaryExpression ::= PreIncrementExpression
            //
            case 383:
                break
            //
            // Rule 384:  UnaryExpression ::= PreDecrementExpression
            //
            case 384:
                break
            //
            // Rule 385:  UnaryExpression ::= + UnaryExpression
            //
            case 385: {
               //#line 866 "GJavaParser.g"
                my.SetResult(
                    //#line 866 GJavaParser.g
                    NewUnaryExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 866 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 866 GJavaParser.g
                                        my.GetRhsSym(2).(IUnaryExpression)),
                //#line 866 GJavaParser.g
                )
                break
            }
            //
            // Rule 386:  UnaryExpression ::= - UnaryExpression
            //
            case 386: {
               //#line 867 "GJavaParser.g"
                my.SetResult(
                    //#line 867 GJavaParser.g
                    NewUnaryExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 867 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 867 GJavaParser.g
                                        my.GetRhsSym(2).(IUnaryExpression)),
                //#line 867 GJavaParser.g
                )
                break
            }
            //
            // Rule 387:  UnaryExpression ::= UnaryExpressionNotPlusMinus
            //
            case 387:
                break
            //
            // Rule 388:  PreIncrementExpression ::= ++ UnaryExpression
            //
            case 388: {
               //#line 870 "GJavaParser.g"
                my.SetResult(
                    //#line 870 GJavaParser.g
                    NewPreIncrementExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 870 GJavaParser.g
                                              NewAstToken(my.GetRhsIToken(1)),
                                              //#line 870 GJavaParser.g
                                              my.GetRhsSym(2).(IUnaryExpression)),
                //#line 870 GJavaParser.g
                )
                break
            }
            //
            // Rule 389:  PreDecrementExpression ::= -- UnaryExpression
            //
            case 389: {
               //#line 872 "GJavaParser.g"
                my.SetResult(
                    //#line 872 GJavaParser.g
                    NewPreDecrementExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 872 GJavaParser.g
                                              NewAstToken(my.GetRhsIToken(1)),
                                              //#line 872 GJavaParser.g
                                              my.GetRhsSym(2).(IUnaryExpression)),
                //#line 872 GJavaParser.g
                )
                break
            }
            //
            // Rule 390:  UnaryExpressionNotPlusMinus ::= PostfixExpression
            //
            case 390:
                break
            //
            // Rule 391:  UnaryExpressionNotPlusMinus ::= ~ UnaryExpression
            //
            case 391: {
               //#line 875 "GJavaParser.g"
                my.SetResult(
                    //#line 875 GJavaParser.g
                    NewUnaryExpressionNotPlusMinus0(my.GetLeftIToken(), my.GetRightIToken(),
                                                    //#line 875 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(1)),
                                                    //#line 875 GJavaParser.g
                                                    my.GetRhsSym(2).(IUnaryExpression)),
                //#line 875 GJavaParser.g
                )
                break
            }
            //
            // Rule 392:  UnaryExpressionNotPlusMinus ::= ! UnaryExpression
            //
            case 392: {
               //#line 876 "GJavaParser.g"
                my.SetResult(
                    //#line 876 GJavaParser.g
                    NewUnaryExpressionNotPlusMinus1(my.GetLeftIToken(), my.GetRightIToken(),
                                                    //#line 876 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(1)),
                                                    //#line 876 GJavaParser.g
                                                    my.GetRhsSym(2).(IUnaryExpression)),
                //#line 876 GJavaParser.g
                )
                break
            }
            //
            // Rule 393:  UnaryExpressionNotPlusMinus ::= CastExpression
            //
            case 393:
                break
            //
            // Rule 394:  CastExpression ::= ( PrimitiveType Dimsopt ) UnaryExpression
            //
            case 394: {
               //#line 879 "GJavaParser.g"
                my.SetResult(
                    //#line 879 GJavaParser.g
                    NewCastExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 879 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 879 GJavaParser.g
                                       my.GetRhsSym(2).(IPrimitiveType),
                                       //#line 879 GJavaParser.g
                                       AnyCastToIDimsopt(my.GetRhsSym(3)),
                                       //#line 879 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(4)),
                                       //#line 879 GJavaParser.g
                                       my.GetRhsSym(5).(IUnaryExpression)),
                //#line 879 GJavaParser.g
                )
                break
            }
            //
            // Rule 395:  CastExpression ::= ( ReferenceType ) UnaryExpressionNotPlusMinus
            //
            case 395: {
               //#line 880 "GJavaParser.g"
                my.SetResult(
                    //#line 880 GJavaParser.g
                    NewCastExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 880 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 880 GJavaParser.g
                                       my.GetRhsSym(2).(IReferenceType),
                                       //#line 880 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(3)),
                                       //#line 880 GJavaParser.g
                                       my.GetRhsSym(4).(IUnaryExpressionNotPlusMinus)),
                //#line 880 GJavaParser.g
                )
                break
            }
            //
            // Rule 396:  MultiplicativeExpression ::= UnaryExpression
            //
            case 396:
                break
            //
            // Rule 397:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
            //
            case 397: {
               //#line 883 "GJavaParser.g"
                my.SetResult(
                    //#line 883 GJavaParser.g
                    NewMultiplicativeExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 883 GJavaParser.g
                                                 my.GetRhsSym(1).(IMultiplicativeExpression),
                                                 //#line 883 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 883 GJavaParser.g
                                                 my.GetRhsSym(3).(IUnaryExpression)),
                //#line 883 GJavaParser.g
                )
                break
            }
            //
            // Rule 398:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
            //
            case 398: {
               //#line 884 "GJavaParser.g"
                my.SetResult(
                    //#line 884 GJavaParser.g
                    NewMultiplicativeExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 884 GJavaParser.g
                                                 my.GetRhsSym(1).(IMultiplicativeExpression),
                                                 //#line 884 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 884 GJavaParser.g
                                                 my.GetRhsSym(3).(IUnaryExpression)),
                //#line 884 GJavaParser.g
                )
                break
            }
            //
            // Rule 399:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
            //
            case 399: {
               //#line 885 "GJavaParser.g"
                my.SetResult(
                    //#line 885 GJavaParser.g
                    NewMultiplicativeExpression2(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 885 GJavaParser.g
                                                 my.GetRhsSym(1).(IMultiplicativeExpression),
                                                 //#line 885 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 885 GJavaParser.g
                                                 my.GetRhsSym(3).(IUnaryExpression)),
                //#line 885 GJavaParser.g
                )
                break
            }
            //
            // Rule 400:  AdditiveExpression ::= MultiplicativeExpression
            //
            case 400:
                break
            //
            // Rule 401:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
            //
            case 401: {
               //#line 888 "GJavaParser.g"
                my.SetResult(
                    //#line 888 GJavaParser.g
                    NewAdditiveExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 888 GJavaParser.g
                                           my.GetRhsSym(1).(IAdditiveExpression),
                                           //#line 888 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 888 GJavaParser.g
                                           my.GetRhsSym(3).(IMultiplicativeExpression)),
                //#line 888 GJavaParser.g
                )
                break
            }
            //
            // Rule 402:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
            //
            case 402: {
               //#line 889 "GJavaParser.g"
                my.SetResult(
                    //#line 889 GJavaParser.g
                    NewAdditiveExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 889 GJavaParser.g
                                           my.GetRhsSym(1).(IAdditiveExpression),
                                           //#line 889 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 889 GJavaParser.g
                                           my.GetRhsSym(3).(IMultiplicativeExpression)),
                //#line 889 GJavaParser.g
                )
                break
            }
            //
            // Rule 403:  ShiftExpression ::= AdditiveExpression
            //
            case 403:
                break
            //
            // Rule 404:  ShiftExpression ::= ShiftExpression << AdditiveExpression
            //
            case 404: {
               //#line 892 "GJavaParser.g"
                my.SetResult(
                    //#line 892 GJavaParser.g
                    NewShiftExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 892 GJavaParser.g
                                        my.GetRhsSym(1).(IShiftExpression),
                                        //#line 892 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 892 GJavaParser.g
                                        my.GetRhsSym(3).(IAdditiveExpression)),
                //#line 892 GJavaParser.g
                )
                break
            }
            //
            // Rule 405:  ShiftExpression ::= ShiftExpression > > AdditiveExpression
            //
            case 405: {
               //#line 893 "GJavaParser.g"
                my.SetResult(
                    //#line 893 GJavaParser.g
                    NewShiftExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 893 GJavaParser.g
                                        my.GetRhsSym(1).(IShiftExpression),
                                        //#line 893 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 893 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3)),
                                        //#line 893 GJavaParser.g
                                        my.GetRhsSym(4).(IAdditiveExpression)),
                //#line 893 GJavaParser.g
                )
                break
            }
            //
            // Rule 406:  ShiftExpression ::= ShiftExpression > > > AdditiveExpression
            //
            case 406: {
               //#line 894 "GJavaParser.g"
                my.SetResult(
                    //#line 894 GJavaParser.g
                    NewShiftExpression2(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 894 GJavaParser.g
                                        my.GetRhsSym(1).(IShiftExpression),
                                        //#line 894 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 894 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3)),
                                        //#line 894 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(4)),
                                        //#line 894 GJavaParser.g
                                        my.GetRhsSym(5).(IAdditiveExpression)),
                //#line 894 GJavaParser.g
                )
                break
            }
            //
            // Rule 407:  RelationalExpression ::= ShiftExpression
            //
            case 407:
                break
            //
            // Rule 408:  RelationalExpression ::= RelationalExpression < ShiftExpression
            //
            case 408: {
               //#line 897 "GJavaParser.g"
                my.SetResult(
                    //#line 897 GJavaParser.g
                    NewRelationalExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 897 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 897 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 897 GJavaParser.g
                                             my.GetRhsSym(3).(IShiftExpression)),
                //#line 897 GJavaParser.g
                )
                break
            }
            //
            // Rule 409:  RelationalExpression ::= RelationalExpression > ShiftExpression
            //
            case 409: {
               //#line 898 "GJavaParser.g"
                my.SetResult(
                    //#line 898 GJavaParser.g
                    NewRelationalExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 898 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 898 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 898 GJavaParser.g
                                             my.GetRhsSym(3).(IShiftExpression)),
                //#line 898 GJavaParser.g
                )
                break
            }
            //
            // Rule 410:  RelationalExpression ::= RelationalExpression <= ShiftExpression
            //
            case 410: {
               //#line 899 "GJavaParser.g"
                my.SetResult(
                    //#line 899 GJavaParser.g
                    NewRelationalExpression2(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 899 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 899 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 899 GJavaParser.g
                                             my.GetRhsSym(3).(IShiftExpression)),
                //#line 899 GJavaParser.g
                )
                break
            }
            //
            // Rule 411:  RelationalExpression ::= RelationalExpression > = ShiftExpression
            //
            case 411: {
               //#line 900 "GJavaParser.g"
                my.SetResult(
                    //#line 900 GJavaParser.g
                    NewRelationalExpression3(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 900 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 900 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 900 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(3)),
                                             //#line 900 GJavaParser.g
                                             my.GetRhsSym(4).(IShiftExpression)),
                //#line 900 GJavaParser.g
                )
                break
            }
            //
            // Rule 412:  RelationalExpression ::= RelationalExpression instanceof ReferenceType
            //
            case 412: {
               //#line 901 "GJavaParser.g"
                my.SetResult(
                    //#line 901 GJavaParser.g
                    NewRelationalExpression4(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 901 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 901 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 901 GJavaParser.g
                                             my.GetRhsSym(3).(IReferenceType)),
                //#line 901 GJavaParser.g
                )
                break
            }
            //
            // Rule 413:  EqualityExpression ::= RelationalExpression
            //
            case 413:
                break
            //
            // Rule 414:  EqualityExpression ::= EqualityExpression == RelationalExpression
            //
            case 414: {
               //#line 904 "GJavaParser.g"
                my.SetResult(
                    //#line 904 GJavaParser.g
                    NewEqualityExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 904 GJavaParser.g
                                           my.GetRhsSym(1).(IEqualityExpression),
                                           //#line 904 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 904 GJavaParser.g
                                           my.GetRhsSym(3).(IRelationalExpression)),
                //#line 904 GJavaParser.g
                )
                break
            }
            //
            // Rule 415:  EqualityExpression ::= EqualityExpression != RelationalExpression
            //
            case 415: {
               //#line 905 "GJavaParser.g"
                my.SetResult(
                    //#line 905 GJavaParser.g
                    NewEqualityExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 905 GJavaParser.g
                                           my.GetRhsSym(1).(IEqualityExpression),
                                           //#line 905 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 905 GJavaParser.g
                                           my.GetRhsSym(3).(IRelationalExpression)),
                //#line 905 GJavaParser.g
                )
                break
            }
            //
            // Rule 416:  AndExpression ::= EqualityExpression
            //
            case 416:
                break
            //
            // Rule 417:  AndExpression ::= AndExpression & EqualityExpression
            //
            case 417: {
               //#line 908 "GJavaParser.g"
                my.SetResult(
                    //#line 908 GJavaParser.g
                    NewAndExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 908 GJavaParser.g
                                     my.GetRhsSym(1).(IAndExpression),
                                     //#line 908 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(2)),
                                     //#line 908 GJavaParser.g
                                     my.GetRhsSym(3).(IEqualityExpression)),
                //#line 908 GJavaParser.g
                )
                break
            }
            //
            // Rule 418:  ExclusiveOrExpression ::= AndExpression
            //
            case 418:
                break
            //
            // Rule 419:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
            //
            case 419: {
               //#line 911 "GJavaParser.g"
                my.SetResult(
                    //#line 911 GJavaParser.g
                    NewExclusiveOrExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 911 GJavaParser.g
                                             my.GetRhsSym(1).(IExclusiveOrExpression),
                                             //#line 911 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 911 GJavaParser.g
                                             my.GetRhsSym(3).(IAndExpression)),
                //#line 911 GJavaParser.g
                )
                break
            }
            //
            // Rule 420:  InclusiveOrExpression ::= ExclusiveOrExpression
            //
            case 420:
                break
            //
            // Rule 421:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
            //
            case 421: {
               //#line 914 "GJavaParser.g"
                my.SetResult(
                    //#line 914 GJavaParser.g
                    NewInclusiveOrExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 914 GJavaParser.g
                                             my.GetRhsSym(1).(IInclusiveOrExpression),
                                             //#line 914 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 914 GJavaParser.g
                                             my.GetRhsSym(3).(IExclusiveOrExpression)),
                //#line 914 GJavaParser.g
                )
                break
            }
            //
            // Rule 422:  ConditionalAndExpression ::= InclusiveOrExpression
            //
            case 422:
                break
            //
            // Rule 423:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
            //
            case 423: {
               //#line 917 "GJavaParser.g"
                my.SetResult(
                    //#line 917 GJavaParser.g
                    NewConditionalAndExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 917 GJavaParser.g
                                                my.GetRhsSym(1).(IConditionalAndExpression),
                                                //#line 917 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(2)),
                                                //#line 917 GJavaParser.g
                                                my.GetRhsSym(3).(IInclusiveOrExpression)),
                //#line 917 GJavaParser.g
                )
                break
            }
            //
            // Rule 424:  ConditionalOrExpression ::= ConditionalAndExpression
            //
            case 424:
                break
            //
            // Rule 425:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
            //
            case 425: {
               //#line 920 "GJavaParser.g"
                my.SetResult(
                    //#line 920 GJavaParser.g
                    NewConditionalOrExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 920 GJavaParser.g
                                               my.GetRhsSym(1).(IConditionalOrExpression),
                                               //#line 920 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2)),
                                               //#line 920 GJavaParser.g
                                               my.GetRhsSym(3).(IConditionalAndExpression)),
                //#line 920 GJavaParser.g
                )
                break
            }
            //
            // Rule 426:  ConditionalExpression ::= ConditionalOrExpression
            //
            case 426:
                break
            //
            // Rule 427:  ConditionalExpression ::= ConditionalOrExpression ? Expression : ConditionalExpression
            //
            case 427: {
               //#line 923 "GJavaParser.g"
                my.SetResult(
                    //#line 923 GJavaParser.g
                    NewConditionalExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 923 GJavaParser.g
                                             my.GetRhsSym(1).(IConditionalOrExpression),
                                             //#line 923 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 923 GJavaParser.g
                                             my.GetRhsSym(3).(IExpression),
                                             //#line 923 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(4)),
                                             //#line 923 GJavaParser.g
                                             my.GetRhsSym(5).(IConditionalExpression)),
                //#line 923 GJavaParser.g
                )
                break
            }
            //
            // Rule 428:  AssignmentExpression ::= ConditionalExpression
            //
            case 428:
                break
            //
            // Rule 429:  AssignmentExpression ::= Assignment
            //
            case 429:
                break
            //
            // Rule 430:  Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
            //
            case 430: {
               //#line 928 "GJavaParser.g"
                my.SetResult(
                    //#line 928 GJavaParser.g
                    NewAssignment(my.GetLeftIToken(), my.GetRightIToken(),
                                  //#line 928 GJavaParser.g
                                  my.GetRhsSym(1).(ILeftHandSide),
                                  //#line 928 GJavaParser.g
                                  my.GetRhsSym(2).(IAssignmentOperator),
                                  //#line 928 GJavaParser.g
                                  my.GetRhsSym(3).(IAssignmentExpression)),
                //#line 928 GJavaParser.g
                )
                break
            }
            //
            // Rule 431:  LeftHandSide ::= ExpressionName
            //
            case 431:
                break
            //
            // Rule 432:  LeftHandSide ::= FieldAccess
            //
            case 432:
                break
            //
            // Rule 433:  LeftHandSide ::= ArrayAccess
            //
            case 433:
                break
            //
            // Rule 434:  AssignmentOperator ::= =
            //
            case 434: {
               //#line 934 "GJavaParser.g"
                my.SetResult(
                    //#line 934 GJavaParser.g
                    NewAssignmentOperator0(my.GetRhsIToken(1)),
                //#line 934 GJavaParser.g
                )
                break
            }
            //
            // Rule 435:  AssignmentOperator ::= *=
            //
            case 435: {
               //#line 935 "GJavaParser.g"
                my.SetResult(
                    //#line 935 GJavaParser.g
                    NewAssignmentOperator1(my.GetRhsIToken(1)),
                //#line 935 GJavaParser.g
                )
                break
            }
            //
            // Rule 436:  AssignmentOperator ::= /=
            //
            case 436: {
               //#line 936 "GJavaParser.g"
                my.SetResult(
                    //#line 936 GJavaParser.g
                    NewAssignmentOperator2(my.GetRhsIToken(1)),
                //#line 936 GJavaParser.g
                )
                break
            }
            //
            // Rule 437:  AssignmentOperator ::= %=
            //
            case 437: {
               //#line 937 "GJavaParser.g"
                my.SetResult(
                    //#line 937 GJavaParser.g
                    NewAssignmentOperator3(my.GetRhsIToken(1)),
                //#line 937 GJavaParser.g
                )
                break
            }
            //
            // Rule 438:  AssignmentOperator ::= +=
            //
            case 438: {
               //#line 938 "GJavaParser.g"
                my.SetResult(
                    //#line 938 GJavaParser.g
                    NewAssignmentOperator4(my.GetRhsIToken(1)),
                //#line 938 GJavaParser.g
                )
                break
            }
            //
            // Rule 439:  AssignmentOperator ::= -=
            //
            case 439: {
               //#line 939 "GJavaParser.g"
                my.SetResult(
                    //#line 939 GJavaParser.g
                    NewAssignmentOperator5(my.GetRhsIToken(1)),
                //#line 939 GJavaParser.g
                )
                break
            }
            //
            // Rule 440:  AssignmentOperator ::= <<=
            //
            case 440: {
               //#line 940 "GJavaParser.g"
                my.SetResult(
                    //#line 940 GJavaParser.g
                    NewAssignmentOperator6(my.GetRhsIToken(1)),
                //#line 940 GJavaParser.g
                )
                break
            }
            //
            // Rule 441:  AssignmentOperator ::= > > =
            //
            case 441: {
               //#line 941 "GJavaParser.g"
                my.SetResult(
                    //#line 941 GJavaParser.g
                    NewAssignmentOperator7(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 941 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(1)),
                                           //#line 941 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 941 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(3))),
                //#line 941 GJavaParser.g
                )
                break
            }
            //
            // Rule 442:  AssignmentOperator ::= > > > =
            //
            case 442: {
               //#line 942 "GJavaParser.g"
                my.SetResult(
                    //#line 942 GJavaParser.g
                    NewAssignmentOperator8(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 942 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(1)),
                                           //#line 942 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 942 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(3)),
                                           //#line 942 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(4))),
                //#line 942 GJavaParser.g
                )
                break
            }
            //
            // Rule 443:  AssignmentOperator ::= &=
            //
            case 443: {
               //#line 943 "GJavaParser.g"
                my.SetResult(
                    //#line 943 GJavaParser.g
                    NewAssignmentOperator9(my.GetRhsIToken(1)),
                //#line 943 GJavaParser.g
                )
                break
            }
            //
            // Rule 444:  AssignmentOperator ::= ^=
            //
            case 444: {
               //#line 944 "GJavaParser.g"
                my.SetResult(
                    //#line 944 GJavaParser.g
                    NewAssignmentOperator10(my.GetRhsIToken(1)),
                //#line 944 GJavaParser.g
                )
                break
            }
            //
            // Rule 445:  AssignmentOperator ::= |=
            //
            case 445: {
               //#line 945 "GJavaParser.g"
                my.SetResult(
                    //#line 945 GJavaParser.g
                    NewAssignmentOperator11(my.GetRhsIToken(1)),
                //#line 945 GJavaParser.g
                )
                break
            }
            //
            // Rule 446:  Expression ::= AssignmentExpression
            //
            case 446:
                break
            //
            // Rule 447:  ConstantExpression ::= Expression
            //
            case 447:
                break
            //
            // Rule 448:  Dimsopt ::= $Empty
            //
            case 448: {
               //#line 954 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 449:  Dimsopt ::= Dims
            //
            case 449:
                break
            //
            // Rule 450:  Catchesopt ::= $Empty
            //
            case 450: {
               //#line 957 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 451:  Catchesopt ::= Catches
            //
            case 451:
                break
            //
            // Rule 452:  identifieropt ::= $Empty
            //
            case 452: {
               //#line 960 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 453:  identifieropt ::= identifier
            //
            case 453:
                break
            //
            // Rule 454:  ForUpdateopt ::= $Empty
            //
            case 454: {
               //#line 963 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 455:  ForUpdateopt ::= ForUpdate
            //
            case 455:
                break
            //
            // Rule 456:  Expressionopt ::= $Empty
            //
            case 456: {
               //#line 966 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 457:  Expressionopt ::= Expression
            //
            case 457:
                break
            //
            // Rule 458:  ForInitopt ::= $Empty
            //
            case 458: {
               //#line 969 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 459:  ForInitopt ::= ForInit
            //
            case 459:
                break
            //
            // Rule 460:  SwitchLabelsopt ::= $Empty
            //
            case 460: {
               //#line 972 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 461:  SwitchLabelsopt ::= SwitchLabels
            //
            case 461:
                break
            //
            // Rule 462:  SwitchBlockStatementGroupsopt ::= $Empty
            //
            case 462: {
               //#line 975 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 463:  SwitchBlockStatementGroupsopt ::= SwitchBlockStatementGroups
            //
            case 463:
                break
            //
            // Rule 464:  VariableModifiersopt ::= $Empty
            //
            case 464: {
               //#line 978 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 465:  VariableModifiersopt ::= VariableModifiers
            //
            case 465:
                break
            //
            // Rule 466:  VariableInitializersopt ::= $Empty
            //
            case 466: {
               //#line 981 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 467:  VariableInitializersopt ::= VariableInitializers
            //
            case 467:
                break
            //
            // Rule 468:  ElementValuesopt ::= $Empty
            //
            case 468: {
               //#line 984 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 469:  ElementValuesopt ::= ElementValues
            //
            case 469:
                break
            //
            // Rule 470:  ElementValuePairsopt ::= $Empty
            //
            case 470: {
               //#line 987 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 471:  ElementValuePairsopt ::= ElementValuePairs
            //
            case 471:
                break
            //
            // Rule 472:  DefaultValueopt ::= $Empty
            //
            case 472: {
               //#line 990 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 473:  DefaultValueopt ::= DefaultValue
            //
            case 473:
                break
            //
            // Rule 474:  AnnotationTypeElementDeclarationsopt ::= $Empty
            //
            case 474: {
               //#line 993 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 475:  AnnotationTypeElementDeclarationsopt ::= AnnotationTypeElementDeclarations
            //
            case 475:
                break
            //
            // Rule 476:  AbstractMethodModifiersopt ::= $Empty
            //
            case 476: {
               //#line 996 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 477:  AbstractMethodModifiersopt ::= AbstractMethodModifiers
            //
            case 477:
                break
            //
            // Rule 478:  ConstantModifiersopt ::= $Empty
            //
            case 478: {
               //#line 999 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 479:  ConstantModifiersopt ::= ConstantModifiers
            //
            case 479:
                break
            //
            // Rule 480:  InterfaceMemberDeclarationsopt ::= $Empty
            //
            case 480: {
               //#line 1002 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 481:  InterfaceMemberDeclarationsopt ::= InterfaceMemberDeclarations
            //
            case 481:
                break
            //
            // Rule 482:  ExtendsInterfacesopt ::= $Empty
            //
            case 482: {
               //#line 1005 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 483:  ExtendsInterfacesopt ::= ExtendsInterfaces
            //
            case 483:
                break
            //
            // Rule 484:  InterfaceModifiersopt ::= $Empty
            //
            case 484: {
               //#line 1008 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 485:  InterfaceModifiersopt ::= InterfaceModifiers
            //
            case 485:
                break
            //
            // Rule 486:  ClassBodyopt ::= $Empty
            //
            case 486: {
               //#line 1011 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 487:  ClassBodyopt ::= ClassBody
            //
            case 487:
                break
            //
            // Rule 488:  Argumentsopt ::= $Empty
            //
            case 488: {
               //#line 1014 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 489:  Argumentsopt ::= Arguments
            //
            case 489:
                break
            //
            // Rule 490:  EnumBodyDeclarationsopt ::= $Empty
            //
            case 490: {
               //#line 1017 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 491:  EnumBodyDeclarationsopt ::= EnumBodyDeclarations
            //
            case 491:
                break
            //
            // Rule 492:  ,opt ::= $Empty
            //
            case 492: {
               //#line 1020 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 493:  ,opt ::= ,
            //
            case 493: {
               //#line 1021 "GJavaParser.g"
                my.SetResult(
                    //#line 1021 GJavaParser.g
                    NewCommaopt(my.GetRhsIToken(1)),
                //#line 1021 GJavaParser.g
                )
                break
            }
            //
            // Rule 494:  EnumConstantsopt ::= $Empty
            //
            case 494: {
               //#line 1023 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 495:  EnumConstantsopt ::= EnumConstants
            //
            case 495:
                break
            //
            // Rule 496:  ArgumentListopt ::= $Empty
            //
            case 496: {
               //#line 1026 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 497:  ArgumentListopt ::= ArgumentList
            //
            case 497:
                break
            //
            // Rule 498:  BlockStatementsopt ::= $Empty
            //
            case 498: {
               //#line 1029 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 499:  BlockStatementsopt ::= BlockStatements
            //
            case 499:
                break
            //
            // Rule 500:  ExplicitConstructorInvocationopt ::= $Empty
            //
            case 500: {
               //#line 1032 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 501:  ExplicitConstructorInvocationopt ::= ExplicitConstructorInvocation
            //
            case 501:
                break
            //
            // Rule 502:  ConstructorModifiersopt ::= $Empty
            //
            case 502: {
               //#line 1035 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 503:  ConstructorModifiersopt ::= ConstructorModifiers
            //
            case 503:
                break
            //
            // Rule 504:  ...opt ::= $Empty
            //
            case 504: {
               //#line 1038 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 505:  ...opt ::= ...
            //
            case 505: {
               //#line 1039 "GJavaParser.g"
                my.SetResult(
                    //#line 1039 GJavaParser.g
                    NewEllipsisopt(my.GetRhsIToken(1)),
                //#line 1039 GJavaParser.g
                )
                break
            }
            //
            // Rule 506:  FormalParameterListopt ::= $Empty
            //
            case 506: {
               //#line 1041 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 507:  FormalParameterListopt ::= FormalParameterList
            //
            case 507:
                break
            //
            // Rule 508:  Throwsopt ::= $Empty
            //
            case 508: {
               //#line 1044 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 509:  Throwsopt ::= Throws
            //
            case 509:
                break
            //
            // Rule 510:  MethodModifiersopt ::= $Empty
            //
            case 510: {
               //#line 1047 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 511:  MethodModifiersopt ::= MethodModifiers
            //
            case 511:
                break
            //
            // Rule 512:  FieldModifiersopt ::= $Empty
            //
            case 512: {
               //#line 1050 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 513:  FieldModifiersopt ::= FieldModifiers
            //
            case 513:
                break
            //
            // Rule 514:  ClassBodyDeclarationsopt ::= $Empty
            //
            case 514: {
               //#line 1053 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 515:  ClassBodyDeclarationsopt ::= ClassBodyDeclarations
            //
            case 515:
                break
            //
            // Rule 516:  Interfacesopt ::= $Empty
            //
            case 516: {
               //#line 1056 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 517:  Interfacesopt ::= Interfaces
            //
            case 517:
                break
            //
            // Rule 518:  Superopt ::= $Empty
            //
            case 518: {
               //#line 1059 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 519:  Superopt ::= Super
            //
            case 519:
                break
            //
            // Rule 520:  TypeParametersopt ::= $Empty
            //
            case 520: {
               //#line 1062 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 521:  TypeParametersopt ::= TypeParameters
            //
            case 521:
                break
            //
            // Rule 522:  ClassModifiersopt ::= $Empty
            //
            case 522: {
               //#line 1065 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 523:  ClassModifiersopt ::= ClassModifiers
            //
            case 523:
                break
            //
            // Rule 524:  Annotationsopt ::= $Empty
            //
            case 524: {
               //#line 1068 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 525:  Annotationsopt ::= Annotations
            //
            case 525:
                break
            //
            // Rule 526:  TypeDeclarationsopt ::= $Empty
            //
            case 526: {
               //#line 1071 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 527:  TypeDeclarationsopt ::= TypeDeclarations
            //
            case 527:
                break
            //
            // Rule 528:  ImportDeclarationsopt ::= $Empty
            //
            case 528: {
               //#line 1074 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 529:  ImportDeclarationsopt ::= ImportDeclarations
            //
            case 529:
                break
            //
            // Rule 530:  PackageDeclarationopt ::= $Empty
            //
            case 530: {
               //#line 1077 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 531:  PackageDeclarationopt ::= PackageDeclaration
            //
            case 531:
                break
            //
            // Rule 532:  WildcardBoundsOpt ::= $Empty
            //
            case 532: {
               //#line 1080 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 533:  WildcardBoundsOpt ::= WildcardBounds
            //
            case 533:
                break
            //
            // Rule 534:  AdditionalBoundListopt ::= $Empty
            //
            case 534: {
               //#line 1083 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 535:  AdditionalBoundListopt ::= AdditionalBoundList
            //
            case 535:
                break
            //
            // Rule 536:  TypeBoundopt ::= $Empty
            //
            case 536: {
               //#line 1086 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 537:  TypeBoundopt ::= TypeBound
            //
            case 537:
                break
            //
            // Rule 538:  TypeArgumentsopt ::= $Empty
            //
            case 538: {
               //#line 1089 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 539:  TypeArgumentsopt ::= TypeArguments
            //
            case 539:
                break
    //#line 330 "btParserTemplateF.gi

    
            default:
                break
        }
        return
    }
type Ast struct{
     leftIToken  IToken 
     rightIToken IToken 
     parent IAst
}
func NewAst2(leftIToken  IToken , rightIToken  IToken ) *Ast{
        my := new(Ast)
        my.leftIToken = leftIToken
        my.rightIToken = rightIToken
        return my
}

func NewAst(token  IToken) *Ast{
        my := new(Ast)
        my.leftIToken = token
        my.rightIToken = token
        return my
}

func (my *Ast)     GetNextAst() IAst  { return nil }
func (my *Ast)      SetParent(parent IAst )  { my.parent = parent }
func (my *Ast)      GetParent() IAst { return my.parent }

func (my *Ast)     GetLeftIToken()  IToken { return my.leftIToken }
func (my *Ast)     GetRightIToken()  IToken { return my.rightIToken }
func (my *Ast)     GetPrecedingAdjuncts()  []IToken { return my.leftIToken.GetPrecedingAdjuncts() }
func (my *Ast)     GetFollowingAdjuncts()  []IToken { return my.rightIToken.GetFollowingAdjuncts() }

func (my *Ast)      ToString()string{
        return my.leftIToken.GetILexStream().ToString(my.leftIToken.GetStartOffset(), my.rightIToken.GetEndOffset())
}

func (my *Ast)     Initialize()  {}

    /**
     * A list of all children of my node, excluding the null ones.
     */
func (my *Ast)      GetChildren() *ArrayList{
        var list = my.GetAllChildren() 
        var k = -1
        var i = 0
        for ; i < list.Size(); i++{
            var element = list.Get(i)
            if element != nil{
                k += i
                if k != i{
                    list.Set(k, element)
                }
            }
        }
        i = list.Size() - 1
        for ; i > k; i--{ // remove extraneous elements
            list.RemoveAt(i)
        }
        return list
}

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Ast)    GetAllChildren() *ArrayList{return nil}

 func (my *Ast) Accept(v IAstVisitor){}


func AnyCastToAst(i interface{}) *Ast {
	if nil == i{
		return nil
	}else{
		return i.(*Ast)
	}
}
type AbstractAstList struct{
     *Ast
     leftRecursive bool 
     list *ArrayList 
}
func NewAbstractAstList(leftToken  IToken, rightToken  IToken, leftRecursive bool)*AbstractAstList{
      my := new(AbstractAstList)
      my.Ast = NewAst2(leftToken, rightToken)
      my.list = NewArrayList()
      my.leftRecursive = leftRecursive
      return my
}

func (my *AbstractAstList)      Size() int { return my.list.Size(); }
func (my *AbstractAstList)      GetList() *ArrayList{ return my.list }
func (my *AbstractAstList)      GetElementAt(i int ) IAst{
    var k int
    if my.leftRecursive {
       k =i
    }else{
       k =my.list.Size() - 1 - i
    }
    return my.list.Get(k).(IAst) 
    }
func (my *AbstractAstList)      GetArrayList() *ArrayList{
        if ! my.leftRecursive{ // reverse the list 
           var i = 0
           var n = my.list.Size() - 1
           for ; i < n;  n--{
                var ith = my.list.Get(i)
                var nth = my.list.Get(n)
                my.list.Set(i, nth)
                my.list.Set(n, ith)
               i++
           }
           my.leftRecursive = true
        }
        return my.list
    }
    /**
     * @deprecated replaced by {@link #AddElement()}
     *
     */
func (my *AbstractAstList)      Add(element IAst) bool {
        my.AddElement(element)
        return true
}

func (my *AbstractAstList)      AddElement(element IAst){
        my.list.Add(element)
        if my.leftRecursive{
             my.rightIToken = element.GetRightIToken()
        }else{
          my.leftIToken = element.GetLeftIToken()
        }
}

    /**
     * Make a copy of the list and return it. Note that we obtain the local list by
     * invoking GetArrayList so as to make sure that the list we return is in proper order.
     */
func (my *AbstractAstList)      GetAllChildren() *ArrayList{
        return my.GetArrayList().Clone()
}



func AnyCastToAbstractAstList(i interface{}) *AbstractAstList {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractAstList)
	}
}
type AstToken struct{
    *Ast
 }
func NewAstToken(token  IToken)*AstToken{
      my := new(AstToken)
      my.Ast = NewAst(token)
      return my
}

func (my *AstToken)      GetIToken()  IToken{ return my.leftIToken }
func (my *AstToken)      ToString()  string  { return my.leftIToken.ToString() }

    /**
     * A token class has no children. So, we return the empty list.
     */
func (my *AstToken)        GetAllChildren()  *ArrayList { return nil }


func (my *AstToken)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AstToken)       Enter(v Visitor){
        v.VisitAstToken(my)
        v.EndVisitAstToken(my)
    }


func AnyCastToAstToken(i interface{}) *AstToken {
	if nil == i{
		return nil
	}else{
		return i.(*AstToken)
	}
}
type IRootForJavaParser interface{
     GetLeftIToken()  IToken
     GetRightIToken()  IToken
 Accept(v IAstVisitor)
}

func CastToAnyForJavaParser(i interface{}) interface{}{return i}

func AnyCastToIRootForJavaParser(i interface{}) IRootForJavaParser {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IRootForJavaParser)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PrimitiveType
 *<li>ClassType
 *<li>ArrayType
 *<li>TypeDeclaration
 *<li>NormalClassDeclaration
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>ResultType
 *<li>VariableModifier
 *<li>MethodBody
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>InterfaceMemberDeclaration
 *<li>ConstantDeclaration
 *<li>AbstractMethodDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>Block
 *<li>BlockStatements
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>Commaopt
 *<li>Ellipsisopt
 *<li>LPGUserAction0
 *<li>LPGUserAction1
 *<li>LPGUserAction2
 *<li>LPGUserAction3
 *<li>LPGUserAction4
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *<li>ClassModifier0
 *<li>ClassModifier1
 *<li>ClassModifier2
 *<li>ClassModifier3
 *<li>ClassModifier4
 *<li>ClassModifier5
 *<li>ClassModifier6
 *<li>FieldModifier0
 *<li>FieldModifier1
 *<li>FieldModifier2
 *<li>FieldModifier3
 *<li>FieldModifier4
 *<li>FieldModifier5
 *<li>FieldModifier6
 *<li>MethodModifier0
 *<li>MethodModifier1
 *<li>MethodModifier2
 *<li>MethodModifier3
 *<li>MethodModifier4
 *<li>MethodModifier5
 *<li>MethodModifier6
 *<li>MethodModifier7
 *<li>MethodModifier8
 *<li>ConstructorModifier0
 *<li>ConstructorModifier1
 *<li>ConstructorModifier2
 *<li>InterfaceModifier0
 *<li>InterfaceModifier1
 *<li>InterfaceModifier2
 *<li>InterfaceModifier3
 *<li>InterfaceModifier4
 *<li>InterfaceModifier5
 *<li>ConstantModifier0
 *<li>ConstantModifier1
 *<li>ConstantModifier2
 *<li>AbstractMethodModifier0
 *<li>AbstractMethodModifier1
 *<li>AnnotationTypeElementDeclaration0
 *<li>AnnotationTypeElementDeclaration1
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>AssignmentOperator0
 *<li>AssignmentOperator1
 *<li>AssignmentOperator2
 *<li>AssignmentOperator3
 *<li>AssignmentOperator4
 *<li>AssignmentOperator5
 *<li>AssignmentOperator6
 *<li>AssignmentOperator7
 *<li>AssignmentOperator8
 *<li>AssignmentOperator9
 *<li>AssignmentOperator10
 *<li>AssignmentOperator11
 *</ul>
 *</b>
 */
type IAstToken interface{
IRootForJavaParser
}

func AnyCastToIAstToken(i interface{}) IAstToken {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAstToken)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>Commaopt</b>
 */
type ICommaopt interface{
IAstToken
}

func AnyCastToICommaopt(i interface{}) ICommaopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICommaopt)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>Ellipsisopt</b>
 */
type IEllipsisopt interface{
IAstToken
}

func AnyCastToIEllipsisopt(i interface{}) IEllipsisopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEllipsisopt)
	  }
}
/**
 * is implemented by <b>CompilationUnit</b>
 */
type ICompilationUnit interface{
IRootForJavaParser
}

func AnyCastToICompilationUnit(i interface{}) ICompilationUnit {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICompilationUnit)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>ClassBodyDeclarations
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>StaticInitializer
 *<li>ConstructorDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>Block
 *</ul>
 *</b>
 */
type IClassBodyDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIClassBodyDeclarationsopt(i interface{}) IClassBodyDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBodyDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>Block
 *<li>BlockStatements
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>LPGUserAction0
 *<li>LPGUserAction1
 *<li>LPGUserAction2
 *<li>LPGUserAction3
 *<li>LPGUserAction4
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type ILPGUserAction interface{
IAstToken
}

func AnyCastToILPGUserAction(i interface{}) ILPGUserAction {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILPGUserAction)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type Iidentifier interface{
IAstToken
ITypeName
ITypeVariable
IPackageName
IExpressionName
IMethodName
IPackageOrTypeName
IAmbiguousName
IVariableDeclaratorId
ISimpleTypeName
ISimpleName
IEnumConstant
Iidentifieropt
}

func AnyCastToIidentifier(i interface{}) Iidentifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(Iidentifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>Block
 *<li>BlockStatements
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IBlockStatementsopt interface{
ILPGUserAction
}

func AnyCastToIBlockStatementsopt(i interface{}) IBlockStatementsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBlockStatementsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PrimitiveType
 *<li>ClassType
 *<li>ArrayType
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type IType interface{
IResultType
}

func AnyCastToIType(i interface{}) IType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>PrimitiveType
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type IPrimitiveType interface{
IType
IAstToken
}

func AnyCastToIPrimitiveType(i interface{}) IPrimitiveType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPrimitiveType)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *<li>ArrayType
 *</ul>
 *</b>
 */
type IReferenceType interface{
IType
IActualTypeArgument
}

func AnyCastToIReferenceType(i interface{}) IReferenceType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IReferenceType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type INumericType interface{
IPrimitiveType
}

func AnyCastToINumericType(i interface{}) INumericType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(INumericType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *</ul>
 *</b>
 */
type IIntegralType interface{
INumericType
IAstToken
}

func AnyCastToIIntegralType(i interface{}) IIntegralType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IIntegralType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type IFloatingPointType interface{
INumericType
IAstToken
}

func AnyCastToIFloatingPointType(i interface{}) IFloatingPointType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFloatingPointType)
	  }
}
/**
 * is implemented by <b>ClassType</b>
 */
type IClassOrInterfaceType interface{
IReferenceType
}

func AnyCastToIClassOrInterfaceType(i interface{}) IClassOrInterfaceType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassOrInterfaceType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type ITypeVariable interface{
IReferenceType
IExceptionType
}

func AnyCastToITypeVariable(i interface{}) ITypeVariable {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeVariable)
	  }
}
/**
 * is implemented by <b>ArrayType</b>
 */
type IArrayType interface{
IReferenceType
}

func AnyCastToIArrayType(i interface{}) IArrayType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArrayType)
	  }
}
/**
 * is implemented by <b>ClassType</b>
 */
type IClassType interface{
IClassOrInterfaceType
IExceptionType
}

func AnyCastToIClassType(i interface{}) IClassType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassType)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>TypeName
 *</ul>
 *</b>
 */
type ITypeName interface{
IClassName
}

func AnyCastToITypeName(i interface{}) ITypeName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeName)
	  }
}
/**
 * is implemented by <b>TypeArguments</b>
 */
type ITypeArgumentsopt interface{
IRootForJavaParser
}

func AnyCastToITypeArgumentsopt(i interface{}) ITypeArgumentsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeArgumentsopt)
	  }
}
/**
 * is implemented by <b>InterfaceType</b>
 */
type IInterfaceType interface{
IInterfaceTypeList
}

func AnyCastToIInterfaceType(i interface{}) IInterfaceType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceType)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>TypeName
 *</ul>
 *</b>
 */
type IClassName interface{
IRootForJavaParser
}

func AnyCastToIClassName(i interface{}) IClassName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassName)
	  }
}
/**
 * is implemented by <b>TypeParameter</b>
 */
type ITypeParameter interface{
ITypeParameterList
}

func AnyCastToITypeParameter(i interface{}) ITypeParameter {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeParameter)
	  }
}
/**
 * is implemented by <b>TypeBound</b>
 */
type ITypeBoundopt interface{
IRootForJavaParser
}

func AnyCastToITypeBoundopt(i interface{}) ITypeBoundopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeBoundopt)
	  }
}
/**
 * is implemented by <b>TypeBound</b>
 */
type ITypeBound interface{
ITypeBoundopt
}

func AnyCastToITypeBound(i interface{}) ITypeBound {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeBound)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AdditionalBoundList
 *<li>AdditionalBound
 *</ul>
 *</b>
 */
type IAdditionalBoundListopt interface{
IRootForJavaParser
}

func AnyCastToIAdditionalBoundListopt(i interface{}) IAdditionalBoundListopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAdditionalBoundListopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AdditionalBoundList
 *<li>AdditionalBound
 *</ul>
 *</b>
 */
type IAdditionalBoundList interface{
IAdditionalBoundListopt
}

func AnyCastToIAdditionalBoundList(i interface{}) IAdditionalBoundList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAdditionalBoundList)
	  }
}
/**
 * is implemented by <b>AdditionalBound</b>
 */
type IAdditionalBound interface{
IAdditionalBoundList
}

func AnyCastToIAdditionalBound(i interface{}) IAdditionalBound {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAdditionalBound)
	  }
}
/**
 * is implemented by <b>TypeArguments</b>
 */
type ITypeArguments interface{
ITypeArgumentsopt
}

func AnyCastToITypeArguments(i interface{}) ITypeArguments {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeArguments)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *<li>ArrayType
 *<li>ActualTypeArgumentList
 *<li>Wildcard
 *</ul>
 *</b>
 */
type IActualTypeArgumentList interface{
IRootForJavaParser
}

func AnyCastToIActualTypeArgumentList(i interface{}) IActualTypeArgumentList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IActualTypeArgumentList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *<li>ArrayType
 *<li>Wildcard
 *</ul>
 *</b>
 */
type IActualTypeArgument interface{
IActualTypeArgumentList
}

func AnyCastToIActualTypeArgument(i interface{}) IActualTypeArgument {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IActualTypeArgument)
	  }
}
/**
 * is implemented by <b>Wildcard</b>
 */
type IWildcard interface{
IActualTypeArgument
}

func AnyCastToIWildcard(i interface{}) IWildcard {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWildcard)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>WildcardBounds0
 *<li>WildcardBounds1
 *</ul>
 *</b>
 */
type IWildcardBoundsOpt interface{
IRootForJavaParser
}

func AnyCastToIWildcardBoundsOpt(i interface{}) IWildcardBoundsOpt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWildcardBoundsOpt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>WildcardBounds0
 *<li>WildcardBounds1
 *</ul>
 *</b>
 */
type IWildcardBounds interface{
IWildcardBoundsOpt
}

func AnyCastToIWildcardBounds(i interface{}) IWildcardBounds {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWildcardBounds)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PackageName
 *</ul>
 *</b>
 */
type IPackageName interface{
IRootForJavaParser
}

func AnyCastToIPackageName(i interface{}) IPackageName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPackageName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *</ul>
 *</b>
 */
type IExpressionName interface{
IPostfixExpression
ILeftHandSide
}

func AnyCastToIExpressionName(i interface{}) IExpressionName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExpressionName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>AmbiguousName
 *</ul>
 *</b>
 */
type IAmbiguousName interface{
IRootForJavaParser
}

func AnyCastToIAmbiguousName(i interface{}) IAmbiguousName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAmbiguousName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>MethodName
 *</ul>
 *</b>
 */
type IMethodName interface{
IRootForJavaParser
}

func AnyCastToIMethodName(i interface{}) IMethodName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PackageOrTypeName
 *</ul>
 *</b>
 */
type IPackageOrTypeName interface{
IRootForJavaParser
}

func AnyCastToIPackageOrTypeName(i interface{}) IPackageOrTypeName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPackageOrTypeName)
	  }
}
/**
 * is implemented by <b>PackageDeclaration</b>
 */
type IPackageDeclarationopt interface{
IRootForJavaParser
}

func AnyCastToIPackageDeclarationopt(i interface{}) IPackageDeclarationopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPackageDeclarationopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ImportDeclarations
 *<li>SingleTypeImportDeclaration
 *<li>TypeImportOnDemandDeclaration
 *<li>SingleStaticImportDeclaration
 *<li>StaticImportOnDemandDeclaration
 *</ul>
 *</b>
 */
type IImportDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIImportDeclarationsopt(i interface{}) IImportDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IImportDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TypeDeclarations
 *<li>TypeDeclaration
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type ITypeDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToITypeDeclarationsopt(i interface{}) ITypeDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ImportDeclarations
 *<li>SingleTypeImportDeclaration
 *<li>TypeImportOnDemandDeclaration
 *<li>SingleStaticImportDeclaration
 *<li>StaticImportOnDemandDeclaration
 *</ul>
 *</b>
 */
type IImportDeclarations interface{
IImportDeclarationsopt
}

func AnyCastToIImportDeclarations(i interface{}) IImportDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IImportDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SingleTypeImportDeclaration
 *<li>TypeImportOnDemandDeclaration
 *<li>SingleStaticImportDeclaration
 *<li>StaticImportOnDemandDeclaration
 *</ul>
 *</b>
 */
type IImportDeclaration interface{
IImportDeclarations
}

func AnyCastToIImportDeclaration(i interface{}) IImportDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IImportDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TypeDeclarations
 *<li>TypeDeclaration
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type ITypeDeclarations interface{
ITypeDeclarationsopt
}

func AnyCastToITypeDeclarations(i interface{}) ITypeDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TypeDeclaration
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type ITypeDeclaration interface{
ITypeDeclarations
IAstToken
}

func AnyCastToITypeDeclaration(i interface{}) ITypeDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeDeclaration)
	  }
}
/**
 * is implemented by <b>PackageDeclaration</b>
 */
type IPackageDeclaration interface{
IPackageDeclarationopt
}

func AnyCastToIPackageDeclaration(i interface{}) IPackageDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPackageDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IAnnotationsopt interface{
IRootForJavaParser
}

func AnyCastToIAnnotationsopt(i interface{}) IAnnotationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationsopt)
	  }
}
/**
 * is implemented by <b>SingleTypeImportDeclaration</b>
 */
type ISingleTypeImportDeclaration interface{
IImportDeclaration
}

func AnyCastToISingleTypeImportDeclaration(i interface{}) ISingleTypeImportDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISingleTypeImportDeclaration)
	  }
}
/**
 * is implemented by <b>TypeImportOnDemandDeclaration</b>
 */
type ITypeImportOnDemandDeclaration interface{
IImportDeclaration
}

func AnyCastToITypeImportOnDemandDeclaration(i interface{}) ITypeImportOnDemandDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeImportOnDemandDeclaration)
	  }
}
/**
 * is implemented by <b>SingleStaticImportDeclaration</b>
 */
type ISingleStaticImportDeclaration interface{
IImportDeclaration
}

func AnyCastToISingleStaticImportDeclaration(i interface{}) ISingleStaticImportDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISingleStaticImportDeclaration)
	  }
}
/**
 * is implemented by <b>StaticImportOnDemandDeclaration</b>
 */
type IStaticImportOnDemandDeclaration interface{
IImportDeclaration
}

func AnyCastToIStaticImportOnDemandDeclaration(i interface{}) IStaticImportOnDemandDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStaticImportOnDemandDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *</ul>
 *</b>
 */
type IClassDeclaration interface{
ITypeDeclaration
IClassMemberDeclaration
IInterfaceMemberDeclaration
IAnnotationTypeElementDeclaration
IBlockStatement
}

func AnyCastToIClassDeclaration(i interface{}) IClassDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IInterfaceDeclaration interface{
ITypeDeclaration
IClassMemberDeclaration
IInterfaceMemberDeclaration
IAnnotationTypeElementDeclaration
}

func AnyCastToIInterfaceDeclaration(i interface{}) IInterfaceDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceDeclaration)
	  }
}
/**
 * is implemented by <b>NormalClassDeclaration</b>
 */
type INormalClassDeclaration interface{
IClassDeclaration
}

func AnyCastToINormalClassDeclaration(i interface{}) INormalClassDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(INormalClassDeclaration)
	  }
}
/**
 * is implemented by <b>EnumDeclaration</b>
 */
type IEnumDeclaration interface{
IClassDeclaration
IAnnotationTypeElementDeclaration
}

func AnyCastToIEnumDeclaration(i interface{}) IEnumDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ClassModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ClassModifier0
 *<li>ClassModifier1
 *<li>ClassModifier2
 *<li>ClassModifier3
 *<li>ClassModifier4
 *<li>ClassModifier5
 *<li>ClassModifier6
 *</ul>
 *</b>
 */
type IClassModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIClassModifiersopt(i interface{}) IClassModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassModifiersopt)
	  }
}
/**
 * is implemented by <b>TypeParameters</b>
 */
type ITypeParametersopt interface{
IRootForJavaParser
}

func AnyCastToITypeParametersopt(i interface{}) ITypeParametersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeParametersopt)
	  }
}
/**
 * is implemented by <b>Super</b>
 */
type ISuperopt interface{
IRootForJavaParser
}

func AnyCastToISuperopt(i interface{}) ISuperopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISuperopt)
	  }
}
/**
 * is implemented by <b>Interfaces</b>
 */
type IInterfacesopt interface{
IRootForJavaParser
}

func AnyCastToIInterfacesopt(i interface{}) IInterfacesopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfacesopt)
	  }
}
/**
 * is implemented by <b>ClassBody</b>
 */
type IClassBody interface{
IClassBodyopt
}

func AnyCastToIClassBody(i interface{}) IClassBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ClassModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ClassModifier0
 *<li>ClassModifier1
 *<li>ClassModifier2
 *<li>ClassModifier3
 *<li>ClassModifier4
 *<li>ClassModifier5
 *<li>ClassModifier6
 *</ul>
 *</b>
 */
type IClassModifiers interface{
IClassModifiersopt
}

func AnyCastToIClassModifiers(i interface{}) IClassModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ClassModifier0
 *<li>ClassModifier1
 *<li>ClassModifier2
 *<li>ClassModifier3
 *<li>ClassModifier4
 *<li>ClassModifier5
 *<li>ClassModifier6
 *</ul>
 *</b>
 */
type IClassModifier interface{
IClassModifiers
IAstToken
}

func AnyCastToIClassModifier(i interface{}) IClassModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IAnnotation interface{
IClassModifier
IFieldModifier
IInterfaceModifier
IConstantModifier
IAnnotations
IElementValue
}

func AnyCastToIAnnotation(i interface{}) IAnnotation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotation)
	  }
}
/**
 * is implemented by <b>TypeParameters</b>
 */
type ITypeParameters interface{
ITypeParametersopt
}

func AnyCastToITypeParameters(i interface{}) ITypeParameters {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeParameters)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TypeParameter
 *<li>TypeParameterList
 *</ul>
 *</b>
 */
type ITypeParameterList interface{
IRootForJavaParser
}

func AnyCastToITypeParameterList(i interface{}) ITypeParameterList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeParameterList)
	  }
}
/**
 * is implemented by <b>Super</b>
 */
type ISuper interface{
ISuperopt
}

func AnyCastToISuper(i interface{}) ISuper {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISuper)
	  }
}
/**
 * is implemented by <b>Interfaces</b>
 */
type IInterfaces interface{
IInterfacesopt
}

func AnyCastToIInterfaces(i interface{}) IInterfaces {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaces)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>InterfaceType
 *<li>InterfaceTypeList
 *</ul>
 *</b>
 */
type IInterfaceTypeList interface{
IRootForJavaParser
}

func AnyCastToIInterfaceTypeList(i interface{}) IInterfaceTypeList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceTypeList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>ClassBodyDeclarations
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>StaticInitializer
 *<li>ConstructorDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>Block
 *</ul>
 *</b>
 */
type IClassBodyDeclarations interface{
IClassBodyDeclarationsopt
}

func AnyCastToIClassBodyDeclarations(i interface{}) IClassBodyDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBodyDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>StaticInitializer
 *<li>ConstructorDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>Block
 *</ul>
 *</b>
 */
type IClassBodyDeclaration interface{
IClassBodyDeclarations
}

func AnyCastToIClassBodyDeclaration(i interface{}) IClassBodyDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBodyDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IClassMemberDeclaration interface{
IClassBodyDeclaration
IAstToken
}

func AnyCastToIClassMemberDeclaration(i interface{}) IClassMemberDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassMemberDeclaration)
	  }
}
/**
 * is implemented by <b>Block</b>
 */
type IInstanceInitializer interface{
IClassBodyDeclaration
}

func AnyCastToIInstanceInitializer(i interface{}) IInstanceInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInstanceInitializer)
	  }
}
/**
 * is implemented by <b>StaticInitializer</b>
 */
type IStaticInitializer interface{
IClassBodyDeclaration
}

func AnyCastToIStaticInitializer(i interface{}) IStaticInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStaticInitializer)
	  }
}
/**
 * is implemented by <b>ConstructorDeclaration</b>
 */
type IConstructorDeclaration interface{
IClassBodyDeclaration
}

func AnyCastToIConstructorDeclaration(i interface{}) IConstructorDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorDeclaration)
	  }
}
/**
 * is implemented by <b>FieldDeclaration</b>
 */
type IFieldDeclaration interface{
IClassMemberDeclaration
}

func AnyCastToIFieldDeclaration(i interface{}) IFieldDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldDeclaration)
	  }
}
/**
 * is implemented by <b>MethodDeclaration</b>
 */
type IMethodDeclaration interface{
IClassMemberDeclaration
}

func AnyCastToIMethodDeclaration(i interface{}) IMethodDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FieldModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>FieldModifier0
 *<li>FieldModifier1
 *<li>FieldModifier2
 *<li>FieldModifier3
 *<li>FieldModifier4
 *<li>FieldModifier5
 *<li>FieldModifier6
 *</ul>
 *</b>
 */
type IFieldModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIFieldModifiersopt(i interface{}) IFieldModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>VariableDeclarators
 *<li>VariableDeclarator
 *<li>VariableDeclaratorId
 *</ul>
 *</b>
 */
type IVariableDeclarators interface{
IRootForJavaParser
}

func AnyCastToIVariableDeclarators(i interface{}) IVariableDeclarators {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableDeclarators)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>VariableDeclarator
 *<li>VariableDeclaratorId
 *</ul>
 *</b>
 */
type IVariableDeclarator interface{
IVariableDeclarators
}

func AnyCastToIVariableDeclarator(i interface{}) IVariableDeclarator {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableDeclarator)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>VariableDeclaratorId
 *</ul>
 *</b>
 */
type IVariableDeclaratorId interface{
IVariableDeclarator
}

func AnyCastToIVariableDeclaratorId(i interface{}) IVariableDeclaratorId {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableDeclaratorId)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArrayInitializer
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IVariableInitializer interface{
IVariableInitializers
}

func AnyCastToIVariableInitializer(i interface{}) IVariableInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableInitializer)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IExpression interface{
IVariableInitializer
IArgumentList
IConstantExpression
IExpressionopt
}

func AnyCastToIExpression(i interface{}) IExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExpression)
	  }
}
/**
 * is implemented by <b>ArrayInitializer</b>
 */
type IArrayInitializer interface{
IVariableInitializer
}

func AnyCastToIArrayInitializer(i interface{}) IArrayInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArrayInitializer)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FieldModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>FieldModifier0
 *<li>FieldModifier1
 *<li>FieldModifier2
 *<li>FieldModifier3
 *<li>FieldModifier4
 *<li>FieldModifier5
 *<li>FieldModifier6
 *</ul>
 *</b>
 */
type IFieldModifiers interface{
IFieldModifiersopt
}

func AnyCastToIFieldModifiers(i interface{}) IFieldModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>FieldModifier0
 *<li>FieldModifier1
 *<li>FieldModifier2
 *<li>FieldModifier3
 *<li>FieldModifier4
 *<li>FieldModifier5
 *<li>FieldModifier6
 *</ul>
 *</b>
 */
type IFieldModifier interface{
IFieldModifiers
IAstToken
}

func AnyCastToIFieldModifier(i interface{}) IFieldModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldModifier)
	  }
}
/**
 * is implemented by <b>MethodHeader</b>
 */
type IMethodHeader interface{
IRootForJavaParser
}

func AnyCastToIMethodHeader(i interface{}) IMethodHeader {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodHeader)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodBody
 *<li>Block
 *</ul>
 *</b>
 */
type IMethodBody interface{
IAstToken
}

func AnyCastToIMethodBody(i interface{}) IMethodBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>MethodModifier0
 *<li>MethodModifier1
 *<li>MethodModifier2
 *<li>MethodModifier3
 *<li>MethodModifier4
 *<li>MethodModifier5
 *<li>MethodModifier6
 *<li>MethodModifier7
 *<li>MethodModifier8
 *</ul>
 *</b>
 */
type IMethodModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIMethodModifiersopt(i interface{}) IMethodModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PrimitiveType
 *<li>ClassType
 *<li>ArrayType
 *<li>ResultType
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type IResultType interface{
IAstToken
}

func AnyCastToIResultType(i interface{}) IResultType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IResultType)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodDeclarator0
 *<li>MethodDeclarator1
 *</ul>
 *</b>
 */
type IMethodDeclarator interface{
IRootForJavaParser
}

func AnyCastToIMethodDeclarator(i interface{}) IMethodDeclarator {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodDeclarator)
	  }
}
/**
 * is implemented by <b>Throws</b>
 */
type IThrowsopt interface{
IRootForJavaParser
}

func AnyCastToIThrowsopt(i interface{}) IThrowsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IThrowsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FormalParameterList
 *<li>LastFormalParameter
 *</ul>
 *</b>
 */
type IFormalParameterListopt interface{
IRootForJavaParser
}

func AnyCastToIFormalParameterListopt(i interface{}) IFormalParameterListopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFormalParameterListopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FormalParameterList
 *<li>LastFormalParameter
 *</ul>
 *</b>
 */
type IFormalParameterList interface{
IFormalParameterListopt
}

func AnyCastToIFormalParameterList(i interface{}) IFormalParameterList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFormalParameterList)
	  }
}
/**
 * is implemented by <b>LastFormalParameter</b>
 */
type ILastFormalParameter interface{
IFormalParameterList
}

func AnyCastToILastFormalParameter(i interface{}) ILastFormalParameter {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILastFormalParameter)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FormalParameters
 *<li>FormalParameter
 *</ul>
 *</b>
 */
type IFormalParameters interface{
IRootForJavaParser
}

func AnyCastToIFormalParameters(i interface{}) IFormalParameters {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFormalParameters)
	  }
}
/**
 * is implemented by <b>FormalParameter</b>
 */
type IFormalParameter interface{
IFormalParameters
}

func AnyCastToIFormalParameter(i interface{}) IFormalParameter {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFormalParameter)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>VariableModifiers
 *<li>VariableModifier
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IVariableModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIVariableModifiersopt(i interface{}) IVariableModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>VariableModifiers
 *<li>VariableModifier
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IVariableModifiers interface{
IVariableModifiersopt
}

func AnyCastToIVariableModifiers(i interface{}) IVariableModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>VariableModifier
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IVariableModifier interface{
IVariableModifiers
IAstToken
}

func AnyCastToIVariableModifier(i interface{}) IVariableModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IAnnotations interface{
IVariableModifier
IMethodModifier
IConstructorModifier
IAbstractMethodModifier
IAnnotationsopt
}

func AnyCastToIAnnotations(i interface{}) IAnnotations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>MethodModifier0
 *<li>MethodModifier1
 *<li>MethodModifier2
 *<li>MethodModifier3
 *<li>MethodModifier4
 *<li>MethodModifier5
 *<li>MethodModifier6
 *<li>MethodModifier7
 *<li>MethodModifier8
 *</ul>
 *</b>
 */
type IMethodModifiers interface{
IMethodModifiersopt
}

func AnyCastToIMethodModifiers(i interface{}) IMethodModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>MethodModifier0
 *<li>MethodModifier1
 *<li>MethodModifier2
 *<li>MethodModifier3
 *<li>MethodModifier4
 *<li>MethodModifier5
 *<li>MethodModifier6
 *<li>MethodModifier7
 *<li>MethodModifier8
 *</ul>
 *</b>
 */
type IMethodModifier interface{
IMethodModifiers
IAstToken
}

func AnyCastToIMethodModifier(i interface{}) IMethodModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodModifier)
	  }
}
/**
 * is implemented by <b>Throws</b>
 */
type IThrows interface{
IThrowsopt
}

func AnyCastToIThrows(i interface{}) IThrows {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IThrows)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *<li>ExceptionTypeList
 *</ul>
 *</b>
 */
type IExceptionTypeList interface{
IRootForJavaParser
}

func AnyCastToIExceptionTypeList(i interface{}) IExceptionTypeList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExceptionTypeList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *</ul>
 *</b>
 */
type IExceptionType interface{
IExceptionTypeList
}

func AnyCastToIExceptionType(i interface{}) IExceptionType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExceptionType)
	  }
}
/**
 * is implemented by <b>Block</b>
 */
type IBlock interface{
IMethodBody
IInstanceInitializer
IStatementWithoutTrailingSubstatement
}

func AnyCastToIBlock(i interface{}) IBlock {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBlock)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ConstructorModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstructorModifier0
 *<li>ConstructorModifier1
 *<li>ConstructorModifier2
 *</ul>
 *</b>
 */
type IConstructorModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIConstructorModifiersopt(i interface{}) IConstructorModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorModifiersopt)
	  }
}
/**
 * is implemented by <b>ConstructorDeclarator</b>
 */
type IConstructorDeclarator interface{
IRootForJavaParser
}

func AnyCastToIConstructorDeclarator(i interface{}) IConstructorDeclarator {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorDeclarator)
	  }
}
/**
 * is implemented by <b>ConstructorBody</b>
 */
type IConstructorBody interface{
IRootForJavaParser
}

func AnyCastToIConstructorBody(i interface{}) IConstructorBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorBody)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type ISimpleTypeName interface{
IRootForJavaParser
}

func AnyCastToISimpleTypeName(i interface{}) ISimpleTypeName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISimpleTypeName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ConstructorModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstructorModifier0
 *<li>ConstructorModifier1
 *<li>ConstructorModifier2
 *</ul>
 *</b>
 */
type IConstructorModifiers interface{
IConstructorModifiersopt
}

func AnyCastToIConstructorModifiers(i interface{}) IConstructorModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstructorModifier0
 *<li>ConstructorModifier1
 *<li>ConstructorModifier2
 *</ul>
 *</b>
 */
type IConstructorModifier interface{
IConstructorModifiers
IAstToken
}

func AnyCastToIConstructorModifier(i interface{}) IConstructorModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ExplicitConstructorInvocation0
 *<li>ExplicitConstructorInvocation1
 *<li>ExplicitConstructorInvocation2
 *</ul>
 *</b>
 */
type IExplicitConstructorInvocationopt interface{
IRootForJavaParser
}

func AnyCastToIExplicitConstructorInvocationopt(i interface{}) IExplicitConstructorInvocationopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExplicitConstructorInvocationopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ExplicitConstructorInvocation0
 *<li>ExplicitConstructorInvocation1
 *<li>ExplicitConstructorInvocation2
 *</ul>
 *</b>
 */
type IExplicitConstructorInvocation interface{
IExplicitConstructorInvocationopt
}

func AnyCastToIExplicitConstructorInvocation(i interface{}) IExplicitConstructorInvocation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExplicitConstructorInvocation)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArgumentList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IArgumentListopt interface{
IRootForJavaParser
}

func AnyCastToIArgumentListopt(i interface{}) IArgumentListopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArgumentListopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type IPrimary interface{
IPostfixExpression
}

func AnyCastToIPrimary(i interface{}) IPrimary {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPrimary)
	  }
}
/**
 * is implemented by <b>EnumBody</b>
 */
type IEnumBody interface{
IRootForJavaParser
}

func AnyCastToIEnumBody(i interface{}) IEnumBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>EnumConstants
 *<li>EnumConstant
 *</ul>
 *</b>
 */
type IEnumConstantsopt interface{
IRootForJavaParser
}

func AnyCastToIEnumConstantsopt(i interface{}) IEnumConstantsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumConstantsopt)
	  }
}
/**
 * is implemented by <b>EnumBodyDeclarations</b>
 */
type IEnumBodyDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIEnumBodyDeclarationsopt(i interface{}) IEnumBodyDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumBodyDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>EnumConstants
 *<li>EnumConstant
 *</ul>
 *</b>
 */
type IEnumConstants interface{
IEnumConstantsopt
}

func AnyCastToIEnumConstants(i interface{}) IEnumConstants {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumConstants)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>EnumConstant
 *</ul>
 *</b>
 */
type IEnumConstant interface{
IEnumConstants
}

func AnyCastToIEnumConstant(i interface{}) IEnumConstant {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumConstant)
	  }
}
/**
 * is implemented by <b>Arguments</b>
 */
type IArgumentsopt interface{
IRootForJavaParser
}

func AnyCastToIArgumentsopt(i interface{}) IArgumentsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArgumentsopt)
	  }
}
/**
 * is implemented by <b>ClassBody</b>
 */
type IClassBodyopt interface{
IRootForJavaParser
}

func AnyCastToIClassBodyopt(i interface{}) IClassBodyopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBodyopt)
	  }
}
/**
 * is implemented by <b>Arguments</b>
 */
type IArguments interface{
IArgumentsopt
}

func AnyCastToIArguments(i interface{}) IArguments {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArguments)
	  }
}
/**
 * is implemented by <b>EnumBodyDeclarations</b>
 */
type IEnumBodyDeclarations interface{
IEnumBodyDeclarationsopt
}

func AnyCastToIEnumBodyDeclarations(i interface{}) IEnumBodyDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumBodyDeclarations)
	  }
}
/**
 * is implemented by <b>NormalInterfaceDeclaration</b>
 */
type INormalInterfaceDeclaration interface{
IInterfaceDeclaration
}

func AnyCastToINormalInterfaceDeclaration(i interface{}) INormalInterfaceDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(INormalInterfaceDeclaration)
	  }
}
/**
 * is implemented by <b>AnnotationTypeDeclaration</b>
 */
type IAnnotationTypeDeclaration interface{
IInterfaceDeclaration
IAnnotationTypeElementDeclaration
}

func AnyCastToIAnnotationTypeDeclaration(i interface{}) IAnnotationTypeDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>InterfaceModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>InterfaceModifier0
 *<li>InterfaceModifier1
 *<li>InterfaceModifier2
 *<li>InterfaceModifier3
 *<li>InterfaceModifier4
 *<li>InterfaceModifier5
 *</ul>
 *</b>
 */
type IInterfaceModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIInterfaceModifiersopt(i interface{}) IInterfaceModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ExtendsInterfaces0
 *<li>ExtendsInterfaces1
 *</ul>
 *</b>
 */
type IExtendsInterfacesopt interface{
IRootForJavaParser
}

func AnyCastToIExtendsInterfacesopt(i interface{}) IExtendsInterfacesopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExtendsInterfacesopt)
	  }
}
/**
 * is implemented by <b>InterfaceBody</b>
 */
type IInterfaceBody interface{
IRootForJavaParser
}

func AnyCastToIInterfaceBody(i interface{}) IInterfaceBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>InterfaceModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>InterfaceModifier0
 *<li>InterfaceModifier1
 *<li>InterfaceModifier2
 *<li>InterfaceModifier3
 *<li>InterfaceModifier4
 *<li>InterfaceModifier5
 *</ul>
 *</b>
 */
type IInterfaceModifiers interface{
IInterfaceModifiersopt
}

func AnyCastToIInterfaceModifiers(i interface{}) IInterfaceModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>InterfaceModifier0
 *<li>InterfaceModifier1
 *<li>InterfaceModifier2
 *<li>InterfaceModifier3
 *<li>InterfaceModifier4
 *<li>InterfaceModifier5
 *</ul>
 *</b>
 */
type IInterfaceModifier interface{
IInterfaceModifiers
IAstToken
}

func AnyCastToIInterfaceModifier(i interface{}) IInterfaceModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ExtendsInterfaces0
 *<li>ExtendsInterfaces1
 *</ul>
 *</b>
 */
type IExtendsInterfaces interface{
IExtendsInterfacesopt
}

func AnyCastToIExtendsInterfaces(i interface{}) IExtendsInterfaces {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExtendsInterfaces)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>InterfaceMemberDeclarations
 *<li>InterfaceMemberDeclaration
 *<li>ConstantDeclaration
 *<li>AbstractMethodDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IInterfaceMemberDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIInterfaceMemberDeclarationsopt(i interface{}) IInterfaceMemberDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceMemberDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>InterfaceMemberDeclarations
 *<li>InterfaceMemberDeclaration
 *<li>ConstantDeclaration
 *<li>AbstractMethodDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IInterfaceMemberDeclarations interface{
IInterfaceMemberDeclarationsopt
}

func AnyCastToIInterfaceMemberDeclarations(i interface{}) IInterfaceMemberDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceMemberDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>InterfaceMemberDeclaration
 *<li>ConstantDeclaration
 *<li>AbstractMethodDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IInterfaceMemberDeclaration interface{
IInterfaceMemberDeclarations
IAstToken
}

func AnyCastToIInterfaceMemberDeclaration(i interface{}) IInterfaceMemberDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceMemberDeclaration)
	  }
}
/**
 * is implemented by <b>ConstantDeclaration</b>
 */
type IConstantDeclaration interface{
IInterfaceMemberDeclaration
IAnnotationTypeElementDeclaration
}

func AnyCastToIConstantDeclaration(i interface{}) IConstantDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantDeclaration)
	  }
}
/**
 * is implemented by <b>AbstractMethodDeclaration</b>
 */
type IAbstractMethodDeclaration interface{
IInterfaceMemberDeclaration
}

func AnyCastToIAbstractMethodDeclaration(i interface{}) IAbstractMethodDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAbstractMethodDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ConstantModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstantModifier0
 *<li>ConstantModifier1
 *<li>ConstantModifier2
 *</ul>
 *</b>
 */
type IConstantModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIConstantModifiersopt(i interface{}) IConstantModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ConstantModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstantModifier0
 *<li>ConstantModifier1
 *<li>ConstantModifier2
 *</ul>
 *</b>
 */
type IConstantModifiers interface{
IConstantModifiersopt
}

func AnyCastToIConstantModifiers(i interface{}) IConstantModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstantModifier0
 *<li>ConstantModifier1
 *<li>ConstantModifier2
 *</ul>
 *</b>
 */
type IConstantModifier interface{
IConstantModifiers
IAstToken
}

func AnyCastToIConstantModifier(i interface{}) IConstantModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AbstractMethodModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>AbstractMethodModifier0
 *<li>AbstractMethodModifier1
 *</ul>
 *</b>
 */
type IAbstractMethodModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIAbstractMethodModifiersopt(i interface{}) IAbstractMethodModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAbstractMethodModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AbstractMethodModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>AbstractMethodModifier0
 *<li>AbstractMethodModifier1
 *</ul>
 *</b>
 */
type IAbstractMethodModifiers interface{
IAbstractMethodModifiersopt
}

func AnyCastToIAbstractMethodModifiers(i interface{}) IAbstractMethodModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAbstractMethodModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>AbstractMethodModifier0
 *<li>AbstractMethodModifier1
 *</ul>
 *</b>
 */
type IAbstractMethodModifier interface{
IAbstractMethodModifiers
IAstToken
}

func AnyCastToIAbstractMethodModifier(i interface{}) IAbstractMethodModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAbstractMethodModifier)
	  }
}
/**
 * is implemented by <b>AnnotationTypeBody</b>
 */
type IAnnotationTypeBody interface{
IRootForJavaParser
}

func AnyCastToIAnnotationTypeBody(i interface{}) IAnnotationTypeBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>ConstantDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>AnnotationTypeElementDeclarations
 *<li>AnnotationTypeElementDeclaration0
 *<li>AnnotationTypeElementDeclaration1
 *</ul>
 *</b>
 */
type IAnnotationTypeElementDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIAnnotationTypeElementDeclarationsopt(i interface{}) IAnnotationTypeElementDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeElementDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>ConstantDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>AnnotationTypeElementDeclarations
 *<li>AnnotationTypeElementDeclaration0
 *<li>AnnotationTypeElementDeclaration1
 *</ul>
 *</b>
 */
type IAnnotationTypeElementDeclarations interface{
IAnnotationTypeElementDeclarationsopt
}

func AnyCastToIAnnotationTypeElementDeclarations(i interface{}) IAnnotationTypeElementDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeElementDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>ConstantDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>AnnotationTypeElementDeclaration0
 *<li>AnnotationTypeElementDeclaration1
 *</ul>
 *</b>
 */
type IAnnotationTypeElementDeclaration interface{
IAnnotationTypeElementDeclarations
IAstToken
}

func AnyCastToIAnnotationTypeElementDeclaration(i interface{}) IAnnotationTypeElementDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeElementDeclaration)
	  }
}
/**
 * is implemented by <b>DefaultValue</b>
 */
type IDefaultValueopt interface{
IRootForJavaParser
}

func AnyCastToIDefaultValueopt(i interface{}) IDefaultValueopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDefaultValueopt)
	  }
}
/**
 * is implemented by <b>DefaultValue</b>
 */
type IDefaultValue interface{
IDefaultValueopt
}

func AnyCastToIDefaultValue(i interface{}) IDefaultValue {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDefaultValue)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>NormalAnnotation
 *<li>ElementValueArrayInitializer
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IElementValue interface{
IElementValues
}

func AnyCastToIElementValue(i interface{}) IElementValue {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValue)
	  }
}
/**
 * is implemented by <b>NormalAnnotation</b>
 */
type INormalAnnotation interface{
IAnnotation
}

func AnyCastToINormalAnnotation(i interface{}) INormalAnnotation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(INormalAnnotation)
	  }
}
/**
 * is implemented by <b>MarkerAnnotation</b>
 */
type IMarkerAnnotation interface{
IAnnotation
}

func AnyCastToIMarkerAnnotation(i interface{}) IMarkerAnnotation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMarkerAnnotation)
	  }
}
/**
 * is implemented by <b>SingleElementAnnotation</b>
 */
type ISingleElementAnnotation interface{
IAnnotation
}

func AnyCastToISingleElementAnnotation(i interface{}) ISingleElementAnnotation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISingleElementAnnotation)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ElementValuePairs
 *<li>ElementValuePair
 *</ul>
 *</b>
 */
type IElementValuePairsopt interface{
IRootForJavaParser
}

func AnyCastToIElementValuePairsopt(i interface{}) IElementValuePairsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValuePairsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ElementValuePairs
 *<li>ElementValuePair
 *</ul>
 *</b>
 */
type IElementValuePairs interface{
IElementValuePairsopt
}

func AnyCastToIElementValuePairs(i interface{}) IElementValuePairs {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValuePairs)
	  }
}
/**
 * is implemented by <b>ElementValuePair</b>
 */
type IElementValuePair interface{
IElementValuePairs
}

func AnyCastToIElementValuePair(i interface{}) IElementValuePair {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValuePair)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type ISimpleName interface{
IRootForJavaParser
}

func AnyCastToISimpleName(i interface{}) ISimpleName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISimpleName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IConditionalExpression interface{
IElementValue
IAssignmentExpression
}

func AnyCastToIConditionalExpression(i interface{}) IConditionalExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConditionalExpression)
	  }
}
/**
 * is implemented by <b>ElementValueArrayInitializer</b>
 */
type IElementValueArrayInitializer interface{
IElementValue
}

func AnyCastToIElementValueArrayInitializer(i interface{}) IElementValueArrayInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValueArrayInitializer)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>NormalAnnotation
 *<li>ElementValueArrayInitializer
 *<li>ElementValues
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IElementValuesopt interface{
IRootForJavaParser
}

func AnyCastToIElementValuesopt(i interface{}) IElementValuesopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValuesopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>NormalAnnotation
 *<li>ElementValueArrayInitializer
 *<li>ElementValues
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IElementValues interface{
IElementValuesopt
}

func AnyCastToIElementValues(i interface{}) IElementValues {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValues)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArrayInitializer
 *<li>VariableInitializers
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IVariableInitializersopt interface{
IRootForJavaParser
}

func AnyCastToIVariableInitializersopt(i interface{}) IVariableInitializersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableInitializersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArrayInitializer
 *<li>VariableInitializers
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IVariableInitializers interface{
IVariableInitializersopt
}

func AnyCastToIVariableInitializers(i interface{}) IVariableInitializers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableInitializers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>Block
 *<li>BlockStatements
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IBlockStatements interface{
IBlockStatementsopt
}

func AnyCastToIBlockStatements(i interface{}) IBlockStatements {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBlockStatements)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>Block
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IBlockStatement interface{
IBlockStatements
}

func AnyCastToIBlockStatement(i interface{}) IBlockStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBlockStatement)
	  }
}
/**
 * is implemented by <b>LocalVariableDeclarationStatement</b>
 */
type ILocalVariableDeclarationStatement interface{
IBlockStatement
}

func AnyCastToILocalVariableDeclarationStatement(i interface{}) ILocalVariableDeclarationStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILocalVariableDeclarationStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Block
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IStatement interface{
IBlockStatement
}

func AnyCastToIStatement(i interface{}) IStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatement)
	  }
}
/**
 * is implemented by <b>LocalVariableDeclaration</b>
 */
type ILocalVariableDeclaration interface{
IForInit
}

func AnyCastToILocalVariableDeclaration(i interface{}) ILocalVariableDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILocalVariableDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Block
 *<li>EmptyStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>DoStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IStatementWithoutTrailingSubstatement interface{
IStatement
IStatementNoShortIf
}

func AnyCastToIStatementWithoutTrailingSubstatement(i interface{}) IStatementWithoutTrailingSubstatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatementWithoutTrailingSubstatement)
	  }
}
/**
 * is implemented by <b>LabeledStatement</b>
 */
type ILabeledStatement interface{
IStatement
}

func AnyCastToILabeledStatement(i interface{}) ILabeledStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILabeledStatement)
	  }
}
/**
 * is implemented by <b>IfThenStatement</b>
 */
type IIfThenStatement interface{
IStatement
}

func AnyCastToIIfThenStatement(i interface{}) IIfThenStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IIfThenStatement)
	  }
}
/**
 * is implemented by <b>IfThenElseStatement</b>
 */
type IIfThenElseStatement interface{
IStatement
}

func AnyCastToIIfThenElseStatement(i interface{}) IIfThenElseStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IIfThenElseStatement)
	  }
}
/**
 * is implemented by <b>WhileStatement</b>
 */
type IWhileStatement interface{
IStatement
}

func AnyCastToIWhileStatement(i interface{}) IWhileStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWhileStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *</ul>
 *</b>
 */
type IForStatement interface{
IStatement
}

func AnyCastToIForStatement(i interface{}) IForStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForStatement)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>EmptyStatement</b>
 */
type IEmptyStatement interface{
IStatementWithoutTrailingSubstatement
IAstToken
}

func AnyCastToIEmptyStatement(i interface{}) IEmptyStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEmptyStatement)
	  }
}
/**
 * is implemented by <b>ExpressionStatement</b>
 */
type IExpressionStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIExpressionStatement(i interface{}) IExpressionStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExpressionStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AssertStatement0
 *<li>AssertStatement1
 *</ul>
 *</b>
 */
type IAssertStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIAssertStatement(i interface{}) IAssertStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAssertStatement)
	  }
}
/**
 * is implemented by <b>SwitchStatement</b>
 */
type ISwitchStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToISwitchStatement(i interface{}) ISwitchStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchStatement)
	  }
}
/**
 * is implemented by <b>DoStatement</b>
 */
type IDoStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIDoStatement(i interface{}) IDoStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDoStatement)
	  }
}
/**
 * is implemented by <b>BreakStatement</b>
 */
type IBreakStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIBreakStatement(i interface{}) IBreakStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBreakStatement)
	  }
}
/**
 * is implemented by <b>ContinueStatement</b>
 */
type IContinueStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIContinueStatement(i interface{}) IContinueStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IContinueStatement)
	  }
}
/**
 * is implemented by <b>ReturnStatement</b>
 */
type IReturnStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIReturnStatement(i interface{}) IReturnStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IReturnStatement)
	  }
}
/**
 * is implemented by <b>SynchronizedStatement</b>
 */
type ISynchronizedStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToISynchronizedStatement(i interface{}) ISynchronizedStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISynchronizedStatement)
	  }
}
/**
 * is implemented by <b>ThrowStatement</b>
 */
type IThrowStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIThrowStatement(i interface{}) IThrowStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IThrowStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type ITryStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToITryStatement(i interface{}) ITryStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITryStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Block
 *<li>IfThenElseStatementNoShortIf
 *<li>EmptyStatement
 *<li>LabeledStatementNoShortIf
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatementNoShortIf
 *<li>DoStatement
 *<li>ForStatementNoShortIf
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IStatementNoShortIf interface{
IRootForJavaParser
}

func AnyCastToIStatementNoShortIf(i interface{}) IStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatementNoShortIf)
	  }
}
/**
 * is implemented by <b>LabeledStatementNoShortIf</b>
 */
type ILabeledStatementNoShortIf interface{
IStatementNoShortIf
}

func AnyCastToILabeledStatementNoShortIf(i interface{}) ILabeledStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILabeledStatementNoShortIf)
	  }
}
/**
 * is implemented by <b>IfThenElseStatementNoShortIf</b>
 */
type IIfThenElseStatementNoShortIf interface{
IStatementNoShortIf
}

func AnyCastToIIfThenElseStatementNoShortIf(i interface{}) IIfThenElseStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IIfThenElseStatementNoShortIf)
	  }
}
/**
 * is implemented by <b>WhileStatementNoShortIf</b>
 */
type IWhileStatementNoShortIf interface{
IStatementNoShortIf
}

func AnyCastToIWhileStatementNoShortIf(i interface{}) IWhileStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWhileStatementNoShortIf)
	  }
}
/**
 * is implemented by <b>ForStatementNoShortIf</b>
 */
type IForStatementNoShortIf interface{
IStatementNoShortIf
}

func AnyCastToIForStatementNoShortIf(i interface{}) IForStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForStatementNoShortIf)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IStatementExpression interface{
IStatementExpressionList
}

func AnyCastToIStatementExpression(i interface{}) IStatementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatementExpression)
	  }
}
/**
 * is implemented by <b>Assignment</b>
 */
type IAssignment interface{
IStatementExpression
IAssignmentExpression
}

func AnyCastToIAssignment(i interface{}) IAssignment {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAssignment)
	  }
}
/**
 * is implemented by <b>PreIncrementExpression</b>
 */
type IPreIncrementExpression interface{
IStatementExpression
IUnaryExpression
}

func AnyCastToIPreIncrementExpression(i interface{}) IPreIncrementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPreIncrementExpression)
	  }
}
/**
 * is implemented by <b>PreDecrementExpression</b>
 */
type IPreDecrementExpression interface{
IStatementExpression
IUnaryExpression
}

func AnyCastToIPreDecrementExpression(i interface{}) IPreDecrementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPreDecrementExpression)
	  }
}
/**
 * is implemented by <b>PostIncrementExpression</b>
 */
type IPostIncrementExpression interface{
IStatementExpression
IPostfixExpression
}

func AnyCastToIPostIncrementExpression(i interface{}) IPostIncrementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPostIncrementExpression)
	  }
}
/**
 * is implemented by <b>PostDecrementExpression</b>
 */
type IPostDecrementExpression interface{
IStatementExpression
IPostfixExpression
}

func AnyCastToIPostDecrementExpression(i interface{}) IPostDecrementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPostDecrementExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IMethodInvocation interface{
IStatementExpression
IPrimaryNoNewArray
}

func AnyCastToIMethodInvocation(i interface{}) IMethodInvocation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodInvocation)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *</ul>
 *</b>
 */
type IClassInstanceCreationExpression interface{
IStatementExpression
IPrimaryNoNewArray
}

func AnyCastToIClassInstanceCreationExpression(i interface{}) IClassInstanceCreationExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassInstanceCreationExpression)
	  }
}
/**
 * is implemented by <b>SwitchBlock</b>
 */
type ISwitchBlock interface{
IRootForJavaParser
}

func AnyCastToISwitchBlock(i interface{}) ISwitchBlock {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchBlock)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchBlockStatementGroups
 *<li>SwitchBlockStatementGroup
 *</ul>
 *</b>
 */
type ISwitchBlockStatementGroupsopt interface{
IRootForJavaParser
}

func AnyCastToISwitchBlockStatementGroupsopt(i interface{}) ISwitchBlockStatementGroupsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchBlockStatementGroupsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchLabels
 *<li>SwitchLabel0
 *<li>SwitchLabel1
 *<li>SwitchLabel2
 *</ul>
 *</b>
 */
type ISwitchLabelsopt interface{
IRootForJavaParser
}

func AnyCastToISwitchLabelsopt(i interface{}) ISwitchLabelsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchLabelsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchBlockStatementGroups
 *<li>SwitchBlockStatementGroup
 *</ul>
 *</b>
 */
type ISwitchBlockStatementGroups interface{
ISwitchBlockStatementGroupsopt
}

func AnyCastToISwitchBlockStatementGroups(i interface{}) ISwitchBlockStatementGroups {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchBlockStatementGroups)
	  }
}
/**
 * is implemented by <b>SwitchBlockStatementGroup</b>
 */
type ISwitchBlockStatementGroup interface{
ISwitchBlockStatementGroups
}

func AnyCastToISwitchBlockStatementGroup(i interface{}) ISwitchBlockStatementGroup {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchBlockStatementGroup)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchLabels
 *<li>SwitchLabel0
 *<li>SwitchLabel1
 *<li>SwitchLabel2
 *</ul>
 *</b>
 */
type ISwitchLabels interface{
ISwitchLabelsopt
}

func AnyCastToISwitchLabels(i interface{}) ISwitchLabels {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchLabels)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchLabel0
 *<li>SwitchLabel1
 *<li>SwitchLabel2
 *</ul>
 *</b>
 */
type ISwitchLabel interface{
ISwitchLabels
}

func AnyCastToISwitchLabel(i interface{}) ISwitchLabel {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchLabel)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IConstantExpression interface{
IRootForJavaParser
}

func AnyCastToIConstantExpression(i interface{}) IConstantExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantExpression)
	  }
}
/**
 * is implemented by <b>BasicForStatement</b>
 */
type IBasicForStatement interface{
IForStatement
}

func AnyCastToIBasicForStatement(i interface{}) IBasicForStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBasicForStatement)
	  }
}
/**
 * is implemented by <b>EnhancedForStatement</b>
 */
type IEnhancedForStatement interface{
IForStatement
}

func AnyCastToIEnhancedForStatement(i interface{}) IEnhancedForStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnhancedForStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>LocalVariableDeclaration
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IForInitopt interface{
IRootForJavaParser
}

func AnyCastToIForInitopt(i interface{}) IForInitopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForInitopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IExpressionopt interface{
IRootForJavaParser
}

func AnyCastToIExpressionopt(i interface{}) IExpressionopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExpressionopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IForUpdateopt interface{
IRootForJavaParser
}

func AnyCastToIForUpdateopt(i interface{}) IForUpdateopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForUpdateopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>LocalVariableDeclaration
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IForInit interface{
IForInitopt
}

func AnyCastToIForInit(i interface{}) IForInit {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForInit)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IStatementExpressionList interface{
IForInit
IForUpdate
}

func AnyCastToIStatementExpressionList(i interface{}) IStatementExpressionList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatementExpressionList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IForUpdate interface{
IForUpdateopt
}

func AnyCastToIForUpdate(i interface{}) IForUpdate {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForUpdate)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type Iidentifieropt interface{
IRootForJavaParser
}

func AnyCastToIidentifieropt(i interface{}) Iidentifieropt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(Iidentifieropt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Catches
 *<li>CatchClause
 *</ul>
 *</b>
 */
type ICatches interface{
ICatchesopt
}

func AnyCastToICatches(i interface{}) ICatches {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICatches)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Catches
 *<li>CatchClause
 *</ul>
 *</b>
 */
type ICatchesopt interface{
IRootForJavaParser
}

func AnyCastToICatchesopt(i interface{}) ICatchesopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICatchesopt)
	  }
}
/**
 * is implemented by <b>Finally</b>
 */
type IFinally interface{
IRootForJavaParser
}

func AnyCastToIFinally(i interface{}) IFinally {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFinally)
	  }
}
/**
 * is implemented by <b>CatchClause</b>
 */
type ICatchClause interface{
ICatches
}

func AnyCastToICatchClause(i interface{}) ICatchClause {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICatchClause)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type IPrimaryNoNewArray interface{
IPrimary
IAstToken
}

func AnyCastToIPrimaryNoNewArray(i interface{}) IPrimaryNoNewArray {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPrimaryNoNewArray)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *</ul>
 *</b>
 */
type IArrayCreationExpression interface{
IPrimary
}

func AnyCastToIArrayCreationExpression(i interface{}) IArrayCreationExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArrayCreationExpression)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *</ul>
 *</b>
 */
type ILiteral interface{
IPrimaryNoNewArray
IAstToken
}

func AnyCastToILiteral(i interface{}) ILiteral {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILiteral)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *</ul>
 *</b>
 */
type IFieldAccess interface{
IPrimaryNoNewArray
ILeftHandSide
}

func AnyCastToIFieldAccess(i interface{}) IFieldAccess {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldAccess)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type IArrayAccess interface{
IPrimaryNoNewArray
ILeftHandSide
}

func AnyCastToIArrayAccess(i interface{}) IArrayAccess {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArrayAccess)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *</ul>
 *</b>
 */
type IBooleanLiteral interface{
ILiteral
IAstToken
}

func AnyCastToIBooleanLiteral(i interface{}) IBooleanLiteral {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBooleanLiteral)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArgumentList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IArgumentList interface{
IArgumentListopt
}

func AnyCastToIArgumentList(i interface{}) IArgumentList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArgumentList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>DimExprs
 *<li>DimExpr
 *</ul>
 *</b>
 */
type IDimExprs interface{
IRootForJavaParser
}

func AnyCastToIDimExprs(i interface{}) IDimExprs {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDimExprs)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Dims0
 *<li>Dims1
 *</ul>
 *</b>
 */
type IDimsopt interface{
IRootForJavaParser
}

func AnyCastToIDimsopt(i interface{}) IDimsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDimsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Dims0
 *<li>Dims1
 *</ul>
 *</b>
 */
type IDims interface{
IDimsopt
}

func AnyCastToIDims(i interface{}) IDims {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDims)
	  }
}
/**
 * is implemented by <b>DimExpr</b>
 */
type IDimExpr interface{
IDimExprs
}

func AnyCastToIDimExpr(i interface{}) IDimExpr {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDimExpr)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type IPostfixExpression interface{
IUnaryExpressionNotPlusMinus
}

func AnyCastToIPostfixExpression(i interface{}) IPostfixExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPostfixExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *</ul>
 *</b>
 */
type IUnaryExpression interface{
IMultiplicativeExpression
}

func AnyCastToIUnaryExpression(i interface{}) IUnaryExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IUnaryExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *</ul>
 *</b>
 */
type IUnaryExpressionNotPlusMinus interface{
IUnaryExpression
}

func AnyCastToIUnaryExpressionNotPlusMinus(i interface{}) IUnaryExpressionNotPlusMinus {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IUnaryExpressionNotPlusMinus)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>CastExpression0
 *<li>CastExpression1
 *</ul>
 *</b>
 */
type ICastExpression interface{
IUnaryExpressionNotPlusMinus
}

func AnyCastToICastExpression(i interface{}) ICastExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICastExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *</ul>
 *</b>
 */
type IMultiplicativeExpression interface{
IAdditiveExpression
}

func AnyCastToIMultiplicativeExpression(i interface{}) IMultiplicativeExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMultiplicativeExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *</ul>
 *</b>
 */
type IAdditiveExpression interface{
IShiftExpression
}

func AnyCastToIAdditiveExpression(i interface{}) IAdditiveExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAdditiveExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *</ul>
 *</b>
 */
type IShiftExpression interface{
IRelationalExpression
}

func AnyCastToIShiftExpression(i interface{}) IShiftExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IShiftExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *</ul>
 *</b>
 */
type IRelationalExpression interface{
IEqualityExpression
}

func AnyCastToIRelationalExpression(i interface{}) IRelationalExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IRelationalExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IEqualityExpression interface{
IAndExpression
}

func AnyCastToIEqualityExpression(i interface{}) IEqualityExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEqualityExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IAndExpression interface{
IExclusiveOrExpression
}

func AnyCastToIAndExpression(i interface{}) IAndExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAndExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IExclusiveOrExpression interface{
IInclusiveOrExpression
}

func AnyCastToIExclusiveOrExpression(i interface{}) IExclusiveOrExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExclusiveOrExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IInclusiveOrExpression interface{
IConditionalAndExpression
}

func AnyCastToIInclusiveOrExpression(i interface{}) IInclusiveOrExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInclusiveOrExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IConditionalAndExpression interface{
IConditionalOrExpression
}

func AnyCastToIConditionalAndExpression(i interface{}) IConditionalAndExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConditionalAndExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IConditionalOrExpression interface{
IConditionalExpression
}

func AnyCastToIConditionalOrExpression(i interface{}) IConditionalOrExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConditionalOrExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IAssignmentExpression interface{
IExpression
}

func AnyCastToIAssignmentExpression(i interface{}) IAssignmentExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAssignmentExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type ILeftHandSide interface{
IRootForJavaParser
}

func AnyCastToILeftHandSide(i interface{}) ILeftHandSide {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILeftHandSide)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AssignmentOperator0
 *<li>AssignmentOperator1
 *<li>AssignmentOperator2
 *<li>AssignmentOperator3
 *<li>AssignmentOperator4
 *<li>AssignmentOperator5
 *<li>AssignmentOperator6
 *<li>AssignmentOperator7
 *<li>AssignmentOperator8
 *<li>AssignmentOperator9
 *<li>AssignmentOperator10
 *<li>AssignmentOperator11
 *</ul>
 *</b>
 */
type IAssignmentOperator interface{
IAstToken
}

func AnyCastToIAssignmentOperator(i interface{}) IAssignmentOperator {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAssignmentOperator)
	  }
}
/**
 *<b>
*<li>Rule 3:  identifier ::= IDENTIFIER
 *</b>
 */
type identifier struct{
    *AstToken
     environment *JavaParser
}
func (my *identifier)     GetEnvironment() *JavaParser{ return my.environment }

func (my *identifier)      GetIDENTIFIER()IToken{ return my.leftIToken; }

func Newidentifier(environment *JavaParser,token IToken )*identifier{
      my := new(identifier)
      my.environment = environment;
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *identifier)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *identifier)       Enter(v Visitor){
        v.Visitidentifier(my)
        v.EndVisitidentifier(my)
    }


func AnyCastToidentifier(i interface{}) *identifier {
	if nil == i{
		return nil
	}else{
		return i.(*identifier)
	}
}
/**
 *<em>
*<li>Rule 12:  PrimitiveType ::= NumericType
 *</em>
 *<p>
 *<b>
*<li>Rule 13:  PrimitiveType ::= boolean
 *</b>
 */
type PrimitiveType struct{
    *AstToken
}
func (my *PrimitiveType)      Getboolean()IToken{ return my.leftIToken; }

func NewPrimitiveType(token IToken )*PrimitiveType{
      my := new(PrimitiveType)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *PrimitiveType)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PrimitiveType)       Enter(v Visitor){
        v.VisitPrimitiveType(my)
        v.EndVisitPrimitiveType(my)
    }


func AnyCastToPrimitiveType(i interface{}) *PrimitiveType {
	if nil == i{
		return nil
	}else{
		return i.(*PrimitiveType)
	}
}
/**
 *<b>
*<li>Rule 27:  ClassType ::= TypeName TypeArgumentsopt
 *</b>
 */
type ClassType struct{
    *Ast
      _TypeName ITypeName
      _TypeArgumentsopt *TypeArguments
}
func (my *ClassType)      GetTypeName() ITypeName{ return my._TypeName}
func (my *ClassType)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ClassType)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ClassType)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }

func NewClassType(leftIToken IToken, rightIToken IToken ,
              _TypeName ITypeName,
              _TypeArgumentsopt *TypeArguments)*ClassType{
      my := new(ClassType)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassType)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        return list
    }

func (my *ClassType)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassType)       Enter(v Visitor){
        var checkChildren = v.VisitClassType(my)
        if checkChildren{
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
        }
        v.EndVisitClassType(my)
    }


func AnyCastToClassType(i interface{}) *ClassType {
	if nil == i{
		return nil
	}else{
		return i.(*ClassType)
	}
}
/**
 *<b>
*<li>Rule 28:  InterfaceType ::= TypeName TypeArgumentsopt
 *</b>
 */
type InterfaceType struct{
    *Ast
      _TypeName ITypeName
      _TypeArgumentsopt *TypeArguments
}
func (my *InterfaceType)      GetTypeName() ITypeName{ return my._TypeName}
func (my *InterfaceType)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *InterfaceType)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *InterfaceType)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }

func NewInterfaceType(leftIToken IToken, rightIToken IToken ,
              _TypeName ITypeName,
              _TypeArgumentsopt *TypeArguments)*InterfaceType{
      my := new(InterfaceType)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceType)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        return list
    }

func (my *InterfaceType)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceType)       Enter(v Visitor){
        var checkChildren = v.VisitInterfaceType(my)
        if checkChildren{
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
        }
        v.EndVisitInterfaceType(my)
    }


func AnyCastToInterfaceType(i interface{}) *InterfaceType {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceType)
	}
}
/**
 *<em>
*<li>Rule 29:  TypeName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 30:  TypeName ::= TypeName . identifier
 *</b>
 */
type TypeName struct{
    *Ast
      _TypeName ITypeName
      _DOT *AstToken
      _identifier *identifier
}
func (my *TypeName)      GetTypeName() ITypeName{ return my._TypeName}
func (my *TypeName)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *TypeName)      GetDOT() *AstToken{ return my._DOT}
func (my *TypeName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *TypeName)      Getidentifier() *identifier{ return my._identifier}
func (my *TypeName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewTypeName(leftIToken IToken, rightIToken IToken ,
              _TypeName ITypeName,
              _DOT *AstToken,
              _identifier *identifier)*TypeName{
      my := new(TypeName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *TypeName)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeName)       Enter(v Visitor){
        var checkChildren = v.VisitTypeName(my)
        if checkChildren{
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitTypeName(my)
    }


func AnyCastToTypeName(i interface{}) *TypeName {
	if nil == i{
		return nil
	}else{
		return i.(*TypeName)
	}
}
/**
 *<b>
*<li>Rule 33:  ArrayType ::= Type [ ]
 *</b>
 */
type ArrayType struct{
    *Ast
      _Type IType
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *ArrayType)      GetType() IType{ return my._Type}
func (my *ArrayType)      SetType( _Type IType)  { my._Type = _Type }
func (my *ArrayType)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *ArrayType)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *ArrayType)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *ArrayType)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewArrayType(leftIToken IToken, rightIToken IToken ,
              _Type IType,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*ArrayType{
      my := new(ArrayType)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayType)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *ArrayType)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArrayType)       Enter(v Visitor){
        var checkChildren = v.VisitArrayType(my)
        if checkChildren{
            if nil != my._Type{my._Type.Accept(v)}
            if nil != my._LBRACKET{my._LBRACKET.Accept(v)}
            if nil != my._RBRACKET{my._RBRACKET.Accept(v)}
        }
        v.EndVisitArrayType(my)
    }


func AnyCastToArrayType(i interface{}) *ArrayType {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayType)
	}
}
/**
 *<b>
*<li>Rule 34:  TypeParameter ::= TypeVariable TypeBoundopt
 *</b>
 */
type TypeParameter struct{
    *Ast
      _TypeVariable *identifier
      _TypeBoundopt *TypeBound
}
func (my *TypeParameter)      GetTypeVariable() *identifier{ return my._TypeVariable}
func (my *TypeParameter)      SetTypeVariable( _TypeVariable *identifier)  { my._TypeVariable = _TypeVariable }
    /**
     * The value returned by <b>GetTypeBoundopt</b> may be <b>null</b>
     */
func (my *TypeParameter)      GetTypeBoundopt() *TypeBound{ return my._TypeBoundopt}
func (my *TypeParameter)      SetTypeBoundopt( _TypeBoundopt *TypeBound)  { my._TypeBoundopt = _TypeBoundopt }

func NewTypeParameter(leftIToken IToken, rightIToken IToken ,
              _TypeVariable *identifier,
              _TypeBoundopt *TypeBound)*TypeParameter{
      my := new(TypeParameter)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeVariable = _TypeVariable;
        if nil != _TypeVariable{
        var trait_ interface{} = _TypeVariable
         trait_.(IAst).SetParent(my)
}
        my._TypeBoundopt = _TypeBoundopt;
        if nil != _TypeBoundopt{
        var trait_ interface{} = _TypeBoundopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeParameter)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeVariable{  list.Add(my._TypeVariable) }
        if nil != my._TypeBoundopt{  list.Add(my._TypeBoundopt) }
        return list
    }

func (my *TypeParameter)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeParameter)       Enter(v Visitor){
        var checkChildren = v.VisitTypeParameter(my)
        if checkChildren{
            if nil != my._TypeVariable{my._TypeVariable.Accept(v)}
            if nil != my._TypeBoundopt{my._TypeBoundopt.Accept(v)}
        }
        v.EndVisitTypeParameter(my)
    }


func AnyCastToTypeParameter(i interface{}) *TypeParameter {
	if nil == i{
		return nil
	}else{
		return i.(*TypeParameter)
	}
}
/**
 *<b>
*<li>Rule 35:  TypeBound ::= extends ClassOrInterfaceType AdditionalBoundListopt
 *</b>
 */
type TypeBound struct{
    *Ast
      _extends *AstToken
      _ClassOrInterfaceType *ClassType
      _AdditionalBoundListopt IAdditionalBoundListopt
}
func (my *TypeBound)      Getextends() *AstToken{ return my._extends}
func (my *TypeBound)      Setextends( _extends *AstToken)  { my._extends = _extends }
func (my *TypeBound)      GetClassOrInterfaceType() *ClassType{ return my._ClassOrInterfaceType}
func (my *TypeBound)      SetClassOrInterfaceType( _ClassOrInterfaceType *ClassType)  { my._ClassOrInterfaceType = _ClassOrInterfaceType }
    /**
     * The value returned by <b>GetAdditionalBoundListopt</b> may be <b>null</b>
     */
func (my *TypeBound)      GetAdditionalBoundListopt() IAdditionalBoundListopt{ return my._AdditionalBoundListopt}
func (my *TypeBound)      SetAdditionalBoundListopt( _AdditionalBoundListopt IAdditionalBoundListopt)  { my._AdditionalBoundListopt = _AdditionalBoundListopt }

func NewTypeBound(leftIToken IToken, rightIToken IToken ,
              _extends *AstToken,
              _ClassOrInterfaceType *ClassType,
              _AdditionalBoundListopt IAdditionalBoundListopt)*TypeBound{
      my := new(TypeBound)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._extends = _extends;
        if nil != _extends{
        var trait_ interface{} = _extends
         trait_.(IAst).SetParent(my)
}
        my._ClassOrInterfaceType = _ClassOrInterfaceType;
        if nil != _ClassOrInterfaceType{
        var trait_ interface{} = _ClassOrInterfaceType
         trait_.(IAst).SetParent(my)
}
        my._AdditionalBoundListopt = _AdditionalBoundListopt;
        if nil != _AdditionalBoundListopt{
        var trait_ interface{} = _AdditionalBoundListopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeBound)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._extends{  list.Add(my._extends) }
        if nil != my._ClassOrInterfaceType{  list.Add(my._ClassOrInterfaceType) }
        if nil != my._AdditionalBoundListopt{  list.Add(my._AdditionalBoundListopt) }
        return list
    }

func (my *TypeBound)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeBound)       Enter(v Visitor){
        var checkChildren = v.VisitTypeBound(my)
        if checkChildren{
            if nil != my._extends{my._extends.Accept(v)}
            if nil != my._ClassOrInterfaceType{my._ClassOrInterfaceType.Accept(v)}
            if nil != my._AdditionalBoundListopt{my._AdditionalBoundListopt.Accept(v)}
        }
        v.EndVisitTypeBound(my)
    }


func AnyCastToTypeBound(i interface{}) *TypeBound {
	if nil == i{
		return nil
	}else{
		return i.(*TypeBound)
	}
}
/**
 *<em>
*<li>Rule 36:  AdditionalBoundList ::= AdditionalBound
 *</em>
 *<p>
 *<b>
*<li>Rule 37:  AdditionalBoundList ::= AdditionalBoundList AdditionalBound
 *</b>
 */
type AdditionalBoundList struct{
    *Ast
      _AdditionalBoundList IAdditionalBoundList
      _AdditionalBound *AdditionalBound
}
func (my *AdditionalBoundList)      GetAdditionalBoundList() IAdditionalBoundList{ return my._AdditionalBoundList}
func (my *AdditionalBoundList)      SetAdditionalBoundList( _AdditionalBoundList IAdditionalBoundList)  { my._AdditionalBoundList = _AdditionalBoundList }
func (my *AdditionalBoundList)      GetAdditionalBound() *AdditionalBound{ return my._AdditionalBound}
func (my *AdditionalBoundList)      SetAdditionalBound( _AdditionalBound *AdditionalBound)  { my._AdditionalBound = _AdditionalBound }

func NewAdditionalBoundList(leftIToken IToken, rightIToken IToken ,
              _AdditionalBoundList IAdditionalBoundList,
              _AdditionalBound *AdditionalBound)*AdditionalBoundList{
      my := new(AdditionalBoundList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AdditionalBoundList = _AdditionalBoundList;
        if nil != _AdditionalBoundList{
        var trait_ interface{} = _AdditionalBoundList
         trait_.(IAst).SetParent(my)
}
        my._AdditionalBound = _AdditionalBound;
        if nil != _AdditionalBound{
        var trait_ interface{} = _AdditionalBound
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AdditionalBoundList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AdditionalBoundList{  list.Add(my._AdditionalBoundList) }
        if nil != my._AdditionalBound{  list.Add(my._AdditionalBound) }
        return list
    }

func (my *AdditionalBoundList)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AdditionalBoundList)       Enter(v Visitor){
        var checkChildren = v.VisitAdditionalBoundList(my)
        if checkChildren{
            if nil != my._AdditionalBoundList{my._AdditionalBoundList.Accept(v)}
            if nil != my._AdditionalBound{my._AdditionalBound.Accept(v)}
        }
        v.EndVisitAdditionalBoundList(my)
    }


func AnyCastToAdditionalBoundList(i interface{}) *AdditionalBoundList {
	if nil == i{
		return nil
	}else{
		return i.(*AdditionalBoundList)
	}
}
/**
 *<b>
*<li>Rule 38:  AdditionalBound ::= & InterfaceType
 *</b>
 */
type AdditionalBound struct{
    *Ast
      _AND *AstToken
      _InterfaceType *InterfaceType
}
func (my *AdditionalBound)      GetAND() *AstToken{ return my._AND}
func (my *AdditionalBound)      SetAND( _AND *AstToken)  { my._AND = _AND }
func (my *AdditionalBound)      GetInterfaceType() *InterfaceType{ return my._InterfaceType}
func (my *AdditionalBound)      SetInterfaceType( _InterfaceType *InterfaceType)  { my._InterfaceType = _InterfaceType }

func NewAdditionalBound(leftIToken IToken, rightIToken IToken ,
              _AND *AstToken,
              _InterfaceType *InterfaceType)*AdditionalBound{
      my := new(AdditionalBound)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AND = _AND;
        if nil != _AND{
        var trait_ interface{} = _AND
         trait_.(IAst).SetParent(my)
}
        my._InterfaceType = _InterfaceType;
        if nil != _InterfaceType{
        var trait_ interface{} = _InterfaceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AdditionalBound)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AND{  list.Add(my._AND) }
        if nil != my._InterfaceType{  list.Add(my._InterfaceType) }
        return list
    }

func (my *AdditionalBound)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AdditionalBound)       Enter(v Visitor){
        var checkChildren = v.VisitAdditionalBound(my)
        if checkChildren{
            if nil != my._AND{my._AND.Accept(v)}
            if nil != my._InterfaceType{my._InterfaceType.Accept(v)}
        }
        v.EndVisitAdditionalBound(my)
    }


func AnyCastToAdditionalBound(i interface{}) *AdditionalBound {
	if nil == i{
		return nil
	}else{
		return i.(*AdditionalBound)
	}
}
/**
 *<b>
*<li>Rule 39:  TypeArguments ::= < ActualTypeArgumentList >
 *</b>
 */
type TypeArguments struct{
    *Ast
      _LESS *AstToken
      _ActualTypeArgumentList IActualTypeArgumentList
      _GREATER *AstToken
}
func (my *TypeArguments)      GetLESS() *AstToken{ return my._LESS}
func (my *TypeArguments)      SetLESS( _LESS *AstToken)  { my._LESS = _LESS }
func (my *TypeArguments)      GetActualTypeArgumentList() IActualTypeArgumentList{ return my._ActualTypeArgumentList}
func (my *TypeArguments)      SetActualTypeArgumentList( _ActualTypeArgumentList IActualTypeArgumentList)  { my._ActualTypeArgumentList = _ActualTypeArgumentList }
func (my *TypeArguments)      GetGREATER() *AstToken{ return my._GREATER}
func (my *TypeArguments)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }

func NewTypeArguments(leftIToken IToken, rightIToken IToken ,
              _LESS *AstToken,
              _ActualTypeArgumentList IActualTypeArgumentList,
              _GREATER *AstToken)*TypeArguments{
      my := new(TypeArguments)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LESS = _LESS;
        if nil != _LESS{
        var trait_ interface{} = _LESS
         trait_.(IAst).SetParent(my)
}
        my._ActualTypeArgumentList = _ActualTypeArgumentList;
        if nil != _ActualTypeArgumentList{
        var trait_ interface{} = _ActualTypeArgumentList
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeArguments)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LESS{  list.Add(my._LESS) }
        if nil != my._ActualTypeArgumentList{  list.Add(my._ActualTypeArgumentList) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        return list
    }

func (my *TypeArguments)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeArguments)       Enter(v Visitor){
        var checkChildren = v.VisitTypeArguments(my)
        if checkChildren{
            if nil != my._LESS{my._LESS.Accept(v)}
            if nil != my._ActualTypeArgumentList{my._ActualTypeArgumentList.Accept(v)}
            if nil != my._GREATER{my._GREATER.Accept(v)}
        }
        v.EndVisitTypeArguments(my)
    }


func AnyCastToTypeArguments(i interface{}) *TypeArguments {
	if nil == i{
		return nil
	}else{
		return i.(*TypeArguments)
	}
}
/**
 *<em>
*<li>Rule 40:  ActualTypeArgumentList ::= ActualTypeArgument
 *</em>
 *<p>
 *<b>
*<li>Rule 41:  ActualTypeArgumentList ::= ActualTypeArgumentList , ActualTypeArgument
 *</b>
 */
type ActualTypeArgumentList struct{
    *Ast
      _ActualTypeArgumentList IActualTypeArgumentList
      _COMMA *AstToken
      _ActualTypeArgument IActualTypeArgument
}
func (my *ActualTypeArgumentList)      GetActualTypeArgumentList() IActualTypeArgumentList{ return my._ActualTypeArgumentList}
func (my *ActualTypeArgumentList)      SetActualTypeArgumentList( _ActualTypeArgumentList IActualTypeArgumentList)  { my._ActualTypeArgumentList = _ActualTypeArgumentList }
func (my *ActualTypeArgumentList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ActualTypeArgumentList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ActualTypeArgumentList)      GetActualTypeArgument() IActualTypeArgument{ return my._ActualTypeArgument}
func (my *ActualTypeArgumentList)      SetActualTypeArgument( _ActualTypeArgument IActualTypeArgument)  { my._ActualTypeArgument = _ActualTypeArgument }

func NewActualTypeArgumentList(leftIToken IToken, rightIToken IToken ,
              _ActualTypeArgumentList IActualTypeArgumentList,
              _COMMA *AstToken,
              _ActualTypeArgument IActualTypeArgument)*ActualTypeArgumentList{
      my := new(ActualTypeArgumentList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ActualTypeArgumentList = _ActualTypeArgumentList;
        if nil != _ActualTypeArgumentList{
        var trait_ interface{} = _ActualTypeArgumentList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._ActualTypeArgument = _ActualTypeArgument;
        if nil != _ActualTypeArgument{
        var trait_ interface{} = _ActualTypeArgument
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ActualTypeArgumentList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ActualTypeArgumentList{  list.Add(my._ActualTypeArgumentList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._ActualTypeArgument{  list.Add(my._ActualTypeArgument) }
        return list
    }

func (my *ActualTypeArgumentList)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ActualTypeArgumentList)       Enter(v Visitor){
        var checkChildren = v.VisitActualTypeArgumentList(my)
        if checkChildren{
            if nil != my._ActualTypeArgumentList{my._ActualTypeArgumentList.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._ActualTypeArgument{my._ActualTypeArgument.Accept(v)}
        }
        v.EndVisitActualTypeArgumentList(my)
    }


func AnyCastToActualTypeArgumentList(i interface{}) *ActualTypeArgumentList {
	if nil == i{
		return nil
	}else{
		return i.(*ActualTypeArgumentList)
	}
}
/**
 *<b>
*<li>Rule 44:  Wildcard ::= ? WildcardBoundsOpt
 *</b>
 */
type Wildcard struct{
    *Ast
      _QUESTION *AstToken
      _WildcardBoundsOpt IWildcardBoundsOpt
}
func (my *Wildcard)      GetQUESTION() *AstToken{ return my._QUESTION}
func (my *Wildcard)      SetQUESTION( _QUESTION *AstToken)  { my._QUESTION = _QUESTION }
    /**
     * The value returned by <b>GetWildcardBoundsOpt</b> may be <b>null</b>
     */
func (my *Wildcard)      GetWildcardBoundsOpt() IWildcardBoundsOpt{ return my._WildcardBoundsOpt}
func (my *Wildcard)      SetWildcardBoundsOpt( _WildcardBoundsOpt IWildcardBoundsOpt)  { my._WildcardBoundsOpt = _WildcardBoundsOpt }

func NewWildcard(leftIToken IToken, rightIToken IToken ,
              _QUESTION *AstToken,
              _WildcardBoundsOpt IWildcardBoundsOpt)*Wildcard{
      my := new(Wildcard)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._QUESTION = _QUESTION;
        if nil != _QUESTION{
        var trait_ interface{} = _QUESTION
         trait_.(IAst).SetParent(my)
}
        my._WildcardBoundsOpt = _WildcardBoundsOpt;
        if nil != _WildcardBoundsOpt{
        var trait_ interface{} = _WildcardBoundsOpt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Wildcard)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._QUESTION{  list.Add(my._QUESTION) }
        if nil != my._WildcardBoundsOpt{  list.Add(my._WildcardBoundsOpt) }
        return list
    }

func (my *Wildcard)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Wildcard)       Enter(v Visitor){
        var checkChildren = v.VisitWildcard(my)
        if checkChildren{
            if nil != my._QUESTION{my._QUESTION.Accept(v)}
            if nil != my._WildcardBoundsOpt{my._WildcardBoundsOpt.Accept(v)}
        }
        v.EndVisitWildcard(my)
    }


func AnyCastToWildcard(i interface{}) *Wildcard {
	if nil == i{
		return nil
	}else{
		return i.(*Wildcard)
	}
}
/**
 *<em>
*<li>Rule 47:  PackageName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 48:  PackageName ::= PackageName . identifier
 *</b>
 */
type PackageName struct{
    *Ast
      _PackageName IPackageName
      _DOT *AstToken
      _identifier *identifier
}
func (my *PackageName)      GetPackageName() IPackageName{ return my._PackageName}
func (my *PackageName)      SetPackageName( _PackageName IPackageName)  { my._PackageName = _PackageName }
func (my *PackageName)      GetDOT() *AstToken{ return my._DOT}
func (my *PackageName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PackageName)      Getidentifier() *identifier{ return my._identifier}
func (my *PackageName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewPackageName(leftIToken IToken, rightIToken IToken ,
              _PackageName IPackageName,
              _DOT *AstToken,
              _identifier *identifier)*PackageName{
      my := new(PackageName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PackageName = _PackageName;
        if nil != _PackageName{
        var trait_ interface{} = _PackageName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PackageName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PackageName{  list.Add(my._PackageName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *PackageName)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PackageName)       Enter(v Visitor){
        var checkChildren = v.VisitPackageName(my)
        if checkChildren{
            if nil != my._PackageName{my._PackageName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitPackageName(my)
    }


func AnyCastToPackageName(i interface{}) *PackageName {
	if nil == i{
		return nil
	}else{
		return i.(*PackageName)
	}
}
/**
 *<em>
*<li>Rule 49:  ExpressionName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 50:  ExpressionName ::= AmbiguousName . identifier
 *</b>
 */
type ExpressionName struct{
    *Ast
      _AmbiguousName IAmbiguousName
      _DOT *AstToken
      _identifier *identifier
}
func (my *ExpressionName)      GetAmbiguousName() IAmbiguousName{ return my._AmbiguousName}
func (my *ExpressionName)      SetAmbiguousName( _AmbiguousName IAmbiguousName)  { my._AmbiguousName = _AmbiguousName }
func (my *ExpressionName)      GetDOT() *AstToken{ return my._DOT}
func (my *ExpressionName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *ExpressionName)      Getidentifier() *identifier{ return my._identifier}
func (my *ExpressionName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewExpressionName(leftIToken IToken, rightIToken IToken ,
              _AmbiguousName IAmbiguousName,
              _DOT *AstToken,
              _identifier *identifier)*ExpressionName{
      my := new(ExpressionName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AmbiguousName = _AmbiguousName;
        if nil != _AmbiguousName{
        var trait_ interface{} = _AmbiguousName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExpressionName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AmbiguousName{  list.Add(my._AmbiguousName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *ExpressionName)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExpressionName)       Enter(v Visitor){
        var checkChildren = v.VisitExpressionName(my)
        if checkChildren{
            if nil != my._AmbiguousName{my._AmbiguousName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitExpressionName(my)
    }


func AnyCastToExpressionName(i interface{}) *ExpressionName {
	if nil == i{
		return nil
	}else{
		return i.(*ExpressionName)
	}
}
/**
 *<em>
*<li>Rule 51:  MethodName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 52:  MethodName ::= AmbiguousName . identifier
 *</b>
 */
type MethodName struct{
    *Ast
      _AmbiguousName IAmbiguousName
      _DOT *AstToken
      _identifier *identifier
}
func (my *MethodName)      GetAmbiguousName() IAmbiguousName{ return my._AmbiguousName}
func (my *MethodName)      SetAmbiguousName( _AmbiguousName IAmbiguousName)  { my._AmbiguousName = _AmbiguousName }
func (my *MethodName)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *MethodName)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewMethodName(leftIToken IToken, rightIToken IToken ,
              _AmbiguousName IAmbiguousName,
              _DOT *AstToken,
              _identifier *identifier)*MethodName{
      my := new(MethodName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AmbiguousName = _AmbiguousName;
        if nil != _AmbiguousName{
        var trait_ interface{} = _AmbiguousName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AmbiguousName{  list.Add(my._AmbiguousName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *MethodName)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodName)       Enter(v Visitor){
        var checkChildren = v.VisitMethodName(my)
        if checkChildren{
            if nil != my._AmbiguousName{my._AmbiguousName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitMethodName(my)
    }


func AnyCastToMethodName(i interface{}) *MethodName {
	if nil == i{
		return nil
	}else{
		return i.(*MethodName)
	}
}
/**
 *<em>
*<li>Rule 53:  PackageOrTypeName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 54:  PackageOrTypeName ::= PackageOrTypeName . identifier
 *</b>
 */
type PackageOrTypeName struct{
    *Ast
      _PackageOrTypeName IPackageOrTypeName
      _DOT *AstToken
      _identifier *identifier
}
func (my *PackageOrTypeName)      GetPackageOrTypeName() IPackageOrTypeName{ return my._PackageOrTypeName}
func (my *PackageOrTypeName)      SetPackageOrTypeName( _PackageOrTypeName IPackageOrTypeName)  { my._PackageOrTypeName = _PackageOrTypeName }
func (my *PackageOrTypeName)      GetDOT() *AstToken{ return my._DOT}
func (my *PackageOrTypeName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PackageOrTypeName)      Getidentifier() *identifier{ return my._identifier}
func (my *PackageOrTypeName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewPackageOrTypeName(leftIToken IToken, rightIToken IToken ,
              _PackageOrTypeName IPackageOrTypeName,
              _DOT *AstToken,
              _identifier *identifier)*PackageOrTypeName{
      my := new(PackageOrTypeName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PackageOrTypeName = _PackageOrTypeName;
        if nil != _PackageOrTypeName{
        var trait_ interface{} = _PackageOrTypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PackageOrTypeName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PackageOrTypeName{  list.Add(my._PackageOrTypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *PackageOrTypeName)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PackageOrTypeName)       Enter(v Visitor){
        var checkChildren = v.VisitPackageOrTypeName(my)
        if checkChildren{
            if nil != my._PackageOrTypeName{my._PackageOrTypeName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitPackageOrTypeName(my)
    }


func AnyCastToPackageOrTypeName(i interface{}) *PackageOrTypeName {
	if nil == i{
		return nil
	}else{
		return i.(*PackageOrTypeName)
	}
}
/**
 *<em>
*<li>Rule 55:  AmbiguousName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 56:  AmbiguousName ::= AmbiguousName . identifier
 *</b>
 */
type AmbiguousName struct{
    *Ast
      _AmbiguousName IAmbiguousName
      _DOT *AstToken
      _identifier *identifier
}
func (my *AmbiguousName)      GetAmbiguousName() IAmbiguousName{ return my._AmbiguousName}
func (my *AmbiguousName)      SetAmbiguousName( _AmbiguousName IAmbiguousName)  { my._AmbiguousName = _AmbiguousName }
func (my *AmbiguousName)      GetDOT() *AstToken{ return my._DOT}
func (my *AmbiguousName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *AmbiguousName)      Getidentifier() *identifier{ return my._identifier}
func (my *AmbiguousName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewAmbiguousName(leftIToken IToken, rightIToken IToken ,
              _AmbiguousName IAmbiguousName,
              _DOT *AstToken,
              _identifier *identifier)*AmbiguousName{
      my := new(AmbiguousName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AmbiguousName = _AmbiguousName;
        if nil != _AmbiguousName{
        var trait_ interface{} = _AmbiguousName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AmbiguousName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AmbiguousName{  list.Add(my._AmbiguousName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *AmbiguousName)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AmbiguousName)       Enter(v Visitor){
        var checkChildren = v.VisitAmbiguousName(my)
        if checkChildren{
            if nil != my._AmbiguousName{my._AmbiguousName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitAmbiguousName(my)
    }


func AnyCastToAmbiguousName(i interface{}) *AmbiguousName {
	if nil == i{
		return nil
	}else{
		return i.(*AmbiguousName)
	}
}
/**
 *<b>
*<li>Rule 57:  CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt
 *</b>
 */
type CompilationUnit struct{
    *Ast
      _PackageDeclarationopt *PackageDeclaration
      _ImportDeclarationsopt IImportDeclarationsopt
      _TypeDeclarationsopt ITypeDeclarationsopt
}
    /**
     * The value returned by <b>GetPackageDeclarationopt</b> may be <b>null</b>
     */
func (my *CompilationUnit)      GetPackageDeclarationopt() *PackageDeclaration{ return my._PackageDeclarationopt}
func (my *CompilationUnit)      SetPackageDeclarationopt( _PackageDeclarationopt *PackageDeclaration)  { my._PackageDeclarationopt = _PackageDeclarationopt }
    /**
     * The value returned by <b>GetImportDeclarationsopt</b> may be <b>null</b>
     */
func (my *CompilationUnit)      GetImportDeclarationsopt() IImportDeclarationsopt{ return my._ImportDeclarationsopt}
func (my *CompilationUnit)      SetImportDeclarationsopt( _ImportDeclarationsopt IImportDeclarationsopt)  { my._ImportDeclarationsopt = _ImportDeclarationsopt }
    /**
     * The value returned by <b>GetTypeDeclarationsopt</b> may be <b>null</b>
     */
func (my *CompilationUnit)      GetTypeDeclarationsopt() ITypeDeclarationsopt{ return my._TypeDeclarationsopt}
func (my *CompilationUnit)      SetTypeDeclarationsopt( _TypeDeclarationsopt ITypeDeclarationsopt)  { my._TypeDeclarationsopt = _TypeDeclarationsopt }

func NewCompilationUnit(leftIToken IToken, rightIToken IToken ,
              _PackageDeclarationopt *PackageDeclaration,
              _ImportDeclarationsopt IImportDeclarationsopt,
              _TypeDeclarationsopt ITypeDeclarationsopt)*CompilationUnit{
      my := new(CompilationUnit)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PackageDeclarationopt = _PackageDeclarationopt;
        if nil != _PackageDeclarationopt{
        var trait_ interface{} = _PackageDeclarationopt
         trait_.(IAst).SetParent(my)
}
        my._ImportDeclarationsopt = _ImportDeclarationsopt;
        if nil != _ImportDeclarationsopt{
        var trait_ interface{} = _ImportDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._TypeDeclarationsopt = _TypeDeclarationsopt;
        if nil != _TypeDeclarationsopt{
        var trait_ interface{} = _TypeDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *CompilationUnit)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PackageDeclarationopt{  list.Add(my._PackageDeclarationopt) }
        if nil != my._ImportDeclarationsopt{  list.Add(my._ImportDeclarationsopt) }
        if nil != my._TypeDeclarationsopt{  list.Add(my._TypeDeclarationsopt) }
        return list
    }

func (my *CompilationUnit)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *CompilationUnit)       Enter(v Visitor){
        var checkChildren = v.VisitCompilationUnit(my)
        if checkChildren{
            if nil != my._PackageDeclarationopt{my._PackageDeclarationopt.Accept(v)}
            if nil != my._ImportDeclarationsopt{my._ImportDeclarationsopt.Accept(v)}
            if nil != my._TypeDeclarationsopt{my._TypeDeclarationsopt.Accept(v)}
        }
        v.EndVisitCompilationUnit(my)
    }


func AnyCastToCompilationUnit(i interface{}) *CompilationUnit {
	if nil == i{
		return nil
	}else{
		return i.(*CompilationUnit)
	}
}
/**
 *<em>
*<li>Rule 58:  ImportDeclarations ::= ImportDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 59:  ImportDeclarations ::= ImportDeclarations ImportDeclaration
 *</b>
 */
type ImportDeclarations struct{
    *Ast
      _ImportDeclarations IImportDeclarations
      _ImportDeclaration IImportDeclaration
}
func (my *ImportDeclarations)      GetImportDeclarations() IImportDeclarations{ return my._ImportDeclarations}
func (my *ImportDeclarations)      SetImportDeclarations( _ImportDeclarations IImportDeclarations)  { my._ImportDeclarations = _ImportDeclarations }
func (my *ImportDeclarations)      GetImportDeclaration() IImportDeclaration{ return my._ImportDeclaration}
func (my *ImportDeclarations)      SetImportDeclaration( _ImportDeclaration IImportDeclaration)  { my._ImportDeclaration = _ImportDeclaration }

func NewImportDeclarations(leftIToken IToken, rightIToken IToken ,
              _ImportDeclarations IImportDeclarations,
              _ImportDeclaration IImportDeclaration)*ImportDeclarations{
      my := new(ImportDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ImportDeclarations = _ImportDeclarations;
        if nil != _ImportDeclarations{
        var trait_ interface{} = _ImportDeclarations
         trait_.(IAst).SetParent(my)
}
        my._ImportDeclaration = _ImportDeclaration;
        if nil != _ImportDeclaration{
        var trait_ interface{} = _ImportDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ImportDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ImportDeclarations{  list.Add(my._ImportDeclarations) }
        if nil != my._ImportDeclaration{  list.Add(my._ImportDeclaration) }
        return list
    }

func (my *ImportDeclarations)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ImportDeclarations)       Enter(v Visitor){
        var checkChildren = v.VisitImportDeclarations(my)
        if checkChildren{
            if nil != my._ImportDeclarations{my._ImportDeclarations.Accept(v)}
            if nil != my._ImportDeclaration{my._ImportDeclaration.Accept(v)}
        }
        v.EndVisitImportDeclarations(my)
    }


func AnyCastToImportDeclarations(i interface{}) *ImportDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*ImportDeclarations)
	}
}
/**
 *<em>
*<li>Rule 60:  TypeDeclarations ::= TypeDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 61:  TypeDeclarations ::= TypeDeclarations TypeDeclaration
 *</b>
 */
type TypeDeclarations struct{
    *Ast
      _TypeDeclarations ITypeDeclarations
      _TypeDeclaration ITypeDeclaration
}
func (my *TypeDeclarations)      GetTypeDeclarations() ITypeDeclarations{ return my._TypeDeclarations}
func (my *TypeDeclarations)      SetTypeDeclarations( _TypeDeclarations ITypeDeclarations)  { my._TypeDeclarations = _TypeDeclarations }
func (my *TypeDeclarations)      GetTypeDeclaration() ITypeDeclaration{ return my._TypeDeclaration}
func (my *TypeDeclarations)      SetTypeDeclaration( _TypeDeclaration ITypeDeclaration)  { my._TypeDeclaration = _TypeDeclaration }

func NewTypeDeclarations(leftIToken IToken, rightIToken IToken ,
              _TypeDeclarations ITypeDeclarations,
              _TypeDeclaration ITypeDeclaration)*TypeDeclarations{
      my := new(TypeDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeDeclarations = _TypeDeclarations;
        if nil != _TypeDeclarations{
        var trait_ interface{} = _TypeDeclarations
         trait_.(IAst).SetParent(my)
}
        my._TypeDeclaration = _TypeDeclaration;
        if nil != _TypeDeclaration{
        var trait_ interface{} = _TypeDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeDeclarations{  list.Add(my._TypeDeclarations) }
        if nil != my._TypeDeclaration{  list.Add(my._TypeDeclaration) }
        return list
    }

func (my *TypeDeclarations)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeDeclarations)       Enter(v Visitor){
        var checkChildren = v.VisitTypeDeclarations(my)
        if checkChildren{
            if nil != my._TypeDeclarations{my._TypeDeclarations.Accept(v)}
            if nil != my._TypeDeclaration{my._TypeDeclaration.Accept(v)}
        }
        v.EndVisitTypeDeclarations(my)
    }


func AnyCastToTypeDeclarations(i interface{}) *TypeDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*TypeDeclarations)
	}
}
/**
 *<b>
*<li>Rule 62:  PackageDeclaration ::= Annotationsopt package PackageName ;
 *</b>
 */
type PackageDeclaration struct{
    *Ast
      _Annotationsopt IAnnotationsopt
      _package *AstToken
      _PackageName IPackageName
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetAnnotationsopt</b> may be <b>null</b>
     */
func (my *PackageDeclaration)      GetAnnotationsopt() IAnnotationsopt{ return my._Annotationsopt}
func (my *PackageDeclaration)      SetAnnotationsopt( _Annotationsopt IAnnotationsopt)  { my._Annotationsopt = _Annotationsopt }
func (my *PackageDeclaration)      Getpackage() *AstToken{ return my._package}
func (my *PackageDeclaration)      Setpackage( _package *AstToken)  { my._package = _package }
func (my *PackageDeclaration)      GetPackageName() IPackageName{ return my._PackageName}
func (my *PackageDeclaration)      SetPackageName( _PackageName IPackageName)  { my._PackageName = _PackageName }
func (my *PackageDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *PackageDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewPackageDeclaration(leftIToken IToken, rightIToken IToken ,
              _Annotationsopt IAnnotationsopt,
              _package *AstToken,
              _PackageName IPackageName,
              _SEMICOLON *AstToken)*PackageDeclaration{
      my := new(PackageDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Annotationsopt = _Annotationsopt;
        if nil != _Annotationsopt{
        var trait_ interface{} = _Annotationsopt
         trait_.(IAst).SetParent(my)
}
        my._package = _package;
        if nil != _package{
        var trait_ interface{} = _package
         trait_.(IAst).SetParent(my)
}
        my._PackageName = _PackageName;
        if nil != _PackageName{
        var trait_ interface{} = _PackageName
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PackageDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Annotationsopt{  list.Add(my._Annotationsopt) }
        if nil != my._package{  list.Add(my._package) }
        if nil != my._PackageName{  list.Add(my._PackageName) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *PackageDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PackageDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitPackageDeclaration(my)
        if checkChildren{
            if nil != my._Annotationsopt{my._Annotationsopt.Accept(v)}
            if nil != my._package{my._package.Accept(v)}
            if nil != my._PackageName{my._PackageName.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitPackageDeclaration(my)
    }


func AnyCastToPackageDeclaration(i interface{}) *PackageDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*PackageDeclaration)
	}
}
/**
 *<b>
*<li>Rule 67:  SingleTypeImportDeclaration ::= import TypeName ;
 *</b>
 */
type SingleTypeImportDeclaration struct{
    *Ast
      _import *AstToken
      _TypeName ITypeName
      _SEMICOLON *AstToken
}
func (my *SingleTypeImportDeclaration)      Getimport() *AstToken{ return my._import}
func (my *SingleTypeImportDeclaration)      Setimport( _import *AstToken)  { my._import = _import }
func (my *SingleTypeImportDeclaration)      GetTypeName() ITypeName{ return my._TypeName}
func (my *SingleTypeImportDeclaration)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *SingleTypeImportDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *SingleTypeImportDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewSingleTypeImportDeclaration(leftIToken IToken, rightIToken IToken ,
              _import *AstToken,
              _TypeName ITypeName,
              _SEMICOLON *AstToken)*SingleTypeImportDeclaration{
      my := new(SingleTypeImportDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._import = _import;
        if nil != _import{
        var trait_ interface{} = _import
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SingleTypeImportDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._import{  list.Add(my._import) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *SingleTypeImportDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SingleTypeImportDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitSingleTypeImportDeclaration(my)
        if checkChildren{
            if nil != my._import{my._import.Accept(v)}
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitSingleTypeImportDeclaration(my)
    }


func AnyCastToSingleTypeImportDeclaration(i interface{}) *SingleTypeImportDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*SingleTypeImportDeclaration)
	}
}
/**
 *<b>
*<li>Rule 68:  TypeImportOnDemandDeclaration ::= import PackageOrTypeName . * ;
 *</b>
 */
type TypeImportOnDemandDeclaration struct{
    *Ast
      _import *AstToken
      _PackageOrTypeName IPackageOrTypeName
      _DOT *AstToken
      _MULTIPLY *AstToken
      _SEMICOLON *AstToken
}
func (my *TypeImportOnDemandDeclaration)      Getimport() *AstToken{ return my._import}
func (my *TypeImportOnDemandDeclaration)      Setimport( _import *AstToken)  { my._import = _import }
func (my *TypeImportOnDemandDeclaration)      GetPackageOrTypeName() IPackageOrTypeName{ return my._PackageOrTypeName}
func (my *TypeImportOnDemandDeclaration)      SetPackageOrTypeName( _PackageOrTypeName IPackageOrTypeName)  { my._PackageOrTypeName = _PackageOrTypeName }
func (my *TypeImportOnDemandDeclaration)      GetDOT() *AstToken{ return my._DOT}
func (my *TypeImportOnDemandDeclaration)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *TypeImportOnDemandDeclaration)      GetMULTIPLY() *AstToken{ return my._MULTIPLY}
func (my *TypeImportOnDemandDeclaration)      SetMULTIPLY( _MULTIPLY *AstToken)  { my._MULTIPLY = _MULTIPLY }
func (my *TypeImportOnDemandDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *TypeImportOnDemandDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewTypeImportOnDemandDeclaration(leftIToken IToken, rightIToken IToken ,
              _import *AstToken,
              _PackageOrTypeName IPackageOrTypeName,
              _DOT *AstToken,
              _MULTIPLY *AstToken,
              _SEMICOLON *AstToken)*TypeImportOnDemandDeclaration{
      my := new(TypeImportOnDemandDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._import = _import;
        if nil != _import{
        var trait_ interface{} = _import
         trait_.(IAst).SetParent(my)
}
        my._PackageOrTypeName = _PackageOrTypeName;
        if nil != _PackageOrTypeName{
        var trait_ interface{} = _PackageOrTypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._MULTIPLY = _MULTIPLY;
        if nil != _MULTIPLY{
        var trait_ interface{} = _MULTIPLY
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeImportOnDemandDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._import{  list.Add(my._import) }
        if nil != my._PackageOrTypeName{  list.Add(my._PackageOrTypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._MULTIPLY{  list.Add(my._MULTIPLY) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *TypeImportOnDemandDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeImportOnDemandDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitTypeImportOnDemandDeclaration(my)
        if checkChildren{
            if nil != my._import{my._import.Accept(v)}
            if nil != my._PackageOrTypeName{my._PackageOrTypeName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._MULTIPLY{my._MULTIPLY.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitTypeImportOnDemandDeclaration(my)
    }


func AnyCastToTypeImportOnDemandDeclaration(i interface{}) *TypeImportOnDemandDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*TypeImportOnDemandDeclaration)
	}
}
/**
 *<b>
*<li>Rule 69:  SingleStaticImportDeclaration ::= import static TypeName . identifier ;
 *</b>
 */
type SingleStaticImportDeclaration struct{
    *Ast
      _import *AstToken
      _static *AstToken
      _TypeName ITypeName
      _DOT *AstToken
      _identifier *identifier
      _SEMICOLON *AstToken
}
func (my *SingleStaticImportDeclaration)      Getimport() *AstToken{ return my._import}
func (my *SingleStaticImportDeclaration)      Setimport( _import *AstToken)  { my._import = _import }
func (my *SingleStaticImportDeclaration)      Getstatic() *AstToken{ return my._static}
func (my *SingleStaticImportDeclaration)      Setstatic( _static *AstToken)  { my._static = _static }
func (my *SingleStaticImportDeclaration)      GetTypeName() ITypeName{ return my._TypeName}
func (my *SingleStaticImportDeclaration)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *SingleStaticImportDeclaration)      GetDOT() *AstToken{ return my._DOT}
func (my *SingleStaticImportDeclaration)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *SingleStaticImportDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *SingleStaticImportDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *SingleStaticImportDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *SingleStaticImportDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewSingleStaticImportDeclaration(leftIToken IToken, rightIToken IToken ,
              _import *AstToken,
              _static *AstToken,
              _TypeName ITypeName,
              _DOT *AstToken,
              _identifier *identifier,
              _SEMICOLON *AstToken)*SingleStaticImportDeclaration{
      my := new(SingleStaticImportDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._import = _import;
        if nil != _import{
        var trait_ interface{} = _import
         trait_.(IAst).SetParent(my)
}
        my._static = _static;
        if nil != _static{
        var trait_ interface{} = _static
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SingleStaticImportDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._import{  list.Add(my._import) }
        if nil != my._static{  list.Add(my._static) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *SingleStaticImportDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SingleStaticImportDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitSingleStaticImportDeclaration(my)
        if checkChildren{
            if nil != my._import{my._import.Accept(v)}
            if nil != my._static{my._static.Accept(v)}
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitSingleStaticImportDeclaration(my)
    }


func AnyCastToSingleStaticImportDeclaration(i interface{}) *SingleStaticImportDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*SingleStaticImportDeclaration)
	}
}
/**
 *<b>
*<li>Rule 70:  StaticImportOnDemandDeclaration ::= import static TypeName . * ;
 *</b>
 */
type StaticImportOnDemandDeclaration struct{
    *Ast
      _import *AstToken
      _static *AstToken
      _TypeName ITypeName
      _DOT *AstToken
      _MULTIPLY *AstToken
      _SEMICOLON *AstToken
}
func (my *StaticImportOnDemandDeclaration)      Getimport() *AstToken{ return my._import}
func (my *StaticImportOnDemandDeclaration)      Setimport( _import *AstToken)  { my._import = _import }
func (my *StaticImportOnDemandDeclaration)      Getstatic() *AstToken{ return my._static}
func (my *StaticImportOnDemandDeclaration)      Setstatic( _static *AstToken)  { my._static = _static }
func (my *StaticImportOnDemandDeclaration)      GetTypeName() ITypeName{ return my._TypeName}
func (my *StaticImportOnDemandDeclaration)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *StaticImportOnDemandDeclaration)      GetDOT() *AstToken{ return my._DOT}
func (my *StaticImportOnDemandDeclaration)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *StaticImportOnDemandDeclaration)      GetMULTIPLY() *AstToken{ return my._MULTIPLY}
func (my *StaticImportOnDemandDeclaration)      SetMULTIPLY( _MULTIPLY *AstToken)  { my._MULTIPLY = _MULTIPLY }
func (my *StaticImportOnDemandDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *StaticImportOnDemandDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewStaticImportOnDemandDeclaration(leftIToken IToken, rightIToken IToken ,
              _import *AstToken,
              _static *AstToken,
              _TypeName ITypeName,
              _DOT *AstToken,
              _MULTIPLY *AstToken,
              _SEMICOLON *AstToken)*StaticImportOnDemandDeclaration{
      my := new(StaticImportOnDemandDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._import = _import;
        if nil != _import{
        var trait_ interface{} = _import
         trait_.(IAst).SetParent(my)
}
        my._static = _static;
        if nil != _static{
        var trait_ interface{} = _static
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._MULTIPLY = _MULTIPLY;
        if nil != _MULTIPLY{
        var trait_ interface{} = _MULTIPLY
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *StaticImportOnDemandDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._import{  list.Add(my._import) }
        if nil != my._static{  list.Add(my._static) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._MULTIPLY{  list.Add(my._MULTIPLY) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *StaticImportOnDemandDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *StaticImportOnDemandDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitStaticImportOnDemandDeclaration(my)
        if checkChildren{
            if nil != my._import{my._import.Accept(v)}
            if nil != my._static{my._static.Accept(v)}
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._MULTIPLY{my._MULTIPLY.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitStaticImportOnDemandDeclaration(my)
    }


func AnyCastToStaticImportOnDemandDeclaration(i interface{}) *StaticImportOnDemandDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*StaticImportOnDemandDeclaration)
	}
}
/**
 *<em>
*<li>Rule 71:  TypeDeclaration ::= ClassDeclaration
*<li>Rule 72:  TypeDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 73:  TypeDeclaration ::= ;
 *</b>
 */
type TypeDeclaration struct{
    *AstToken
}
func (my *TypeDeclaration)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewTypeDeclaration(token IToken )*TypeDeclaration{
      my := new(TypeDeclaration)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *TypeDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeDeclaration)       Enter(v Visitor){
        v.VisitTypeDeclaration(my)
        v.EndVisitTypeDeclaration(my)
    }


func AnyCastToTypeDeclaration(i interface{}) *TypeDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*TypeDeclaration)
	}
}
/**
 *<b>
*<li>Rule 76:  NormalClassDeclaration ::= ClassModifiersopt class identifier TypeParametersopt Superopt Interfacesopt ClassBody
 *</b>
 */
type NormalClassDeclaration struct{
    *Ast
      _ClassModifiersopt IClassModifiersopt
      _class *AstToken
      _identifier *identifier
      _TypeParametersopt *TypeParameters
      _Superopt *Super
      _Interfacesopt *Interfaces
      _ClassBody *ClassBody
}
    /**
     * The value returned by <b>GetClassModifiersopt</b> may be <b>null</b>
     */
func (my *NormalClassDeclaration)      GetClassModifiersopt() IClassModifiersopt{ return my._ClassModifiersopt}
func (my *NormalClassDeclaration)      SetClassModifiersopt( _ClassModifiersopt IClassModifiersopt)  { my._ClassModifiersopt = _ClassModifiersopt }
func (my *NormalClassDeclaration)      Getclass() *AstToken{ return my._class}
func (my *NormalClassDeclaration)      Setclass( _class *AstToken)  { my._class = _class }
func (my *NormalClassDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *NormalClassDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *NormalClassDeclaration)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *NormalClassDeclaration)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
    /**
     * The value returned by <b>GetSuperopt</b> may be <b>null</b>
     */
func (my *NormalClassDeclaration)      GetSuperopt() *Super{ return my._Superopt}
func (my *NormalClassDeclaration)      SetSuperopt( _Superopt *Super)  { my._Superopt = _Superopt }
    /**
     * The value returned by <b>GetInterfacesopt</b> may be <b>null</b>
     */
func (my *NormalClassDeclaration)      GetInterfacesopt() *Interfaces{ return my._Interfacesopt}
func (my *NormalClassDeclaration)      SetInterfacesopt( _Interfacesopt *Interfaces)  { my._Interfacesopt = _Interfacesopt }
func (my *NormalClassDeclaration)      GetClassBody() *ClassBody{ return my._ClassBody}
func (my *NormalClassDeclaration)      SetClassBody( _ClassBody *ClassBody)  { my._ClassBody = _ClassBody }

func NewNormalClassDeclaration(leftIToken IToken, rightIToken IToken ,
              _ClassModifiersopt IClassModifiersopt,
              _class *AstToken,
              _identifier *identifier,
              _TypeParametersopt *TypeParameters,
              _Superopt *Super,
              _Interfacesopt *Interfaces,
              _ClassBody *ClassBody)*NormalClassDeclaration{
      my := new(NormalClassDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassModifiersopt = _ClassModifiersopt;
        if nil != _ClassModifiersopt{
        var trait_ interface{} = _ClassModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._class = _class;
        if nil != _class{
        var trait_ interface{} = _class
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._Superopt = _Superopt;
        if nil != _Superopt{
        var trait_ interface{} = _Superopt
         trait_.(IAst).SetParent(my)
}
        my._Interfacesopt = _Interfacesopt;
        if nil != _Interfacesopt{
        var trait_ interface{} = _Interfacesopt
         trait_.(IAst).SetParent(my)
}
        my._ClassBody = _ClassBody;
        if nil != _ClassBody{
        var trait_ interface{} = _ClassBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *NormalClassDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassModifiersopt{  list.Add(my._ClassModifiersopt) }
        if nil != my._class{  list.Add(my._class) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._Superopt{  list.Add(my._Superopt) }
        if nil != my._Interfacesopt{  list.Add(my._Interfacesopt) }
        if nil != my._ClassBody{  list.Add(my._ClassBody) }
        return list
    }

func (my *NormalClassDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *NormalClassDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitNormalClassDeclaration(my)
        if checkChildren{
            if nil != my._ClassModifiersopt{my._ClassModifiersopt.Accept(v)}
            if nil != my._class{my._class.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._TypeParametersopt{my._TypeParametersopt.Accept(v)}
            if nil != my._Superopt{my._Superopt.Accept(v)}
            if nil != my._Interfacesopt{my._Interfacesopt.Accept(v)}
            if nil != my._ClassBody{my._ClassBody.Accept(v)}
        }
        v.EndVisitNormalClassDeclaration(my)
    }


func AnyCastToNormalClassDeclaration(i interface{}) *NormalClassDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*NormalClassDeclaration)
	}
}
/**
 *<em>
*<li>Rule 77:  ClassModifiers ::= ClassModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 78:  ClassModifiers ::= ClassModifiers ClassModifier
 *</b>
 */
type ClassModifiers struct{
    *Ast
      _ClassModifiers IClassModifiers
      _ClassModifier IClassModifier
}
func (my *ClassModifiers)      GetClassModifiers() IClassModifiers{ return my._ClassModifiers}
func (my *ClassModifiers)      SetClassModifiers( _ClassModifiers IClassModifiers)  { my._ClassModifiers = _ClassModifiers }
func (my *ClassModifiers)      GetClassModifier() IClassModifier{ return my._ClassModifier}
func (my *ClassModifiers)      SetClassModifier( _ClassModifier IClassModifier)  { my._ClassModifier = _ClassModifier }

func NewClassModifiers(leftIToken IToken, rightIToken IToken ,
              _ClassModifiers IClassModifiers,
              _ClassModifier IClassModifier)*ClassModifiers{
      my := new(ClassModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassModifiers = _ClassModifiers;
        if nil != _ClassModifiers{
        var trait_ interface{} = _ClassModifiers
         trait_.(IAst).SetParent(my)
}
        my._ClassModifier = _ClassModifier;
        if nil != _ClassModifier{
        var trait_ interface{} = _ClassModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassModifiers{  list.Add(my._ClassModifiers) }
        if nil != my._ClassModifier{  list.Add(my._ClassModifier) }
        return list
    }

func (my *ClassModifiers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassModifiers)       Enter(v Visitor){
        var checkChildren = v.VisitClassModifiers(my)
        if checkChildren{
            if nil != my._ClassModifiers{my._ClassModifiers.Accept(v)}
            if nil != my._ClassModifier{my._ClassModifier.Accept(v)}
        }
        v.EndVisitClassModifiers(my)
    }


func AnyCastToClassModifiers(i interface{}) *ClassModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifiers)
	}
}
/**
 *<b>
*<li>Rule 87:  TypeParameters ::= < TypeParameterList >
 *</b>
 */
type TypeParameters struct{
    *Ast
      _LESS *AstToken
      _TypeParameterList ITypeParameterList
      _GREATER *AstToken
}
func (my *TypeParameters)      GetLESS() *AstToken{ return my._LESS}
func (my *TypeParameters)      SetLESS( _LESS *AstToken)  { my._LESS = _LESS }
func (my *TypeParameters)      GetTypeParameterList() ITypeParameterList{ return my._TypeParameterList}
func (my *TypeParameters)      SetTypeParameterList( _TypeParameterList ITypeParameterList)  { my._TypeParameterList = _TypeParameterList }
func (my *TypeParameters)      GetGREATER() *AstToken{ return my._GREATER}
func (my *TypeParameters)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }

func NewTypeParameters(leftIToken IToken, rightIToken IToken ,
              _LESS *AstToken,
              _TypeParameterList ITypeParameterList,
              _GREATER *AstToken)*TypeParameters{
      my := new(TypeParameters)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LESS = _LESS;
        if nil != _LESS{
        var trait_ interface{} = _LESS
         trait_.(IAst).SetParent(my)
}
        my._TypeParameterList = _TypeParameterList;
        if nil != _TypeParameterList{
        var trait_ interface{} = _TypeParameterList
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeParameters)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LESS{  list.Add(my._LESS) }
        if nil != my._TypeParameterList{  list.Add(my._TypeParameterList) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        return list
    }

func (my *TypeParameters)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeParameters)       Enter(v Visitor){
        var checkChildren = v.VisitTypeParameters(my)
        if checkChildren{
            if nil != my._LESS{my._LESS.Accept(v)}
            if nil != my._TypeParameterList{my._TypeParameterList.Accept(v)}
            if nil != my._GREATER{my._GREATER.Accept(v)}
        }
        v.EndVisitTypeParameters(my)
    }


func AnyCastToTypeParameters(i interface{}) *TypeParameters {
	if nil == i{
		return nil
	}else{
		return i.(*TypeParameters)
	}
}
/**
 *<em>
*<li>Rule 88:  TypeParameterList ::= TypeParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 89:  TypeParameterList ::= TypeParameterList , TypeParameter
 *</b>
 */
type TypeParameterList struct{
    *Ast
      _TypeParameterList ITypeParameterList
      _COMMA *AstToken
      _TypeParameter *TypeParameter
}
func (my *TypeParameterList)      GetTypeParameterList() ITypeParameterList{ return my._TypeParameterList}
func (my *TypeParameterList)      SetTypeParameterList( _TypeParameterList ITypeParameterList)  { my._TypeParameterList = _TypeParameterList }
func (my *TypeParameterList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *TypeParameterList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *TypeParameterList)      GetTypeParameter() *TypeParameter{ return my._TypeParameter}
func (my *TypeParameterList)      SetTypeParameter( _TypeParameter *TypeParameter)  { my._TypeParameter = _TypeParameter }

func NewTypeParameterList(leftIToken IToken, rightIToken IToken ,
              _TypeParameterList ITypeParameterList,
              _COMMA *AstToken,
              _TypeParameter *TypeParameter)*TypeParameterList{
      my := new(TypeParameterList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeParameterList = _TypeParameterList;
        if nil != _TypeParameterList{
        var trait_ interface{} = _TypeParameterList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._TypeParameter = _TypeParameter;
        if nil != _TypeParameter{
        var trait_ interface{} = _TypeParameter
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeParameterList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeParameterList{  list.Add(my._TypeParameterList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._TypeParameter{  list.Add(my._TypeParameter) }
        return list
    }

func (my *TypeParameterList)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TypeParameterList)       Enter(v Visitor){
        var checkChildren = v.VisitTypeParameterList(my)
        if checkChildren{
            if nil != my._TypeParameterList{my._TypeParameterList.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._TypeParameter{my._TypeParameter.Accept(v)}
        }
        v.EndVisitTypeParameterList(my)
    }


func AnyCastToTypeParameterList(i interface{}) *TypeParameterList {
	if nil == i{
		return nil
	}else{
		return i.(*TypeParameterList)
	}
}
/**
 *<b>
*<li>Rule 90:  Super ::= extends ClassType
 *</b>
 */
type Super struct{
    *Ast
      _extends *AstToken
      _ClassType *ClassType
}
func (my *Super)      Getextends() *AstToken{ return my._extends}
func (my *Super)      Setextends( _extends *AstToken)  { my._extends = _extends }
func (my *Super)      GetClassType() *ClassType{ return my._ClassType}
func (my *Super)      SetClassType( _ClassType *ClassType)  { my._ClassType = _ClassType }

func NewSuper(leftIToken IToken, rightIToken IToken ,
              _extends *AstToken,
              _ClassType *ClassType)*Super{
      my := new(Super)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._extends = _extends;
        if nil != _extends{
        var trait_ interface{} = _extends
         trait_.(IAst).SetParent(my)
}
        my._ClassType = _ClassType;
        if nil != _ClassType{
        var trait_ interface{} = _ClassType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Super)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._extends{  list.Add(my._extends) }
        if nil != my._ClassType{  list.Add(my._ClassType) }
        return list
    }

func (my *Super)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Super)       Enter(v Visitor){
        var checkChildren = v.VisitSuper(my)
        if checkChildren{
            if nil != my._extends{my._extends.Accept(v)}
            if nil != my._ClassType{my._ClassType.Accept(v)}
        }
        v.EndVisitSuper(my)
    }


func AnyCastToSuper(i interface{}) *Super {
	if nil == i{
		return nil
	}else{
		return i.(*Super)
	}
}
/**
 *<b>
*<li>Rule 91:  Interfaces ::= implements InterfaceTypeList
 *</b>
 */
type Interfaces struct{
    *Ast
      _implements *AstToken
      _InterfaceTypeList IInterfaceTypeList
}
func (my *Interfaces)      Getimplements() *AstToken{ return my._implements}
func (my *Interfaces)      Setimplements( _implements *AstToken)  { my._implements = _implements }
func (my *Interfaces)      GetInterfaceTypeList() IInterfaceTypeList{ return my._InterfaceTypeList}
func (my *Interfaces)      SetInterfaceTypeList( _InterfaceTypeList IInterfaceTypeList)  { my._InterfaceTypeList = _InterfaceTypeList }

func NewInterfaces(leftIToken IToken, rightIToken IToken ,
              _implements *AstToken,
              _InterfaceTypeList IInterfaceTypeList)*Interfaces{
      my := new(Interfaces)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._implements = _implements;
        if nil != _implements{
        var trait_ interface{} = _implements
         trait_.(IAst).SetParent(my)
}
        my._InterfaceTypeList = _InterfaceTypeList;
        if nil != _InterfaceTypeList{
        var trait_ interface{} = _InterfaceTypeList
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Interfaces)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._implements{  list.Add(my._implements) }
        if nil != my._InterfaceTypeList{  list.Add(my._InterfaceTypeList) }
        return list
    }

func (my *Interfaces)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Interfaces)       Enter(v Visitor){
        var checkChildren = v.VisitInterfaces(my)
        if checkChildren{
            if nil != my._implements{my._implements.Accept(v)}
            if nil != my._InterfaceTypeList{my._InterfaceTypeList.Accept(v)}
        }
        v.EndVisitInterfaces(my)
    }


func AnyCastToInterfaces(i interface{}) *Interfaces {
	if nil == i{
		return nil
	}else{
		return i.(*Interfaces)
	}
}
/**
 *<em>
*<li>Rule 92:  InterfaceTypeList ::= InterfaceType
 *</em>
 *<p>
 *<b>
*<li>Rule 93:  InterfaceTypeList ::= InterfaceTypeList , InterfaceType
 *</b>
 */
type InterfaceTypeList struct{
    *Ast
      _InterfaceTypeList IInterfaceTypeList
      _COMMA *AstToken
      _InterfaceType *InterfaceType
}
func (my *InterfaceTypeList)      GetInterfaceTypeList() IInterfaceTypeList{ return my._InterfaceTypeList}
func (my *InterfaceTypeList)      SetInterfaceTypeList( _InterfaceTypeList IInterfaceTypeList)  { my._InterfaceTypeList = _InterfaceTypeList }
func (my *InterfaceTypeList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *InterfaceTypeList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *InterfaceTypeList)      GetInterfaceType() *InterfaceType{ return my._InterfaceType}
func (my *InterfaceTypeList)      SetInterfaceType( _InterfaceType *InterfaceType)  { my._InterfaceType = _InterfaceType }

func NewInterfaceTypeList(leftIToken IToken, rightIToken IToken ,
              _InterfaceTypeList IInterfaceTypeList,
              _COMMA *AstToken,
              _InterfaceType *InterfaceType)*InterfaceTypeList{
      my := new(InterfaceTypeList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceTypeList = _InterfaceTypeList;
        if nil != _InterfaceTypeList{
        var trait_ interface{} = _InterfaceTypeList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._InterfaceType = _InterfaceType;
        if nil != _InterfaceType{
        var trait_ interface{} = _InterfaceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceTypeList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceTypeList{  list.Add(my._InterfaceTypeList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._InterfaceType{  list.Add(my._InterfaceType) }
        return list
    }

func (my *InterfaceTypeList)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceTypeList)       Enter(v Visitor){
        var checkChildren = v.VisitInterfaceTypeList(my)
        if checkChildren{
            if nil != my._InterfaceTypeList{my._InterfaceTypeList.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._InterfaceType{my._InterfaceType.Accept(v)}
        }
        v.EndVisitInterfaceTypeList(my)
    }


func AnyCastToInterfaceTypeList(i interface{}) *InterfaceTypeList {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceTypeList)
	}
}
/**
 *<b>
*<li>Rule 94:  ClassBody ::= { ClassBodyDeclarationsopt }
 *</b>
 */
type ClassBody struct{
    *Ast
      _LBRACE *AstToken
      _ClassBodyDeclarationsopt IClassBodyDeclarationsopt
      _RBRACE *AstToken
}
func (my *ClassBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *ClassBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetClassBodyDeclarationsopt</b> may be <b>null</b>
     */
func (my *ClassBody)      GetClassBodyDeclarationsopt() IClassBodyDeclarationsopt{ return my._ClassBodyDeclarationsopt}
func (my *ClassBody)      SetClassBodyDeclarationsopt( _ClassBodyDeclarationsopt IClassBodyDeclarationsopt)  { my._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt }
func (my *ClassBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *ClassBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewClassBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _ClassBodyDeclarationsopt IClassBodyDeclarationsopt,
              _RBRACE *AstToken)*ClassBody{
      my := new(ClassBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt;
        if nil != _ClassBodyDeclarationsopt{
        var trait_ interface{} = _ClassBodyDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._ClassBodyDeclarationsopt{  list.Add(my._ClassBodyDeclarationsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *ClassBody)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassBody)       Enter(v Visitor){
        var checkChildren = v.VisitClassBody(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._ClassBodyDeclarationsopt{my._ClassBodyDeclarationsopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitClassBody(my)
    }


func AnyCastToClassBody(i interface{}) *ClassBody {
	if nil == i{
		return nil
	}else{
		return i.(*ClassBody)
	}
}
/**
 *<em>
*<li>Rule 95:  ClassBodyDeclarations ::= ClassBodyDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 96:  ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
 *</b>
 */
type ClassBodyDeclarations struct{
    *Ast
      _ClassBodyDeclarations IClassBodyDeclarations
      _ClassBodyDeclaration IClassBodyDeclaration
}
func (my *ClassBodyDeclarations)      GetClassBodyDeclarations() IClassBodyDeclarations{ return my._ClassBodyDeclarations}
func (my *ClassBodyDeclarations)      SetClassBodyDeclarations( _ClassBodyDeclarations IClassBodyDeclarations)  { my._ClassBodyDeclarations = _ClassBodyDeclarations }
func (my *ClassBodyDeclarations)      GetClassBodyDeclaration() IClassBodyDeclaration{ return my._ClassBodyDeclaration}
func (my *ClassBodyDeclarations)      SetClassBodyDeclaration( _ClassBodyDeclaration IClassBodyDeclaration)  { my._ClassBodyDeclaration = _ClassBodyDeclaration }

func NewClassBodyDeclarations(leftIToken IToken, rightIToken IToken ,
              _ClassBodyDeclarations IClassBodyDeclarations,
              _ClassBodyDeclaration IClassBodyDeclaration)*ClassBodyDeclarations{
      my := new(ClassBodyDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassBodyDeclarations = _ClassBodyDeclarations;
        if nil != _ClassBodyDeclarations{
        var trait_ interface{} = _ClassBodyDeclarations
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyDeclaration = _ClassBodyDeclaration;
        if nil != _ClassBodyDeclaration{
        var trait_ interface{} = _ClassBodyDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassBodyDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassBodyDeclarations{  list.Add(my._ClassBodyDeclarations) }
        if nil != my._ClassBodyDeclaration{  list.Add(my._ClassBodyDeclaration) }
        return list
    }

func (my *ClassBodyDeclarations)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassBodyDeclarations)       Enter(v Visitor){
        var checkChildren = v.VisitClassBodyDeclarations(my)
        if checkChildren{
            if nil != my._ClassBodyDeclarations{my._ClassBodyDeclarations.Accept(v)}
            if nil != my._ClassBodyDeclaration{my._ClassBodyDeclaration.Accept(v)}
        }
        v.EndVisitClassBodyDeclarations(my)
    }


func AnyCastToClassBodyDeclarations(i interface{}) *ClassBodyDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*ClassBodyDeclarations)
	}
}
/**
 *<em>
*<li>Rule 101:  ClassMemberDeclaration ::= FieldDeclaration
*<li>Rule 102:  ClassMemberDeclaration ::= MethodDeclaration
*<li>Rule 103:  ClassMemberDeclaration ::= ClassDeclaration
*<li>Rule 104:  ClassMemberDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 105:  ClassMemberDeclaration ::= ;
 *</b>
 */
type ClassMemberDeclaration struct{
    *AstToken
}
func (my *ClassMemberDeclaration)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewClassMemberDeclaration(token IToken )*ClassMemberDeclaration{
      my := new(ClassMemberDeclaration)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassMemberDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassMemberDeclaration)       Enter(v Visitor){
        v.VisitClassMemberDeclaration(my)
        v.EndVisitClassMemberDeclaration(my)
    }


func AnyCastToClassMemberDeclaration(i interface{}) *ClassMemberDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*ClassMemberDeclaration)
	}
}
/**
 *<b>
*<li>Rule 106:  FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ;
 *</b>
 */
type FieldDeclaration struct{
    *Ast
      _FieldModifiersopt IFieldModifiersopt
      _Type IType
      _VariableDeclarators IVariableDeclarators
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetFieldModifiersopt</b> may be <b>null</b>
     */
func (my *FieldDeclaration)      GetFieldModifiersopt() IFieldModifiersopt{ return my._FieldModifiersopt}
func (my *FieldDeclaration)      SetFieldModifiersopt( _FieldModifiersopt IFieldModifiersopt)  { my._FieldModifiersopt = _FieldModifiersopt }
func (my *FieldDeclaration)      GetType() IType{ return my._Type}
func (my *FieldDeclaration)      SetType( _Type IType)  { my._Type = _Type }
func (my *FieldDeclaration)      GetVariableDeclarators() IVariableDeclarators{ return my._VariableDeclarators}
func (my *FieldDeclaration)      SetVariableDeclarators( _VariableDeclarators IVariableDeclarators)  { my._VariableDeclarators = _VariableDeclarators }
func (my *FieldDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *FieldDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewFieldDeclaration(leftIToken IToken, rightIToken IToken ,
              _FieldModifiersopt IFieldModifiersopt,
              _Type IType,
              _VariableDeclarators IVariableDeclarators,
              _SEMICOLON *AstToken)*FieldDeclaration{
      my := new(FieldDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._FieldModifiersopt = _FieldModifiersopt;
        if nil != _FieldModifiersopt{
        var trait_ interface{} = _FieldModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclarators = _VariableDeclarators;
        if nil != _VariableDeclarators{
        var trait_ interface{} = _VariableDeclarators
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._FieldModifiersopt{  list.Add(my._FieldModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._VariableDeclarators{  list.Add(my._VariableDeclarators) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *FieldDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitFieldDeclaration(my)
        if checkChildren{
            if nil != my._FieldModifiersopt{my._FieldModifiersopt.Accept(v)}
            if nil != my._Type{my._Type.Accept(v)}
            if nil != my._VariableDeclarators{my._VariableDeclarators.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitFieldDeclaration(my)
    }


func AnyCastToFieldDeclaration(i interface{}) *FieldDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*FieldDeclaration)
	}
}
/**
 *<em>
*<li>Rule 107:  VariableDeclarators ::= VariableDeclarator
 *</em>
 *<p>
 *<b>
*<li>Rule 108:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
 *</b>
 */
type VariableDeclarators struct{
    *Ast
      _VariableDeclarators IVariableDeclarators
      _COMMA *AstToken
      _VariableDeclarator IVariableDeclarator
}
func (my *VariableDeclarators)      GetVariableDeclarators() IVariableDeclarators{ return my._VariableDeclarators}
func (my *VariableDeclarators)      SetVariableDeclarators( _VariableDeclarators IVariableDeclarators)  { my._VariableDeclarators = _VariableDeclarators }
func (my *VariableDeclarators)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *VariableDeclarators)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *VariableDeclarators)      GetVariableDeclarator() IVariableDeclarator{ return my._VariableDeclarator}
func (my *VariableDeclarators)      SetVariableDeclarator( _VariableDeclarator IVariableDeclarator)  { my._VariableDeclarator = _VariableDeclarator }

func NewVariableDeclarators(leftIToken IToken, rightIToken IToken ,
              _VariableDeclarators IVariableDeclarators,
              _COMMA *AstToken,
              _VariableDeclarator IVariableDeclarator)*VariableDeclarators{
      my := new(VariableDeclarators)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableDeclarators = _VariableDeclarators;
        if nil != _VariableDeclarators{
        var trait_ interface{} = _VariableDeclarators
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclarator = _VariableDeclarator;
        if nil != _VariableDeclarator{
        var trait_ interface{} = _VariableDeclarator
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableDeclarators)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableDeclarators{  list.Add(my._VariableDeclarators) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._VariableDeclarator{  list.Add(my._VariableDeclarator) }
        return list
    }

func (my *VariableDeclarators)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *VariableDeclarators)       Enter(v Visitor){
        var checkChildren = v.VisitVariableDeclarators(my)
        if checkChildren{
            if nil != my._VariableDeclarators{my._VariableDeclarators.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._VariableDeclarator{my._VariableDeclarator.Accept(v)}
        }
        v.EndVisitVariableDeclarators(my)
    }


func AnyCastToVariableDeclarators(i interface{}) *VariableDeclarators {
	if nil == i{
		return nil
	}else{
		return i.(*VariableDeclarators)
	}
}
/**
 *<em>
*<li>Rule 109:  VariableDeclarator ::= VariableDeclaratorId
 *</em>
 *<p>
 *<b>
*<li>Rule 110:  VariableDeclarator ::= VariableDeclaratorId = VariableInitializer
 *</b>
 */
type VariableDeclarator struct{
    *Ast
      _VariableDeclaratorId IVariableDeclaratorId
      _EQUAL *AstToken
      _VariableInitializer IVariableInitializer
}
func (my *VariableDeclarator)      GetVariableDeclaratorId() IVariableDeclaratorId{ return my._VariableDeclaratorId}
func (my *VariableDeclarator)      SetVariableDeclaratorId( _VariableDeclaratorId IVariableDeclaratorId)  { my._VariableDeclaratorId = _VariableDeclaratorId }
func (my *VariableDeclarator)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *VariableDeclarator)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }
func (my *VariableDeclarator)      GetVariableInitializer() IVariableInitializer{ return my._VariableInitializer}
func (my *VariableDeclarator)      SetVariableInitializer( _VariableInitializer IVariableInitializer)  { my._VariableInitializer = _VariableInitializer }

func NewVariableDeclarator(leftIToken IToken, rightIToken IToken ,
              _VariableDeclaratorId IVariableDeclaratorId,
              _EQUAL *AstToken,
              _VariableInitializer IVariableInitializer)*VariableDeclarator{
      my := new(VariableDeclarator)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableDeclaratorId = _VariableDeclaratorId;
        if nil != _VariableDeclaratorId{
        var trait_ interface{} = _VariableDeclaratorId
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my._VariableInitializer = _VariableInitializer;
        if nil != _VariableInitializer{
        var trait_ interface{} = _VariableInitializer
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableDeclarator)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableDeclaratorId{  list.Add(my._VariableDeclaratorId) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        if nil != my._VariableInitializer{  list.Add(my._VariableInitializer) }
        return list
    }

func (my *VariableDeclarator)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *VariableDeclarator)       Enter(v Visitor){
        var checkChildren = v.VisitVariableDeclarator(my)
        if checkChildren{
            if nil != my._VariableDeclaratorId{my._VariableDeclaratorId.Accept(v)}
            if nil != my._EQUAL{my._EQUAL.Accept(v)}
            if nil != my._VariableInitializer{my._VariableInitializer.Accept(v)}
        }
        v.EndVisitVariableDeclarator(my)
    }


func AnyCastToVariableDeclarator(i interface{}) *VariableDeclarator {
	if nil == i{
		return nil
	}else{
		return i.(*VariableDeclarator)
	}
}
/**
 *<em>
*<li>Rule 111:  VariableDeclaratorId ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 112:  VariableDeclaratorId ::= VariableDeclaratorId [ ]
 *</b>
 */
type VariableDeclaratorId struct{
    *Ast
      _VariableDeclaratorId IVariableDeclaratorId
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *VariableDeclaratorId)      GetVariableDeclaratorId() IVariableDeclaratorId{ return my._VariableDeclaratorId}
func (my *VariableDeclaratorId)      SetVariableDeclaratorId( _VariableDeclaratorId IVariableDeclaratorId)  { my._VariableDeclaratorId = _VariableDeclaratorId }
func (my *VariableDeclaratorId)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *VariableDeclaratorId)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *VariableDeclaratorId)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *VariableDeclaratorId)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewVariableDeclaratorId(leftIToken IToken, rightIToken IToken ,
              _VariableDeclaratorId IVariableDeclaratorId,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*VariableDeclaratorId{
      my := new(VariableDeclaratorId)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableDeclaratorId = _VariableDeclaratorId;
        if nil != _VariableDeclaratorId{
        var trait_ interface{} = _VariableDeclaratorId
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableDeclaratorId)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableDeclaratorId{  list.Add(my._VariableDeclaratorId) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *VariableDeclaratorId)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *VariableDeclaratorId)       Enter(v Visitor){
        var checkChildren = v.VisitVariableDeclaratorId(my)
        if checkChildren{
            if nil != my._VariableDeclaratorId{my._VariableDeclaratorId.Accept(v)}
            if nil != my._LBRACKET{my._LBRACKET.Accept(v)}
            if nil != my._RBRACKET{my._RBRACKET.Accept(v)}
        }
        v.EndVisitVariableDeclaratorId(my)
    }


func AnyCastToVariableDeclaratorId(i interface{}) *VariableDeclaratorId {
	if nil == i{
		return nil
	}else{
		return i.(*VariableDeclaratorId)
	}
}
/**
 *<em>
*<li>Rule 115:  FieldModifiers ::= FieldModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 116:  FieldModifiers ::= FieldModifiers FieldModifier
 *</b>
 */
type FieldModifiers struct{
    *Ast
      _FieldModifiers IFieldModifiers
      _FieldModifier IFieldModifier
}
func (my *FieldModifiers)      GetFieldModifiers() IFieldModifiers{ return my._FieldModifiers}
func (my *FieldModifiers)      SetFieldModifiers( _FieldModifiers IFieldModifiers)  { my._FieldModifiers = _FieldModifiers }
func (my *FieldModifiers)      GetFieldModifier() IFieldModifier{ return my._FieldModifier}
func (my *FieldModifiers)      SetFieldModifier( _FieldModifier IFieldModifier)  { my._FieldModifier = _FieldModifier }

func NewFieldModifiers(leftIToken IToken, rightIToken IToken ,
              _FieldModifiers IFieldModifiers,
              _FieldModifier IFieldModifier)*FieldModifiers{
      my := new(FieldModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._FieldModifiers = _FieldModifiers;
        if nil != _FieldModifiers{
        var trait_ interface{} = _FieldModifiers
         trait_.(IAst).SetParent(my)
}
        my._FieldModifier = _FieldModifier;
        if nil != _FieldModifier{
        var trait_ interface{} = _FieldModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._FieldModifiers{  list.Add(my._FieldModifiers) }
        if nil != my._FieldModifier{  list.Add(my._FieldModifier) }
        return list
    }

func (my *FieldModifiers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldModifiers)       Enter(v Visitor){
        var checkChildren = v.VisitFieldModifiers(my)
        if checkChildren{
            if nil != my._FieldModifiers{my._FieldModifiers.Accept(v)}
            if nil != my._FieldModifier{my._FieldModifier.Accept(v)}
        }
        v.EndVisitFieldModifiers(my)
    }


func AnyCastToFieldModifiers(i interface{}) *FieldModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifiers)
	}
}
/**
 *<b>
*<li>Rule 125:  MethodDeclaration ::= MethodHeader MethodBody
 *</b>
 */
type MethodDeclaration struct{
    *Ast
      _MethodHeader *MethodHeader
      _MethodBody IMethodBody
}
func (my *MethodDeclaration)      GetMethodHeader() *MethodHeader{ return my._MethodHeader}
func (my *MethodDeclaration)      SetMethodHeader( _MethodHeader *MethodHeader)  { my._MethodHeader = _MethodHeader }
func (my *MethodDeclaration)      GetMethodBody() IMethodBody{ return my._MethodBody}
func (my *MethodDeclaration)      SetMethodBody( _MethodBody IMethodBody)  { my._MethodBody = _MethodBody }

func NewMethodDeclaration(leftIToken IToken, rightIToken IToken ,
              _MethodHeader *MethodHeader,
              _MethodBody IMethodBody)*MethodDeclaration{
      my := new(MethodDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodHeader = _MethodHeader;
        if nil != _MethodHeader{
        var trait_ interface{} = _MethodHeader
         trait_.(IAst).SetParent(my)
}
        my._MethodBody = _MethodBody;
        if nil != _MethodBody{
        var trait_ interface{} = _MethodBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodHeader{  list.Add(my._MethodHeader) }
        if nil != my._MethodBody{  list.Add(my._MethodBody) }
        return list
    }

func (my *MethodDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitMethodDeclaration(my)
        if checkChildren{
            if nil != my._MethodHeader{my._MethodHeader.Accept(v)}
            if nil != my._MethodBody{my._MethodBody.Accept(v)}
        }
        v.EndVisitMethodDeclaration(my)
    }


func AnyCastToMethodDeclaration(i interface{}) *MethodDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*MethodDeclaration)
	}
}
/**
 *<b>
*<li>Rule 126:  MethodHeader ::= MethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt
 *</b>
 */
type MethodHeader struct{
    *Ast
      _MethodModifiersopt IMethodModifiersopt
      _TypeParametersopt *TypeParameters
      _ResultType IResultType
      _MethodDeclarator IMethodDeclarator
      _Throwsopt *Throws
}
    /**
     * The value returned by <b>GetMethodModifiersopt</b> may be <b>null</b>
     */
func (my *MethodHeader)      GetMethodModifiersopt() IMethodModifiersopt{ return my._MethodModifiersopt}
func (my *MethodHeader)      SetMethodModifiersopt( _MethodModifiersopt IMethodModifiersopt)  { my._MethodModifiersopt = _MethodModifiersopt }
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *MethodHeader)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *MethodHeader)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
func (my *MethodHeader)      GetResultType() IResultType{ return my._ResultType}
func (my *MethodHeader)      SetResultType( _ResultType IResultType)  { my._ResultType = _ResultType }
func (my *MethodHeader)      GetMethodDeclarator() IMethodDeclarator{ return my._MethodDeclarator}
func (my *MethodHeader)      SetMethodDeclarator( _MethodDeclarator IMethodDeclarator)  { my._MethodDeclarator = _MethodDeclarator }
    /**
     * The value returned by <b>GetThrowsopt</b> may be <b>null</b>
     */
func (my *MethodHeader)      GetThrowsopt() *Throws{ return my._Throwsopt}
func (my *MethodHeader)      SetThrowsopt( _Throwsopt *Throws)  { my._Throwsopt = _Throwsopt }

func NewMethodHeader(leftIToken IToken, rightIToken IToken ,
              _MethodModifiersopt IMethodModifiersopt,
              _TypeParametersopt *TypeParameters,
              _ResultType IResultType,
              _MethodDeclarator IMethodDeclarator,
              _Throwsopt *Throws)*MethodHeader{
      my := new(MethodHeader)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodModifiersopt = _MethodModifiersopt;
        if nil != _MethodModifiersopt{
        var trait_ interface{} = _MethodModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._ResultType = _ResultType;
        if nil != _ResultType{
        var trait_ interface{} = _ResultType
         trait_.(IAst).SetParent(my)
}
        my._MethodDeclarator = _MethodDeclarator;
        if nil != _MethodDeclarator{
        var trait_ interface{} = _MethodDeclarator
         trait_.(IAst).SetParent(my)
}
        my._Throwsopt = _Throwsopt;
        if nil != _Throwsopt{
        var trait_ interface{} = _Throwsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodHeader)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodModifiersopt{  list.Add(my._MethodModifiersopt) }
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._ResultType{  list.Add(my._ResultType) }
        if nil != my._MethodDeclarator{  list.Add(my._MethodDeclarator) }
        if nil != my._Throwsopt{  list.Add(my._Throwsopt) }
        return list
    }

func (my *MethodHeader)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodHeader)       Enter(v Visitor){
        var checkChildren = v.VisitMethodHeader(my)
        if checkChildren{
            if nil != my._MethodModifiersopt{my._MethodModifiersopt.Accept(v)}
            if nil != my._TypeParametersopt{my._TypeParametersopt.Accept(v)}
            if nil != my._ResultType{my._ResultType.Accept(v)}
            if nil != my._MethodDeclarator{my._MethodDeclarator.Accept(v)}
            if nil != my._Throwsopt{my._Throwsopt.Accept(v)}
        }
        v.EndVisitMethodHeader(my)
    }


func AnyCastToMethodHeader(i interface{}) *MethodHeader {
	if nil == i{
		return nil
	}else{
		return i.(*MethodHeader)
	}
}
/**
 *<em>
*<li>Rule 127:  ResultType ::= Type
 *</em>
 *<p>
 *<b>
*<li>Rule 128:  ResultType ::= void
 *</b>
 */
type ResultType struct{
    *AstToken
}
func (my *ResultType)      Getvoid()IToken{ return my.leftIToken; }

func NewResultType(token IToken )*ResultType{
      my := new(ResultType)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ResultType)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ResultType)       Enter(v Visitor){
        v.VisitResultType(my)
        v.EndVisitResultType(my)
    }


func AnyCastToResultType(i interface{}) *ResultType {
	if nil == i{
		return nil
	}else{
		return i.(*ResultType)
	}
}
/**
 *<em>
*<li>Rule 131:  FormalParameterList ::= LastFormalParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 132:  FormalParameterList ::= FormalParameters , LastFormalParameter
 *</b>
 */
type FormalParameterList struct{
    *Ast
      _FormalParameters IFormalParameters
      _COMMA *AstToken
      _LastFormalParameter *LastFormalParameter
}
func (my *FormalParameterList)      GetFormalParameters() IFormalParameters{ return my._FormalParameters}
func (my *FormalParameterList)      SetFormalParameters( _FormalParameters IFormalParameters)  { my._FormalParameters = _FormalParameters }
func (my *FormalParameterList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *FormalParameterList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *FormalParameterList)      GetLastFormalParameter() *LastFormalParameter{ return my._LastFormalParameter}
func (my *FormalParameterList)      SetLastFormalParameter( _LastFormalParameter *LastFormalParameter)  { my._LastFormalParameter = _LastFormalParameter }

func NewFormalParameterList(leftIToken IToken, rightIToken IToken ,
              _FormalParameters IFormalParameters,
              _COMMA *AstToken,
              _LastFormalParameter *LastFormalParameter)*FormalParameterList{
      my := new(FormalParameterList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._FormalParameters = _FormalParameters;
        if nil != _FormalParameters{
        var trait_ interface{} = _FormalParameters
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._LastFormalParameter = _LastFormalParameter;
        if nil != _LastFormalParameter{
        var trait_ interface{} = _LastFormalParameter
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FormalParameterList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._FormalParameters{  list.Add(my._FormalParameters) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._LastFormalParameter{  list.Add(my._LastFormalParameter) }
        return list
    }

func (my *FormalParameterList)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FormalParameterList)       Enter(v Visitor){
        var checkChildren = v.VisitFormalParameterList(my)
        if checkChildren{
            if nil != my._FormalParameters{my._FormalParameters.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._LastFormalParameter{my._LastFormalParameter.Accept(v)}
        }
        v.EndVisitFormalParameterList(my)
    }


func AnyCastToFormalParameterList(i interface{}) *FormalParameterList {
	if nil == i{
		return nil
	}else{
		return i.(*FormalParameterList)
	}
}
/**
 *<em>
*<li>Rule 133:  FormalParameters ::= FormalParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 134:  FormalParameters ::= FormalParameters , FormalParameter
 *</b>
 */
type FormalParameters struct{
    *Ast
      _FormalParameters IFormalParameters
      _COMMA *AstToken
      _FormalParameter *FormalParameter
}
func (my *FormalParameters)      GetFormalParameters() IFormalParameters{ return my._FormalParameters}
func (my *FormalParameters)      SetFormalParameters( _FormalParameters IFormalParameters)  { my._FormalParameters = _FormalParameters }
func (my *FormalParameters)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *FormalParameters)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *FormalParameters)      GetFormalParameter() *FormalParameter{ return my._FormalParameter}
func (my *FormalParameters)      SetFormalParameter( _FormalParameter *FormalParameter)  { my._FormalParameter = _FormalParameter }

func NewFormalParameters(leftIToken IToken, rightIToken IToken ,
              _FormalParameters IFormalParameters,
              _COMMA *AstToken,
              _FormalParameter *FormalParameter)*FormalParameters{
      my := new(FormalParameters)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._FormalParameters = _FormalParameters;
        if nil != _FormalParameters{
        var trait_ interface{} = _FormalParameters
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._FormalParameter = _FormalParameter;
        if nil != _FormalParameter{
        var trait_ interface{} = _FormalParameter
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FormalParameters)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._FormalParameters{  list.Add(my._FormalParameters) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._FormalParameter{  list.Add(my._FormalParameter) }
        return list
    }

func (my *FormalParameters)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FormalParameters)       Enter(v Visitor){
        var checkChildren = v.VisitFormalParameters(my)
        if checkChildren{
            if nil != my._FormalParameters{my._FormalParameters.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._FormalParameter{my._FormalParameter.Accept(v)}
        }
        v.EndVisitFormalParameters(my)
    }


func AnyCastToFormalParameters(i interface{}) *FormalParameters {
	if nil == i{
		return nil
	}else{
		return i.(*FormalParameters)
	}
}
/**
 *<b>
*<li>Rule 135:  FormalParameter ::= VariableModifiersopt Type VariableDeclaratorId
 *</b>
 */
type FormalParameter struct{
    *Ast
      _VariableModifiersopt IVariableModifiersopt
      _Type IType
      _VariableDeclaratorId IVariableDeclaratorId
}
    /**
     * The value returned by <b>GetVariableModifiersopt</b> may be <b>null</b>
     */
func (my *FormalParameter)      GetVariableModifiersopt() IVariableModifiersopt{ return my._VariableModifiersopt}
func (my *FormalParameter)      SetVariableModifiersopt( _VariableModifiersopt IVariableModifiersopt)  { my._VariableModifiersopt = _VariableModifiersopt }
func (my *FormalParameter)      GetType() IType{ return my._Type}
func (my *FormalParameter)      SetType( _Type IType)  { my._Type = _Type }
func (my *FormalParameter)      GetVariableDeclaratorId() IVariableDeclaratorId{ return my._VariableDeclaratorId}
func (my *FormalParameter)      SetVariableDeclaratorId( _VariableDeclaratorId IVariableDeclaratorId)  { my._VariableDeclaratorId = _VariableDeclaratorId }

func NewFormalParameter(leftIToken IToken, rightIToken IToken ,
              _VariableModifiersopt IVariableModifiersopt,
              _Type IType,
              _VariableDeclaratorId IVariableDeclaratorId)*FormalParameter{
      my := new(FormalParameter)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableModifiersopt = _VariableModifiersopt;
        if nil != _VariableModifiersopt{
        var trait_ interface{} = _VariableModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclaratorId = _VariableDeclaratorId;
        if nil != _VariableDeclaratorId{
        var trait_ interface{} = _VariableDeclaratorId
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FormalParameter)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableModifiersopt{  list.Add(my._VariableModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._VariableDeclaratorId{  list.Add(my._VariableDeclaratorId) }
        return list
    }

func (my *FormalParameter)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FormalParameter)       Enter(v Visitor){
        var checkChildren = v.VisitFormalParameter(my)
        if checkChildren{
            if nil != my._VariableModifiersopt{my._VariableModifiersopt.Accept(v)}
            if nil != my._Type{my._Type.Accept(v)}
            if nil != my._VariableDeclaratorId{my._VariableDeclaratorId.Accept(v)}
        }
        v.EndVisitFormalParameter(my)
    }


func AnyCastToFormalParameter(i interface{}) *FormalParameter {
	if nil == i{
		return nil
	}else{
		return i.(*FormalParameter)
	}
}
/**
 *<em>
*<li>Rule 136:  VariableModifiers ::= VariableModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 137:  VariableModifiers ::= VariableModifiers VariableModifier
 *</b>
 */
type VariableModifiers struct{
    *Ast
      _VariableModifiers IVariableModifiers
      _VariableModifier IVariableModifier
}
func (my *VariableModifiers)      GetVariableModifiers() IVariableModifiers{ return my._VariableModifiers}
func (my *VariableModifiers)      SetVariableModifiers( _VariableModifiers IVariableModifiers)  { my._VariableModifiers = _VariableModifiers }
func (my *VariableModifiers)      GetVariableModifier() IVariableModifier{ return my._VariableModifier}
func (my *VariableModifiers)      SetVariableModifier( _VariableModifier IVariableModifier)  { my._VariableModifier = _VariableModifier }

func NewVariableModifiers(leftIToken IToken, rightIToken IToken ,
              _VariableModifiers IVariableModifiers,
              _VariableModifier IVariableModifier)*VariableModifiers{
      my := new(VariableModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableModifiers = _VariableModifiers;
        if nil != _VariableModifiers{
        var trait_ interface{} = _VariableModifiers
         trait_.(IAst).SetParent(my)
}
        my._VariableModifier = _VariableModifier;
        if nil != _VariableModifier{
        var trait_ interface{} = _VariableModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableModifiers{  list.Add(my._VariableModifiers) }
        if nil != my._VariableModifier{  list.Add(my._VariableModifier) }
        return list
    }

func (my *VariableModifiers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *VariableModifiers)       Enter(v Visitor){
        var checkChildren = v.VisitVariableModifiers(my)
        if checkChildren{
            if nil != my._VariableModifiers{my._VariableModifiers.Accept(v)}
            if nil != my._VariableModifier{my._VariableModifier.Accept(v)}
        }
        v.EndVisitVariableModifiers(my)
    }


func AnyCastToVariableModifiers(i interface{}) *VariableModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*VariableModifiers)
	}
}
/**
 *<em>
*<li>Rule 139:  VariableModifier ::= Annotations
 *</em>
 *<p>
 *<b>
*<li>Rule 138:  VariableModifier ::= final
 *</b>
 */
type VariableModifier struct{
    *AstToken
}
func (my *VariableModifier)      Getfinal()IToken{ return my.leftIToken; }

func NewVariableModifier(token IToken )*VariableModifier{
      my := new(VariableModifier)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *VariableModifier)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *VariableModifier)       Enter(v Visitor){
        v.VisitVariableModifier(my)
        v.EndVisitVariableModifier(my)
    }


func AnyCastToVariableModifier(i interface{}) *VariableModifier {
	if nil == i{
		return nil
	}else{
		return i.(*VariableModifier)
	}
}
/**
 *<b>
*<li>Rule 140:  LastFormalParameter ::= VariableModifiersopt Type ...opt VariableDeclaratorId
 *</b>
 */
type LastFormalParameter struct{
    *Ast
      _VariableModifiersopt IVariableModifiersopt
      _Type IType
      _Ellipsisopt *Ellipsisopt
      _VariableDeclaratorId IVariableDeclaratorId
}
    /**
     * The value returned by <b>GetVariableModifiersopt</b> may be <b>null</b>
     */
func (my *LastFormalParameter)      GetVariableModifiersopt() IVariableModifiersopt{ return my._VariableModifiersopt}
func (my *LastFormalParameter)      SetVariableModifiersopt( _VariableModifiersopt IVariableModifiersopt)  { my._VariableModifiersopt = _VariableModifiersopt }
func (my *LastFormalParameter)      GetType() IType{ return my._Type}
func (my *LastFormalParameter)      SetType( _Type IType)  { my._Type = _Type }
    /**
     * The value returned by <b>GetEllipsisopt</b> may be <b>null</b>
     */
func (my *LastFormalParameter)      GetEllipsisopt() *Ellipsisopt{ return my._Ellipsisopt}
func (my *LastFormalParameter)      SetEllipsisopt( _Ellipsisopt *Ellipsisopt)  { my._Ellipsisopt = _Ellipsisopt }
func (my *LastFormalParameter)      GetVariableDeclaratorId() IVariableDeclaratorId{ return my._VariableDeclaratorId}
func (my *LastFormalParameter)      SetVariableDeclaratorId( _VariableDeclaratorId IVariableDeclaratorId)  { my._VariableDeclaratorId = _VariableDeclaratorId }

func NewLastFormalParameter(leftIToken IToken, rightIToken IToken ,
              _VariableModifiersopt IVariableModifiersopt,
              _Type IType,
              _Ellipsisopt *Ellipsisopt,
              _VariableDeclaratorId IVariableDeclaratorId)*LastFormalParameter{
      my := new(LastFormalParameter)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableModifiersopt = _VariableModifiersopt;
        if nil != _VariableModifiersopt{
        var trait_ interface{} = _VariableModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._Ellipsisopt = _Ellipsisopt;
        if nil != _Ellipsisopt{
        var trait_ interface{} = _Ellipsisopt
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclaratorId = _VariableDeclaratorId;
        if nil != _VariableDeclaratorId{
        var trait_ interface{} = _VariableDeclaratorId
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LastFormalParameter)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableModifiersopt{  list.Add(my._VariableModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._Ellipsisopt{  list.Add(my._Ellipsisopt) }
        if nil != my._VariableDeclaratorId{  list.Add(my._VariableDeclaratorId) }
        return list
    }

func (my *LastFormalParameter)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LastFormalParameter)       Enter(v Visitor){
        var checkChildren = v.VisitLastFormalParameter(my)
        if checkChildren{
            if nil != my._VariableModifiersopt{my._VariableModifiersopt.Accept(v)}
            if nil != my._Type{my._Type.Accept(v)}
            if nil != my._Ellipsisopt{my._Ellipsisopt.Accept(v)}
            if nil != my._VariableDeclaratorId{my._VariableDeclaratorId.Accept(v)}
        }
        v.EndVisitLastFormalParameter(my)
    }


func AnyCastToLastFormalParameter(i interface{}) *LastFormalParameter {
	if nil == i{
		return nil
	}else{
		return i.(*LastFormalParameter)
	}
}
/**
 *<em>
*<li>Rule 141:  MethodModifiers ::= MethodModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 142:  MethodModifiers ::= MethodModifiers MethodModifier
 *</b>
 */
type MethodModifiers struct{
    *Ast
      _MethodModifiers IMethodModifiers
      _MethodModifier IMethodModifier
}
func (my *MethodModifiers)      GetMethodModifiers() IMethodModifiers{ return my._MethodModifiers}
func (my *MethodModifiers)      SetMethodModifiers( _MethodModifiers IMethodModifiers)  { my._MethodModifiers = _MethodModifiers }
func (my *MethodModifiers)      GetMethodModifier() IMethodModifier{ return my._MethodModifier}
func (my *MethodModifiers)      SetMethodModifier( _MethodModifier IMethodModifier)  { my._MethodModifier = _MethodModifier }

func NewMethodModifiers(leftIToken IToken, rightIToken IToken ,
              _MethodModifiers IMethodModifiers,
              _MethodModifier IMethodModifier)*MethodModifiers{
      my := new(MethodModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodModifiers = _MethodModifiers;
        if nil != _MethodModifiers{
        var trait_ interface{} = _MethodModifiers
         trait_.(IAst).SetParent(my)
}
        my._MethodModifier = _MethodModifier;
        if nil != _MethodModifier{
        var trait_ interface{} = _MethodModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodModifiers{  list.Add(my._MethodModifiers) }
        if nil != my._MethodModifier{  list.Add(my._MethodModifier) }
        return list
    }

func (my *MethodModifiers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifiers)       Enter(v Visitor){
        var checkChildren = v.VisitMethodModifiers(my)
        if checkChildren{
            if nil != my._MethodModifiers{my._MethodModifiers.Accept(v)}
            if nil != my._MethodModifier{my._MethodModifier.Accept(v)}
        }
        v.EndVisitMethodModifiers(my)
    }


func AnyCastToMethodModifiers(i interface{}) *MethodModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifiers)
	}
}
/**
 *<b>
*<li>Rule 153:  Throws ::= throws ExceptionTypeList
 *</b>
 */
type Throws struct{
    *Ast
      _throws *AstToken
      _ExceptionTypeList IExceptionTypeList
}
func (my *Throws)      Getthrows() *AstToken{ return my._throws}
func (my *Throws)      Setthrows( _throws *AstToken)  { my._throws = _throws }
func (my *Throws)      GetExceptionTypeList() IExceptionTypeList{ return my._ExceptionTypeList}
func (my *Throws)      SetExceptionTypeList( _ExceptionTypeList IExceptionTypeList)  { my._ExceptionTypeList = _ExceptionTypeList }

func NewThrows(leftIToken IToken, rightIToken IToken ,
              _throws *AstToken,
              _ExceptionTypeList IExceptionTypeList)*Throws{
      my := new(Throws)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._throws = _throws;
        if nil != _throws{
        var trait_ interface{} = _throws
         trait_.(IAst).SetParent(my)
}
        my._ExceptionTypeList = _ExceptionTypeList;
        if nil != _ExceptionTypeList{
        var trait_ interface{} = _ExceptionTypeList
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Throws)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._throws{  list.Add(my._throws) }
        if nil != my._ExceptionTypeList{  list.Add(my._ExceptionTypeList) }
        return list
    }

func (my *Throws)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Throws)       Enter(v Visitor){
        var checkChildren = v.VisitThrows(my)
        if checkChildren{
            if nil != my._throws{my._throws.Accept(v)}
            if nil != my._ExceptionTypeList{my._ExceptionTypeList.Accept(v)}
        }
        v.EndVisitThrows(my)
    }


func AnyCastToThrows(i interface{}) *Throws {
	if nil == i{
		return nil
	}else{
		return i.(*Throws)
	}
}
/**
 *<em>
*<li>Rule 154:  ExceptionTypeList ::= ExceptionType
 *</em>
 *<p>
 *<b>
*<li>Rule 155:  ExceptionTypeList ::= ExceptionTypeList , ExceptionType
 *</b>
 */
type ExceptionTypeList struct{
    *Ast
      _ExceptionTypeList IExceptionTypeList
      _COMMA *AstToken
      _ExceptionType IExceptionType
}
func (my *ExceptionTypeList)      GetExceptionTypeList() IExceptionTypeList{ return my._ExceptionTypeList}
func (my *ExceptionTypeList)      SetExceptionTypeList( _ExceptionTypeList IExceptionTypeList)  { my._ExceptionTypeList = _ExceptionTypeList }
func (my *ExceptionTypeList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ExceptionTypeList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ExceptionTypeList)      GetExceptionType() IExceptionType{ return my._ExceptionType}
func (my *ExceptionTypeList)      SetExceptionType( _ExceptionType IExceptionType)  { my._ExceptionType = _ExceptionType }

func NewExceptionTypeList(leftIToken IToken, rightIToken IToken ,
              _ExceptionTypeList IExceptionTypeList,
              _COMMA *AstToken,
              _ExceptionType IExceptionType)*ExceptionTypeList{
      my := new(ExceptionTypeList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ExceptionTypeList = _ExceptionTypeList;
        if nil != _ExceptionTypeList{
        var trait_ interface{} = _ExceptionTypeList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._ExceptionType = _ExceptionType;
        if nil != _ExceptionType{
        var trait_ interface{} = _ExceptionType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExceptionTypeList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ExceptionTypeList{  list.Add(my._ExceptionTypeList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._ExceptionType{  list.Add(my._ExceptionType) }
        return list
    }

func (my *ExceptionTypeList)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExceptionTypeList)       Enter(v Visitor){
        var checkChildren = v.VisitExceptionTypeList(my)
        if checkChildren{
            if nil != my._ExceptionTypeList{my._ExceptionTypeList.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._ExceptionType{my._ExceptionType.Accept(v)}
        }
        v.EndVisitExceptionTypeList(my)
    }


func AnyCastToExceptionTypeList(i interface{}) *ExceptionTypeList {
	if nil == i{
		return nil
	}else{
		return i.(*ExceptionTypeList)
	}
}
/**
 *<em>
*<li>Rule 158:  MethodBody ::= Block
 *</em>
 *<p>
 *<b>
*<li>Rule 159:  MethodBody ::= ;
 *</b>
 */
type MethodBody struct{
    *AstToken
}
func (my *MethodBody)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewMethodBody(token IToken )*MethodBody{
      my := new(MethodBody)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodBody)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodBody)       Enter(v Visitor){
        v.VisitMethodBody(my)
        v.EndVisitMethodBody(my)
    }


func AnyCastToMethodBody(i interface{}) *MethodBody {
	if nil == i{
		return nil
	}else{
		return i.(*MethodBody)
	}
}
/**
 *<b>
*<li>Rule 161:  StaticInitializer ::= static Block
 *</b>
 */
type StaticInitializer struct{
    *Ast
      _static *AstToken
      _Block *Block
}
func (my *StaticInitializer)      Getstatic() *AstToken{ return my._static}
func (my *StaticInitializer)      Setstatic( _static *AstToken)  { my._static = _static }
func (my *StaticInitializer)      GetBlock() *Block{ return my._Block}
func (my *StaticInitializer)      SetBlock( _Block *Block)  { my._Block = _Block }

func NewStaticInitializer(leftIToken IToken, rightIToken IToken ,
              _static *AstToken,
              _Block *Block)*StaticInitializer{
      my := new(StaticInitializer)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._static = _static;
        if nil != _static{
        var trait_ interface{} = _static
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *StaticInitializer)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._static{  list.Add(my._static) }
        if nil != my._Block{  list.Add(my._Block) }
        return list
    }

func (my *StaticInitializer)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *StaticInitializer)       Enter(v Visitor){
        var checkChildren = v.VisitStaticInitializer(my)
        if checkChildren{
            if nil != my._static{my._static.Accept(v)}
            if nil != my._Block{my._Block.Accept(v)}
        }
        v.EndVisitStaticInitializer(my)
    }


func AnyCastToStaticInitializer(i interface{}) *StaticInitializer {
	if nil == i{
		return nil
	}else{
		return i.(*StaticInitializer)
	}
}
/**
 *<b>
*<li>Rule 162:  ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator Throwsopt ConstructorBody
 *</b>
 */
type ConstructorDeclaration struct{
    *Ast
      _ConstructorModifiersopt IConstructorModifiersopt
      _ConstructorDeclarator *ConstructorDeclarator
      _Throwsopt *Throws
      _ConstructorBody *ConstructorBody
}
    /**
     * The value returned by <b>GetConstructorModifiersopt</b> may be <b>null</b>
     */
func (my *ConstructorDeclaration)      GetConstructorModifiersopt() IConstructorModifiersopt{ return my._ConstructorModifiersopt}
func (my *ConstructorDeclaration)      SetConstructorModifiersopt( _ConstructorModifiersopt IConstructorModifiersopt)  { my._ConstructorModifiersopt = _ConstructorModifiersopt }
func (my *ConstructorDeclaration)      GetConstructorDeclarator() *ConstructorDeclarator{ return my._ConstructorDeclarator}
func (my *ConstructorDeclaration)      SetConstructorDeclarator( _ConstructorDeclarator *ConstructorDeclarator)  { my._ConstructorDeclarator = _ConstructorDeclarator }
    /**
     * The value returned by <b>GetThrowsopt</b> may be <b>null</b>
     */
func (my *ConstructorDeclaration)      GetThrowsopt() *Throws{ return my._Throwsopt}
func (my *ConstructorDeclaration)      SetThrowsopt( _Throwsopt *Throws)  { my._Throwsopt = _Throwsopt }
func (my *ConstructorDeclaration)      GetConstructorBody() *ConstructorBody{ return my._ConstructorBody}
func (my *ConstructorDeclaration)      SetConstructorBody( _ConstructorBody *ConstructorBody)  { my._ConstructorBody = _ConstructorBody }

func NewConstructorDeclaration(leftIToken IToken, rightIToken IToken ,
              _ConstructorModifiersopt IConstructorModifiersopt,
              _ConstructorDeclarator *ConstructorDeclarator,
              _Throwsopt *Throws,
              _ConstructorBody *ConstructorBody)*ConstructorDeclaration{
      my := new(ConstructorDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConstructorModifiersopt = _ConstructorModifiersopt;
        if nil != _ConstructorModifiersopt{
        var trait_ interface{} = _ConstructorModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._ConstructorDeclarator = _ConstructorDeclarator;
        if nil != _ConstructorDeclarator{
        var trait_ interface{} = _ConstructorDeclarator
         trait_.(IAst).SetParent(my)
}
        my._Throwsopt = _Throwsopt;
        if nil != _Throwsopt{
        var trait_ interface{} = _Throwsopt
         trait_.(IAst).SetParent(my)
}
        my._ConstructorBody = _ConstructorBody;
        if nil != _ConstructorBody{
        var trait_ interface{} = _ConstructorBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstructorDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConstructorModifiersopt{  list.Add(my._ConstructorModifiersopt) }
        if nil != my._ConstructorDeclarator{  list.Add(my._ConstructorDeclarator) }
        if nil != my._Throwsopt{  list.Add(my._Throwsopt) }
        if nil != my._ConstructorBody{  list.Add(my._ConstructorBody) }
        return list
    }

func (my *ConstructorDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstructorDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitConstructorDeclaration(my)
        if checkChildren{
            if nil != my._ConstructorModifiersopt{my._ConstructorModifiersopt.Accept(v)}
            if nil != my._ConstructorDeclarator{my._ConstructorDeclarator.Accept(v)}
            if nil != my._Throwsopt{my._Throwsopt.Accept(v)}
            if nil != my._ConstructorBody{my._ConstructorBody.Accept(v)}
        }
        v.EndVisitConstructorDeclaration(my)
    }


func AnyCastToConstructorDeclaration(i interface{}) *ConstructorDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorDeclaration)
	}
}
/**
 *<b>
*<li>Rule 163:  ConstructorDeclarator ::= TypeParametersopt SimpleTypeName ( FormalParameterListopt )
 *</b>
 */
type ConstructorDeclarator struct{
    *Ast
      _TypeParametersopt *TypeParameters
      _SimpleTypeName *identifier
      _LPAREN *AstToken
      _FormalParameterListopt IFormalParameterListopt
      _RPAREN *AstToken
}
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *ConstructorDeclarator)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *ConstructorDeclarator)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
func (my *ConstructorDeclarator)      GetSimpleTypeName() *identifier{ return my._SimpleTypeName}
func (my *ConstructorDeclarator)      SetSimpleTypeName( _SimpleTypeName *identifier)  { my._SimpleTypeName = _SimpleTypeName }
func (my *ConstructorDeclarator)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ConstructorDeclarator)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetFormalParameterListopt</b> may be <b>null</b>
     */
func (my *ConstructorDeclarator)      GetFormalParameterListopt() IFormalParameterListopt{ return my._FormalParameterListopt}
func (my *ConstructorDeclarator)      SetFormalParameterListopt( _FormalParameterListopt IFormalParameterListopt)  { my._FormalParameterListopt = _FormalParameterListopt }
func (my *ConstructorDeclarator)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ConstructorDeclarator)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewConstructorDeclarator(leftIToken IToken, rightIToken IToken ,
              _TypeParametersopt *TypeParameters,
              _SimpleTypeName *identifier,
              _LPAREN *AstToken,
              _FormalParameterListopt IFormalParameterListopt,
              _RPAREN *AstToken)*ConstructorDeclarator{
      my := new(ConstructorDeclarator)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._SimpleTypeName = _SimpleTypeName;
        if nil != _SimpleTypeName{
        var trait_ interface{} = _SimpleTypeName
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._FormalParameterListopt = _FormalParameterListopt;
        if nil != _FormalParameterListopt{
        var trait_ interface{} = _FormalParameterListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstructorDeclarator)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._SimpleTypeName{  list.Add(my._SimpleTypeName) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._FormalParameterListopt{  list.Add(my._FormalParameterListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *ConstructorDeclarator)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstructorDeclarator)       Enter(v Visitor){
        var checkChildren = v.VisitConstructorDeclarator(my)
        if checkChildren{
            if nil != my._TypeParametersopt{my._TypeParametersopt.Accept(v)}
            if nil != my._SimpleTypeName{my._SimpleTypeName.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._FormalParameterListopt{my._FormalParameterListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitConstructorDeclarator(my)
    }


func AnyCastToConstructorDeclarator(i interface{}) *ConstructorDeclarator {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorDeclarator)
	}
}
/**
 *<em>
*<li>Rule 165:  ConstructorModifiers ::= ConstructorModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 166:  ConstructorModifiers ::= ConstructorModifiers ConstructorModifier
 *</b>
 */
type ConstructorModifiers struct{
    *Ast
      _ConstructorModifiers IConstructorModifiers
      _ConstructorModifier IConstructorModifier
}
func (my *ConstructorModifiers)      GetConstructorModifiers() IConstructorModifiers{ return my._ConstructorModifiers}
func (my *ConstructorModifiers)      SetConstructorModifiers( _ConstructorModifiers IConstructorModifiers)  { my._ConstructorModifiers = _ConstructorModifiers }
func (my *ConstructorModifiers)      GetConstructorModifier() IConstructorModifier{ return my._ConstructorModifier}
func (my *ConstructorModifiers)      SetConstructorModifier( _ConstructorModifier IConstructorModifier)  { my._ConstructorModifier = _ConstructorModifier }

func NewConstructorModifiers(leftIToken IToken, rightIToken IToken ,
              _ConstructorModifiers IConstructorModifiers,
              _ConstructorModifier IConstructorModifier)*ConstructorModifiers{
      my := new(ConstructorModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConstructorModifiers = _ConstructorModifiers;
        if nil != _ConstructorModifiers{
        var trait_ interface{} = _ConstructorModifiers
         trait_.(IAst).SetParent(my)
}
        my._ConstructorModifier = _ConstructorModifier;
        if nil != _ConstructorModifier{
        var trait_ interface{} = _ConstructorModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstructorModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConstructorModifiers{  list.Add(my._ConstructorModifiers) }
        if nil != my._ConstructorModifier{  list.Add(my._ConstructorModifier) }
        return list
    }

func (my *ConstructorModifiers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstructorModifiers)       Enter(v Visitor){
        var checkChildren = v.VisitConstructorModifiers(my)
        if checkChildren{
            if nil != my._ConstructorModifiers{my._ConstructorModifiers.Accept(v)}
            if nil != my._ConstructorModifier{my._ConstructorModifier.Accept(v)}
        }
        v.EndVisitConstructorModifiers(my)
    }


func AnyCastToConstructorModifiers(i interface{}) *ConstructorModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorModifiers)
	}
}
/**
 *<b>
*<li>Rule 171:  ConstructorBody ::= { ExplicitConstructorInvocationopt BlockStatementsopt }
 *</b>
 */
type ConstructorBody struct{
    *Ast
      _LBRACE *AstToken
      _ExplicitConstructorInvocationopt IExplicitConstructorInvocationopt
      _BlockStatementsopt IBlockStatementsopt
      _RBRACE *AstToken
}
func (my *ConstructorBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *ConstructorBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetExplicitConstructorInvocationopt</b> may be <b>null</b>
     */
func (my *ConstructorBody)      GetExplicitConstructorInvocationopt() IExplicitConstructorInvocationopt{ return my._ExplicitConstructorInvocationopt}
func (my *ConstructorBody)      SetExplicitConstructorInvocationopt( _ExplicitConstructorInvocationopt IExplicitConstructorInvocationopt)  { my._ExplicitConstructorInvocationopt = _ExplicitConstructorInvocationopt }
    /**
     * The value returned by <b>GetBlockStatementsopt</b> may be <b>null</b>
     */
func (my *ConstructorBody)      GetBlockStatementsopt() IBlockStatementsopt{ return my._BlockStatementsopt}
func (my *ConstructorBody)      SetBlockStatementsopt( _BlockStatementsopt IBlockStatementsopt)  { my._BlockStatementsopt = _BlockStatementsopt }
func (my *ConstructorBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *ConstructorBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewConstructorBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _ExplicitConstructorInvocationopt IExplicitConstructorInvocationopt,
              _BlockStatementsopt IBlockStatementsopt,
              _RBRACE *AstToken)*ConstructorBody{
      my := new(ConstructorBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._ExplicitConstructorInvocationopt = _ExplicitConstructorInvocationopt;
        if nil != _ExplicitConstructorInvocationopt{
        var trait_ interface{} = _ExplicitConstructorInvocationopt
         trait_.(IAst).SetParent(my)
}
        my._BlockStatementsopt = _BlockStatementsopt;
        if nil != _BlockStatementsopt{
        var trait_ interface{} = _BlockStatementsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstructorBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._ExplicitConstructorInvocationopt{  list.Add(my._ExplicitConstructorInvocationopt) }
        if nil != my._BlockStatementsopt{  list.Add(my._BlockStatementsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *ConstructorBody)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstructorBody)       Enter(v Visitor){
        var checkChildren = v.VisitConstructorBody(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._ExplicitConstructorInvocationopt{my._ExplicitConstructorInvocationopt.Accept(v)}
            if nil != my._BlockStatementsopt{my._BlockStatementsopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitConstructorBody(my)
    }


func AnyCastToConstructorBody(i interface{}) *ConstructorBody {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorBody)
	}
}
/**
 *<b>
*<li>Rule 175:  EnumDeclaration ::= ClassModifiersopt enum identifier Interfacesopt EnumBody
 *</b>
 */
type EnumDeclaration struct{
    *Ast
      _ClassModifiersopt IClassModifiersopt
      _enum *AstToken
      _identifier *identifier
      _Interfacesopt *Interfaces
      _EnumBody *EnumBody
}
    /**
     * The value returned by <b>GetClassModifiersopt</b> may be <b>null</b>
     */
func (my *EnumDeclaration)      GetClassModifiersopt() IClassModifiersopt{ return my._ClassModifiersopt}
func (my *EnumDeclaration)      SetClassModifiersopt( _ClassModifiersopt IClassModifiersopt)  { my._ClassModifiersopt = _ClassModifiersopt }
func (my *EnumDeclaration)      Getenum() *AstToken{ return my._enum}
func (my *EnumDeclaration)      Setenum( _enum *AstToken)  { my._enum = _enum }
func (my *EnumDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *EnumDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetInterfacesopt</b> may be <b>null</b>
     */
func (my *EnumDeclaration)      GetInterfacesopt() *Interfaces{ return my._Interfacesopt}
func (my *EnumDeclaration)      SetInterfacesopt( _Interfacesopt *Interfaces)  { my._Interfacesopt = _Interfacesopt }
func (my *EnumDeclaration)      GetEnumBody() *EnumBody{ return my._EnumBody}
func (my *EnumDeclaration)      SetEnumBody( _EnumBody *EnumBody)  { my._EnumBody = _EnumBody }

func NewEnumDeclaration(leftIToken IToken, rightIToken IToken ,
              _ClassModifiersopt IClassModifiersopt,
              _enum *AstToken,
              _identifier *identifier,
              _Interfacesopt *Interfaces,
              _EnumBody *EnumBody)*EnumDeclaration{
      my := new(EnumDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassModifiersopt = _ClassModifiersopt;
        if nil != _ClassModifiersopt{
        var trait_ interface{} = _ClassModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._enum = _enum;
        if nil != _enum{
        var trait_ interface{} = _enum
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._Interfacesopt = _Interfacesopt;
        if nil != _Interfacesopt{
        var trait_ interface{} = _Interfacesopt
         trait_.(IAst).SetParent(my)
}
        my._EnumBody = _EnumBody;
        if nil != _EnumBody{
        var trait_ interface{} = _EnumBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassModifiersopt{  list.Add(my._ClassModifiersopt) }
        if nil != my._enum{  list.Add(my._enum) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._Interfacesopt{  list.Add(my._Interfacesopt) }
        if nil != my._EnumBody{  list.Add(my._EnumBody) }
        return list
    }

func (my *EnumDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EnumDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitEnumDeclaration(my)
        if checkChildren{
            if nil != my._ClassModifiersopt{my._ClassModifiersopt.Accept(v)}
            if nil != my._enum{my._enum.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._Interfacesopt{my._Interfacesopt.Accept(v)}
            if nil != my._EnumBody{my._EnumBody.Accept(v)}
        }
        v.EndVisitEnumDeclaration(my)
    }


func AnyCastToEnumDeclaration(i interface{}) *EnumDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*EnumDeclaration)
	}
}
/**
 *<b>
*<li>Rule 176:  EnumBody ::= { EnumConstantsopt ,opt EnumBodyDeclarationsopt }
 *</b>
 */
type EnumBody struct{
    *Ast
      _LBRACE *AstToken
      _EnumConstantsopt IEnumConstantsopt
      _Commaopt *Commaopt
      _EnumBodyDeclarationsopt *EnumBodyDeclarations
      _RBRACE *AstToken
}
func (my *EnumBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *EnumBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetEnumConstantsopt</b> may be <b>null</b>
     */
func (my *EnumBody)      GetEnumConstantsopt() IEnumConstantsopt{ return my._EnumConstantsopt}
func (my *EnumBody)      SetEnumConstantsopt( _EnumConstantsopt IEnumConstantsopt)  { my._EnumConstantsopt = _EnumConstantsopt }
    /**
     * The value returned by <b>GetCommaopt</b> may be <b>null</b>
     */
func (my *EnumBody)      GetCommaopt() *Commaopt{ return my._Commaopt}
func (my *EnumBody)      SetCommaopt( _Commaopt *Commaopt)  { my._Commaopt = _Commaopt }
    /**
     * The value returned by <b>GetEnumBodyDeclarationsopt</b> may be <b>null</b>
     */
func (my *EnumBody)      GetEnumBodyDeclarationsopt() *EnumBodyDeclarations{ return my._EnumBodyDeclarationsopt}
func (my *EnumBody)      SetEnumBodyDeclarationsopt( _EnumBodyDeclarationsopt *EnumBodyDeclarations)  { my._EnumBodyDeclarationsopt = _EnumBodyDeclarationsopt }
func (my *EnumBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *EnumBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewEnumBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _EnumConstantsopt IEnumConstantsopt,
              _Commaopt *Commaopt,
              _EnumBodyDeclarationsopt *EnumBodyDeclarations,
              _RBRACE *AstToken)*EnumBody{
      my := new(EnumBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._EnumConstantsopt = _EnumConstantsopt;
        if nil != _EnumConstantsopt{
        var trait_ interface{} = _EnumConstantsopt
         trait_.(IAst).SetParent(my)
}
        my._Commaopt = _Commaopt;
        if nil != _Commaopt{
        var trait_ interface{} = _Commaopt
         trait_.(IAst).SetParent(my)
}
        my._EnumBodyDeclarationsopt = _EnumBodyDeclarationsopt;
        if nil != _EnumBodyDeclarationsopt{
        var trait_ interface{} = _EnumBodyDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._EnumConstantsopt{  list.Add(my._EnumConstantsopt) }
        if nil != my._Commaopt{  list.Add(my._Commaopt) }
        if nil != my._EnumBodyDeclarationsopt{  list.Add(my._EnumBodyDeclarationsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *EnumBody)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EnumBody)       Enter(v Visitor){
        var checkChildren = v.VisitEnumBody(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._EnumConstantsopt{my._EnumConstantsopt.Accept(v)}
            if nil != my._Commaopt{my._Commaopt.Accept(v)}
            if nil != my._EnumBodyDeclarationsopt{my._EnumBodyDeclarationsopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitEnumBody(my)
    }


func AnyCastToEnumBody(i interface{}) *EnumBody {
	if nil == i{
		return nil
	}else{
		return i.(*EnumBody)
	}
}
/**
 *<em>
*<li>Rule 177:  EnumConstants ::= EnumConstant
 *</em>
 *<p>
 *<b>
*<li>Rule 178:  EnumConstants ::= EnumConstants , EnumConstant
 *</b>
 */
type EnumConstants struct{
    *Ast
      _EnumConstants IEnumConstants
      _COMMA *AstToken
      _EnumConstant IEnumConstant
}
func (my *EnumConstants)      GetEnumConstants() IEnumConstants{ return my._EnumConstants}
func (my *EnumConstants)      SetEnumConstants( _EnumConstants IEnumConstants)  { my._EnumConstants = _EnumConstants }
func (my *EnumConstants)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *EnumConstants)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *EnumConstants)      GetEnumConstant() IEnumConstant{ return my._EnumConstant}
func (my *EnumConstants)      SetEnumConstant( _EnumConstant IEnumConstant)  { my._EnumConstant = _EnumConstant }

func NewEnumConstants(leftIToken IToken, rightIToken IToken ,
              _EnumConstants IEnumConstants,
              _COMMA *AstToken,
              _EnumConstant IEnumConstant)*EnumConstants{
      my := new(EnumConstants)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._EnumConstants = _EnumConstants;
        if nil != _EnumConstants{
        var trait_ interface{} = _EnumConstants
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._EnumConstant = _EnumConstant;
        if nil != _EnumConstant{
        var trait_ interface{} = _EnumConstant
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumConstants)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._EnumConstants{  list.Add(my._EnumConstants) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._EnumConstant{  list.Add(my._EnumConstant) }
        return list
    }

func (my *EnumConstants)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EnumConstants)       Enter(v Visitor){
        var checkChildren = v.VisitEnumConstants(my)
        if checkChildren{
            if nil != my._EnumConstants{my._EnumConstants.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._EnumConstant{my._EnumConstant.Accept(v)}
        }
        v.EndVisitEnumConstants(my)
    }


func AnyCastToEnumConstants(i interface{}) *EnumConstants {
	if nil == i{
		return nil
	}else{
		return i.(*EnumConstants)
	}
}
/**
 *<em>
*<li>Rule 307:  EnumConstant ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 179:  EnumConstant ::= Annotationsopt identifier Argumentsopt ClassBodyopt
 *</b>
 */
type EnumConstant struct{
    *Ast
      _Annotationsopt IAnnotationsopt
      _identifier *identifier
      _Argumentsopt *Arguments
      _ClassBodyopt *ClassBody
}
    /**
     * The value returned by <b>GetAnnotationsopt</b> may be <b>null</b>
     */
func (my *EnumConstant)      GetAnnotationsopt() IAnnotationsopt{ return my._Annotationsopt}
func (my *EnumConstant)      SetAnnotationsopt( _Annotationsopt IAnnotationsopt)  { my._Annotationsopt = _Annotationsopt }
func (my *EnumConstant)      Getidentifier() *identifier{ return my._identifier}
func (my *EnumConstant)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetArgumentsopt</b> may be <b>null</b>
     */
func (my *EnumConstant)      GetArgumentsopt() *Arguments{ return my._Argumentsopt}
func (my *EnumConstant)      SetArgumentsopt( _Argumentsopt *Arguments)  { my._Argumentsopt = _Argumentsopt }
    /**
     * The value returned by <b>GetClassBodyopt</b> may be <b>null</b>
     */
func (my *EnumConstant)      GetClassBodyopt() *ClassBody{ return my._ClassBodyopt}
func (my *EnumConstant)      SetClassBodyopt( _ClassBodyopt *ClassBody)  { my._ClassBodyopt = _ClassBodyopt }

func NewEnumConstant(leftIToken IToken, rightIToken IToken ,
              _Annotationsopt IAnnotationsopt,
              _identifier *identifier,
              _Argumentsopt *Arguments,
              _ClassBodyopt *ClassBody)*EnumConstant{
      my := new(EnumConstant)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Annotationsopt = _Annotationsopt;
        if nil != _Annotationsopt{
        var trait_ interface{} = _Annotationsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._Argumentsopt = _Argumentsopt;
        if nil != _Argumentsopt{
        var trait_ interface{} = _Argumentsopt
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyopt = _ClassBodyopt;
        if nil != _ClassBodyopt{
        var trait_ interface{} = _ClassBodyopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumConstant)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Annotationsopt{  list.Add(my._Annotationsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._Argumentsopt{  list.Add(my._Argumentsopt) }
        if nil != my._ClassBodyopt{  list.Add(my._ClassBodyopt) }
        return list
    }

func (my *EnumConstant)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EnumConstant)       Enter(v Visitor){
        var checkChildren = v.VisitEnumConstant(my)
        if checkChildren{
            if nil != my._Annotationsopt{my._Annotationsopt.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._Argumentsopt{my._Argumentsopt.Accept(v)}
            if nil != my._ClassBodyopt{my._ClassBodyopt.Accept(v)}
        }
        v.EndVisitEnumConstant(my)
    }


func AnyCastToEnumConstant(i interface{}) *EnumConstant {
	if nil == i{
		return nil
	}else{
		return i.(*EnumConstant)
	}
}
/**
 *<b>
*<li>Rule 180:  Arguments ::= ( ArgumentListopt )
 *</b>
 */
type Arguments struct{
    *Ast
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *Arguments)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *Arguments)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *Arguments)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *Arguments)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *Arguments)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *Arguments)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewArguments(leftIToken IToken, rightIToken IToken ,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*Arguments{
      my := new(Arguments)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Arguments)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *Arguments)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Arguments)       Enter(v Visitor){
        var checkChildren = v.VisitArguments(my)
        if checkChildren{
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitArguments(my)
    }


func AnyCastToArguments(i interface{}) *Arguments {
	if nil == i{
		return nil
	}else{
		return i.(*Arguments)
	}
}
/**
 *<b>
*<li>Rule 181:  EnumBodyDeclarations ::= ; ClassBodyDeclarationsopt
 *</b>
 */
type EnumBodyDeclarations struct{
    *Ast
      _SEMICOLON *AstToken
      _ClassBodyDeclarationsopt IClassBodyDeclarationsopt
}
func (my *EnumBodyDeclarations)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *EnumBodyDeclarations)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }
    /**
     * The value returned by <b>GetClassBodyDeclarationsopt</b> may be <b>null</b>
     */
func (my *EnumBodyDeclarations)      GetClassBodyDeclarationsopt() IClassBodyDeclarationsopt{ return my._ClassBodyDeclarationsopt}
func (my *EnumBodyDeclarations)      SetClassBodyDeclarationsopt( _ClassBodyDeclarationsopt IClassBodyDeclarationsopt)  { my._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt }

func NewEnumBodyDeclarations(leftIToken IToken, rightIToken IToken ,
              _SEMICOLON *AstToken,
              _ClassBodyDeclarationsopt IClassBodyDeclarationsopt)*EnumBodyDeclarations{
      my := new(EnumBodyDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt;
        if nil != _ClassBodyDeclarationsopt{
        var trait_ interface{} = _ClassBodyDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumBodyDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        if nil != my._ClassBodyDeclarationsopt{  list.Add(my._ClassBodyDeclarationsopt) }
        return list
    }

func (my *EnumBodyDeclarations)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EnumBodyDeclarations)       Enter(v Visitor){
        var checkChildren = v.VisitEnumBodyDeclarations(my)
        if checkChildren{
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
            if nil != my._ClassBodyDeclarationsopt{my._ClassBodyDeclarationsopt.Accept(v)}
        }
        v.EndVisitEnumBodyDeclarations(my)
    }


func AnyCastToEnumBodyDeclarations(i interface{}) *EnumBodyDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*EnumBodyDeclarations)
	}
}
/**
 *<b>
*<li>Rule 184:  NormalInterfaceDeclaration ::= InterfaceModifiersopt interface identifier TypeParametersopt ExtendsInterfacesopt InterfaceBody
 *</b>
 */
type NormalInterfaceDeclaration struct{
    *Ast
      _InterfaceModifiersopt IInterfaceModifiersopt
      _interface *AstToken
      _identifier *identifier
      _TypeParametersopt *TypeParameters
      _ExtendsInterfacesopt IExtendsInterfacesopt
      _InterfaceBody *InterfaceBody
}
    /**
     * The value returned by <b>GetInterfaceModifiersopt</b> may be <b>null</b>
     */
func (my *NormalInterfaceDeclaration)      GetInterfaceModifiersopt() IInterfaceModifiersopt{ return my._InterfaceModifiersopt}
func (my *NormalInterfaceDeclaration)      SetInterfaceModifiersopt( _InterfaceModifiersopt IInterfaceModifiersopt)  { my._InterfaceModifiersopt = _InterfaceModifiersopt }
func (my *NormalInterfaceDeclaration)      Getinterface() *AstToken{ return my._interface}
func (my *NormalInterfaceDeclaration)      Setinterface( _interface *AstToken)  { my._interface = _interface }
func (my *NormalInterfaceDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *NormalInterfaceDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *NormalInterfaceDeclaration)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *NormalInterfaceDeclaration)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
    /**
     * The value returned by <b>GetExtendsInterfacesopt</b> may be <b>null</b>
     */
func (my *NormalInterfaceDeclaration)      GetExtendsInterfacesopt() IExtendsInterfacesopt{ return my._ExtendsInterfacesopt}
func (my *NormalInterfaceDeclaration)      SetExtendsInterfacesopt( _ExtendsInterfacesopt IExtendsInterfacesopt)  { my._ExtendsInterfacesopt = _ExtendsInterfacesopt }
func (my *NormalInterfaceDeclaration)      GetInterfaceBody() *InterfaceBody{ return my._InterfaceBody}
func (my *NormalInterfaceDeclaration)      SetInterfaceBody( _InterfaceBody *InterfaceBody)  { my._InterfaceBody = _InterfaceBody }

func NewNormalInterfaceDeclaration(leftIToken IToken, rightIToken IToken ,
              _InterfaceModifiersopt IInterfaceModifiersopt,
              _interface *AstToken,
              _identifier *identifier,
              _TypeParametersopt *TypeParameters,
              _ExtendsInterfacesopt IExtendsInterfacesopt,
              _InterfaceBody *InterfaceBody)*NormalInterfaceDeclaration{
      my := new(NormalInterfaceDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceModifiersopt = _InterfaceModifiersopt;
        if nil != _InterfaceModifiersopt{
        var trait_ interface{} = _InterfaceModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._interface = _interface;
        if nil != _interface{
        var trait_ interface{} = _interface
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._ExtendsInterfacesopt = _ExtendsInterfacesopt;
        if nil != _ExtendsInterfacesopt{
        var trait_ interface{} = _ExtendsInterfacesopt
         trait_.(IAst).SetParent(my)
}
        my._InterfaceBody = _InterfaceBody;
        if nil != _InterfaceBody{
        var trait_ interface{} = _InterfaceBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *NormalInterfaceDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceModifiersopt{  list.Add(my._InterfaceModifiersopt) }
        if nil != my._interface{  list.Add(my._interface) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._ExtendsInterfacesopt{  list.Add(my._ExtendsInterfacesopt) }
        if nil != my._InterfaceBody{  list.Add(my._InterfaceBody) }
        return list
    }

func (my *NormalInterfaceDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *NormalInterfaceDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitNormalInterfaceDeclaration(my)
        if checkChildren{
            if nil != my._InterfaceModifiersopt{my._InterfaceModifiersopt.Accept(v)}
            if nil != my._interface{my._interface.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._TypeParametersopt{my._TypeParametersopt.Accept(v)}
            if nil != my._ExtendsInterfacesopt{my._ExtendsInterfacesopt.Accept(v)}
            if nil != my._InterfaceBody{my._InterfaceBody.Accept(v)}
        }
        v.EndVisitNormalInterfaceDeclaration(my)
    }


func AnyCastToNormalInterfaceDeclaration(i interface{}) *NormalInterfaceDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*NormalInterfaceDeclaration)
	}
}
/**
 *<em>
*<li>Rule 185:  InterfaceModifiers ::= InterfaceModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 186:  InterfaceModifiers ::= InterfaceModifiers InterfaceModifier
 *</b>
 */
type InterfaceModifiers struct{
    *Ast
      _InterfaceModifiers IInterfaceModifiers
      _InterfaceModifier IInterfaceModifier
}
func (my *InterfaceModifiers)      GetInterfaceModifiers() IInterfaceModifiers{ return my._InterfaceModifiers}
func (my *InterfaceModifiers)      SetInterfaceModifiers( _InterfaceModifiers IInterfaceModifiers)  { my._InterfaceModifiers = _InterfaceModifiers }
func (my *InterfaceModifiers)      GetInterfaceModifier() IInterfaceModifier{ return my._InterfaceModifier}
func (my *InterfaceModifiers)      SetInterfaceModifier( _InterfaceModifier IInterfaceModifier)  { my._InterfaceModifier = _InterfaceModifier }

func NewInterfaceModifiers(leftIToken IToken, rightIToken IToken ,
              _InterfaceModifiers IInterfaceModifiers,
              _InterfaceModifier IInterfaceModifier)*InterfaceModifiers{
      my := new(InterfaceModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceModifiers = _InterfaceModifiers;
        if nil != _InterfaceModifiers{
        var trait_ interface{} = _InterfaceModifiers
         trait_.(IAst).SetParent(my)
}
        my._InterfaceModifier = _InterfaceModifier;
        if nil != _InterfaceModifier{
        var trait_ interface{} = _InterfaceModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceModifiers{  list.Add(my._InterfaceModifiers) }
        if nil != my._InterfaceModifier{  list.Add(my._InterfaceModifier) }
        return list
    }

func (my *InterfaceModifiers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceModifiers)       Enter(v Visitor){
        var checkChildren = v.VisitInterfaceModifiers(my)
        if checkChildren{
            if nil != my._InterfaceModifiers{my._InterfaceModifiers.Accept(v)}
            if nil != my._InterfaceModifier{my._InterfaceModifier.Accept(v)}
        }
        v.EndVisitInterfaceModifiers(my)
    }


func AnyCastToInterfaceModifiers(i interface{}) *InterfaceModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifiers)
	}
}
/**
 *<b>
*<li>Rule 196:  InterfaceBody ::= { InterfaceMemberDeclarationsopt }
 *</b>
 */
type InterfaceBody struct{
    *Ast
      _LBRACE *AstToken
      _InterfaceMemberDeclarationsopt IInterfaceMemberDeclarationsopt
      _RBRACE *AstToken
}
func (my *InterfaceBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *InterfaceBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetInterfaceMemberDeclarationsopt</b> may be <b>null</b>
     */
func (my *InterfaceBody)      GetInterfaceMemberDeclarationsopt() IInterfaceMemberDeclarationsopt{ return my._InterfaceMemberDeclarationsopt}
func (my *InterfaceBody)      SetInterfaceMemberDeclarationsopt( _InterfaceMemberDeclarationsopt IInterfaceMemberDeclarationsopt)  { my._InterfaceMemberDeclarationsopt = _InterfaceMemberDeclarationsopt }
func (my *InterfaceBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *InterfaceBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewInterfaceBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _InterfaceMemberDeclarationsopt IInterfaceMemberDeclarationsopt,
              _RBRACE *AstToken)*InterfaceBody{
      my := new(InterfaceBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._InterfaceMemberDeclarationsopt = _InterfaceMemberDeclarationsopt;
        if nil != _InterfaceMemberDeclarationsopt{
        var trait_ interface{} = _InterfaceMemberDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._InterfaceMemberDeclarationsopt{  list.Add(my._InterfaceMemberDeclarationsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *InterfaceBody)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceBody)       Enter(v Visitor){
        var checkChildren = v.VisitInterfaceBody(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._InterfaceMemberDeclarationsopt{my._InterfaceMemberDeclarationsopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitInterfaceBody(my)
    }


func AnyCastToInterfaceBody(i interface{}) *InterfaceBody {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceBody)
	}
}
/**
 *<em>
*<li>Rule 197:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 198:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
 *</b>
 */
type InterfaceMemberDeclarations struct{
    *Ast
      _InterfaceMemberDeclarations IInterfaceMemberDeclarations
      _InterfaceMemberDeclaration IInterfaceMemberDeclaration
}
func (my *InterfaceMemberDeclarations)      GetInterfaceMemberDeclarations() IInterfaceMemberDeclarations{ return my._InterfaceMemberDeclarations}
func (my *InterfaceMemberDeclarations)      SetInterfaceMemberDeclarations( _InterfaceMemberDeclarations IInterfaceMemberDeclarations)  { my._InterfaceMemberDeclarations = _InterfaceMemberDeclarations }
func (my *InterfaceMemberDeclarations)      GetInterfaceMemberDeclaration() IInterfaceMemberDeclaration{ return my._InterfaceMemberDeclaration}
func (my *InterfaceMemberDeclarations)      SetInterfaceMemberDeclaration( _InterfaceMemberDeclaration IInterfaceMemberDeclaration)  { my._InterfaceMemberDeclaration = _InterfaceMemberDeclaration }

func NewInterfaceMemberDeclarations(leftIToken IToken, rightIToken IToken ,
              _InterfaceMemberDeclarations IInterfaceMemberDeclarations,
              _InterfaceMemberDeclaration IInterfaceMemberDeclaration)*InterfaceMemberDeclarations{
      my := new(InterfaceMemberDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceMemberDeclarations = _InterfaceMemberDeclarations;
        if nil != _InterfaceMemberDeclarations{
        var trait_ interface{} = _InterfaceMemberDeclarations
         trait_.(IAst).SetParent(my)
}
        my._InterfaceMemberDeclaration = _InterfaceMemberDeclaration;
        if nil != _InterfaceMemberDeclaration{
        var trait_ interface{} = _InterfaceMemberDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceMemberDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceMemberDeclarations{  list.Add(my._InterfaceMemberDeclarations) }
        if nil != my._InterfaceMemberDeclaration{  list.Add(my._InterfaceMemberDeclaration) }
        return list
    }

func (my *InterfaceMemberDeclarations)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceMemberDeclarations)       Enter(v Visitor){
        var checkChildren = v.VisitInterfaceMemberDeclarations(my)
        if checkChildren{
            if nil != my._InterfaceMemberDeclarations{my._InterfaceMemberDeclarations.Accept(v)}
            if nil != my._InterfaceMemberDeclaration{my._InterfaceMemberDeclaration.Accept(v)}
        }
        v.EndVisitInterfaceMemberDeclarations(my)
    }


func AnyCastToInterfaceMemberDeclarations(i interface{}) *InterfaceMemberDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceMemberDeclarations)
	}
}
/**
 *<em>
*<li>Rule 199:  InterfaceMemberDeclaration ::= ConstantDeclaration
*<li>Rule 200:  InterfaceMemberDeclaration ::= AbstractMethodDeclaration
*<li>Rule 201:  InterfaceMemberDeclaration ::= ClassDeclaration
*<li>Rule 202:  InterfaceMemberDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 203:  InterfaceMemberDeclaration ::= ;
 *</b>
 */
type InterfaceMemberDeclaration struct{
    *AstToken
}
func (my *InterfaceMemberDeclaration)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewInterfaceMemberDeclaration(token IToken )*InterfaceMemberDeclaration{
      my := new(InterfaceMemberDeclaration)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceMemberDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceMemberDeclaration)       Enter(v Visitor){
        v.VisitInterfaceMemberDeclaration(my)
        v.EndVisitInterfaceMemberDeclaration(my)
    }


func AnyCastToInterfaceMemberDeclaration(i interface{}) *InterfaceMemberDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceMemberDeclaration)
	}
}
/**
 *<b>
*<li>Rule 204:  ConstantDeclaration ::= ConstantModifiersopt Type VariableDeclarators
 *</b>
 */
type ConstantDeclaration struct{
    *Ast
      _ConstantModifiersopt IConstantModifiersopt
      _Type IType
      _VariableDeclarators IVariableDeclarators
}
    /**
     * The value returned by <b>GetConstantModifiersopt</b> may be <b>null</b>
     */
func (my *ConstantDeclaration)      GetConstantModifiersopt() IConstantModifiersopt{ return my._ConstantModifiersopt}
func (my *ConstantDeclaration)      SetConstantModifiersopt( _ConstantModifiersopt IConstantModifiersopt)  { my._ConstantModifiersopt = _ConstantModifiersopt }
func (my *ConstantDeclaration)      GetType() IType{ return my._Type}
func (my *ConstantDeclaration)      SetType( _Type IType)  { my._Type = _Type }
func (my *ConstantDeclaration)      GetVariableDeclarators() IVariableDeclarators{ return my._VariableDeclarators}
func (my *ConstantDeclaration)      SetVariableDeclarators( _VariableDeclarators IVariableDeclarators)  { my._VariableDeclarators = _VariableDeclarators }

func NewConstantDeclaration(leftIToken IToken, rightIToken IToken ,
              _ConstantModifiersopt IConstantModifiersopt,
              _Type IType,
              _VariableDeclarators IVariableDeclarators)*ConstantDeclaration{
      my := new(ConstantDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConstantModifiersopt = _ConstantModifiersopt;
        if nil != _ConstantModifiersopt{
        var trait_ interface{} = _ConstantModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclarators = _VariableDeclarators;
        if nil != _VariableDeclarators{
        var trait_ interface{} = _VariableDeclarators
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstantDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConstantModifiersopt{  list.Add(my._ConstantModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._VariableDeclarators{  list.Add(my._VariableDeclarators) }
        return list
    }

func (my *ConstantDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstantDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitConstantDeclaration(my)
        if checkChildren{
            if nil != my._ConstantModifiersopt{my._ConstantModifiersopt.Accept(v)}
            if nil != my._Type{my._Type.Accept(v)}
            if nil != my._VariableDeclarators{my._VariableDeclarators.Accept(v)}
        }
        v.EndVisitConstantDeclaration(my)
    }


func AnyCastToConstantDeclaration(i interface{}) *ConstantDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantDeclaration)
	}
}
/**
 *<em>
*<li>Rule 205:  ConstantModifiers ::= ConstantModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 206:  ConstantModifiers ::= ConstantModifiers ConstantModifier
 *</b>
 */
type ConstantModifiers struct{
    *Ast
      _ConstantModifiers IConstantModifiers
      _ConstantModifier IConstantModifier
}
func (my *ConstantModifiers)      GetConstantModifiers() IConstantModifiers{ return my._ConstantModifiers}
func (my *ConstantModifiers)      SetConstantModifiers( _ConstantModifiers IConstantModifiers)  { my._ConstantModifiers = _ConstantModifiers }
func (my *ConstantModifiers)      GetConstantModifier() IConstantModifier{ return my._ConstantModifier}
func (my *ConstantModifiers)      SetConstantModifier( _ConstantModifier IConstantModifier)  { my._ConstantModifier = _ConstantModifier }

func NewConstantModifiers(leftIToken IToken, rightIToken IToken ,
              _ConstantModifiers IConstantModifiers,
              _ConstantModifier IConstantModifier)*ConstantModifiers{
      my := new(ConstantModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConstantModifiers = _ConstantModifiers;
        if nil != _ConstantModifiers{
        var trait_ interface{} = _ConstantModifiers
         trait_.(IAst).SetParent(my)
}
        my._ConstantModifier = _ConstantModifier;
        if nil != _ConstantModifier{
        var trait_ interface{} = _ConstantModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstantModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConstantModifiers{  list.Add(my._ConstantModifiers) }
        if nil != my._ConstantModifier{  list.Add(my._ConstantModifier) }
        return list
    }

func (my *ConstantModifiers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstantModifiers)       Enter(v Visitor){
        var checkChildren = v.VisitConstantModifiers(my)
        if checkChildren{
            if nil != my._ConstantModifiers{my._ConstantModifiers.Accept(v)}
            if nil != my._ConstantModifier{my._ConstantModifier.Accept(v)}
        }
        v.EndVisitConstantModifiers(my)
    }


func AnyCastToConstantModifiers(i interface{}) *ConstantModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantModifiers)
	}
}
/**
 *<b>
*<li>Rule 211:  AbstractMethodDeclaration ::= AbstractMethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt ;
 *</b>
 */
type AbstractMethodDeclaration struct{
    *Ast
      _AbstractMethodModifiersopt IAbstractMethodModifiersopt
      _TypeParametersopt *TypeParameters
      _ResultType IResultType
      _MethodDeclarator IMethodDeclarator
      _Throwsopt *Throws
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetAbstractMethodModifiersopt</b> may be <b>null</b>
     */
func (my *AbstractMethodDeclaration)      GetAbstractMethodModifiersopt() IAbstractMethodModifiersopt{ return my._AbstractMethodModifiersopt}
func (my *AbstractMethodDeclaration)      SetAbstractMethodModifiersopt( _AbstractMethodModifiersopt IAbstractMethodModifiersopt)  { my._AbstractMethodModifiersopt = _AbstractMethodModifiersopt }
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *AbstractMethodDeclaration)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *AbstractMethodDeclaration)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
func (my *AbstractMethodDeclaration)      GetResultType() IResultType{ return my._ResultType}
func (my *AbstractMethodDeclaration)      SetResultType( _ResultType IResultType)  { my._ResultType = _ResultType }
func (my *AbstractMethodDeclaration)      GetMethodDeclarator() IMethodDeclarator{ return my._MethodDeclarator}
func (my *AbstractMethodDeclaration)      SetMethodDeclarator( _MethodDeclarator IMethodDeclarator)  { my._MethodDeclarator = _MethodDeclarator }
    /**
     * The value returned by <b>GetThrowsopt</b> may be <b>null</b>
     */
func (my *AbstractMethodDeclaration)      GetThrowsopt() *Throws{ return my._Throwsopt}
func (my *AbstractMethodDeclaration)      SetThrowsopt( _Throwsopt *Throws)  { my._Throwsopt = _Throwsopt }
func (my *AbstractMethodDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *AbstractMethodDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewAbstractMethodDeclaration(leftIToken IToken, rightIToken IToken ,
              _AbstractMethodModifiersopt IAbstractMethodModifiersopt,
              _TypeParametersopt *TypeParameters,
              _ResultType IResultType,
              _MethodDeclarator IMethodDeclarator,
              _Throwsopt *Throws,
              _SEMICOLON *AstToken)*AbstractMethodDeclaration{
      my := new(AbstractMethodDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AbstractMethodModifiersopt = _AbstractMethodModifiersopt;
        if nil != _AbstractMethodModifiersopt{
        var trait_ interface{} = _AbstractMethodModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._ResultType = _ResultType;
        if nil != _ResultType{
        var trait_ interface{} = _ResultType
         trait_.(IAst).SetParent(my)
}
        my._MethodDeclarator = _MethodDeclarator;
        if nil != _MethodDeclarator{
        var trait_ interface{} = _MethodDeclarator
         trait_.(IAst).SetParent(my)
}
        my._Throwsopt = _Throwsopt;
        if nil != _Throwsopt{
        var trait_ interface{} = _Throwsopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AbstractMethodDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AbstractMethodModifiersopt{  list.Add(my._AbstractMethodModifiersopt) }
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._ResultType{  list.Add(my._ResultType) }
        if nil != my._MethodDeclarator{  list.Add(my._MethodDeclarator) }
        if nil != my._Throwsopt{  list.Add(my._Throwsopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *AbstractMethodDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AbstractMethodDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitAbstractMethodDeclaration(my)
        if checkChildren{
            if nil != my._AbstractMethodModifiersopt{my._AbstractMethodModifiersopt.Accept(v)}
            if nil != my._TypeParametersopt{my._TypeParametersopt.Accept(v)}
            if nil != my._ResultType{my._ResultType.Accept(v)}
            if nil != my._MethodDeclarator{my._MethodDeclarator.Accept(v)}
            if nil != my._Throwsopt{my._Throwsopt.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitAbstractMethodDeclaration(my)
    }


func AnyCastToAbstractMethodDeclaration(i interface{}) *AbstractMethodDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractMethodDeclaration)
	}
}
/**
 *<em>
*<li>Rule 212:  AbstractMethodModifiers ::= AbstractMethodModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 213:  AbstractMethodModifiers ::= AbstractMethodModifiers AbstractMethodModifier
 *</b>
 */
type AbstractMethodModifiers struct{
    *Ast
      _AbstractMethodModifiers IAbstractMethodModifiers
      _AbstractMethodModifier IAbstractMethodModifier
}
func (my *AbstractMethodModifiers)      GetAbstractMethodModifiers() IAbstractMethodModifiers{ return my._AbstractMethodModifiers}
func (my *AbstractMethodModifiers)      SetAbstractMethodModifiers( _AbstractMethodModifiers IAbstractMethodModifiers)  { my._AbstractMethodModifiers = _AbstractMethodModifiers }
func (my *AbstractMethodModifiers)      GetAbstractMethodModifier() IAbstractMethodModifier{ return my._AbstractMethodModifier}
func (my *AbstractMethodModifiers)      SetAbstractMethodModifier( _AbstractMethodModifier IAbstractMethodModifier)  { my._AbstractMethodModifier = _AbstractMethodModifier }

func NewAbstractMethodModifiers(leftIToken IToken, rightIToken IToken ,
              _AbstractMethodModifiers IAbstractMethodModifiers,
              _AbstractMethodModifier IAbstractMethodModifier)*AbstractMethodModifiers{
      my := new(AbstractMethodModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AbstractMethodModifiers = _AbstractMethodModifiers;
        if nil != _AbstractMethodModifiers{
        var trait_ interface{} = _AbstractMethodModifiers
         trait_.(IAst).SetParent(my)
}
        my._AbstractMethodModifier = _AbstractMethodModifier;
        if nil != _AbstractMethodModifier{
        var trait_ interface{} = _AbstractMethodModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AbstractMethodModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AbstractMethodModifiers{  list.Add(my._AbstractMethodModifiers) }
        if nil != my._AbstractMethodModifier{  list.Add(my._AbstractMethodModifier) }
        return list
    }

func (my *AbstractMethodModifiers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AbstractMethodModifiers)       Enter(v Visitor){
        var checkChildren = v.VisitAbstractMethodModifiers(my)
        if checkChildren{
            if nil != my._AbstractMethodModifiers{my._AbstractMethodModifiers.Accept(v)}
            if nil != my._AbstractMethodModifier{my._AbstractMethodModifier.Accept(v)}
        }
        v.EndVisitAbstractMethodModifiers(my)
    }


func AnyCastToAbstractMethodModifiers(i interface{}) *AbstractMethodModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractMethodModifiers)
	}
}
/**
 *<b>
*<li>Rule 217:  AnnotationTypeDeclaration ::= InterfaceModifiersopt @ interface identifier AnnotationTypeBody
 *</b>
 */
type AnnotationTypeDeclaration struct{
    *Ast
      _InterfaceModifiersopt IInterfaceModifiersopt
      _AT *AstToken
      _interface *AstToken
      _identifier *identifier
      _AnnotationTypeBody *AnnotationTypeBody
}
    /**
     * The value returned by <b>GetInterfaceModifiersopt</b> may be <b>null</b>
     */
func (my *AnnotationTypeDeclaration)      GetInterfaceModifiersopt() IInterfaceModifiersopt{ return my._InterfaceModifiersopt}
func (my *AnnotationTypeDeclaration)      SetInterfaceModifiersopt( _InterfaceModifiersopt IInterfaceModifiersopt)  { my._InterfaceModifiersopt = _InterfaceModifiersopt }
func (my *AnnotationTypeDeclaration)      GetAT() *AstToken{ return my._AT}
func (my *AnnotationTypeDeclaration)      SetAT( _AT *AstToken)  { my._AT = _AT }
func (my *AnnotationTypeDeclaration)      Getinterface() *AstToken{ return my._interface}
func (my *AnnotationTypeDeclaration)      Setinterface( _interface *AstToken)  { my._interface = _interface }
func (my *AnnotationTypeDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *AnnotationTypeDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *AnnotationTypeDeclaration)      GetAnnotationTypeBody() *AnnotationTypeBody{ return my._AnnotationTypeBody}
func (my *AnnotationTypeDeclaration)      SetAnnotationTypeBody( _AnnotationTypeBody *AnnotationTypeBody)  { my._AnnotationTypeBody = _AnnotationTypeBody }

func NewAnnotationTypeDeclaration(leftIToken IToken, rightIToken IToken ,
              _InterfaceModifiersopt IInterfaceModifiersopt,
              _AT *AstToken,
              _interface *AstToken,
              _identifier *identifier,
              _AnnotationTypeBody *AnnotationTypeBody)*AnnotationTypeDeclaration{
      my := new(AnnotationTypeDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceModifiersopt = _InterfaceModifiersopt;
        if nil != _InterfaceModifiersopt{
        var trait_ interface{} = _InterfaceModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._AT = _AT;
        if nil != _AT{
        var trait_ interface{} = _AT
         trait_.(IAst).SetParent(my)
}
        my._interface = _interface;
        if nil != _interface{
        var trait_ interface{} = _interface
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._AnnotationTypeBody = _AnnotationTypeBody;
        if nil != _AnnotationTypeBody{
        var trait_ interface{} = _AnnotationTypeBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AnnotationTypeDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceModifiersopt{  list.Add(my._InterfaceModifiersopt) }
        if nil != my._AT{  list.Add(my._AT) }
        if nil != my._interface{  list.Add(my._interface) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._AnnotationTypeBody{  list.Add(my._AnnotationTypeBody) }
        return list
    }

func (my *AnnotationTypeDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AnnotationTypeDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitAnnotationTypeDeclaration(my)
        if checkChildren{
            if nil != my._InterfaceModifiersopt{my._InterfaceModifiersopt.Accept(v)}
            if nil != my._AT{my._AT.Accept(v)}
            if nil != my._interface{my._interface.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._AnnotationTypeBody{my._AnnotationTypeBody.Accept(v)}
        }
        v.EndVisitAnnotationTypeDeclaration(my)
    }


func AnyCastToAnnotationTypeDeclaration(i interface{}) *AnnotationTypeDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeDeclaration)
	}
}
/**
 *<b>
*<li>Rule 218:  AnnotationTypeBody ::= { AnnotationTypeElementDeclarationsopt }
 *</b>
 */
type AnnotationTypeBody struct{
    *Ast
      _LBRACE *AstToken
      _AnnotationTypeElementDeclarationsopt IAnnotationTypeElementDeclarationsopt
      _RBRACE *AstToken
}
func (my *AnnotationTypeBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *AnnotationTypeBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetAnnotationTypeElementDeclarationsopt</b> may be <b>null</b>
     */
func (my *AnnotationTypeBody)      GetAnnotationTypeElementDeclarationsopt() IAnnotationTypeElementDeclarationsopt{ return my._AnnotationTypeElementDeclarationsopt}
func (my *AnnotationTypeBody)      SetAnnotationTypeElementDeclarationsopt( _AnnotationTypeElementDeclarationsopt IAnnotationTypeElementDeclarationsopt)  { my._AnnotationTypeElementDeclarationsopt = _AnnotationTypeElementDeclarationsopt }
func (my *AnnotationTypeBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *AnnotationTypeBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewAnnotationTypeBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _AnnotationTypeElementDeclarationsopt IAnnotationTypeElementDeclarationsopt,
              _RBRACE *AstToken)*AnnotationTypeBody{
      my := new(AnnotationTypeBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._AnnotationTypeElementDeclarationsopt = _AnnotationTypeElementDeclarationsopt;
        if nil != _AnnotationTypeElementDeclarationsopt{
        var trait_ interface{} = _AnnotationTypeElementDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AnnotationTypeBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._AnnotationTypeElementDeclarationsopt{  list.Add(my._AnnotationTypeElementDeclarationsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *AnnotationTypeBody)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AnnotationTypeBody)       Enter(v Visitor){
        var checkChildren = v.VisitAnnotationTypeBody(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._AnnotationTypeElementDeclarationsopt{my._AnnotationTypeElementDeclarationsopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitAnnotationTypeBody(my)
    }


func AnyCastToAnnotationTypeBody(i interface{}) *AnnotationTypeBody {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeBody)
	}
}
/**
 *<em>
*<li>Rule 219:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 220:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
 *</b>
 */
type AnnotationTypeElementDeclarations struct{
    *Ast
      _AnnotationTypeElementDeclarations IAnnotationTypeElementDeclarations
      _AnnotationTypeElementDeclaration IAnnotationTypeElementDeclaration
}
func (my *AnnotationTypeElementDeclarations)      GetAnnotationTypeElementDeclarations() IAnnotationTypeElementDeclarations{ return my._AnnotationTypeElementDeclarations}
func (my *AnnotationTypeElementDeclarations)      SetAnnotationTypeElementDeclarations( _AnnotationTypeElementDeclarations IAnnotationTypeElementDeclarations)  { my._AnnotationTypeElementDeclarations = _AnnotationTypeElementDeclarations }
func (my *AnnotationTypeElementDeclarations)      GetAnnotationTypeElementDeclaration() IAnnotationTypeElementDeclaration{ return my._AnnotationTypeElementDeclaration}
func (my *AnnotationTypeElementDeclarations)      SetAnnotationTypeElementDeclaration( _AnnotationTypeElementDeclaration IAnnotationTypeElementDeclaration)  { my._AnnotationTypeElementDeclaration = _AnnotationTypeElementDeclaration }

func NewAnnotationTypeElementDeclarations(leftIToken IToken, rightIToken IToken ,
              _AnnotationTypeElementDeclarations IAnnotationTypeElementDeclarations,
              _AnnotationTypeElementDeclaration IAnnotationTypeElementDeclaration)*AnnotationTypeElementDeclarations{
      my := new(AnnotationTypeElementDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AnnotationTypeElementDeclarations = _AnnotationTypeElementDeclarations;
        if nil != _AnnotationTypeElementDeclarations{
        var trait_ interface{} = _AnnotationTypeElementDeclarations
         trait_.(IAst).SetParent(my)
}
        my._AnnotationTypeElementDeclaration = _AnnotationTypeElementDeclaration;
        if nil != _AnnotationTypeElementDeclaration{
        var trait_ interface{} = _AnnotationTypeElementDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AnnotationTypeElementDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AnnotationTypeElementDeclarations{  list.Add(my._AnnotationTypeElementDeclarations) }
        if nil != my._AnnotationTypeElementDeclaration{  list.Add(my._AnnotationTypeElementDeclaration) }
        return list
    }

func (my *AnnotationTypeElementDeclarations)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AnnotationTypeElementDeclarations)       Enter(v Visitor){
        var checkChildren = v.VisitAnnotationTypeElementDeclarations(my)
        if checkChildren{
            if nil != my._AnnotationTypeElementDeclarations{my._AnnotationTypeElementDeclarations.Accept(v)}
            if nil != my._AnnotationTypeElementDeclaration{my._AnnotationTypeElementDeclaration.Accept(v)}
        }
        v.EndVisitAnnotationTypeElementDeclarations(my)
    }


func AnyCastToAnnotationTypeElementDeclarations(i interface{}) *AnnotationTypeElementDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeElementDeclarations)
	}
}
/**
 *<b>
*<li>Rule 228:  DefaultValue ::= default ElementValue
 *</b>
 */
type DefaultValue struct{
    *Ast
      _default *AstToken
      _ElementValue IElementValue
}
func (my *DefaultValue)      Getdefault() *AstToken{ return my._default}
func (my *DefaultValue)      Setdefault( _default *AstToken)  { my._default = _default }
func (my *DefaultValue)      GetElementValue() IElementValue{ return my._ElementValue}
func (my *DefaultValue)      SetElementValue( _ElementValue IElementValue)  { my._ElementValue = _ElementValue }

func NewDefaultValue(leftIToken IToken, rightIToken IToken ,
              _default *AstToken,
              _ElementValue IElementValue)*DefaultValue{
      my := new(DefaultValue)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._default = _default;
        if nil != _default{
        var trait_ interface{} = _default
         trait_.(IAst).SetParent(my)
}
        my._ElementValue = _ElementValue;
        if nil != _ElementValue{
        var trait_ interface{} = _ElementValue
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *DefaultValue)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._default{  list.Add(my._default) }
        if nil != my._ElementValue{  list.Add(my._ElementValue) }
        return list
    }

func (my *DefaultValue)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *DefaultValue)       Enter(v Visitor){
        var checkChildren = v.VisitDefaultValue(my)
        if checkChildren{
            if nil != my._default{my._default.Accept(v)}
            if nil != my._ElementValue{my._ElementValue.Accept(v)}
        }
        v.EndVisitDefaultValue(my)
    }


func AnyCastToDefaultValue(i interface{}) *DefaultValue {
	if nil == i{
		return nil
	}else{
		return i.(*DefaultValue)
	}
}
/**
 *<em>
*<li>Rule 229:  Annotations ::= Annotation
 *</em>
 *<p>
 *<b>
*<li>Rule 230:  Annotations ::= Annotations Annotation
 *</b>
 */
type Annotations struct{
    *Ast
      _Annotations IAnnotations
      _Annotation IAnnotation
}
func (my *Annotations)      GetAnnotations() IAnnotations{ return my._Annotations}
func (my *Annotations)      SetAnnotations( _Annotations IAnnotations)  { my._Annotations = _Annotations }
func (my *Annotations)      GetAnnotation() IAnnotation{ return my._Annotation}
func (my *Annotations)      SetAnnotation( _Annotation IAnnotation)  { my._Annotation = _Annotation }

func NewAnnotations(leftIToken IToken, rightIToken IToken ,
              _Annotations IAnnotations,
              _Annotation IAnnotation)*Annotations{
      my := new(Annotations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Annotations = _Annotations;
        if nil != _Annotations{
        var trait_ interface{} = _Annotations
         trait_.(IAst).SetParent(my)
}
        my._Annotation = _Annotation;
        if nil != _Annotation{
        var trait_ interface{} = _Annotation
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Annotations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Annotations{  list.Add(my._Annotations) }
        if nil != my._Annotation{  list.Add(my._Annotation) }
        return list
    }

func (my *Annotations)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Annotations)       Enter(v Visitor){
        var checkChildren = v.VisitAnnotations(my)
        if checkChildren{
            if nil != my._Annotations{my._Annotations.Accept(v)}
            if nil != my._Annotation{my._Annotation.Accept(v)}
        }
        v.EndVisitAnnotations(my)
    }


func AnyCastToAnnotations(i interface{}) *Annotations {
	if nil == i{
		return nil
	}else{
		return i.(*Annotations)
	}
}
/**
 *<b>
*<li>Rule 234:  NormalAnnotation ::= @ TypeName ( ElementValuePairsopt )
 *</b>
 */
type NormalAnnotation struct{
    *Ast
      _AT *AstToken
      _TypeName ITypeName
      _LPAREN *AstToken
      _ElementValuePairsopt IElementValuePairsopt
      _RPAREN *AstToken
}
func (my *NormalAnnotation)      GetAT() *AstToken{ return my._AT}
func (my *NormalAnnotation)      SetAT( _AT *AstToken)  { my._AT = _AT }
func (my *NormalAnnotation)      GetTypeName() ITypeName{ return my._TypeName}
func (my *NormalAnnotation)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *NormalAnnotation)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *NormalAnnotation)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetElementValuePairsopt</b> may be <b>null</b>
     */
func (my *NormalAnnotation)      GetElementValuePairsopt() IElementValuePairsopt{ return my._ElementValuePairsopt}
func (my *NormalAnnotation)      SetElementValuePairsopt( _ElementValuePairsopt IElementValuePairsopt)  { my._ElementValuePairsopt = _ElementValuePairsopt }
func (my *NormalAnnotation)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *NormalAnnotation)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewNormalAnnotation(leftIToken IToken, rightIToken IToken ,
              _AT *AstToken,
              _TypeName ITypeName,
              _LPAREN *AstToken,
              _ElementValuePairsopt IElementValuePairsopt,
              _RPAREN *AstToken)*NormalAnnotation{
      my := new(NormalAnnotation)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AT = _AT;
        if nil != _AT{
        var trait_ interface{} = _AT
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ElementValuePairsopt = _ElementValuePairsopt;
        if nil != _ElementValuePairsopt{
        var trait_ interface{} = _ElementValuePairsopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *NormalAnnotation)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AT{  list.Add(my._AT) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ElementValuePairsopt{  list.Add(my._ElementValuePairsopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *NormalAnnotation)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *NormalAnnotation)       Enter(v Visitor){
        var checkChildren = v.VisitNormalAnnotation(my)
        if checkChildren{
            if nil != my._AT{my._AT.Accept(v)}
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ElementValuePairsopt{my._ElementValuePairsopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitNormalAnnotation(my)
    }


func AnyCastToNormalAnnotation(i interface{}) *NormalAnnotation {
	if nil == i{
		return nil
	}else{
		return i.(*NormalAnnotation)
	}
}
/**
 *<em>
*<li>Rule 235:  ElementValuePairs ::= ElementValuePair
 *</em>
 *<p>
 *<b>
*<li>Rule 236:  ElementValuePairs ::= ElementValuePairs , ElementValuePair
 *</b>
 */
type ElementValuePairs struct{
    *Ast
      _ElementValuePairs IElementValuePairs
      _COMMA *AstToken
      _ElementValuePair *ElementValuePair
}
func (my *ElementValuePairs)      GetElementValuePairs() IElementValuePairs{ return my._ElementValuePairs}
func (my *ElementValuePairs)      SetElementValuePairs( _ElementValuePairs IElementValuePairs)  { my._ElementValuePairs = _ElementValuePairs }
func (my *ElementValuePairs)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ElementValuePairs)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ElementValuePairs)      GetElementValuePair() *ElementValuePair{ return my._ElementValuePair}
func (my *ElementValuePairs)      SetElementValuePair( _ElementValuePair *ElementValuePair)  { my._ElementValuePair = _ElementValuePair }

func NewElementValuePairs(leftIToken IToken, rightIToken IToken ,
              _ElementValuePairs IElementValuePairs,
              _COMMA *AstToken,
              _ElementValuePair *ElementValuePair)*ElementValuePairs{
      my := new(ElementValuePairs)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ElementValuePairs = _ElementValuePairs;
        if nil != _ElementValuePairs{
        var trait_ interface{} = _ElementValuePairs
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._ElementValuePair = _ElementValuePair;
        if nil != _ElementValuePair{
        var trait_ interface{} = _ElementValuePair
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ElementValuePairs)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ElementValuePairs{  list.Add(my._ElementValuePairs) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._ElementValuePair{  list.Add(my._ElementValuePair) }
        return list
    }

func (my *ElementValuePairs)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ElementValuePairs)       Enter(v Visitor){
        var checkChildren = v.VisitElementValuePairs(my)
        if checkChildren{
            if nil != my._ElementValuePairs{my._ElementValuePairs.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._ElementValuePair{my._ElementValuePair.Accept(v)}
        }
        v.EndVisitElementValuePairs(my)
    }


func AnyCastToElementValuePairs(i interface{}) *ElementValuePairs {
	if nil == i{
		return nil
	}else{
		return i.(*ElementValuePairs)
	}
}
/**
 *<b>
*<li>Rule 237:  ElementValuePair ::= SimpleName = ElementValue
 *</b>
 */
type ElementValuePair struct{
    *Ast
      _SimpleName *identifier
      _EQUAL *AstToken
      _ElementValue IElementValue
}
func (my *ElementValuePair)      GetSimpleName() *identifier{ return my._SimpleName}
func (my *ElementValuePair)      SetSimpleName( _SimpleName *identifier)  { my._SimpleName = _SimpleName }
func (my *ElementValuePair)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *ElementValuePair)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }
func (my *ElementValuePair)      GetElementValue() IElementValue{ return my._ElementValue}
func (my *ElementValuePair)      SetElementValue( _ElementValue IElementValue)  { my._ElementValue = _ElementValue }

func NewElementValuePair(leftIToken IToken, rightIToken IToken ,
              _SimpleName *identifier,
              _EQUAL *AstToken,
              _ElementValue IElementValue)*ElementValuePair{
      my := new(ElementValuePair)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SimpleName = _SimpleName;
        if nil != _SimpleName{
        var trait_ interface{} = _SimpleName
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my._ElementValue = _ElementValue;
        if nil != _ElementValue{
        var trait_ interface{} = _ElementValue
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ElementValuePair)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SimpleName{  list.Add(my._SimpleName) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        if nil != my._ElementValue{  list.Add(my._ElementValue) }
        return list
    }

func (my *ElementValuePair)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ElementValuePair)       Enter(v Visitor){
        var checkChildren = v.VisitElementValuePair(my)
        if checkChildren{
            if nil != my._SimpleName{my._SimpleName.Accept(v)}
            if nil != my._EQUAL{my._EQUAL.Accept(v)}
            if nil != my._ElementValue{my._ElementValue.Accept(v)}
        }
        v.EndVisitElementValuePair(my)
    }


func AnyCastToElementValuePair(i interface{}) *ElementValuePair {
	if nil == i{
		return nil
	}else{
		return i.(*ElementValuePair)
	}
}
/**
 *<b>
*<li>Rule 242:  ElementValueArrayInitializer ::= { ElementValuesopt ,opt }
 *</b>
 */
type ElementValueArrayInitializer struct{
    *Ast
      _LBRACE *AstToken
      _ElementValuesopt IElementValuesopt
      _Commaopt *Commaopt
      _RBRACE *AstToken
}
func (my *ElementValueArrayInitializer)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *ElementValueArrayInitializer)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetElementValuesopt</b> may be <b>null</b>
     */
func (my *ElementValueArrayInitializer)      GetElementValuesopt() IElementValuesopt{ return my._ElementValuesopt}
func (my *ElementValueArrayInitializer)      SetElementValuesopt( _ElementValuesopt IElementValuesopt)  { my._ElementValuesopt = _ElementValuesopt }
    /**
     * The value returned by <b>GetCommaopt</b> may be <b>null</b>
     */
func (my *ElementValueArrayInitializer)      GetCommaopt() *Commaopt{ return my._Commaopt}
func (my *ElementValueArrayInitializer)      SetCommaopt( _Commaopt *Commaopt)  { my._Commaopt = _Commaopt }
func (my *ElementValueArrayInitializer)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *ElementValueArrayInitializer)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewElementValueArrayInitializer(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _ElementValuesopt IElementValuesopt,
              _Commaopt *Commaopt,
              _RBRACE *AstToken)*ElementValueArrayInitializer{
      my := new(ElementValueArrayInitializer)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._ElementValuesopt = _ElementValuesopt;
        if nil != _ElementValuesopt{
        var trait_ interface{} = _ElementValuesopt
         trait_.(IAst).SetParent(my)
}
        my._Commaopt = _Commaopt;
        if nil != _Commaopt{
        var trait_ interface{} = _Commaopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ElementValueArrayInitializer)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._ElementValuesopt{  list.Add(my._ElementValuesopt) }
        if nil != my._Commaopt{  list.Add(my._Commaopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *ElementValueArrayInitializer)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ElementValueArrayInitializer)       Enter(v Visitor){
        var checkChildren = v.VisitElementValueArrayInitializer(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._ElementValuesopt{my._ElementValuesopt.Accept(v)}
            if nil != my._Commaopt{my._Commaopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitElementValueArrayInitializer(my)
    }


func AnyCastToElementValueArrayInitializer(i interface{}) *ElementValueArrayInitializer {
	if nil == i{
		return nil
	}else{
		return i.(*ElementValueArrayInitializer)
	}
}
/**
 *<em>
*<li>Rule 243:  ElementValues ::= ElementValue
 *</em>
 *<p>
 *<b>
*<li>Rule 244:  ElementValues ::= ElementValues , ElementValue
 *</b>
 */
type ElementValues struct{
    *Ast
      _ElementValues IElementValues
      _COMMA *AstToken
      _ElementValue IElementValue
}
func (my *ElementValues)      GetElementValues() IElementValues{ return my._ElementValues}
func (my *ElementValues)      SetElementValues( _ElementValues IElementValues)  { my._ElementValues = _ElementValues }
func (my *ElementValues)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ElementValues)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ElementValues)      GetElementValue() IElementValue{ return my._ElementValue}
func (my *ElementValues)      SetElementValue( _ElementValue IElementValue)  { my._ElementValue = _ElementValue }

func NewElementValues(leftIToken IToken, rightIToken IToken ,
              _ElementValues IElementValues,
              _COMMA *AstToken,
              _ElementValue IElementValue)*ElementValues{
      my := new(ElementValues)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ElementValues = _ElementValues;
        if nil != _ElementValues{
        var trait_ interface{} = _ElementValues
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._ElementValue = _ElementValue;
        if nil != _ElementValue{
        var trait_ interface{} = _ElementValue
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ElementValues)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ElementValues{  list.Add(my._ElementValues) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._ElementValue{  list.Add(my._ElementValue) }
        return list
    }

func (my *ElementValues)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ElementValues)       Enter(v Visitor){
        var checkChildren = v.VisitElementValues(my)
        if checkChildren{
            if nil != my._ElementValues{my._ElementValues.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._ElementValue{my._ElementValue.Accept(v)}
        }
        v.EndVisitElementValues(my)
    }


func AnyCastToElementValues(i interface{}) *ElementValues {
	if nil == i{
		return nil
	}else{
		return i.(*ElementValues)
	}
}
/**
 *<b>
*<li>Rule 245:  MarkerAnnotation ::= @ TypeName
 *</b>
 */
type MarkerAnnotation struct{
    *Ast
      _AT *AstToken
      _TypeName ITypeName
}
func (my *MarkerAnnotation)      GetAT() *AstToken{ return my._AT}
func (my *MarkerAnnotation)      SetAT( _AT *AstToken)  { my._AT = _AT }
func (my *MarkerAnnotation)      GetTypeName() ITypeName{ return my._TypeName}
func (my *MarkerAnnotation)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }

func NewMarkerAnnotation(leftIToken IToken, rightIToken IToken ,
              _AT *AstToken,
              _TypeName ITypeName)*MarkerAnnotation{
      my := new(MarkerAnnotation)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AT = _AT;
        if nil != _AT{
        var trait_ interface{} = _AT
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MarkerAnnotation)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AT{  list.Add(my._AT) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        return list
    }

func (my *MarkerAnnotation)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MarkerAnnotation)       Enter(v Visitor){
        var checkChildren = v.VisitMarkerAnnotation(my)
        if checkChildren{
            if nil != my._AT{my._AT.Accept(v)}
            if nil != my._TypeName{my._TypeName.Accept(v)}
        }
        v.EndVisitMarkerAnnotation(my)
    }


func AnyCastToMarkerAnnotation(i interface{}) *MarkerAnnotation {
	if nil == i{
		return nil
	}else{
		return i.(*MarkerAnnotation)
	}
}
/**
 *<b>
*<li>Rule 246:  SingleElementAnnotation ::= @ TypeName ( ElementValue )
 *</b>
 */
type SingleElementAnnotation struct{
    *Ast
      _AT *AstToken
      _TypeName ITypeName
      _LPAREN *AstToken
      _ElementValue IElementValue
      _RPAREN *AstToken
}
func (my *SingleElementAnnotation)      GetAT() *AstToken{ return my._AT}
func (my *SingleElementAnnotation)      SetAT( _AT *AstToken)  { my._AT = _AT }
func (my *SingleElementAnnotation)      GetTypeName() ITypeName{ return my._TypeName}
func (my *SingleElementAnnotation)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *SingleElementAnnotation)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *SingleElementAnnotation)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *SingleElementAnnotation)      GetElementValue() IElementValue{ return my._ElementValue}
func (my *SingleElementAnnotation)      SetElementValue( _ElementValue IElementValue)  { my._ElementValue = _ElementValue }
func (my *SingleElementAnnotation)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *SingleElementAnnotation)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewSingleElementAnnotation(leftIToken IToken, rightIToken IToken ,
              _AT *AstToken,
              _TypeName ITypeName,
              _LPAREN *AstToken,
              _ElementValue IElementValue,
              _RPAREN *AstToken)*SingleElementAnnotation{
      my := new(SingleElementAnnotation)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AT = _AT;
        if nil != _AT{
        var trait_ interface{} = _AT
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ElementValue = _ElementValue;
        if nil != _ElementValue{
        var trait_ interface{} = _ElementValue
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SingleElementAnnotation)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AT{  list.Add(my._AT) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ElementValue{  list.Add(my._ElementValue) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *SingleElementAnnotation)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SingleElementAnnotation)       Enter(v Visitor){
        var checkChildren = v.VisitSingleElementAnnotation(my)
        if checkChildren{
            if nil != my._AT{my._AT.Accept(v)}
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ElementValue{my._ElementValue.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitSingleElementAnnotation(my)
    }


func AnyCastToSingleElementAnnotation(i interface{}) *SingleElementAnnotation {
	if nil == i{
		return nil
	}else{
		return i.(*SingleElementAnnotation)
	}
}
/**
 *<b>
*<li>Rule 247:  ArrayInitializer ::= { VariableInitializersopt ,opt }
 *</b>
 */
type ArrayInitializer struct{
    *Ast
      _LBRACE *AstToken
      _VariableInitializersopt IVariableInitializersopt
      _Commaopt *Commaopt
      _RBRACE *AstToken
}
func (my *ArrayInitializer)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *ArrayInitializer)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetVariableInitializersopt</b> may be <b>null</b>
     */
func (my *ArrayInitializer)      GetVariableInitializersopt() IVariableInitializersopt{ return my._VariableInitializersopt}
func (my *ArrayInitializer)      SetVariableInitializersopt( _VariableInitializersopt IVariableInitializersopt)  { my._VariableInitializersopt = _VariableInitializersopt }
    /**
     * The value returned by <b>GetCommaopt</b> may be <b>null</b>
     */
func (my *ArrayInitializer)      GetCommaopt() *Commaopt{ return my._Commaopt}
func (my *ArrayInitializer)      SetCommaopt( _Commaopt *Commaopt)  { my._Commaopt = _Commaopt }
func (my *ArrayInitializer)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *ArrayInitializer)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewArrayInitializer(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _VariableInitializersopt IVariableInitializersopt,
              _Commaopt *Commaopt,
              _RBRACE *AstToken)*ArrayInitializer{
      my := new(ArrayInitializer)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._VariableInitializersopt = _VariableInitializersopt;
        if nil != _VariableInitializersopt{
        var trait_ interface{} = _VariableInitializersopt
         trait_.(IAst).SetParent(my)
}
        my._Commaopt = _Commaopt;
        if nil != _Commaopt{
        var trait_ interface{} = _Commaopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayInitializer)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._VariableInitializersopt{  list.Add(my._VariableInitializersopt) }
        if nil != my._Commaopt{  list.Add(my._Commaopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *ArrayInitializer)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArrayInitializer)       Enter(v Visitor){
        var checkChildren = v.VisitArrayInitializer(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._VariableInitializersopt{my._VariableInitializersopt.Accept(v)}
            if nil != my._Commaopt{my._Commaopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitArrayInitializer(my)
    }


func AnyCastToArrayInitializer(i interface{}) *ArrayInitializer {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayInitializer)
	}
}
/**
 *<em>
*<li>Rule 248:  VariableInitializers ::= VariableInitializer
 *</em>
 *<p>
 *<b>
*<li>Rule 249:  VariableInitializers ::= VariableInitializers , VariableInitializer
 *</b>
 */
type VariableInitializers struct{
    *Ast
      _VariableInitializers IVariableInitializers
      _COMMA *AstToken
      _VariableInitializer IVariableInitializer
}
func (my *VariableInitializers)      GetVariableInitializers() IVariableInitializers{ return my._VariableInitializers}
func (my *VariableInitializers)      SetVariableInitializers( _VariableInitializers IVariableInitializers)  { my._VariableInitializers = _VariableInitializers }
func (my *VariableInitializers)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *VariableInitializers)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *VariableInitializers)      GetVariableInitializer() IVariableInitializer{ return my._VariableInitializer}
func (my *VariableInitializers)      SetVariableInitializer( _VariableInitializer IVariableInitializer)  { my._VariableInitializer = _VariableInitializer }

func NewVariableInitializers(leftIToken IToken, rightIToken IToken ,
              _VariableInitializers IVariableInitializers,
              _COMMA *AstToken,
              _VariableInitializer IVariableInitializer)*VariableInitializers{
      my := new(VariableInitializers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableInitializers = _VariableInitializers;
        if nil != _VariableInitializers{
        var trait_ interface{} = _VariableInitializers
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._VariableInitializer = _VariableInitializer;
        if nil != _VariableInitializer{
        var trait_ interface{} = _VariableInitializer
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableInitializers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableInitializers{  list.Add(my._VariableInitializers) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._VariableInitializer{  list.Add(my._VariableInitializer) }
        return list
    }

func (my *VariableInitializers)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *VariableInitializers)       Enter(v Visitor){
        var checkChildren = v.VisitVariableInitializers(my)
        if checkChildren{
            if nil != my._VariableInitializers{my._VariableInitializers.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._VariableInitializer{my._VariableInitializer.Accept(v)}
        }
        v.EndVisitVariableInitializers(my)
    }


func AnyCastToVariableInitializers(i interface{}) *VariableInitializers {
	if nil == i{
		return nil
	}else{
		return i.(*VariableInitializers)
	}
}
/**
 *<b>
*<li>Rule 250:  Block ::= { BlockStatementsopt }
 *</b>
 */
type Block struct{
    *Ast
      _LBRACE *AstToken
      _BlockStatementsopt IBlockStatementsopt
      _RBRACE *AstToken
}
func (my *Block)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *Block)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetBlockStatementsopt</b> may be <b>null</b>
     */
func (my *Block)      GetBlockStatementsopt() IBlockStatementsopt{ return my._BlockStatementsopt}
func (my *Block)      SetBlockStatementsopt( _BlockStatementsopt IBlockStatementsopt)  { my._BlockStatementsopt = _BlockStatementsopt }
func (my *Block)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *Block)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewBlock(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _BlockStatementsopt IBlockStatementsopt,
              _RBRACE *AstToken)*Block{
      my := new(Block)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._BlockStatementsopt = _BlockStatementsopt;
        if nil != _BlockStatementsopt{
        var trait_ interface{} = _BlockStatementsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Block)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._BlockStatementsopt{  list.Add(my._BlockStatementsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *Block)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Block)       Enter(v Visitor){
        var checkChildren = v.VisitBlock(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._BlockStatementsopt{my._BlockStatementsopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitBlock(my)
    }


func AnyCastToBlock(i interface{}) *Block {
	if nil == i{
		return nil
	}else{
		return i.(*Block)
	}
}
/**
 *<em>
*<li>Rule 251:  BlockStatements ::= BlockStatement
 *</em>
 *<p>
 *<b>
*<li>Rule 252:  BlockStatements ::= BlockStatements BlockStatement
 *</b>
 */
type BlockStatements struct{
    *Ast
      _BlockStatements IBlockStatements
      _BlockStatement IBlockStatement
}
func (my *BlockStatements)      GetBlockStatements() IBlockStatements{ return my._BlockStatements}
func (my *BlockStatements)      SetBlockStatements( _BlockStatements IBlockStatements)  { my._BlockStatements = _BlockStatements }
func (my *BlockStatements)      GetBlockStatement() IBlockStatement{ return my._BlockStatement}
func (my *BlockStatements)      SetBlockStatement( _BlockStatement IBlockStatement)  { my._BlockStatement = _BlockStatement }

func NewBlockStatements(leftIToken IToken, rightIToken IToken ,
              _BlockStatements IBlockStatements,
              _BlockStatement IBlockStatement)*BlockStatements{
      my := new(BlockStatements)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._BlockStatements = _BlockStatements;
        if nil != _BlockStatements{
        var trait_ interface{} = _BlockStatements
         trait_.(IAst).SetParent(my)
}
        my._BlockStatement = _BlockStatement;
        if nil != _BlockStatement{
        var trait_ interface{} = _BlockStatement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *BlockStatements)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._BlockStatements{  list.Add(my._BlockStatements) }
        if nil != my._BlockStatement{  list.Add(my._BlockStatement) }
        return list
    }

func (my *BlockStatements)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *BlockStatements)       Enter(v Visitor){
        var checkChildren = v.VisitBlockStatements(my)
        if checkChildren{
            if nil != my._BlockStatements{my._BlockStatements.Accept(v)}
            if nil != my._BlockStatement{my._BlockStatement.Accept(v)}
        }
        v.EndVisitBlockStatements(my)
    }


func AnyCastToBlockStatements(i interface{}) *BlockStatements {
	if nil == i{
		return nil
	}else{
		return i.(*BlockStatements)
	}
}
/**
 *<b>
*<li>Rule 256:  LocalVariableDeclarationStatement ::= LocalVariableDeclaration ;
 *</b>
 */
type LocalVariableDeclarationStatement struct{
    *Ast
      _LocalVariableDeclaration *LocalVariableDeclaration
      _SEMICOLON *AstToken
}
func (my *LocalVariableDeclarationStatement)      GetLocalVariableDeclaration() *LocalVariableDeclaration{ return my._LocalVariableDeclaration}
func (my *LocalVariableDeclarationStatement)      SetLocalVariableDeclaration( _LocalVariableDeclaration *LocalVariableDeclaration)  { my._LocalVariableDeclaration = _LocalVariableDeclaration }
func (my *LocalVariableDeclarationStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *LocalVariableDeclarationStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewLocalVariableDeclarationStatement(leftIToken IToken, rightIToken IToken ,
              _LocalVariableDeclaration *LocalVariableDeclaration,
              _SEMICOLON *AstToken)*LocalVariableDeclarationStatement{
      my := new(LocalVariableDeclarationStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LocalVariableDeclaration = _LocalVariableDeclaration;
        if nil != _LocalVariableDeclaration{
        var trait_ interface{} = _LocalVariableDeclaration
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LocalVariableDeclarationStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LocalVariableDeclaration{  list.Add(my._LocalVariableDeclaration) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *LocalVariableDeclarationStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LocalVariableDeclarationStatement)       Enter(v Visitor){
        var checkChildren = v.VisitLocalVariableDeclarationStatement(my)
        if checkChildren{
            if nil != my._LocalVariableDeclaration{my._LocalVariableDeclaration.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitLocalVariableDeclarationStatement(my)
    }


func AnyCastToLocalVariableDeclarationStatement(i interface{}) *LocalVariableDeclarationStatement {
	if nil == i{
		return nil
	}else{
		return i.(*LocalVariableDeclarationStatement)
	}
}
/**
 *<b>
*<li>Rule 257:  LocalVariableDeclaration ::= VariableModifiersopt Type VariableDeclarators
 *</b>
 */
type LocalVariableDeclaration struct{
    *Ast
      _VariableModifiersopt IVariableModifiersopt
      _Type IType
      _VariableDeclarators IVariableDeclarators
}
    /**
     * The value returned by <b>GetVariableModifiersopt</b> may be <b>null</b>
     */
func (my *LocalVariableDeclaration)      GetVariableModifiersopt() IVariableModifiersopt{ return my._VariableModifiersopt}
func (my *LocalVariableDeclaration)      SetVariableModifiersopt( _VariableModifiersopt IVariableModifiersopt)  { my._VariableModifiersopt = _VariableModifiersopt }
func (my *LocalVariableDeclaration)      GetType() IType{ return my._Type}
func (my *LocalVariableDeclaration)      SetType( _Type IType)  { my._Type = _Type }
func (my *LocalVariableDeclaration)      GetVariableDeclarators() IVariableDeclarators{ return my._VariableDeclarators}
func (my *LocalVariableDeclaration)      SetVariableDeclarators( _VariableDeclarators IVariableDeclarators)  { my._VariableDeclarators = _VariableDeclarators }

func NewLocalVariableDeclaration(leftIToken IToken, rightIToken IToken ,
              _VariableModifiersopt IVariableModifiersopt,
              _Type IType,
              _VariableDeclarators IVariableDeclarators)*LocalVariableDeclaration{
      my := new(LocalVariableDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableModifiersopt = _VariableModifiersopt;
        if nil != _VariableModifiersopt{
        var trait_ interface{} = _VariableModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclarators = _VariableDeclarators;
        if nil != _VariableDeclarators{
        var trait_ interface{} = _VariableDeclarators
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LocalVariableDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableModifiersopt{  list.Add(my._VariableModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._VariableDeclarators{  list.Add(my._VariableDeclarators) }
        return list
    }

func (my *LocalVariableDeclaration)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LocalVariableDeclaration)       Enter(v Visitor){
        var checkChildren = v.VisitLocalVariableDeclaration(my)
        if checkChildren{
            if nil != my._VariableModifiersopt{my._VariableModifiersopt.Accept(v)}
            if nil != my._Type{my._Type.Accept(v)}
            if nil != my._VariableDeclarators{my._VariableDeclarators.Accept(v)}
        }
        v.EndVisitLocalVariableDeclaration(my)
    }


func AnyCastToLocalVariableDeclaration(i interface{}) *LocalVariableDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*LocalVariableDeclaration)
	}
}
/**
 *<b>
*<li>Rule 281:  IfThenStatement ::= if ( Expression ) Statement
 *</b>
 */
type IfThenStatement struct{
    *Ast
      _if *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _Statement IStatement
}
func (my *IfThenStatement)      Getif() *AstToken{ return my._if}
func (my *IfThenStatement)      Setif( _if *AstToken)  { my._if = _if }
func (my *IfThenStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *IfThenStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *IfThenStatement)      GetExpression() IExpression{ return my._Expression}
func (my *IfThenStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *IfThenStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *IfThenStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *IfThenStatement)      GetStatement() IStatement{ return my._Statement}
func (my *IfThenStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewIfThenStatement(leftIToken IToken, rightIToken IToken ,
              _if *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _Statement IStatement)*IfThenStatement{
      my := new(IfThenStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._if = _if;
        if nil != _if{
        var trait_ interface{} = _if
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *IfThenStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._if{  list.Add(my._if) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *IfThenStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *IfThenStatement)       Enter(v Visitor){
        var checkChildren = v.VisitIfThenStatement(my)
        if checkChildren{
            if nil != my._if{my._if.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._Statement{my._Statement.Accept(v)}
        }
        v.EndVisitIfThenStatement(my)
    }


func AnyCastToIfThenStatement(i interface{}) *IfThenStatement {
	if nil == i{
		return nil
	}else{
		return i.(*IfThenStatement)
	}
}
/**
 *<b>
*<li>Rule 282:  IfThenElseStatement ::= if ( Expression ) StatementNoShortIf else Statement
 *</b>
 */
type IfThenElseStatement struct{
    *Ast
      _if *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _StatementNoShortIf IStatementNoShortIf
      _else *AstToken
      _Statement IStatement
}
func (my *IfThenElseStatement)      Getif() *AstToken{ return my._if}
func (my *IfThenElseStatement)      Setif( _if *AstToken)  { my._if = _if }
func (my *IfThenElseStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *IfThenElseStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *IfThenElseStatement)      GetExpression() IExpression{ return my._Expression}
func (my *IfThenElseStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *IfThenElseStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *IfThenElseStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *IfThenElseStatement)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *IfThenElseStatement)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }
func (my *IfThenElseStatement)      Getelse() *AstToken{ return my._else}
func (my *IfThenElseStatement)      Setelse( _else *AstToken)  { my._else = _else }
func (my *IfThenElseStatement)      GetStatement() IStatement{ return my._Statement}
func (my *IfThenElseStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewIfThenElseStatement(leftIToken IToken, rightIToken IToken ,
              _if *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _StatementNoShortIf IStatementNoShortIf,
              _else *AstToken,
              _Statement IStatement)*IfThenElseStatement{
      my := new(IfThenElseStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._if = _if;
        if nil != _if{
        var trait_ interface{} = _if
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my._else = _else;
        if nil != _else{
        var trait_ interface{} = _else
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *IfThenElseStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._if{  list.Add(my._if) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        if nil != my._else{  list.Add(my._else) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *IfThenElseStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *IfThenElseStatement)       Enter(v Visitor){
        var checkChildren = v.VisitIfThenElseStatement(my)
        if checkChildren{
            if nil != my._if{my._if.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._StatementNoShortIf{my._StatementNoShortIf.Accept(v)}
            if nil != my._else{my._else.Accept(v)}
            if nil != my._Statement{my._Statement.Accept(v)}
        }
        v.EndVisitIfThenElseStatement(my)
    }


func AnyCastToIfThenElseStatement(i interface{}) *IfThenElseStatement {
	if nil == i{
		return nil
	}else{
		return i.(*IfThenElseStatement)
	}
}
/**
 *<b>
*<li>Rule 283:  IfThenElseStatementNoShortIf ::= if ( Expression ) StatementNoShortIf else StatementNoShortIf
 *</b>
 */
type IfThenElseStatementNoShortIf struct{
    *Ast
      _if *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _StatementNoShortIf IStatementNoShortIf
      _else *AstToken
      _StatementNoShortIf7 IStatementNoShortIf
}
func (my *IfThenElseStatementNoShortIf)      Getif() *AstToken{ return my._if}
func (my *IfThenElseStatementNoShortIf)      Setif( _if *AstToken)  { my._if = _if }
func (my *IfThenElseStatementNoShortIf)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *IfThenElseStatementNoShortIf)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *IfThenElseStatementNoShortIf)      GetExpression() IExpression{ return my._Expression}
func (my *IfThenElseStatementNoShortIf)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *IfThenElseStatementNoShortIf)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *IfThenElseStatementNoShortIf)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *IfThenElseStatementNoShortIf)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *IfThenElseStatementNoShortIf)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }
func (my *IfThenElseStatementNoShortIf)      Getelse() *AstToken{ return my._else}
func (my *IfThenElseStatementNoShortIf)      Setelse( _else *AstToken)  { my._else = _else }
func (my *IfThenElseStatementNoShortIf)      GetStatementNoShortIf7() IStatementNoShortIf{ return my._StatementNoShortIf7}
func (my *IfThenElseStatementNoShortIf)      SetStatementNoShortIf7( _StatementNoShortIf7 IStatementNoShortIf)  { my._StatementNoShortIf7 = _StatementNoShortIf7 }

func NewIfThenElseStatementNoShortIf(leftIToken IToken, rightIToken IToken ,
              _if *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _StatementNoShortIf IStatementNoShortIf,
              _else *AstToken,
              _StatementNoShortIf7 IStatementNoShortIf)*IfThenElseStatementNoShortIf{
      my := new(IfThenElseStatementNoShortIf)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._if = _if;
        if nil != _if{
        var trait_ interface{} = _if
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my._else = _else;
        if nil != _else{
        var trait_ interface{} = _else
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf7 = _StatementNoShortIf7;
        if nil != _StatementNoShortIf7{
        var trait_ interface{} = _StatementNoShortIf7
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *IfThenElseStatementNoShortIf)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._if{  list.Add(my._if) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        if nil != my._else{  list.Add(my._else) }
        if nil != my._StatementNoShortIf7{  list.Add(my._StatementNoShortIf7) }
        return list
    }

func (my *IfThenElseStatementNoShortIf)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *IfThenElseStatementNoShortIf)       Enter(v Visitor){
        var checkChildren = v.VisitIfThenElseStatementNoShortIf(my)
        if checkChildren{
            if nil != my._if{my._if.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._StatementNoShortIf{my._StatementNoShortIf.Accept(v)}
            if nil != my._else{my._else.Accept(v)}
            if nil != my._StatementNoShortIf7{my._StatementNoShortIf7.Accept(v)}
        }
        v.EndVisitIfThenElseStatementNoShortIf(my)
    }


func AnyCastToIfThenElseStatementNoShortIf(i interface{}) *IfThenElseStatementNoShortIf {
	if nil == i{
		return nil
	}else{
		return i.(*IfThenElseStatementNoShortIf)
	}
}
/**
 *<b>
*<li>Rule 284:  EmptyStatement ::= ;
 *</b>
 */
type EmptyStatement struct{
    *AstToken
}
func (my *EmptyStatement)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewEmptyStatement(token IToken )*EmptyStatement{
      my := new(EmptyStatement)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *EmptyStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EmptyStatement)       Enter(v Visitor){
        v.VisitEmptyStatement(my)
        v.EndVisitEmptyStatement(my)
    }


func AnyCastToEmptyStatement(i interface{}) *EmptyStatement {
	if nil == i{
		return nil
	}else{
		return i.(*EmptyStatement)
	}
}
/**
 *<b>
*<li>Rule 285:  LabeledStatement ::= identifier : Statement
 *</b>
 */
type LabeledStatement struct{
    *Ast
      _identifier *identifier
      _COLON *AstToken
      _Statement IStatement
}
func (my *LabeledStatement)      Getidentifier() *identifier{ return my._identifier}
func (my *LabeledStatement)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *LabeledStatement)      GetCOLON() *AstToken{ return my._COLON}
func (my *LabeledStatement)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *LabeledStatement)      GetStatement() IStatement{ return my._Statement}
func (my *LabeledStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewLabeledStatement(leftIToken IToken, rightIToken IToken ,
              _identifier *identifier,
              _COLON *AstToken,
              _Statement IStatement)*LabeledStatement{
      my := new(LabeledStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LabeledStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *LabeledStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LabeledStatement)       Enter(v Visitor){
        var checkChildren = v.VisitLabeledStatement(my)
        if checkChildren{
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._COLON{my._COLON.Accept(v)}
            if nil != my._Statement{my._Statement.Accept(v)}
        }
        v.EndVisitLabeledStatement(my)
    }


func AnyCastToLabeledStatement(i interface{}) *LabeledStatement {
	if nil == i{
		return nil
	}else{
		return i.(*LabeledStatement)
	}
}
/**
 *<b>
*<li>Rule 286:  LabeledStatementNoShortIf ::= identifier : StatementNoShortIf
 *</b>
 */
type LabeledStatementNoShortIf struct{
    *Ast
      _identifier *identifier
      _COLON *AstToken
      _StatementNoShortIf IStatementNoShortIf
}
func (my *LabeledStatementNoShortIf)      Getidentifier() *identifier{ return my._identifier}
func (my *LabeledStatementNoShortIf)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *LabeledStatementNoShortIf)      GetCOLON() *AstToken{ return my._COLON}
func (my *LabeledStatementNoShortIf)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *LabeledStatementNoShortIf)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *LabeledStatementNoShortIf)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }

func NewLabeledStatementNoShortIf(leftIToken IToken, rightIToken IToken ,
              _identifier *identifier,
              _COLON *AstToken,
              _StatementNoShortIf IStatementNoShortIf)*LabeledStatementNoShortIf{
      my := new(LabeledStatementNoShortIf)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LabeledStatementNoShortIf)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        return list
    }

func (my *LabeledStatementNoShortIf)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LabeledStatementNoShortIf)       Enter(v Visitor){
        var checkChildren = v.VisitLabeledStatementNoShortIf(my)
        if checkChildren{
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._COLON{my._COLON.Accept(v)}
            if nil != my._StatementNoShortIf{my._StatementNoShortIf.Accept(v)}
        }
        v.EndVisitLabeledStatementNoShortIf(my)
    }


func AnyCastToLabeledStatementNoShortIf(i interface{}) *LabeledStatementNoShortIf {
	if nil == i{
		return nil
	}else{
		return i.(*LabeledStatementNoShortIf)
	}
}
/**
 *<b>
*<li>Rule 287:  ExpressionStatement ::= StatementExpression ;
 *</b>
 */
type ExpressionStatement struct{
    *Ast
      _StatementExpression IStatementExpression
      _SEMICOLON *AstToken
}
func (my *ExpressionStatement)      GetStatementExpression() IStatementExpression{ return my._StatementExpression}
func (my *ExpressionStatement)      SetStatementExpression( _StatementExpression IStatementExpression)  { my._StatementExpression = _StatementExpression }
func (my *ExpressionStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ExpressionStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewExpressionStatement(leftIToken IToken, rightIToken IToken ,
              _StatementExpression IStatementExpression,
              _SEMICOLON *AstToken)*ExpressionStatement{
      my := new(ExpressionStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._StatementExpression = _StatementExpression;
        if nil != _StatementExpression{
        var trait_ interface{} = _StatementExpression
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExpressionStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._StatementExpression{  list.Add(my._StatementExpression) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ExpressionStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExpressionStatement)       Enter(v Visitor){
        var checkChildren = v.VisitExpressionStatement(my)
        if checkChildren{
            if nil != my._StatementExpression{my._StatementExpression.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitExpressionStatement(my)
    }


func AnyCastToExpressionStatement(i interface{}) *ExpressionStatement {
	if nil == i{
		return nil
	}else{
		return i.(*ExpressionStatement)
	}
}
/**
 *<b>
*<li>Rule 297:  SwitchStatement ::= switch ( Expression ) SwitchBlock
 *</b>
 */
type SwitchStatement struct{
    *Ast
      _switch *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _SwitchBlock *SwitchBlock
}
func (my *SwitchStatement)      Getswitch() *AstToken{ return my._switch}
func (my *SwitchStatement)      Setswitch( _switch *AstToken)  { my._switch = _switch }
func (my *SwitchStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *SwitchStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *SwitchStatement)      GetExpression() IExpression{ return my._Expression}
func (my *SwitchStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *SwitchStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *SwitchStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *SwitchStatement)      GetSwitchBlock() *SwitchBlock{ return my._SwitchBlock}
func (my *SwitchStatement)      SetSwitchBlock( _SwitchBlock *SwitchBlock)  { my._SwitchBlock = _SwitchBlock }

func NewSwitchStatement(leftIToken IToken, rightIToken IToken ,
              _switch *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _SwitchBlock *SwitchBlock)*SwitchStatement{
      my := new(SwitchStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._switch = _switch;
        if nil != _switch{
        var trait_ interface{} = _switch
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SwitchBlock = _SwitchBlock;
        if nil != _SwitchBlock{
        var trait_ interface{} = _SwitchBlock
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._switch{  list.Add(my._switch) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SwitchBlock{  list.Add(my._SwitchBlock) }
        return list
    }

func (my *SwitchStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SwitchStatement)       Enter(v Visitor){
        var checkChildren = v.VisitSwitchStatement(my)
        if checkChildren{
            if nil != my._switch{my._switch.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._SwitchBlock{my._SwitchBlock.Accept(v)}
        }
        v.EndVisitSwitchStatement(my)
    }


func AnyCastToSwitchStatement(i interface{}) *SwitchStatement {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchStatement)
	}
}
/**
 *<b>
*<li>Rule 298:  SwitchBlock ::= { SwitchBlockStatementGroupsopt SwitchLabelsopt }
 *</b>
 */
type SwitchBlock struct{
    *Ast
      _LBRACE *AstToken
      _SwitchBlockStatementGroupsopt ISwitchBlockStatementGroupsopt
      _SwitchLabelsopt ISwitchLabelsopt
      _RBRACE *AstToken
}
func (my *SwitchBlock)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *SwitchBlock)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetSwitchBlockStatementGroupsopt</b> may be <b>null</b>
     */
func (my *SwitchBlock)      GetSwitchBlockStatementGroupsopt() ISwitchBlockStatementGroupsopt{ return my._SwitchBlockStatementGroupsopt}
func (my *SwitchBlock)      SetSwitchBlockStatementGroupsopt( _SwitchBlockStatementGroupsopt ISwitchBlockStatementGroupsopt)  { my._SwitchBlockStatementGroupsopt = _SwitchBlockStatementGroupsopt }
    /**
     * The value returned by <b>GetSwitchLabelsopt</b> may be <b>null</b>
     */
func (my *SwitchBlock)      GetSwitchLabelsopt() ISwitchLabelsopt{ return my._SwitchLabelsopt}
func (my *SwitchBlock)      SetSwitchLabelsopt( _SwitchLabelsopt ISwitchLabelsopt)  { my._SwitchLabelsopt = _SwitchLabelsopt }
func (my *SwitchBlock)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *SwitchBlock)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewSwitchBlock(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _SwitchBlockStatementGroupsopt ISwitchBlockStatementGroupsopt,
              _SwitchLabelsopt ISwitchLabelsopt,
              _RBRACE *AstToken)*SwitchBlock{
      my := new(SwitchBlock)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._SwitchBlockStatementGroupsopt = _SwitchBlockStatementGroupsopt;
        if nil != _SwitchBlockStatementGroupsopt{
        var trait_ interface{} = _SwitchBlockStatementGroupsopt
         trait_.(IAst).SetParent(my)
}
        my._SwitchLabelsopt = _SwitchLabelsopt;
        if nil != _SwitchLabelsopt{
        var trait_ interface{} = _SwitchLabelsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchBlock)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._SwitchBlockStatementGroupsopt{  list.Add(my._SwitchBlockStatementGroupsopt) }
        if nil != my._SwitchLabelsopt{  list.Add(my._SwitchLabelsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *SwitchBlock)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SwitchBlock)       Enter(v Visitor){
        var checkChildren = v.VisitSwitchBlock(my)
        if checkChildren{
            if nil != my._LBRACE{my._LBRACE.Accept(v)}
            if nil != my._SwitchBlockStatementGroupsopt{my._SwitchBlockStatementGroupsopt.Accept(v)}
            if nil != my._SwitchLabelsopt{my._SwitchLabelsopt.Accept(v)}
            if nil != my._RBRACE{my._RBRACE.Accept(v)}
        }
        v.EndVisitSwitchBlock(my)
    }


func AnyCastToSwitchBlock(i interface{}) *SwitchBlock {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchBlock)
	}
}
/**
 *<em>
*<li>Rule 299:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroup
 *</em>
 *<p>
 *<b>
*<li>Rule 300:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup
 *</b>
 */
type SwitchBlockStatementGroups struct{
    *Ast
      _SwitchBlockStatementGroups ISwitchBlockStatementGroups
      _SwitchBlockStatementGroup *SwitchBlockStatementGroup
}
func (my *SwitchBlockStatementGroups)      GetSwitchBlockStatementGroups() ISwitchBlockStatementGroups{ return my._SwitchBlockStatementGroups}
func (my *SwitchBlockStatementGroups)      SetSwitchBlockStatementGroups( _SwitchBlockStatementGroups ISwitchBlockStatementGroups)  { my._SwitchBlockStatementGroups = _SwitchBlockStatementGroups }
func (my *SwitchBlockStatementGroups)      GetSwitchBlockStatementGroup() *SwitchBlockStatementGroup{ return my._SwitchBlockStatementGroup}
func (my *SwitchBlockStatementGroups)      SetSwitchBlockStatementGroup( _SwitchBlockStatementGroup *SwitchBlockStatementGroup)  { my._SwitchBlockStatementGroup = _SwitchBlockStatementGroup }

func NewSwitchBlockStatementGroups(leftIToken IToken, rightIToken IToken ,
              _SwitchBlockStatementGroups ISwitchBlockStatementGroups,
              _SwitchBlockStatementGroup *SwitchBlockStatementGroup)*SwitchBlockStatementGroups{
      my := new(SwitchBlockStatementGroups)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SwitchBlockStatementGroups = _SwitchBlockStatementGroups;
        if nil != _SwitchBlockStatementGroups{
        var trait_ interface{} = _SwitchBlockStatementGroups
         trait_.(IAst).SetParent(my)
}
        my._SwitchBlockStatementGroup = _SwitchBlockStatementGroup;
        if nil != _SwitchBlockStatementGroup{
        var trait_ interface{} = _SwitchBlockStatementGroup
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchBlockStatementGroups)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SwitchBlockStatementGroups{  list.Add(my._SwitchBlockStatementGroups) }
        if nil != my._SwitchBlockStatementGroup{  list.Add(my._SwitchBlockStatementGroup) }
        return list
    }

func (my *SwitchBlockStatementGroups)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SwitchBlockStatementGroups)       Enter(v Visitor){
        var checkChildren = v.VisitSwitchBlockStatementGroups(my)
        if checkChildren{
            if nil != my._SwitchBlockStatementGroups{my._SwitchBlockStatementGroups.Accept(v)}
            if nil != my._SwitchBlockStatementGroup{my._SwitchBlockStatementGroup.Accept(v)}
        }
        v.EndVisitSwitchBlockStatementGroups(my)
    }


func AnyCastToSwitchBlockStatementGroups(i interface{}) *SwitchBlockStatementGroups {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchBlockStatementGroups)
	}
}
/**
 *<b>
*<li>Rule 301:  SwitchBlockStatementGroup ::= SwitchLabels BlockStatements
 *</b>
 */
type SwitchBlockStatementGroup struct{
    *Ast
      _SwitchLabels ISwitchLabels
      _BlockStatements IBlockStatements
}
func (my *SwitchBlockStatementGroup)      GetSwitchLabels() ISwitchLabels{ return my._SwitchLabels}
func (my *SwitchBlockStatementGroup)      SetSwitchLabels( _SwitchLabels ISwitchLabels)  { my._SwitchLabels = _SwitchLabels }
func (my *SwitchBlockStatementGroup)      GetBlockStatements() IBlockStatements{ return my._BlockStatements}
func (my *SwitchBlockStatementGroup)      SetBlockStatements( _BlockStatements IBlockStatements)  { my._BlockStatements = _BlockStatements }

func NewSwitchBlockStatementGroup(leftIToken IToken, rightIToken IToken ,
              _SwitchLabels ISwitchLabels,
              _BlockStatements IBlockStatements)*SwitchBlockStatementGroup{
      my := new(SwitchBlockStatementGroup)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SwitchLabels = _SwitchLabels;
        if nil != _SwitchLabels{
        var trait_ interface{} = _SwitchLabels
         trait_.(IAst).SetParent(my)
}
        my._BlockStatements = _BlockStatements;
        if nil != _BlockStatements{
        var trait_ interface{} = _BlockStatements
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchBlockStatementGroup)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SwitchLabels{  list.Add(my._SwitchLabels) }
        if nil != my._BlockStatements{  list.Add(my._BlockStatements) }
        return list
    }

func (my *SwitchBlockStatementGroup)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SwitchBlockStatementGroup)       Enter(v Visitor){
        var checkChildren = v.VisitSwitchBlockStatementGroup(my)
        if checkChildren{
            if nil != my._SwitchLabels{my._SwitchLabels.Accept(v)}
            if nil != my._BlockStatements{my._BlockStatements.Accept(v)}
        }
        v.EndVisitSwitchBlockStatementGroup(my)
    }


func AnyCastToSwitchBlockStatementGroup(i interface{}) *SwitchBlockStatementGroup {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchBlockStatementGroup)
	}
}
/**
 *<em>
*<li>Rule 302:  SwitchLabels ::= SwitchLabel
 *</em>
 *<p>
 *<b>
*<li>Rule 303:  SwitchLabels ::= SwitchLabels SwitchLabel
 *</b>
 */
type SwitchLabels struct{
    *Ast
      _SwitchLabels ISwitchLabels
      _SwitchLabel ISwitchLabel
}
func (my *SwitchLabels)      GetSwitchLabels() ISwitchLabels{ return my._SwitchLabels}
func (my *SwitchLabels)      SetSwitchLabels( _SwitchLabels ISwitchLabels)  { my._SwitchLabels = _SwitchLabels }
func (my *SwitchLabels)      GetSwitchLabel() ISwitchLabel{ return my._SwitchLabel}
func (my *SwitchLabels)      SetSwitchLabel( _SwitchLabel ISwitchLabel)  { my._SwitchLabel = _SwitchLabel }

func NewSwitchLabels(leftIToken IToken, rightIToken IToken ,
              _SwitchLabels ISwitchLabels,
              _SwitchLabel ISwitchLabel)*SwitchLabels{
      my := new(SwitchLabels)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SwitchLabels = _SwitchLabels;
        if nil != _SwitchLabels{
        var trait_ interface{} = _SwitchLabels
         trait_.(IAst).SetParent(my)
}
        my._SwitchLabel = _SwitchLabel;
        if nil != _SwitchLabel{
        var trait_ interface{} = _SwitchLabel
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchLabels)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SwitchLabels{  list.Add(my._SwitchLabels) }
        if nil != my._SwitchLabel{  list.Add(my._SwitchLabel) }
        return list
    }

func (my *SwitchLabels)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SwitchLabels)       Enter(v Visitor){
        var checkChildren = v.VisitSwitchLabels(my)
        if checkChildren{
            if nil != my._SwitchLabels{my._SwitchLabels.Accept(v)}
            if nil != my._SwitchLabel{my._SwitchLabel.Accept(v)}
        }
        v.EndVisitSwitchLabels(my)
    }


func AnyCastToSwitchLabels(i interface{}) *SwitchLabels {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchLabels)
	}
}
/**
 *<b>
*<li>Rule 308:  WhileStatement ::= while ( Expression ) Statement
 *</b>
 */
type WhileStatement struct{
    *Ast
      _while *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _Statement IStatement
}
func (my *WhileStatement)      Getwhile() *AstToken{ return my._while}
func (my *WhileStatement)      Setwhile( _while *AstToken)  { my._while = _while }
func (my *WhileStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *WhileStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *WhileStatement)      GetExpression() IExpression{ return my._Expression}
func (my *WhileStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *WhileStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *WhileStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *WhileStatement)      GetStatement() IStatement{ return my._Statement}
func (my *WhileStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewWhileStatement(leftIToken IToken, rightIToken IToken ,
              _while *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _Statement IStatement)*WhileStatement{
      my := new(WhileStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._while = _while;
        if nil != _while{
        var trait_ interface{} = _while
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *WhileStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._while{  list.Add(my._while) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *WhileStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *WhileStatement)       Enter(v Visitor){
        var checkChildren = v.VisitWhileStatement(my)
        if checkChildren{
            if nil != my._while{my._while.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._Statement{my._Statement.Accept(v)}
        }
        v.EndVisitWhileStatement(my)
    }


func AnyCastToWhileStatement(i interface{}) *WhileStatement {
	if nil == i{
		return nil
	}else{
		return i.(*WhileStatement)
	}
}
/**
 *<b>
*<li>Rule 309:  WhileStatementNoShortIf ::= while ( Expression ) StatementNoShortIf
 *</b>
 */
type WhileStatementNoShortIf struct{
    *Ast
      _while *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _StatementNoShortIf IStatementNoShortIf
}
func (my *WhileStatementNoShortIf)      Getwhile() *AstToken{ return my._while}
func (my *WhileStatementNoShortIf)      Setwhile( _while *AstToken)  { my._while = _while }
func (my *WhileStatementNoShortIf)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *WhileStatementNoShortIf)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *WhileStatementNoShortIf)      GetExpression() IExpression{ return my._Expression}
func (my *WhileStatementNoShortIf)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *WhileStatementNoShortIf)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *WhileStatementNoShortIf)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *WhileStatementNoShortIf)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *WhileStatementNoShortIf)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }

func NewWhileStatementNoShortIf(leftIToken IToken, rightIToken IToken ,
              _while *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _StatementNoShortIf IStatementNoShortIf)*WhileStatementNoShortIf{
      my := new(WhileStatementNoShortIf)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._while = _while;
        if nil != _while{
        var trait_ interface{} = _while
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *WhileStatementNoShortIf)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._while{  list.Add(my._while) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        return list
    }

func (my *WhileStatementNoShortIf)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *WhileStatementNoShortIf)       Enter(v Visitor){
        var checkChildren = v.VisitWhileStatementNoShortIf(my)
        if checkChildren{
            if nil != my._while{my._while.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._StatementNoShortIf{my._StatementNoShortIf.Accept(v)}
        }
        v.EndVisitWhileStatementNoShortIf(my)
    }


func AnyCastToWhileStatementNoShortIf(i interface{}) *WhileStatementNoShortIf {
	if nil == i{
		return nil
	}else{
		return i.(*WhileStatementNoShortIf)
	}
}
/**
 *<b>
*<li>Rule 310:  DoStatement ::= do Statement while ( Expression ) ;
 *</b>
 */
type DoStatement struct{
    *Ast
      _do *AstToken
      _Statement IStatement
      _while *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _SEMICOLON *AstToken
}
func (my *DoStatement)      Getdo() *AstToken{ return my._do}
func (my *DoStatement)      Setdo( _do *AstToken)  { my._do = _do }
func (my *DoStatement)      GetStatement() IStatement{ return my._Statement}
func (my *DoStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }
func (my *DoStatement)      Getwhile() *AstToken{ return my._while}
func (my *DoStatement)      Setwhile( _while *AstToken)  { my._while = _while }
func (my *DoStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *DoStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *DoStatement)      GetExpression() IExpression{ return my._Expression}
func (my *DoStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *DoStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *DoStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *DoStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *DoStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewDoStatement(leftIToken IToken, rightIToken IToken ,
              _do *AstToken,
              _Statement IStatement,
              _while *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _SEMICOLON *AstToken)*DoStatement{
      my := new(DoStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._do = _do;
        if nil != _do{
        var trait_ interface{} = _do
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my._while = _while;
        if nil != _while{
        var trait_ interface{} = _while
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *DoStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._do{  list.Add(my._do) }
        if nil != my._Statement{  list.Add(my._Statement) }
        if nil != my._while{  list.Add(my._while) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *DoStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *DoStatement)       Enter(v Visitor){
        var checkChildren = v.VisitDoStatement(my)
        if checkChildren{
            if nil != my._do{my._do.Accept(v)}
            if nil != my._Statement{my._Statement.Accept(v)}
            if nil != my._while{my._while.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitDoStatement(my)
    }


func AnyCastToDoStatement(i interface{}) *DoStatement {
	if nil == i{
		return nil
	}else{
		return i.(*DoStatement)
	}
}
/**
 *<b>
*<li>Rule 313:  BasicForStatement ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement
 *</b>
 */
type BasicForStatement struct{
    *Ast
      _for *AstToken
      _LPAREN *AstToken
      _ForInitopt IForInitopt
      _SEMICOLON *AstToken
      _Expressionopt IExpressionopt
      _SEMICOLON6 *AstToken
      _ForUpdateopt IForUpdateopt
      _RPAREN *AstToken
      _Statement IStatement
}
func (my *BasicForStatement)      Getfor() *AstToken{ return my._for}
func (my *BasicForStatement)      Setfor( _for *AstToken)  { my._for = _for }
func (my *BasicForStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *BasicForStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetForInitopt</b> may be <b>null</b>
     */
func (my *BasicForStatement)      GetForInitopt() IForInitopt{ return my._ForInitopt}
func (my *BasicForStatement)      SetForInitopt( _ForInitopt IForInitopt)  { my._ForInitopt = _ForInitopt }
func (my *BasicForStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *BasicForStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }
    /**
     * The value returned by <b>GetExpressionopt</b> may be <b>null</b>
     */
func (my *BasicForStatement)      GetExpressionopt() IExpressionopt{ return my._Expressionopt}
func (my *BasicForStatement)      SetExpressionopt( _Expressionopt IExpressionopt)  { my._Expressionopt = _Expressionopt }
func (my *BasicForStatement)      GetSEMICOLON6() *AstToken{ return my._SEMICOLON6}
func (my *BasicForStatement)      SetSEMICOLON6( _SEMICOLON6 *AstToken)  { my._SEMICOLON6 = _SEMICOLON6 }
    /**
     * The value returned by <b>GetForUpdateopt</b> may be <b>null</b>
     */
func (my *BasicForStatement)      GetForUpdateopt() IForUpdateopt{ return my._ForUpdateopt}
func (my *BasicForStatement)      SetForUpdateopt( _ForUpdateopt IForUpdateopt)  { my._ForUpdateopt = _ForUpdateopt }
func (my *BasicForStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *BasicForStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *BasicForStatement)      GetStatement() IStatement{ return my._Statement}
func (my *BasicForStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewBasicForStatement(leftIToken IToken, rightIToken IToken ,
              _for *AstToken,
              _LPAREN *AstToken,
              _ForInitopt IForInitopt,
              _SEMICOLON *AstToken,
              _Expressionopt IExpressionopt,
              _SEMICOLON6 *AstToken,
              _ForUpdateopt IForUpdateopt,
              _RPAREN *AstToken,
              _Statement IStatement)*BasicForStatement{
      my := new(BasicForStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._for = _for;
        if nil != _for{
        var trait_ interface{} = _for
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ForInitopt = _ForInitopt;
        if nil != _ForInitopt{
        var trait_ interface{} = _ForInitopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my._Expressionopt = _Expressionopt;
        if nil != _Expressionopt{
        var trait_ interface{} = _Expressionopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON6 = _SEMICOLON6;
        if nil != _SEMICOLON6{
        var trait_ interface{} = _SEMICOLON6
         trait_.(IAst).SetParent(my)
}
        my._ForUpdateopt = _ForUpdateopt;
        if nil != _ForUpdateopt{
        var trait_ interface{} = _ForUpdateopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *BasicForStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._for{  list.Add(my._for) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ForInitopt{  list.Add(my._ForInitopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        if nil != my._Expressionopt{  list.Add(my._Expressionopt) }
        if nil != my._SEMICOLON6{  list.Add(my._SEMICOLON6) }
        if nil != my._ForUpdateopt{  list.Add(my._ForUpdateopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *BasicForStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *BasicForStatement)       Enter(v Visitor){
        var checkChildren = v.VisitBasicForStatement(my)
        if checkChildren{
            if nil != my._for{my._for.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ForInitopt{my._ForInitopt.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
            if nil != my._Expressionopt{my._Expressionopt.Accept(v)}
            if nil != my._SEMICOLON6{my._SEMICOLON6.Accept(v)}
            if nil != my._ForUpdateopt{my._ForUpdateopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._Statement{my._Statement.Accept(v)}
        }
        v.EndVisitBasicForStatement(my)
    }


func AnyCastToBasicForStatement(i interface{}) *BasicForStatement {
	if nil == i{
		return nil
	}else{
		return i.(*BasicForStatement)
	}
}
/**
 *<b>
*<li>Rule 314:  ForStatementNoShortIf ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) StatementNoShortIf
 *</b>
 */
type ForStatementNoShortIf struct{
    *Ast
      _for *AstToken
      _LPAREN *AstToken
      _ForInitopt IForInitopt
      _SEMICOLON *AstToken
      _Expressionopt IExpressionopt
      _SEMICOLON6 *AstToken
      _ForUpdateopt IForUpdateopt
      _RPAREN *AstToken
      _StatementNoShortIf IStatementNoShortIf
}
func (my *ForStatementNoShortIf)      Getfor() *AstToken{ return my._for}
func (my *ForStatementNoShortIf)      Setfor( _for *AstToken)  { my._for = _for }
func (my *ForStatementNoShortIf)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ForStatementNoShortIf)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetForInitopt</b> may be <b>null</b>
     */
func (my *ForStatementNoShortIf)      GetForInitopt() IForInitopt{ return my._ForInitopt}
func (my *ForStatementNoShortIf)      SetForInitopt( _ForInitopt IForInitopt)  { my._ForInitopt = _ForInitopt }
func (my *ForStatementNoShortIf)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ForStatementNoShortIf)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }
    /**
     * The value returned by <b>GetExpressionopt</b> may be <b>null</b>
     */
func (my *ForStatementNoShortIf)      GetExpressionopt() IExpressionopt{ return my._Expressionopt}
func (my *ForStatementNoShortIf)      SetExpressionopt( _Expressionopt IExpressionopt)  { my._Expressionopt = _Expressionopt }
func (my *ForStatementNoShortIf)      GetSEMICOLON6() *AstToken{ return my._SEMICOLON6}
func (my *ForStatementNoShortIf)      SetSEMICOLON6( _SEMICOLON6 *AstToken)  { my._SEMICOLON6 = _SEMICOLON6 }
    /**
     * The value returned by <b>GetForUpdateopt</b> may be <b>null</b>
     */
func (my *ForStatementNoShortIf)      GetForUpdateopt() IForUpdateopt{ return my._ForUpdateopt}
func (my *ForStatementNoShortIf)      SetForUpdateopt( _ForUpdateopt IForUpdateopt)  { my._ForUpdateopt = _ForUpdateopt }
func (my *ForStatementNoShortIf)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ForStatementNoShortIf)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *ForStatementNoShortIf)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *ForStatementNoShortIf)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }

func NewForStatementNoShortIf(leftIToken IToken, rightIToken IToken ,
              _for *AstToken,
              _LPAREN *AstToken,
              _ForInitopt IForInitopt,
              _SEMICOLON *AstToken,
              _Expressionopt IExpressionopt,
              _SEMICOLON6 *AstToken,
              _ForUpdateopt IForUpdateopt,
              _RPAREN *AstToken,
              _StatementNoShortIf IStatementNoShortIf)*ForStatementNoShortIf{
      my := new(ForStatementNoShortIf)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._for = _for;
        if nil != _for{
        var trait_ interface{} = _for
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ForInitopt = _ForInitopt;
        if nil != _ForInitopt{
        var trait_ interface{} = _ForInitopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my._Expressionopt = _Expressionopt;
        if nil != _Expressionopt{
        var trait_ interface{} = _Expressionopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON6 = _SEMICOLON6;
        if nil != _SEMICOLON6{
        var trait_ interface{} = _SEMICOLON6
         trait_.(IAst).SetParent(my)
}
        my._ForUpdateopt = _ForUpdateopt;
        if nil != _ForUpdateopt{
        var trait_ interface{} = _ForUpdateopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ForStatementNoShortIf)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._for{  list.Add(my._for) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ForInitopt{  list.Add(my._ForInitopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        if nil != my._Expressionopt{  list.Add(my._Expressionopt) }
        if nil != my._SEMICOLON6{  list.Add(my._SEMICOLON6) }
        if nil != my._ForUpdateopt{  list.Add(my._ForUpdateopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        return list
    }

func (my *ForStatementNoShortIf)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ForStatementNoShortIf)       Enter(v Visitor){
        var checkChildren = v.VisitForStatementNoShortIf(my)
        if checkChildren{
            if nil != my._for{my._for.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ForInitopt{my._ForInitopt.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
            if nil != my._Expressionopt{my._Expressionopt.Accept(v)}
            if nil != my._SEMICOLON6{my._SEMICOLON6.Accept(v)}
            if nil != my._ForUpdateopt{my._ForUpdateopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._StatementNoShortIf{my._StatementNoShortIf.Accept(v)}
        }
        v.EndVisitForStatementNoShortIf(my)
    }


func AnyCastToForStatementNoShortIf(i interface{}) *ForStatementNoShortIf {
	if nil == i{
		return nil
	}else{
		return i.(*ForStatementNoShortIf)
	}
}
/**
 *<em>
*<li>Rule 318:  StatementExpressionList ::= StatementExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 319:  StatementExpressionList ::= StatementExpressionList , StatementExpression
 *</b>
 */
type StatementExpressionList struct{
    *Ast
      _StatementExpressionList IStatementExpressionList
      _COMMA *AstToken
      _StatementExpression IStatementExpression
}
func (my *StatementExpressionList)      GetStatementExpressionList() IStatementExpressionList{ return my._StatementExpressionList}
func (my *StatementExpressionList)      SetStatementExpressionList( _StatementExpressionList IStatementExpressionList)  { my._StatementExpressionList = _StatementExpressionList }
func (my *StatementExpressionList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *StatementExpressionList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *StatementExpressionList)      GetStatementExpression() IStatementExpression{ return my._StatementExpression}
func (my *StatementExpressionList)      SetStatementExpression( _StatementExpression IStatementExpression)  { my._StatementExpression = _StatementExpression }

func NewStatementExpressionList(leftIToken IToken, rightIToken IToken ,
              _StatementExpressionList IStatementExpressionList,
              _COMMA *AstToken,
              _StatementExpression IStatementExpression)*StatementExpressionList{
      my := new(StatementExpressionList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._StatementExpressionList = _StatementExpressionList;
        if nil != _StatementExpressionList{
        var trait_ interface{} = _StatementExpressionList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._StatementExpression = _StatementExpression;
        if nil != _StatementExpression{
        var trait_ interface{} = _StatementExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *StatementExpressionList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._StatementExpressionList{  list.Add(my._StatementExpressionList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._StatementExpression{  list.Add(my._StatementExpression) }
        return list
    }

func (my *StatementExpressionList)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *StatementExpressionList)       Enter(v Visitor){
        var checkChildren = v.VisitStatementExpressionList(my)
        if checkChildren{
            if nil != my._StatementExpressionList{my._StatementExpressionList.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._StatementExpression{my._StatementExpression.Accept(v)}
        }
        v.EndVisitStatementExpressionList(my)
    }


func AnyCastToStatementExpressionList(i interface{}) *StatementExpressionList {
	if nil == i{
		return nil
	}else{
		return i.(*StatementExpressionList)
	}
}
/**
 *<b>
*<li>Rule 320:  EnhancedForStatement ::= for ( FormalParameter : Expression ) Statement
 *</b>
 */
type EnhancedForStatement struct{
    *Ast
      _for *AstToken
      _LPAREN *AstToken
      _FormalParameter *FormalParameter
      _COLON *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _Statement IStatement
}
func (my *EnhancedForStatement)      Getfor() *AstToken{ return my._for}
func (my *EnhancedForStatement)      Setfor( _for *AstToken)  { my._for = _for }
func (my *EnhancedForStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *EnhancedForStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *EnhancedForStatement)      GetFormalParameter() *FormalParameter{ return my._FormalParameter}
func (my *EnhancedForStatement)      SetFormalParameter( _FormalParameter *FormalParameter)  { my._FormalParameter = _FormalParameter }
func (my *EnhancedForStatement)      GetCOLON() *AstToken{ return my._COLON}
func (my *EnhancedForStatement)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *EnhancedForStatement)      GetExpression() IExpression{ return my._Expression}
func (my *EnhancedForStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *EnhancedForStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *EnhancedForStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *EnhancedForStatement)      GetStatement() IStatement{ return my._Statement}
func (my *EnhancedForStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewEnhancedForStatement(leftIToken IToken, rightIToken IToken ,
              _for *AstToken,
              _LPAREN *AstToken,
              _FormalParameter *FormalParameter,
              _COLON *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _Statement IStatement)*EnhancedForStatement{
      my := new(EnhancedForStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._for = _for;
        if nil != _for{
        var trait_ interface{} = _for
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._FormalParameter = _FormalParameter;
        if nil != _FormalParameter{
        var trait_ interface{} = _FormalParameter
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnhancedForStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._for{  list.Add(my._for) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._FormalParameter{  list.Add(my._FormalParameter) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *EnhancedForStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EnhancedForStatement)       Enter(v Visitor){
        var checkChildren = v.VisitEnhancedForStatement(my)
        if checkChildren{
            if nil != my._for{my._for.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._FormalParameter{my._FormalParameter.Accept(v)}
            if nil != my._COLON{my._COLON.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._Statement{my._Statement.Accept(v)}
        }
        v.EndVisitEnhancedForStatement(my)
    }


func AnyCastToEnhancedForStatement(i interface{}) *EnhancedForStatement {
	if nil == i{
		return nil
	}else{
		return i.(*EnhancedForStatement)
	}
}
/**
 *<b>
*<li>Rule 321:  BreakStatement ::= break identifieropt ;
 *</b>
 */
type BreakStatement struct{
    *Ast
      _break *AstToken
      _identifieropt *identifier
      _SEMICOLON *AstToken
}
func (my *BreakStatement)      Getbreak() *AstToken{ return my._break}
func (my *BreakStatement)      Setbreak( _break *AstToken)  { my._break = _break }
    /**
     * The value returned by <b>Getidentifieropt</b> may be <b>null</b>
     */
func (my *BreakStatement)      Getidentifieropt() *identifier{ return my._identifieropt}
func (my *BreakStatement)      Setidentifieropt( _identifieropt *identifier)  { my._identifieropt = _identifieropt }
func (my *BreakStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *BreakStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewBreakStatement(leftIToken IToken, rightIToken IToken ,
              _break *AstToken,
              _identifieropt *identifier,
              _SEMICOLON *AstToken)*BreakStatement{
      my := new(BreakStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._break = _break;
        if nil != _break{
        var trait_ interface{} = _break
         trait_.(IAst).SetParent(my)
}
        my._identifieropt = _identifieropt;
        if nil != _identifieropt{
        var trait_ interface{} = _identifieropt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *BreakStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._break{  list.Add(my._break) }
        if nil != my._identifieropt{  list.Add(my._identifieropt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *BreakStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *BreakStatement)       Enter(v Visitor){
        var checkChildren = v.VisitBreakStatement(my)
        if checkChildren{
            if nil != my._break{my._break.Accept(v)}
            if nil != my._identifieropt{my._identifieropt.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitBreakStatement(my)
    }


func AnyCastToBreakStatement(i interface{}) *BreakStatement {
	if nil == i{
		return nil
	}else{
		return i.(*BreakStatement)
	}
}
/**
 *<b>
*<li>Rule 322:  ContinueStatement ::= continue identifieropt ;
 *</b>
 */
type ContinueStatement struct{
    *Ast
      _continue *AstToken
      _identifieropt *identifier
      _SEMICOLON *AstToken
}
func (my *ContinueStatement)      Getcontinue() *AstToken{ return my._continue}
func (my *ContinueStatement)      Setcontinue( _continue *AstToken)  { my._continue = _continue }
    /**
     * The value returned by <b>Getidentifieropt</b> may be <b>null</b>
     */
func (my *ContinueStatement)      Getidentifieropt() *identifier{ return my._identifieropt}
func (my *ContinueStatement)      Setidentifieropt( _identifieropt *identifier)  { my._identifieropt = _identifieropt }
func (my *ContinueStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ContinueStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewContinueStatement(leftIToken IToken, rightIToken IToken ,
              _continue *AstToken,
              _identifieropt *identifier,
              _SEMICOLON *AstToken)*ContinueStatement{
      my := new(ContinueStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._continue = _continue;
        if nil != _continue{
        var trait_ interface{} = _continue
         trait_.(IAst).SetParent(my)
}
        my._identifieropt = _identifieropt;
        if nil != _identifieropt{
        var trait_ interface{} = _identifieropt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ContinueStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._continue{  list.Add(my._continue) }
        if nil != my._identifieropt{  list.Add(my._identifieropt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ContinueStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ContinueStatement)       Enter(v Visitor){
        var checkChildren = v.VisitContinueStatement(my)
        if checkChildren{
            if nil != my._continue{my._continue.Accept(v)}
            if nil != my._identifieropt{my._identifieropt.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitContinueStatement(my)
    }


func AnyCastToContinueStatement(i interface{}) *ContinueStatement {
	if nil == i{
		return nil
	}else{
		return i.(*ContinueStatement)
	}
}
/**
 *<b>
*<li>Rule 323:  ReturnStatement ::= return Expressionopt ;
 *</b>
 */
type ReturnStatement struct{
    *Ast
      _return *AstToken
      _Expressionopt IExpressionopt
      _SEMICOLON *AstToken
}
func (my *ReturnStatement)      Getreturn() *AstToken{ return my._return}
func (my *ReturnStatement)      Setreturn( _return *AstToken)  { my._return = _return }
    /**
     * The value returned by <b>GetExpressionopt</b> may be <b>null</b>
     */
func (my *ReturnStatement)      GetExpressionopt() IExpressionopt{ return my._Expressionopt}
func (my *ReturnStatement)      SetExpressionopt( _Expressionopt IExpressionopt)  { my._Expressionopt = _Expressionopt }
func (my *ReturnStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ReturnStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewReturnStatement(leftIToken IToken, rightIToken IToken ,
              _return *AstToken,
              _Expressionopt IExpressionopt,
              _SEMICOLON *AstToken)*ReturnStatement{
      my := new(ReturnStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._return = _return;
        if nil != _return{
        var trait_ interface{} = _return
         trait_.(IAst).SetParent(my)
}
        my._Expressionopt = _Expressionopt;
        if nil != _Expressionopt{
        var trait_ interface{} = _Expressionopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ReturnStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._return{  list.Add(my._return) }
        if nil != my._Expressionopt{  list.Add(my._Expressionopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ReturnStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ReturnStatement)       Enter(v Visitor){
        var checkChildren = v.VisitReturnStatement(my)
        if checkChildren{
            if nil != my._return{my._return.Accept(v)}
            if nil != my._Expressionopt{my._Expressionopt.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitReturnStatement(my)
    }


func AnyCastToReturnStatement(i interface{}) *ReturnStatement {
	if nil == i{
		return nil
	}else{
		return i.(*ReturnStatement)
	}
}
/**
 *<b>
*<li>Rule 324:  ThrowStatement ::= throw Expression ;
 *</b>
 */
type ThrowStatement struct{
    *Ast
      _throw *AstToken
      _Expression IExpression
      _SEMICOLON *AstToken
}
func (my *ThrowStatement)      Getthrow() *AstToken{ return my._throw}
func (my *ThrowStatement)      Setthrow( _throw *AstToken)  { my._throw = _throw }
func (my *ThrowStatement)      GetExpression() IExpression{ return my._Expression}
func (my *ThrowStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *ThrowStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ThrowStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewThrowStatement(leftIToken IToken, rightIToken IToken ,
              _throw *AstToken,
              _Expression IExpression,
              _SEMICOLON *AstToken)*ThrowStatement{
      my := new(ThrowStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._throw = _throw;
        if nil != _throw{
        var trait_ interface{} = _throw
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ThrowStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._throw{  list.Add(my._throw) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ThrowStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ThrowStatement)       Enter(v Visitor){
        var checkChildren = v.VisitThrowStatement(my)
        if checkChildren{
            if nil != my._throw{my._throw.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitThrowStatement(my)
    }


func AnyCastToThrowStatement(i interface{}) *ThrowStatement {
	if nil == i{
		return nil
	}else{
		return i.(*ThrowStatement)
	}
}
/**
 *<b>
*<li>Rule 325:  SynchronizedStatement ::= synchronized ( Expression ) Block
 *</b>
 */
type SynchronizedStatement struct{
    *Ast
      _synchronized *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _Block *Block
}
func (my *SynchronizedStatement)      Getsynchronized() *AstToken{ return my._synchronized}
func (my *SynchronizedStatement)      Setsynchronized( _synchronized *AstToken)  { my._synchronized = _synchronized }
func (my *SynchronizedStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *SynchronizedStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *SynchronizedStatement)      GetExpression() IExpression{ return my._Expression}
func (my *SynchronizedStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *SynchronizedStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *SynchronizedStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *SynchronizedStatement)      GetBlock() *Block{ return my._Block}
func (my *SynchronizedStatement)      SetBlock( _Block *Block)  { my._Block = _Block }

func NewSynchronizedStatement(leftIToken IToken, rightIToken IToken ,
              _synchronized *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _Block *Block)*SynchronizedStatement{
      my := new(SynchronizedStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._synchronized = _synchronized;
        if nil != _synchronized{
        var trait_ interface{} = _synchronized
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SynchronizedStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._synchronized{  list.Add(my._synchronized) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Block{  list.Add(my._Block) }
        return list
    }

func (my *SynchronizedStatement)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SynchronizedStatement)       Enter(v Visitor){
        var checkChildren = v.VisitSynchronizedStatement(my)
        if checkChildren{
            if nil != my._synchronized{my._synchronized.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._Block{my._Block.Accept(v)}
        }
        v.EndVisitSynchronizedStatement(my)
    }


func AnyCastToSynchronizedStatement(i interface{}) *SynchronizedStatement {
	if nil == i{
		return nil
	}else{
		return i.(*SynchronizedStatement)
	}
}
/**
 *<em>
*<li>Rule 328:  Catches ::= CatchClause
 *</em>
 *<p>
 *<b>
*<li>Rule 329:  Catches ::= Catches CatchClause
 *</b>
 */
type Catches struct{
    *Ast
      _Catches ICatches
      _CatchClause *CatchClause
}
func (my *Catches)      GetCatches() ICatches{ return my._Catches}
func (my *Catches)      SetCatches( _Catches ICatches)  { my._Catches = _Catches }
func (my *Catches)      GetCatchClause() *CatchClause{ return my._CatchClause}
func (my *Catches)      SetCatchClause( _CatchClause *CatchClause)  { my._CatchClause = _CatchClause }

func NewCatches(leftIToken IToken, rightIToken IToken ,
              _Catches ICatches,
              _CatchClause *CatchClause)*Catches{
      my := new(Catches)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Catches = _Catches;
        if nil != _Catches{
        var trait_ interface{} = _Catches
         trait_.(IAst).SetParent(my)
}
        my._CatchClause = _CatchClause;
        if nil != _CatchClause{
        var trait_ interface{} = _CatchClause
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Catches)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Catches{  list.Add(my._Catches) }
        if nil != my._CatchClause{  list.Add(my._CatchClause) }
        return list
    }

func (my *Catches)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Catches)       Enter(v Visitor){
        var checkChildren = v.VisitCatches(my)
        if checkChildren{
            if nil != my._Catches{my._Catches.Accept(v)}
            if nil != my._CatchClause{my._CatchClause.Accept(v)}
        }
        v.EndVisitCatches(my)
    }


func AnyCastToCatches(i interface{}) *Catches {
	if nil == i{
		return nil
	}else{
		return i.(*Catches)
	}
}
/**
 *<b>
*<li>Rule 330:  CatchClause ::= catch ( FormalParameter ) Block
 *</b>
 */
type CatchClause struct{
    *Ast
      _catch *AstToken
      _LPAREN *AstToken
      _FormalParameter *FormalParameter
      _RPAREN *AstToken
      _Block *Block
}
func (my *CatchClause)      Getcatch() *AstToken{ return my._catch}
func (my *CatchClause)      Setcatch( _catch *AstToken)  { my._catch = _catch }
func (my *CatchClause)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *CatchClause)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *CatchClause)      GetFormalParameter() *FormalParameter{ return my._FormalParameter}
func (my *CatchClause)      SetFormalParameter( _FormalParameter *FormalParameter)  { my._FormalParameter = _FormalParameter }
func (my *CatchClause)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *CatchClause)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *CatchClause)      GetBlock() *Block{ return my._Block}
func (my *CatchClause)      SetBlock( _Block *Block)  { my._Block = _Block }

func NewCatchClause(leftIToken IToken, rightIToken IToken ,
              _catch *AstToken,
              _LPAREN *AstToken,
              _FormalParameter *FormalParameter,
              _RPAREN *AstToken,
              _Block *Block)*CatchClause{
      my := new(CatchClause)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._catch = _catch;
        if nil != _catch{
        var trait_ interface{} = _catch
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._FormalParameter = _FormalParameter;
        if nil != _FormalParameter{
        var trait_ interface{} = _FormalParameter
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *CatchClause)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._catch{  list.Add(my._catch) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._FormalParameter{  list.Add(my._FormalParameter) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Block{  list.Add(my._Block) }
        return list
    }

func (my *CatchClause)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *CatchClause)       Enter(v Visitor){
        var checkChildren = v.VisitCatchClause(my)
        if checkChildren{
            if nil != my._catch{my._catch.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._FormalParameter{my._FormalParameter.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._Block{my._Block.Accept(v)}
        }
        v.EndVisitCatchClause(my)
    }


func AnyCastToCatchClause(i interface{}) *CatchClause {
	if nil == i{
		return nil
	}else{
		return i.(*CatchClause)
	}
}
/**
 *<b>
*<li>Rule 331:  Finally ::= finally Block
 *</b>
 */
type Finally struct{
    *Ast
      _finally *AstToken
      _Block *Block
}
func (my *Finally)      Getfinally() *AstToken{ return my._finally}
func (my *Finally)      Setfinally( _finally *AstToken)  { my._finally = _finally }
func (my *Finally)      GetBlock() *Block{ return my._Block}
func (my *Finally)      SetBlock( _Block *Block)  { my._Block = _Block }

func NewFinally(leftIToken IToken, rightIToken IToken ,
              _finally *AstToken,
              _Block *Block)*Finally{
      my := new(Finally)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._finally = _finally;
        if nil != _finally{
        var trait_ interface{} = _finally
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Finally)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._finally{  list.Add(my._finally) }
        if nil != my._Block{  list.Add(my._Block) }
        return list
    }

func (my *Finally)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Finally)       Enter(v Visitor){
        var checkChildren = v.VisitFinally(my)
        if checkChildren{
            if nil != my._finally{my._finally.Accept(v)}
            if nil != my._Block{my._Block.Accept(v)}
        }
        v.EndVisitFinally(my)
    }


func AnyCastToFinally(i interface{}) *Finally {
	if nil == i{
		return nil
	}else{
		return i.(*Finally)
	}
}
/**
 *<em>
*<li>Rule 356:  ArgumentList ::= Expression
 *</em>
 *<p>
 *<b>
*<li>Rule 357:  ArgumentList ::= ArgumentList , Expression
 *</b>
 */
type ArgumentList struct{
    *Ast
      _ArgumentList IArgumentList
      _COMMA *AstToken
      _Expression IExpression
}
func (my *ArgumentList)      GetArgumentList() IArgumentList{ return my._ArgumentList}
func (my *ArgumentList)      SetArgumentList( _ArgumentList IArgumentList)  { my._ArgumentList = _ArgumentList }
func (my *ArgumentList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ArgumentList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ArgumentList)      GetExpression() IExpression{ return my._Expression}
func (my *ArgumentList)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }

func NewArgumentList(leftIToken IToken, rightIToken IToken ,
              _ArgumentList IArgumentList,
              _COMMA *AstToken,
              _Expression IExpression)*ArgumentList{
      my := new(ArgumentList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ArgumentList = _ArgumentList;
        if nil != _ArgumentList{
        var trait_ interface{} = _ArgumentList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArgumentList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ArgumentList{  list.Add(my._ArgumentList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._Expression{  list.Add(my._Expression) }
        return list
    }

func (my *ArgumentList)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArgumentList)       Enter(v Visitor){
        var checkChildren = v.VisitArgumentList(my)
        if checkChildren{
            if nil != my._ArgumentList{my._ArgumentList.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
        }
        v.EndVisitArgumentList(my)
    }


func AnyCastToArgumentList(i interface{}) *ArgumentList {
	if nil == i{
		return nil
	}else{
		return i.(*ArgumentList)
	}
}
/**
 *<em>
*<li>Rule 362:  DimExprs ::= DimExpr
 *</em>
 *<p>
 *<b>
*<li>Rule 363:  DimExprs ::= DimExprs DimExpr
 *</b>
 */
type DimExprs struct{
    *Ast
      _DimExprs IDimExprs
      _DimExpr *DimExpr
}
func (my *DimExprs)      GetDimExprs() IDimExprs{ return my._DimExprs}
func (my *DimExprs)      SetDimExprs( _DimExprs IDimExprs)  { my._DimExprs = _DimExprs }
func (my *DimExprs)      GetDimExpr() *DimExpr{ return my._DimExpr}
func (my *DimExprs)      SetDimExpr( _DimExpr *DimExpr)  { my._DimExpr = _DimExpr }

func NewDimExprs(leftIToken IToken, rightIToken IToken ,
              _DimExprs IDimExprs,
              _DimExpr *DimExpr)*DimExprs{
      my := new(DimExprs)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._DimExprs = _DimExprs;
        if nil != _DimExprs{
        var trait_ interface{} = _DimExprs
         trait_.(IAst).SetParent(my)
}
        my._DimExpr = _DimExpr;
        if nil != _DimExpr{
        var trait_ interface{} = _DimExpr
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *DimExprs)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._DimExprs{  list.Add(my._DimExprs) }
        if nil != my._DimExpr{  list.Add(my._DimExpr) }
        return list
    }

func (my *DimExprs)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *DimExprs)       Enter(v Visitor){
        var checkChildren = v.VisitDimExprs(my)
        if checkChildren{
            if nil != my._DimExprs{my._DimExprs.Accept(v)}
            if nil != my._DimExpr{my._DimExpr.Accept(v)}
        }
        v.EndVisitDimExprs(my)
    }


func AnyCastToDimExprs(i interface{}) *DimExprs {
	if nil == i{
		return nil
	}else{
		return i.(*DimExprs)
	}
}
/**
 *<b>
*<li>Rule 364:  DimExpr ::= [ Expression ]
 *</b>
 */
type DimExpr struct{
    *Ast
      _LBRACKET *AstToken
      _Expression IExpression
      _RBRACKET *AstToken
}
func (my *DimExpr)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *DimExpr)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *DimExpr)      GetExpression() IExpression{ return my._Expression}
func (my *DimExpr)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *DimExpr)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *DimExpr)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewDimExpr(leftIToken IToken, rightIToken IToken ,
              _LBRACKET *AstToken,
              _Expression IExpression,
              _RBRACKET *AstToken)*DimExpr{
      my := new(DimExpr)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *DimExpr)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *DimExpr)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *DimExpr)       Enter(v Visitor){
        var checkChildren = v.VisitDimExpr(my)
        if checkChildren{
            if nil != my._LBRACKET{my._LBRACKET.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RBRACKET{my._RBRACKET.Accept(v)}
        }
        v.EndVisitDimExpr(my)
    }


func AnyCastToDimExpr(i interface{}) *DimExpr {
	if nil == i{
		return nil
	}else{
		return i.(*DimExpr)
	}
}
/**
 *<b>
*<li>Rule 381:  PostIncrementExpression ::= PostfixExpression ++
 *</b>
 */
type PostIncrementExpression struct{
    *Ast
      _PostfixExpression IPostfixExpression
      _PLUS_PLUS *AstToken
}
func (my *PostIncrementExpression)      GetPostfixExpression() IPostfixExpression{ return my._PostfixExpression}
func (my *PostIncrementExpression)      SetPostfixExpression( _PostfixExpression IPostfixExpression)  { my._PostfixExpression = _PostfixExpression }
func (my *PostIncrementExpression)      GetPLUS_PLUS() *AstToken{ return my._PLUS_PLUS}
func (my *PostIncrementExpression)      SetPLUS_PLUS( _PLUS_PLUS *AstToken)  { my._PLUS_PLUS = _PLUS_PLUS }

func NewPostIncrementExpression(leftIToken IToken, rightIToken IToken ,
              _PostfixExpression IPostfixExpression,
              _PLUS_PLUS *AstToken)*PostIncrementExpression{
      my := new(PostIncrementExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PostfixExpression = _PostfixExpression;
        if nil != _PostfixExpression{
        var trait_ interface{} = _PostfixExpression
         trait_.(IAst).SetParent(my)
}
        my._PLUS_PLUS = _PLUS_PLUS;
        if nil != _PLUS_PLUS{
        var trait_ interface{} = _PLUS_PLUS
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PostIncrementExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PostfixExpression{  list.Add(my._PostfixExpression) }
        if nil != my._PLUS_PLUS{  list.Add(my._PLUS_PLUS) }
        return list
    }

func (my *PostIncrementExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PostIncrementExpression)       Enter(v Visitor){
        var checkChildren = v.VisitPostIncrementExpression(my)
        if checkChildren{
            if nil != my._PostfixExpression{my._PostfixExpression.Accept(v)}
            if nil != my._PLUS_PLUS{my._PLUS_PLUS.Accept(v)}
        }
        v.EndVisitPostIncrementExpression(my)
    }


func AnyCastToPostIncrementExpression(i interface{}) *PostIncrementExpression {
	if nil == i{
		return nil
	}else{
		return i.(*PostIncrementExpression)
	}
}
/**
 *<b>
*<li>Rule 382:  PostDecrementExpression ::= PostfixExpression --
 *</b>
 */
type PostDecrementExpression struct{
    *Ast
      _PostfixExpression IPostfixExpression
      _MINUS_MINUS *AstToken
}
func (my *PostDecrementExpression)      GetPostfixExpression() IPostfixExpression{ return my._PostfixExpression}
func (my *PostDecrementExpression)      SetPostfixExpression( _PostfixExpression IPostfixExpression)  { my._PostfixExpression = _PostfixExpression }
func (my *PostDecrementExpression)      GetMINUS_MINUS() *AstToken{ return my._MINUS_MINUS}
func (my *PostDecrementExpression)      SetMINUS_MINUS( _MINUS_MINUS *AstToken)  { my._MINUS_MINUS = _MINUS_MINUS }

func NewPostDecrementExpression(leftIToken IToken, rightIToken IToken ,
              _PostfixExpression IPostfixExpression,
              _MINUS_MINUS *AstToken)*PostDecrementExpression{
      my := new(PostDecrementExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PostfixExpression = _PostfixExpression;
        if nil != _PostfixExpression{
        var trait_ interface{} = _PostfixExpression
         trait_.(IAst).SetParent(my)
}
        my._MINUS_MINUS = _MINUS_MINUS;
        if nil != _MINUS_MINUS{
        var trait_ interface{} = _MINUS_MINUS
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PostDecrementExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PostfixExpression{  list.Add(my._PostfixExpression) }
        if nil != my._MINUS_MINUS{  list.Add(my._MINUS_MINUS) }
        return list
    }

func (my *PostDecrementExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PostDecrementExpression)       Enter(v Visitor){
        var checkChildren = v.VisitPostDecrementExpression(my)
        if checkChildren{
            if nil != my._PostfixExpression{my._PostfixExpression.Accept(v)}
            if nil != my._MINUS_MINUS{my._MINUS_MINUS.Accept(v)}
        }
        v.EndVisitPostDecrementExpression(my)
    }


func AnyCastToPostDecrementExpression(i interface{}) *PostDecrementExpression {
	if nil == i{
		return nil
	}else{
		return i.(*PostDecrementExpression)
	}
}
/**
 *<b>
*<li>Rule 388:  PreIncrementExpression ::= ++ UnaryExpression
 *</b>
 */
type PreIncrementExpression struct{
    *Ast
      _PLUS_PLUS *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *PreIncrementExpression)      GetPLUS_PLUS() *AstToken{ return my._PLUS_PLUS}
func (my *PreIncrementExpression)      SetPLUS_PLUS( _PLUS_PLUS *AstToken)  { my._PLUS_PLUS = _PLUS_PLUS }
func (my *PreIncrementExpression)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *PreIncrementExpression)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewPreIncrementExpression(leftIToken IToken, rightIToken IToken ,
              _PLUS_PLUS *AstToken,
              _UnaryExpression IUnaryExpression)*PreIncrementExpression{
      my := new(PreIncrementExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PLUS_PLUS = _PLUS_PLUS;
        if nil != _PLUS_PLUS{
        var trait_ interface{} = _PLUS_PLUS
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PreIncrementExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PLUS_PLUS{  list.Add(my._PLUS_PLUS) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *PreIncrementExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PreIncrementExpression)       Enter(v Visitor){
        var checkChildren = v.VisitPreIncrementExpression(my)
        if checkChildren{
            if nil != my._PLUS_PLUS{my._PLUS_PLUS.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitPreIncrementExpression(my)
    }


func AnyCastToPreIncrementExpression(i interface{}) *PreIncrementExpression {
	if nil == i{
		return nil
	}else{
		return i.(*PreIncrementExpression)
	}
}
/**
 *<b>
*<li>Rule 389:  PreDecrementExpression ::= -- UnaryExpression
 *</b>
 */
type PreDecrementExpression struct{
    *Ast
      _MINUS_MINUS *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *PreDecrementExpression)      GetMINUS_MINUS() *AstToken{ return my._MINUS_MINUS}
func (my *PreDecrementExpression)      SetMINUS_MINUS( _MINUS_MINUS *AstToken)  { my._MINUS_MINUS = _MINUS_MINUS }
func (my *PreDecrementExpression)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *PreDecrementExpression)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewPreDecrementExpression(leftIToken IToken, rightIToken IToken ,
              _MINUS_MINUS *AstToken,
              _UnaryExpression IUnaryExpression)*PreDecrementExpression{
      my := new(PreDecrementExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MINUS_MINUS = _MINUS_MINUS;
        if nil != _MINUS_MINUS{
        var trait_ interface{} = _MINUS_MINUS
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PreDecrementExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MINUS_MINUS{  list.Add(my._MINUS_MINUS) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *PreDecrementExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PreDecrementExpression)       Enter(v Visitor){
        var checkChildren = v.VisitPreDecrementExpression(my)
        if checkChildren{
            if nil != my._MINUS_MINUS{my._MINUS_MINUS.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitPreDecrementExpression(my)
    }


func AnyCastToPreDecrementExpression(i interface{}) *PreDecrementExpression {
	if nil == i{
		return nil
	}else{
		return i.(*PreDecrementExpression)
	}
}
/**
 *<em>
*<li>Rule 416:  AndExpression ::= EqualityExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 417:  AndExpression ::= AndExpression & EqualityExpression
 *</b>
 */
type AndExpression struct{
    *Ast
      _AndExpression IAndExpression
      _AND *AstToken
      _EqualityExpression IEqualityExpression
}
func (my *AndExpression)      GetAndExpression() IAndExpression{ return my._AndExpression}
func (my *AndExpression)      SetAndExpression( _AndExpression IAndExpression)  { my._AndExpression = _AndExpression }
func (my *AndExpression)      GetAND() *AstToken{ return my._AND}
func (my *AndExpression)      SetAND( _AND *AstToken)  { my._AND = _AND }
func (my *AndExpression)      GetEqualityExpression() IEqualityExpression{ return my._EqualityExpression}
func (my *AndExpression)      SetEqualityExpression( _EqualityExpression IEqualityExpression)  { my._EqualityExpression = _EqualityExpression }

func NewAndExpression(leftIToken IToken, rightIToken IToken ,
              _AndExpression IAndExpression,
              _AND *AstToken,
              _EqualityExpression IEqualityExpression)*AndExpression{
      my := new(AndExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AndExpression = _AndExpression;
        if nil != _AndExpression{
        var trait_ interface{} = _AndExpression
         trait_.(IAst).SetParent(my)
}
        my._AND = _AND;
        if nil != _AND{
        var trait_ interface{} = _AND
         trait_.(IAst).SetParent(my)
}
        my._EqualityExpression = _EqualityExpression;
        if nil != _EqualityExpression{
        var trait_ interface{} = _EqualityExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AndExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AndExpression{  list.Add(my._AndExpression) }
        if nil != my._AND{  list.Add(my._AND) }
        if nil != my._EqualityExpression{  list.Add(my._EqualityExpression) }
        return list
    }

func (my *AndExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AndExpression)       Enter(v Visitor){
        var checkChildren = v.VisitAndExpression(my)
        if checkChildren{
            if nil != my._AndExpression{my._AndExpression.Accept(v)}
            if nil != my._AND{my._AND.Accept(v)}
            if nil != my._EqualityExpression{my._EqualityExpression.Accept(v)}
        }
        v.EndVisitAndExpression(my)
    }


func AnyCastToAndExpression(i interface{}) *AndExpression {
	if nil == i{
		return nil
	}else{
		return i.(*AndExpression)
	}
}
/**
 *<em>
*<li>Rule 418:  ExclusiveOrExpression ::= AndExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 419:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
 *</b>
 */
type ExclusiveOrExpression struct{
    *Ast
      _ExclusiveOrExpression IExclusiveOrExpression
      _XOR *AstToken
      _AndExpression IAndExpression
}
func (my *ExclusiveOrExpression)      GetExclusiveOrExpression() IExclusiveOrExpression{ return my._ExclusiveOrExpression}
func (my *ExclusiveOrExpression)      SetExclusiveOrExpression( _ExclusiveOrExpression IExclusiveOrExpression)  { my._ExclusiveOrExpression = _ExclusiveOrExpression }
func (my *ExclusiveOrExpression)      GetXOR() *AstToken{ return my._XOR}
func (my *ExclusiveOrExpression)      SetXOR( _XOR *AstToken)  { my._XOR = _XOR }
func (my *ExclusiveOrExpression)      GetAndExpression() IAndExpression{ return my._AndExpression}
func (my *ExclusiveOrExpression)      SetAndExpression( _AndExpression IAndExpression)  { my._AndExpression = _AndExpression }

func NewExclusiveOrExpression(leftIToken IToken, rightIToken IToken ,
              _ExclusiveOrExpression IExclusiveOrExpression,
              _XOR *AstToken,
              _AndExpression IAndExpression)*ExclusiveOrExpression{
      my := new(ExclusiveOrExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ExclusiveOrExpression = _ExclusiveOrExpression;
        if nil != _ExclusiveOrExpression{
        var trait_ interface{} = _ExclusiveOrExpression
         trait_.(IAst).SetParent(my)
}
        my._XOR = _XOR;
        if nil != _XOR{
        var trait_ interface{} = _XOR
         trait_.(IAst).SetParent(my)
}
        my._AndExpression = _AndExpression;
        if nil != _AndExpression{
        var trait_ interface{} = _AndExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExclusiveOrExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ExclusiveOrExpression{  list.Add(my._ExclusiveOrExpression) }
        if nil != my._XOR{  list.Add(my._XOR) }
        if nil != my._AndExpression{  list.Add(my._AndExpression) }
        return list
    }

func (my *ExclusiveOrExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExclusiveOrExpression)       Enter(v Visitor){
        var checkChildren = v.VisitExclusiveOrExpression(my)
        if checkChildren{
            if nil != my._ExclusiveOrExpression{my._ExclusiveOrExpression.Accept(v)}
            if nil != my._XOR{my._XOR.Accept(v)}
            if nil != my._AndExpression{my._AndExpression.Accept(v)}
        }
        v.EndVisitExclusiveOrExpression(my)
    }


func AnyCastToExclusiveOrExpression(i interface{}) *ExclusiveOrExpression {
	if nil == i{
		return nil
	}else{
		return i.(*ExclusiveOrExpression)
	}
}
/**
 *<em>
*<li>Rule 420:  InclusiveOrExpression ::= ExclusiveOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 421:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
 *</b>
 */
type InclusiveOrExpression struct{
    *Ast
      _InclusiveOrExpression IInclusiveOrExpression
      _OR *AstToken
      _ExclusiveOrExpression IExclusiveOrExpression
}
func (my *InclusiveOrExpression)      GetInclusiveOrExpression() IInclusiveOrExpression{ return my._InclusiveOrExpression}
func (my *InclusiveOrExpression)      SetInclusiveOrExpression( _InclusiveOrExpression IInclusiveOrExpression)  { my._InclusiveOrExpression = _InclusiveOrExpression }
func (my *InclusiveOrExpression)      GetOR() *AstToken{ return my._OR}
func (my *InclusiveOrExpression)      SetOR( _OR *AstToken)  { my._OR = _OR }
func (my *InclusiveOrExpression)      GetExclusiveOrExpression() IExclusiveOrExpression{ return my._ExclusiveOrExpression}
func (my *InclusiveOrExpression)      SetExclusiveOrExpression( _ExclusiveOrExpression IExclusiveOrExpression)  { my._ExclusiveOrExpression = _ExclusiveOrExpression }

func NewInclusiveOrExpression(leftIToken IToken, rightIToken IToken ,
              _InclusiveOrExpression IInclusiveOrExpression,
              _OR *AstToken,
              _ExclusiveOrExpression IExclusiveOrExpression)*InclusiveOrExpression{
      my := new(InclusiveOrExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InclusiveOrExpression = _InclusiveOrExpression;
        if nil != _InclusiveOrExpression{
        var trait_ interface{} = _InclusiveOrExpression
         trait_.(IAst).SetParent(my)
}
        my._OR = _OR;
        if nil != _OR{
        var trait_ interface{} = _OR
         trait_.(IAst).SetParent(my)
}
        my._ExclusiveOrExpression = _ExclusiveOrExpression;
        if nil != _ExclusiveOrExpression{
        var trait_ interface{} = _ExclusiveOrExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InclusiveOrExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InclusiveOrExpression{  list.Add(my._InclusiveOrExpression) }
        if nil != my._OR{  list.Add(my._OR) }
        if nil != my._ExclusiveOrExpression{  list.Add(my._ExclusiveOrExpression) }
        return list
    }

func (my *InclusiveOrExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InclusiveOrExpression)       Enter(v Visitor){
        var checkChildren = v.VisitInclusiveOrExpression(my)
        if checkChildren{
            if nil != my._InclusiveOrExpression{my._InclusiveOrExpression.Accept(v)}
            if nil != my._OR{my._OR.Accept(v)}
            if nil != my._ExclusiveOrExpression{my._ExclusiveOrExpression.Accept(v)}
        }
        v.EndVisitInclusiveOrExpression(my)
    }


func AnyCastToInclusiveOrExpression(i interface{}) *InclusiveOrExpression {
	if nil == i{
		return nil
	}else{
		return i.(*InclusiveOrExpression)
	}
}
/**
 *<em>
*<li>Rule 422:  ConditionalAndExpression ::= InclusiveOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 423:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
 *</b>
 */
type ConditionalAndExpression struct{
    *Ast
      _ConditionalAndExpression IConditionalAndExpression
      _AND_AND *AstToken
      _InclusiveOrExpression IInclusiveOrExpression
}
func (my *ConditionalAndExpression)      GetConditionalAndExpression() IConditionalAndExpression{ return my._ConditionalAndExpression}
func (my *ConditionalAndExpression)      SetConditionalAndExpression( _ConditionalAndExpression IConditionalAndExpression)  { my._ConditionalAndExpression = _ConditionalAndExpression }
func (my *ConditionalAndExpression)      GetAND_AND() *AstToken{ return my._AND_AND}
func (my *ConditionalAndExpression)      SetAND_AND( _AND_AND *AstToken)  { my._AND_AND = _AND_AND }
func (my *ConditionalAndExpression)      GetInclusiveOrExpression() IInclusiveOrExpression{ return my._InclusiveOrExpression}
func (my *ConditionalAndExpression)      SetInclusiveOrExpression( _InclusiveOrExpression IInclusiveOrExpression)  { my._InclusiveOrExpression = _InclusiveOrExpression }

func NewConditionalAndExpression(leftIToken IToken, rightIToken IToken ,
              _ConditionalAndExpression IConditionalAndExpression,
              _AND_AND *AstToken,
              _InclusiveOrExpression IInclusiveOrExpression)*ConditionalAndExpression{
      my := new(ConditionalAndExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConditionalAndExpression = _ConditionalAndExpression;
        if nil != _ConditionalAndExpression{
        var trait_ interface{} = _ConditionalAndExpression
         trait_.(IAst).SetParent(my)
}
        my._AND_AND = _AND_AND;
        if nil != _AND_AND{
        var trait_ interface{} = _AND_AND
         trait_.(IAst).SetParent(my)
}
        my._InclusiveOrExpression = _InclusiveOrExpression;
        if nil != _InclusiveOrExpression{
        var trait_ interface{} = _InclusiveOrExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConditionalAndExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConditionalAndExpression{  list.Add(my._ConditionalAndExpression) }
        if nil != my._AND_AND{  list.Add(my._AND_AND) }
        if nil != my._InclusiveOrExpression{  list.Add(my._InclusiveOrExpression) }
        return list
    }

func (my *ConditionalAndExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConditionalAndExpression)       Enter(v Visitor){
        var checkChildren = v.VisitConditionalAndExpression(my)
        if checkChildren{
            if nil != my._ConditionalAndExpression{my._ConditionalAndExpression.Accept(v)}
            if nil != my._AND_AND{my._AND_AND.Accept(v)}
            if nil != my._InclusiveOrExpression{my._InclusiveOrExpression.Accept(v)}
        }
        v.EndVisitConditionalAndExpression(my)
    }


func AnyCastToConditionalAndExpression(i interface{}) *ConditionalAndExpression {
	if nil == i{
		return nil
	}else{
		return i.(*ConditionalAndExpression)
	}
}
/**
 *<em>
*<li>Rule 424:  ConditionalOrExpression ::= ConditionalAndExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 425:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
 *</b>
 */
type ConditionalOrExpression struct{
    *Ast
      _ConditionalOrExpression IConditionalOrExpression
      _OR_OR *AstToken
      _ConditionalAndExpression IConditionalAndExpression
}
func (my *ConditionalOrExpression)      GetConditionalOrExpression() IConditionalOrExpression{ return my._ConditionalOrExpression}
func (my *ConditionalOrExpression)      SetConditionalOrExpression( _ConditionalOrExpression IConditionalOrExpression)  { my._ConditionalOrExpression = _ConditionalOrExpression }
func (my *ConditionalOrExpression)      GetOR_OR() *AstToken{ return my._OR_OR}
func (my *ConditionalOrExpression)      SetOR_OR( _OR_OR *AstToken)  { my._OR_OR = _OR_OR }
func (my *ConditionalOrExpression)      GetConditionalAndExpression() IConditionalAndExpression{ return my._ConditionalAndExpression}
func (my *ConditionalOrExpression)      SetConditionalAndExpression( _ConditionalAndExpression IConditionalAndExpression)  { my._ConditionalAndExpression = _ConditionalAndExpression }

func NewConditionalOrExpression(leftIToken IToken, rightIToken IToken ,
              _ConditionalOrExpression IConditionalOrExpression,
              _OR_OR *AstToken,
              _ConditionalAndExpression IConditionalAndExpression)*ConditionalOrExpression{
      my := new(ConditionalOrExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConditionalOrExpression = _ConditionalOrExpression;
        if nil != _ConditionalOrExpression{
        var trait_ interface{} = _ConditionalOrExpression
         trait_.(IAst).SetParent(my)
}
        my._OR_OR = _OR_OR;
        if nil != _OR_OR{
        var trait_ interface{} = _OR_OR
         trait_.(IAst).SetParent(my)
}
        my._ConditionalAndExpression = _ConditionalAndExpression;
        if nil != _ConditionalAndExpression{
        var trait_ interface{} = _ConditionalAndExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConditionalOrExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConditionalOrExpression{  list.Add(my._ConditionalOrExpression) }
        if nil != my._OR_OR{  list.Add(my._OR_OR) }
        if nil != my._ConditionalAndExpression{  list.Add(my._ConditionalAndExpression) }
        return list
    }

func (my *ConditionalOrExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConditionalOrExpression)       Enter(v Visitor){
        var checkChildren = v.VisitConditionalOrExpression(my)
        if checkChildren{
            if nil != my._ConditionalOrExpression{my._ConditionalOrExpression.Accept(v)}
            if nil != my._OR_OR{my._OR_OR.Accept(v)}
            if nil != my._ConditionalAndExpression{my._ConditionalAndExpression.Accept(v)}
        }
        v.EndVisitConditionalOrExpression(my)
    }


func AnyCastToConditionalOrExpression(i interface{}) *ConditionalOrExpression {
	if nil == i{
		return nil
	}else{
		return i.(*ConditionalOrExpression)
	}
}
/**
 *<em>
*<li>Rule 426:  ConditionalExpression ::= ConditionalOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 427:  ConditionalExpression ::= ConditionalOrExpression ? Expression : ConditionalExpression
 *</b>
 */
type ConditionalExpression struct{
    *Ast
      _ConditionalOrExpression IConditionalOrExpression
      _QUESTION *AstToken
      _Expression IExpression
      _COLON *AstToken
      _ConditionalExpression IConditionalExpression
}
func (my *ConditionalExpression)      GetConditionalOrExpression() IConditionalOrExpression{ return my._ConditionalOrExpression}
func (my *ConditionalExpression)      SetConditionalOrExpression( _ConditionalOrExpression IConditionalOrExpression)  { my._ConditionalOrExpression = _ConditionalOrExpression }
func (my *ConditionalExpression)      GetQUESTION() *AstToken{ return my._QUESTION}
func (my *ConditionalExpression)      SetQUESTION( _QUESTION *AstToken)  { my._QUESTION = _QUESTION }
func (my *ConditionalExpression)      GetExpression() IExpression{ return my._Expression}
func (my *ConditionalExpression)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *ConditionalExpression)      GetCOLON() *AstToken{ return my._COLON}
func (my *ConditionalExpression)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *ConditionalExpression)      GetConditionalExpression() IConditionalExpression{ return my._ConditionalExpression}
func (my *ConditionalExpression)      SetConditionalExpression( _ConditionalExpression IConditionalExpression)  { my._ConditionalExpression = _ConditionalExpression }

func NewConditionalExpression(leftIToken IToken, rightIToken IToken ,
              _ConditionalOrExpression IConditionalOrExpression,
              _QUESTION *AstToken,
              _Expression IExpression,
              _COLON *AstToken,
              _ConditionalExpression IConditionalExpression)*ConditionalExpression{
      my := new(ConditionalExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConditionalOrExpression = _ConditionalOrExpression;
        if nil != _ConditionalOrExpression{
        var trait_ interface{} = _ConditionalOrExpression
         trait_.(IAst).SetParent(my)
}
        my._QUESTION = _QUESTION;
        if nil != _QUESTION{
        var trait_ interface{} = _QUESTION
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._ConditionalExpression = _ConditionalExpression;
        if nil != _ConditionalExpression{
        var trait_ interface{} = _ConditionalExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConditionalExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConditionalOrExpression{  list.Add(my._ConditionalOrExpression) }
        if nil != my._QUESTION{  list.Add(my._QUESTION) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._ConditionalExpression{  list.Add(my._ConditionalExpression) }
        return list
    }

func (my *ConditionalExpression)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConditionalExpression)       Enter(v Visitor){
        var checkChildren = v.VisitConditionalExpression(my)
        if checkChildren{
            if nil != my._ConditionalOrExpression{my._ConditionalOrExpression.Accept(v)}
            if nil != my._QUESTION{my._QUESTION.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._COLON{my._COLON.Accept(v)}
            if nil != my._ConditionalExpression{my._ConditionalExpression.Accept(v)}
        }
        v.EndVisitConditionalExpression(my)
    }


func AnyCastToConditionalExpression(i interface{}) *ConditionalExpression {
	if nil == i{
		return nil
	}else{
		return i.(*ConditionalExpression)
	}
}
/**
 *<b>
*<li>Rule 430:  Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
 *</b>
 */
type Assignment struct{
    *Ast
      _LeftHandSide ILeftHandSide
      _AssignmentOperator IAssignmentOperator
      _AssignmentExpression IAssignmentExpression
}
func (my *Assignment)      GetLeftHandSide() ILeftHandSide{ return my._LeftHandSide}
func (my *Assignment)      SetLeftHandSide( _LeftHandSide ILeftHandSide)  { my._LeftHandSide = _LeftHandSide }
func (my *Assignment)      GetAssignmentOperator() IAssignmentOperator{ return my._AssignmentOperator}
func (my *Assignment)      SetAssignmentOperator( _AssignmentOperator IAssignmentOperator)  { my._AssignmentOperator = _AssignmentOperator }
func (my *Assignment)      GetAssignmentExpression() IAssignmentExpression{ return my._AssignmentExpression}
func (my *Assignment)      SetAssignmentExpression( _AssignmentExpression IAssignmentExpression)  { my._AssignmentExpression = _AssignmentExpression }

func NewAssignment(leftIToken IToken, rightIToken IToken ,
              _LeftHandSide ILeftHandSide,
              _AssignmentOperator IAssignmentOperator,
              _AssignmentExpression IAssignmentExpression)*Assignment{
      my := new(Assignment)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LeftHandSide = _LeftHandSide;
        if nil != _LeftHandSide{
        var trait_ interface{} = _LeftHandSide
         trait_.(IAst).SetParent(my)
}
        my._AssignmentOperator = _AssignmentOperator;
        if nil != _AssignmentOperator{
        var trait_ interface{} = _AssignmentOperator
         trait_.(IAst).SetParent(my)
}
        my._AssignmentExpression = _AssignmentExpression;
        if nil != _AssignmentExpression{
        var trait_ interface{} = _AssignmentExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Assignment)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LeftHandSide{  list.Add(my._LeftHandSide) }
        if nil != my._AssignmentOperator{  list.Add(my._AssignmentOperator) }
        if nil != my._AssignmentExpression{  list.Add(my._AssignmentExpression) }
        return list
    }

func (my *Assignment)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Assignment)       Enter(v Visitor){
        var checkChildren = v.VisitAssignment(my)
        if checkChildren{
            if nil != my._LeftHandSide{my._LeftHandSide.Accept(v)}
            if nil != my._AssignmentOperator{my._AssignmentOperator.Accept(v)}
            if nil != my._AssignmentExpression{my._AssignmentExpression.Accept(v)}
        }
        v.EndVisitAssignment(my)
    }


func AnyCastToAssignment(i interface{}) *Assignment {
	if nil == i{
		return nil
	}else{
		return i.(*Assignment)
	}
}
/**
 *<em>
*<li>Rule 492:  ,opt ::= $Empty
 *</em>
 *<p>
 *<b>
*<li>Rule 493:  ,opt ::= ,
 *</b>
 */
type Commaopt struct{
    *AstToken
}
func (my *Commaopt)      GetCOMMA()IToken{ return my.leftIToken; }

func NewCommaopt(token IToken )*Commaopt{
      my := new(Commaopt)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Commaopt)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Commaopt)       Enter(v Visitor){
        v.VisitCommaopt(my)
        v.EndVisitCommaopt(my)
    }


func AnyCastToCommaopt(i interface{}) *Commaopt {
	if nil == i{
		return nil
	}else{
		return i.(*Commaopt)
	}
}
/**
 *<em>
*<li>Rule 504:  ...opt ::= $Empty
 *</em>
 *<p>
 *<b>
*<li>Rule 505:  ...opt ::= ...
 *</b>
 */
type Ellipsisopt struct{
    *AstToken
}
func (my *Ellipsisopt)      GetELLIPSIS()IToken{ return my.leftIToken; }

func NewEllipsisopt(token IToken )*Ellipsisopt{
      my := new(Ellipsisopt)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Ellipsisopt)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Ellipsisopt)       Enter(v Visitor){
        v.VisitEllipsisopt(my)
        v.EndVisitEllipsisopt(my)
    }


func AnyCastToEllipsisopt(i interface{}) *Ellipsisopt {
	if nil == i{
		return nil
	}else{
		return i.(*Ellipsisopt)
	}
}
/**
 *<b>
*<li>Rule 5:  LPGUserAction ::= $BeginAction BlockStatementsopt $EndAction
 *</b>
 */
type LPGUserAction0 struct{
    *Ast
      _BeginAction *AstToken
      _BlockStatementsopt IBlockStatementsopt
      _EndAction *AstToken
}
func (my *LPGUserAction0)      GetBeginAction() *AstToken{ return my._BeginAction}
func (my *LPGUserAction0)      SetBeginAction( _BeginAction *AstToken)  { my._BeginAction = _BeginAction }
    /**
     * The value returned by <b>GetBlockStatementsopt</b> may be <b>null</b>
     */
func (my *LPGUserAction0)      GetBlockStatementsopt() IBlockStatementsopt{ return my._BlockStatementsopt}
func (my *LPGUserAction0)      SetBlockStatementsopt( _BlockStatementsopt IBlockStatementsopt)  { my._BlockStatementsopt = _BlockStatementsopt }
func (my *LPGUserAction0)      GetEndAction() *AstToken{ return my._EndAction}
func (my *LPGUserAction0)      SetEndAction( _EndAction *AstToken)  { my._EndAction = _EndAction }

func NewLPGUserAction0(leftIToken IToken, rightIToken IToken ,
              _BeginAction *AstToken,
              _BlockStatementsopt IBlockStatementsopt,
              _EndAction *AstToken)*LPGUserAction0{
      my := new(LPGUserAction0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._BeginAction = _BeginAction;
        if nil != _BeginAction{
        var trait_ interface{} = _BeginAction
         trait_.(IAst).SetParent(my)
}
        my._BlockStatementsopt = _BlockStatementsopt;
        if nil != _BlockStatementsopt{
        var trait_ interface{} = _BlockStatementsopt
         trait_.(IAst).SetParent(my)
}
        my._EndAction = _EndAction;
        if nil != _EndAction{
        var trait_ interface{} = _EndAction
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LPGUserAction0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._BeginAction{  list.Add(my._BeginAction) }
        if nil != my._BlockStatementsopt{  list.Add(my._BlockStatementsopt) }
        if nil != my._EndAction{  list.Add(my._EndAction) }
        return list
    }

func (my *LPGUserAction0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LPGUserAction0)       Enter(v Visitor){
        var checkChildren = v.VisitLPGUserAction0(my)
        if checkChildren{
            if nil != my._BeginAction{my._BeginAction.Accept(v)}
            if nil != my._BlockStatementsopt{my._BlockStatementsopt.Accept(v)}
            if nil != my._EndAction{my._EndAction.Accept(v)}
        }
        v.EndVisitLPGUserAction0(my)
    }


func AnyCastToLPGUserAction0(i interface{}) *LPGUserAction0 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction0)
	}
}
/**
 *<b>
*<li>Rule 6:  LPGUserAction ::= $BeginJava BlockStatementsopt $EndJava
 *</b>
 */
type LPGUserAction1 struct{
    *Ast
      _BeginJava *AstToken
      _BlockStatementsopt IBlockStatementsopt
      _EndJava *AstToken
}
func (my *LPGUserAction1)      GetBeginJava() *AstToken{ return my._BeginJava}
func (my *LPGUserAction1)      SetBeginJava( _BeginJava *AstToken)  { my._BeginJava = _BeginJava }
    /**
     * The value returned by <b>GetBlockStatementsopt</b> may be <b>null</b>
     */
func (my *LPGUserAction1)      GetBlockStatementsopt() IBlockStatementsopt{ return my._BlockStatementsopt}
func (my *LPGUserAction1)      SetBlockStatementsopt( _BlockStatementsopt IBlockStatementsopt)  { my._BlockStatementsopt = _BlockStatementsopt }
func (my *LPGUserAction1)      GetEndJava() *AstToken{ return my._EndJava}
func (my *LPGUserAction1)      SetEndJava( _EndJava *AstToken)  { my._EndJava = _EndJava }

func NewLPGUserAction1(leftIToken IToken, rightIToken IToken ,
              _BeginJava *AstToken,
              _BlockStatementsopt IBlockStatementsopt,
              _EndJava *AstToken)*LPGUserAction1{
      my := new(LPGUserAction1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._BeginJava = _BeginJava;
        if nil != _BeginJava{
        var trait_ interface{} = _BeginJava
         trait_.(IAst).SetParent(my)
}
        my._BlockStatementsopt = _BlockStatementsopt;
        if nil != _BlockStatementsopt{
        var trait_ interface{} = _BlockStatementsopt
         trait_.(IAst).SetParent(my)
}
        my._EndJava = _EndJava;
        if nil != _EndJava{
        var trait_ interface{} = _EndJava
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LPGUserAction1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._BeginJava{  list.Add(my._BeginJava) }
        if nil != my._BlockStatementsopt{  list.Add(my._BlockStatementsopt) }
        if nil != my._EndJava{  list.Add(my._EndJava) }
        return list
    }

func (my *LPGUserAction1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LPGUserAction1)       Enter(v Visitor){
        var checkChildren = v.VisitLPGUserAction1(my)
        if checkChildren{
            if nil != my._BeginJava{my._BeginJava.Accept(v)}
            if nil != my._BlockStatementsopt{my._BlockStatementsopt.Accept(v)}
            if nil != my._EndJava{my._EndJava.Accept(v)}
        }
        v.EndVisitLPGUserAction1(my)
    }


func AnyCastToLPGUserAction1(i interface{}) *LPGUserAction1 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction1)
	}
}
/**
 *<b>
*<li>Rule 7:  LPGUserAction ::= $NoAction
 *</b>
 */
type LPGUserAction2 struct{
    *AstToken
}
func (my *LPGUserAction2)      GetNoAction()IToken{ return my.leftIToken; }

func NewLPGUserAction2(token IToken )*LPGUserAction2{
      my := new(LPGUserAction2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *LPGUserAction2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LPGUserAction2)       Enter(v Visitor){
        v.VisitLPGUserAction2(my)
        v.EndVisitLPGUserAction2(my)
    }


func AnyCastToLPGUserAction2(i interface{}) *LPGUserAction2 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction2)
	}
}
/**
 *<b>
*<li>Rule 8:  LPGUserAction ::= $NullAction
 *</b>
 */
type LPGUserAction3 struct{
    *AstToken
}
func (my *LPGUserAction3)      GetNullAction()IToken{ return my.leftIToken; }

func NewLPGUserAction3(token IToken )*LPGUserAction3{
      my := new(LPGUserAction3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *LPGUserAction3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LPGUserAction3)       Enter(v Visitor){
        v.VisitLPGUserAction3(my)
        v.EndVisitLPGUserAction3(my)
    }


func AnyCastToLPGUserAction3(i interface{}) *LPGUserAction3 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction3)
	}
}
/**
 *<b>
*<li>Rule 9:  LPGUserAction ::= $BadAction
 *</b>
 */
type LPGUserAction4 struct{
    *AstToken
}
func (my *LPGUserAction4)      GetBadAction()IToken{ return my.leftIToken; }

func NewLPGUserAction4(token IToken )*LPGUserAction4{
      my := new(LPGUserAction4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *LPGUserAction4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *LPGUserAction4)       Enter(v Visitor){
        v.VisitLPGUserAction4(my)
        v.EndVisitLPGUserAction4(my)
    }


func AnyCastToLPGUserAction4(i interface{}) *LPGUserAction4 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction4)
	}
}
/**
 *<b>
*<li>Rule 16:  IntegralType ::= byte
 *</b>
 */
type IntegralType0 struct{
    *AstToken
}
func (my *IntegralType0)      Getbyte()IToken{ return my.leftIToken; }

func NewIntegralType0(token IToken )*IntegralType0{
      my := new(IntegralType0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *IntegralType0)       Enter(v Visitor){
        v.VisitIntegralType0(my)
        v.EndVisitIntegralType0(my)
    }


func AnyCastToIntegralType0(i interface{}) *IntegralType0 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType0)
	}
}
/**
 *<b>
*<li>Rule 17:  IntegralType ::= short
 *</b>
 */
type IntegralType1 struct{
    *AstToken
}
func (my *IntegralType1)      Getshort()IToken{ return my.leftIToken; }

func NewIntegralType1(token IToken )*IntegralType1{
      my := new(IntegralType1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *IntegralType1)       Enter(v Visitor){
        v.VisitIntegralType1(my)
        v.EndVisitIntegralType1(my)
    }


func AnyCastToIntegralType1(i interface{}) *IntegralType1 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType1)
	}
}
/**
 *<b>
*<li>Rule 18:  IntegralType ::= int
 *</b>
 */
type IntegralType2 struct{
    *AstToken
}
func (my *IntegralType2)      Getint()IToken{ return my.leftIToken; }

func NewIntegralType2(token IToken )*IntegralType2{
      my := new(IntegralType2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *IntegralType2)       Enter(v Visitor){
        v.VisitIntegralType2(my)
        v.EndVisitIntegralType2(my)
    }


func AnyCastToIntegralType2(i interface{}) *IntegralType2 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType2)
	}
}
/**
 *<b>
*<li>Rule 19:  IntegralType ::= long
 *</b>
 */
type IntegralType3 struct{
    *AstToken
}
func (my *IntegralType3)      Getlong()IToken{ return my.leftIToken; }

func NewIntegralType3(token IToken )*IntegralType3{
      my := new(IntegralType3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *IntegralType3)       Enter(v Visitor){
        v.VisitIntegralType3(my)
        v.EndVisitIntegralType3(my)
    }


func AnyCastToIntegralType3(i interface{}) *IntegralType3 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType3)
	}
}
/**
 *<b>
*<li>Rule 20:  IntegralType ::= char
 *</b>
 */
type IntegralType4 struct{
    *AstToken
}
func (my *IntegralType4)      Getchar()IToken{ return my.leftIToken; }

func NewIntegralType4(token IToken )*IntegralType4{
      my := new(IntegralType4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *IntegralType4)       Enter(v Visitor){
        v.VisitIntegralType4(my)
        v.EndVisitIntegralType4(my)
    }


func AnyCastToIntegralType4(i interface{}) *IntegralType4 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType4)
	}
}
/**
 *<b>
*<li>Rule 21:  FloatingPointType ::= float
 *</b>
 */
type FloatingPointType0 struct{
    *AstToken
}
func (my *FloatingPointType0)      Getfloat()IToken{ return my.leftIToken; }

func NewFloatingPointType0(token IToken )*FloatingPointType0{
      my := new(FloatingPointType0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FloatingPointType0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FloatingPointType0)       Enter(v Visitor){
        v.VisitFloatingPointType0(my)
        v.EndVisitFloatingPointType0(my)
    }


func AnyCastToFloatingPointType0(i interface{}) *FloatingPointType0 {
	if nil == i{
		return nil
	}else{
		return i.(*FloatingPointType0)
	}
}
/**
 *<b>
*<li>Rule 22:  FloatingPointType ::= double
 *</b>
 */
type FloatingPointType1 struct{
    *AstToken
}
func (my *FloatingPointType1)      Getdouble()IToken{ return my.leftIToken; }

func NewFloatingPointType1(token IToken )*FloatingPointType1{
      my := new(FloatingPointType1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FloatingPointType1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FloatingPointType1)       Enter(v Visitor){
        v.VisitFloatingPointType1(my)
        v.EndVisitFloatingPointType1(my)
    }


func AnyCastToFloatingPointType1(i interface{}) *FloatingPointType1 {
	if nil == i{
		return nil
	}else{
		return i.(*FloatingPointType1)
	}
}
/**
 *<b>
*<li>Rule 45:  WildcardBounds ::= extends ReferenceType
 *</b>
 */
type WildcardBounds0 struct{
    *Ast
      _extends *AstToken
      _ReferenceType IReferenceType
}
func (my *WildcardBounds0)      Getextends() *AstToken{ return my._extends}
func (my *WildcardBounds0)      Setextends( _extends *AstToken)  { my._extends = _extends }
func (my *WildcardBounds0)      GetReferenceType() IReferenceType{ return my._ReferenceType}
func (my *WildcardBounds0)      SetReferenceType( _ReferenceType IReferenceType)  { my._ReferenceType = _ReferenceType }

func NewWildcardBounds0(leftIToken IToken, rightIToken IToken ,
              _extends *AstToken,
              _ReferenceType IReferenceType)*WildcardBounds0{
      my := new(WildcardBounds0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._extends = _extends;
        if nil != _extends{
        var trait_ interface{} = _extends
         trait_.(IAst).SetParent(my)
}
        my._ReferenceType = _ReferenceType;
        if nil != _ReferenceType{
        var trait_ interface{} = _ReferenceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *WildcardBounds0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._extends{  list.Add(my._extends) }
        if nil != my._ReferenceType{  list.Add(my._ReferenceType) }
        return list
    }

func (my *WildcardBounds0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *WildcardBounds0)       Enter(v Visitor){
        var checkChildren = v.VisitWildcardBounds0(my)
        if checkChildren{
            if nil != my._extends{my._extends.Accept(v)}
            if nil != my._ReferenceType{my._ReferenceType.Accept(v)}
        }
        v.EndVisitWildcardBounds0(my)
    }


func AnyCastToWildcardBounds0(i interface{}) *WildcardBounds0 {
	if nil == i{
		return nil
	}else{
		return i.(*WildcardBounds0)
	}
}
/**
 *<b>
*<li>Rule 46:  WildcardBounds ::= super ReferenceType
 *</b>
 */
type WildcardBounds1 struct{
    *Ast
      _super *AstToken
      _ReferenceType IReferenceType
}
func (my *WildcardBounds1)      Getsuper() *AstToken{ return my._super}
func (my *WildcardBounds1)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *WildcardBounds1)      GetReferenceType() IReferenceType{ return my._ReferenceType}
func (my *WildcardBounds1)      SetReferenceType( _ReferenceType IReferenceType)  { my._ReferenceType = _ReferenceType }

func NewWildcardBounds1(leftIToken IToken, rightIToken IToken ,
              _super *AstToken,
              _ReferenceType IReferenceType)*WildcardBounds1{
      my := new(WildcardBounds1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._ReferenceType = _ReferenceType;
        if nil != _ReferenceType{
        var trait_ interface{} = _ReferenceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *WildcardBounds1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._super{  list.Add(my._super) }
        if nil != my._ReferenceType{  list.Add(my._ReferenceType) }
        return list
    }

func (my *WildcardBounds1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *WildcardBounds1)       Enter(v Visitor){
        var checkChildren = v.VisitWildcardBounds1(my)
        if checkChildren{
            if nil != my._super{my._super.Accept(v)}
            if nil != my._ReferenceType{my._ReferenceType.Accept(v)}
        }
        v.EndVisitWildcardBounds1(my)
    }


func AnyCastToWildcardBounds1(i interface{}) *WildcardBounds1 {
	if nil == i{
		return nil
	}else{
		return i.(*WildcardBounds1)
	}
}
/**
 *<b>
*<li>Rule 80:  ClassModifier ::= public
 *</b>
 */
type ClassModifier0 struct{
    *AstToken
}
func (my *ClassModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewClassModifier0(token IToken )*ClassModifier0{
      my := new(ClassModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassModifier0)       Enter(v Visitor){
        v.VisitClassModifier0(my)
        v.EndVisitClassModifier0(my)
    }


func AnyCastToClassModifier0(i interface{}) *ClassModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier0)
	}
}
/**
 *<b>
*<li>Rule 81:  ClassModifier ::= protected
 *</b>
 */
type ClassModifier1 struct{
    *AstToken
}
func (my *ClassModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewClassModifier1(token IToken )*ClassModifier1{
      my := new(ClassModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassModifier1)       Enter(v Visitor){
        v.VisitClassModifier1(my)
        v.EndVisitClassModifier1(my)
    }


func AnyCastToClassModifier1(i interface{}) *ClassModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier1)
	}
}
/**
 *<b>
*<li>Rule 82:  ClassModifier ::= private
 *</b>
 */
type ClassModifier2 struct{
    *AstToken
}
func (my *ClassModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewClassModifier2(token IToken )*ClassModifier2{
      my := new(ClassModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassModifier2)       Enter(v Visitor){
        v.VisitClassModifier2(my)
        v.EndVisitClassModifier2(my)
    }


func AnyCastToClassModifier2(i interface{}) *ClassModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier2)
	}
}
/**
 *<b>
*<li>Rule 83:  ClassModifier ::= abstract
 *</b>
 */
type ClassModifier3 struct{
    *AstToken
}
func (my *ClassModifier3)      Getabstract()IToken{ return my.leftIToken; }

func NewClassModifier3(token IToken )*ClassModifier3{
      my := new(ClassModifier3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassModifier3)       Enter(v Visitor){
        v.VisitClassModifier3(my)
        v.EndVisitClassModifier3(my)
    }


func AnyCastToClassModifier3(i interface{}) *ClassModifier3 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier3)
	}
}
/**
 *<b>
*<li>Rule 84:  ClassModifier ::= static
 *</b>
 */
type ClassModifier4 struct{
    *AstToken
}
func (my *ClassModifier4)      Getstatic()IToken{ return my.leftIToken; }

func NewClassModifier4(token IToken )*ClassModifier4{
      my := new(ClassModifier4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassModifier4)       Enter(v Visitor){
        v.VisitClassModifier4(my)
        v.EndVisitClassModifier4(my)
    }


func AnyCastToClassModifier4(i interface{}) *ClassModifier4 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier4)
	}
}
/**
 *<b>
*<li>Rule 85:  ClassModifier ::= final
 *</b>
 */
type ClassModifier5 struct{
    *AstToken
}
func (my *ClassModifier5)      Getfinal()IToken{ return my.leftIToken; }

func NewClassModifier5(token IToken )*ClassModifier5{
      my := new(ClassModifier5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier5)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassModifier5)       Enter(v Visitor){
        v.VisitClassModifier5(my)
        v.EndVisitClassModifier5(my)
    }


func AnyCastToClassModifier5(i interface{}) *ClassModifier5 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier5)
	}
}
/**
 *<b>
*<li>Rule 86:  ClassModifier ::= strictfp
 *</b>
 */
type ClassModifier6 struct{
    *AstToken
}
func (my *ClassModifier6)      Getstrictfp()IToken{ return my.leftIToken; }

func NewClassModifier6(token IToken )*ClassModifier6{
      my := new(ClassModifier6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier6)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassModifier6)       Enter(v Visitor){
        v.VisitClassModifier6(my)
        v.EndVisitClassModifier6(my)
    }


func AnyCastToClassModifier6(i interface{}) *ClassModifier6 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier6)
	}
}
/**
 *<b>
*<li>Rule 118:  FieldModifier ::= public
 *</b>
 */
type FieldModifier0 struct{
    *AstToken
}
func (my *FieldModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewFieldModifier0(token IToken )*FieldModifier0{
      my := new(FieldModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldModifier0)       Enter(v Visitor){
        v.VisitFieldModifier0(my)
        v.EndVisitFieldModifier0(my)
    }


func AnyCastToFieldModifier0(i interface{}) *FieldModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier0)
	}
}
/**
 *<b>
*<li>Rule 119:  FieldModifier ::= protected
 *</b>
 */
type FieldModifier1 struct{
    *AstToken
}
func (my *FieldModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewFieldModifier1(token IToken )*FieldModifier1{
      my := new(FieldModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldModifier1)       Enter(v Visitor){
        v.VisitFieldModifier1(my)
        v.EndVisitFieldModifier1(my)
    }


func AnyCastToFieldModifier1(i interface{}) *FieldModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier1)
	}
}
/**
 *<b>
*<li>Rule 120:  FieldModifier ::= private
 *</b>
 */
type FieldModifier2 struct{
    *AstToken
}
func (my *FieldModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewFieldModifier2(token IToken )*FieldModifier2{
      my := new(FieldModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldModifier2)       Enter(v Visitor){
        v.VisitFieldModifier2(my)
        v.EndVisitFieldModifier2(my)
    }


func AnyCastToFieldModifier2(i interface{}) *FieldModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier2)
	}
}
/**
 *<b>
*<li>Rule 121:  FieldModifier ::= static
 *</b>
 */
type FieldModifier3 struct{
    *AstToken
}
func (my *FieldModifier3)      Getstatic()IToken{ return my.leftIToken; }

func NewFieldModifier3(token IToken )*FieldModifier3{
      my := new(FieldModifier3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldModifier3)       Enter(v Visitor){
        v.VisitFieldModifier3(my)
        v.EndVisitFieldModifier3(my)
    }


func AnyCastToFieldModifier3(i interface{}) *FieldModifier3 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier3)
	}
}
/**
 *<b>
*<li>Rule 122:  FieldModifier ::= final
 *</b>
 */
type FieldModifier4 struct{
    *AstToken
}
func (my *FieldModifier4)      Getfinal()IToken{ return my.leftIToken; }

func NewFieldModifier4(token IToken )*FieldModifier4{
      my := new(FieldModifier4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldModifier4)       Enter(v Visitor){
        v.VisitFieldModifier4(my)
        v.EndVisitFieldModifier4(my)
    }


func AnyCastToFieldModifier4(i interface{}) *FieldModifier4 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier4)
	}
}
/**
 *<b>
*<li>Rule 123:  FieldModifier ::= transient
 *</b>
 */
type FieldModifier5 struct{
    *AstToken
}
func (my *FieldModifier5)      Gettransient()IToken{ return my.leftIToken; }

func NewFieldModifier5(token IToken )*FieldModifier5{
      my := new(FieldModifier5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier5)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldModifier5)       Enter(v Visitor){
        v.VisitFieldModifier5(my)
        v.EndVisitFieldModifier5(my)
    }


func AnyCastToFieldModifier5(i interface{}) *FieldModifier5 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier5)
	}
}
/**
 *<b>
*<li>Rule 124:  FieldModifier ::= volatile
 *</b>
 */
type FieldModifier6 struct{
    *AstToken
}
func (my *FieldModifier6)      Getvolatile()IToken{ return my.leftIToken; }

func NewFieldModifier6(token IToken )*FieldModifier6{
      my := new(FieldModifier6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier6)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldModifier6)       Enter(v Visitor){
        v.VisitFieldModifier6(my)
        v.EndVisitFieldModifier6(my)
    }


func AnyCastToFieldModifier6(i interface{}) *FieldModifier6 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier6)
	}
}
/**
 *<b>
*<li>Rule 129:  MethodDeclarator ::= identifier ( FormalParameterListopt )
 *</b>
 */
type MethodDeclarator0 struct{
    *Ast
      _identifier *identifier
      _LPAREN *AstToken
      _FormalParameterListopt IFormalParameterListopt
      _RPAREN *AstToken
}
func (my *MethodDeclarator0)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodDeclarator0)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodDeclarator0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodDeclarator0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetFormalParameterListopt</b> may be <b>null</b>
     */
func (my *MethodDeclarator0)      GetFormalParameterListopt() IFormalParameterListopt{ return my._FormalParameterListopt}
func (my *MethodDeclarator0)      SetFormalParameterListopt( _FormalParameterListopt IFormalParameterListopt)  { my._FormalParameterListopt = _FormalParameterListopt }
func (my *MethodDeclarator0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodDeclarator0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodDeclarator0(leftIToken IToken, rightIToken IToken ,
              _identifier *identifier,
              _LPAREN *AstToken,
              _FormalParameterListopt IFormalParameterListopt,
              _RPAREN *AstToken)*MethodDeclarator0{
      my := new(MethodDeclarator0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._FormalParameterListopt = _FormalParameterListopt;
        if nil != _FormalParameterListopt{
        var trait_ interface{} = _FormalParameterListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodDeclarator0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._FormalParameterListopt{  list.Add(my._FormalParameterListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodDeclarator0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodDeclarator0)       Enter(v Visitor){
        var checkChildren = v.VisitMethodDeclarator0(my)
        if checkChildren{
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._FormalParameterListopt{my._FormalParameterListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitMethodDeclarator0(my)
    }


func AnyCastToMethodDeclarator0(i interface{}) *MethodDeclarator0 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodDeclarator0)
	}
}
/**
 *<b>
*<li>Rule 130:  MethodDeclarator ::= MethodDeclarator [ ]
 *</b>
 */
type MethodDeclarator1 struct{
    *Ast
      _MethodDeclarator IMethodDeclarator
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *MethodDeclarator1)      GetMethodDeclarator() IMethodDeclarator{ return my._MethodDeclarator}
func (my *MethodDeclarator1)      SetMethodDeclarator( _MethodDeclarator IMethodDeclarator)  { my._MethodDeclarator = _MethodDeclarator }
func (my *MethodDeclarator1)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *MethodDeclarator1)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *MethodDeclarator1)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *MethodDeclarator1)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewMethodDeclarator1(leftIToken IToken, rightIToken IToken ,
              _MethodDeclarator IMethodDeclarator,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*MethodDeclarator1{
      my := new(MethodDeclarator1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodDeclarator = _MethodDeclarator;
        if nil != _MethodDeclarator{
        var trait_ interface{} = _MethodDeclarator
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodDeclarator1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodDeclarator{  list.Add(my._MethodDeclarator) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *MethodDeclarator1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodDeclarator1)       Enter(v Visitor){
        var checkChildren = v.VisitMethodDeclarator1(my)
        if checkChildren{
            if nil != my._MethodDeclarator{my._MethodDeclarator.Accept(v)}
            if nil != my._LBRACKET{my._LBRACKET.Accept(v)}
            if nil != my._RBRACKET{my._RBRACKET.Accept(v)}
        }
        v.EndVisitMethodDeclarator1(my)
    }


func AnyCastToMethodDeclarator1(i interface{}) *MethodDeclarator1 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodDeclarator1)
	}
}
/**
 *<b>
*<li>Rule 144:  MethodModifier ::= public
 *</b>
 */
type MethodModifier0 struct{
    *AstToken
}
func (my *MethodModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewMethodModifier0(token IToken )*MethodModifier0{
      my := new(MethodModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier0)       Enter(v Visitor){
        v.VisitMethodModifier0(my)
        v.EndVisitMethodModifier0(my)
    }


func AnyCastToMethodModifier0(i interface{}) *MethodModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier0)
	}
}
/**
 *<b>
*<li>Rule 145:  MethodModifier ::= protected
 *</b>
 */
type MethodModifier1 struct{
    *AstToken
}
func (my *MethodModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewMethodModifier1(token IToken )*MethodModifier1{
      my := new(MethodModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier1)       Enter(v Visitor){
        v.VisitMethodModifier1(my)
        v.EndVisitMethodModifier1(my)
    }


func AnyCastToMethodModifier1(i interface{}) *MethodModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier1)
	}
}
/**
 *<b>
*<li>Rule 146:  MethodModifier ::= private
 *</b>
 */
type MethodModifier2 struct{
    *AstToken
}
func (my *MethodModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewMethodModifier2(token IToken )*MethodModifier2{
      my := new(MethodModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier2)       Enter(v Visitor){
        v.VisitMethodModifier2(my)
        v.EndVisitMethodModifier2(my)
    }


func AnyCastToMethodModifier2(i interface{}) *MethodModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier2)
	}
}
/**
 *<b>
*<li>Rule 147:  MethodModifier ::= abstract
 *</b>
 */
type MethodModifier3 struct{
    *AstToken
}
func (my *MethodModifier3)      Getabstract()IToken{ return my.leftIToken; }

func NewMethodModifier3(token IToken )*MethodModifier3{
      my := new(MethodModifier3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier3)       Enter(v Visitor){
        v.VisitMethodModifier3(my)
        v.EndVisitMethodModifier3(my)
    }


func AnyCastToMethodModifier3(i interface{}) *MethodModifier3 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier3)
	}
}
/**
 *<b>
*<li>Rule 148:  MethodModifier ::= static
 *</b>
 */
type MethodModifier4 struct{
    *AstToken
}
func (my *MethodModifier4)      Getstatic()IToken{ return my.leftIToken; }

func NewMethodModifier4(token IToken )*MethodModifier4{
      my := new(MethodModifier4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier4)       Enter(v Visitor){
        v.VisitMethodModifier4(my)
        v.EndVisitMethodModifier4(my)
    }


func AnyCastToMethodModifier4(i interface{}) *MethodModifier4 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier4)
	}
}
/**
 *<b>
*<li>Rule 149:  MethodModifier ::= final
 *</b>
 */
type MethodModifier5 struct{
    *AstToken
}
func (my *MethodModifier5)      Getfinal()IToken{ return my.leftIToken; }

func NewMethodModifier5(token IToken )*MethodModifier5{
      my := new(MethodModifier5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier5)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier5)       Enter(v Visitor){
        v.VisitMethodModifier5(my)
        v.EndVisitMethodModifier5(my)
    }


func AnyCastToMethodModifier5(i interface{}) *MethodModifier5 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier5)
	}
}
/**
 *<b>
*<li>Rule 150:  MethodModifier ::= synchronized
 *</b>
 */
type MethodModifier6 struct{
    *AstToken
}
func (my *MethodModifier6)      Getsynchronized()IToken{ return my.leftIToken; }

func NewMethodModifier6(token IToken )*MethodModifier6{
      my := new(MethodModifier6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier6)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier6)       Enter(v Visitor){
        v.VisitMethodModifier6(my)
        v.EndVisitMethodModifier6(my)
    }


func AnyCastToMethodModifier6(i interface{}) *MethodModifier6 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier6)
	}
}
/**
 *<b>
*<li>Rule 151:  MethodModifier ::= native
 *</b>
 */
type MethodModifier7 struct{
    *AstToken
}
func (my *MethodModifier7)      Getnative()IToken{ return my.leftIToken; }

func NewMethodModifier7(token IToken )*MethodModifier7{
      my := new(MethodModifier7)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier7)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier7)       Enter(v Visitor){
        v.VisitMethodModifier7(my)
        v.EndVisitMethodModifier7(my)
    }


func AnyCastToMethodModifier7(i interface{}) *MethodModifier7 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier7)
	}
}
/**
 *<b>
*<li>Rule 152:  MethodModifier ::= strictfp
 *</b>
 */
type MethodModifier8 struct{
    *AstToken
}
func (my *MethodModifier8)      Getstrictfp()IToken{ return my.leftIToken; }

func NewMethodModifier8(token IToken )*MethodModifier8{
      my := new(MethodModifier8)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier8)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodModifier8)       Enter(v Visitor){
        v.VisitMethodModifier8(my)
        v.EndVisitMethodModifier8(my)
    }


func AnyCastToMethodModifier8(i interface{}) *MethodModifier8 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier8)
	}
}
/**
 *<b>
*<li>Rule 168:  ConstructorModifier ::= public
 *</b>
 */
type ConstructorModifier0 struct{
    *AstToken
}
func (my *ConstructorModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewConstructorModifier0(token IToken )*ConstructorModifier0{
      my := new(ConstructorModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstructorModifier0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstructorModifier0)       Enter(v Visitor){
        v.VisitConstructorModifier0(my)
        v.EndVisitConstructorModifier0(my)
    }


func AnyCastToConstructorModifier0(i interface{}) *ConstructorModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorModifier0)
	}
}
/**
 *<b>
*<li>Rule 169:  ConstructorModifier ::= protected
 *</b>
 */
type ConstructorModifier1 struct{
    *AstToken
}
func (my *ConstructorModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewConstructorModifier1(token IToken )*ConstructorModifier1{
      my := new(ConstructorModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstructorModifier1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstructorModifier1)       Enter(v Visitor){
        v.VisitConstructorModifier1(my)
        v.EndVisitConstructorModifier1(my)
    }


func AnyCastToConstructorModifier1(i interface{}) *ConstructorModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorModifier1)
	}
}
/**
 *<b>
*<li>Rule 170:  ConstructorModifier ::= private
 *</b>
 */
type ConstructorModifier2 struct{
    *AstToken
}
func (my *ConstructorModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewConstructorModifier2(token IToken )*ConstructorModifier2{
      my := new(ConstructorModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstructorModifier2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstructorModifier2)       Enter(v Visitor){
        v.VisitConstructorModifier2(my)
        v.EndVisitConstructorModifier2(my)
    }


func AnyCastToConstructorModifier2(i interface{}) *ConstructorModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorModifier2)
	}
}
/**
 *<b>
*<li>Rule 172:  ExplicitConstructorInvocation ::= TypeArgumentsopt this ( ArgumentListopt ) ;
 *</b>
 */
type ExplicitConstructorInvocation0 struct{
    *Ast
      _TypeArgumentsopt *TypeArguments
      _this *AstToken
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation0)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ExplicitConstructorInvocation0)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ExplicitConstructorInvocation0)      Getthis() *AstToken{ return my._this}
func (my *ExplicitConstructorInvocation0)      Setthis( _this *AstToken)  { my._this = _this }
func (my *ExplicitConstructorInvocation0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ExplicitConstructorInvocation0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation0)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ExplicitConstructorInvocation0)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ExplicitConstructorInvocation0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ExplicitConstructorInvocation0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *ExplicitConstructorInvocation0)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ExplicitConstructorInvocation0)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewExplicitConstructorInvocation0(leftIToken IToken, rightIToken IToken ,
              _TypeArgumentsopt *TypeArguments,
              _this *AstToken,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _SEMICOLON *AstToken)*ExplicitConstructorInvocation0{
      my := new(ExplicitConstructorInvocation0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._this = _this;
        if nil != _this{
        var trait_ interface{} = _this
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExplicitConstructorInvocation0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._this{  list.Add(my._this) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ExplicitConstructorInvocation0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExplicitConstructorInvocation0)       Enter(v Visitor){
        var checkChildren = v.VisitExplicitConstructorInvocation0(my)
        if checkChildren{
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
            if nil != my._this{my._this.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitExplicitConstructorInvocation0(my)
    }


func AnyCastToExplicitConstructorInvocation0(i interface{}) *ExplicitConstructorInvocation0 {
	if nil == i{
		return nil
	}else{
		return i.(*ExplicitConstructorInvocation0)
	}
}
/**
 *<b>
*<li>Rule 173:  ExplicitConstructorInvocation ::= TypeArgumentsopt super ( ArgumentListopt ) ;
 *</b>
 */
type ExplicitConstructorInvocation1 struct{
    *Ast
      _TypeArgumentsopt *TypeArguments
      _super *AstToken
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation1)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ExplicitConstructorInvocation1)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ExplicitConstructorInvocation1)      Getsuper() *AstToken{ return my._super}
func (my *ExplicitConstructorInvocation1)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *ExplicitConstructorInvocation1)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ExplicitConstructorInvocation1)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation1)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ExplicitConstructorInvocation1)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ExplicitConstructorInvocation1)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ExplicitConstructorInvocation1)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *ExplicitConstructorInvocation1)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ExplicitConstructorInvocation1)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewExplicitConstructorInvocation1(leftIToken IToken, rightIToken IToken ,
              _TypeArgumentsopt *TypeArguments,
              _super *AstToken,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _SEMICOLON *AstToken)*ExplicitConstructorInvocation1{
      my := new(ExplicitConstructorInvocation1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExplicitConstructorInvocation1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._super{  list.Add(my._super) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ExplicitConstructorInvocation1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExplicitConstructorInvocation1)       Enter(v Visitor){
        var checkChildren = v.VisitExplicitConstructorInvocation1(my)
        if checkChildren{
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
            if nil != my._super{my._super.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitExplicitConstructorInvocation1(my)
    }


func AnyCastToExplicitConstructorInvocation1(i interface{}) *ExplicitConstructorInvocation1 {
	if nil == i{
		return nil
	}else{
		return i.(*ExplicitConstructorInvocation1)
	}
}
/**
 *<b>
*<li>Rule 174:  ExplicitConstructorInvocation ::= Primary . TypeArgumentsopt super ( ArgumentListopt ) ;
 *</b>
 */
type ExplicitConstructorInvocation2 struct{
    *Ast
      _Primary IPrimary
      _DOT *AstToken
      _TypeArgumentsopt *TypeArguments
      _super *AstToken
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _SEMICOLON *AstToken
}
func (my *ExplicitConstructorInvocation2)      GetPrimary() IPrimary{ return my._Primary}
func (my *ExplicitConstructorInvocation2)      SetPrimary( _Primary IPrimary)  { my._Primary = _Primary }
func (my *ExplicitConstructorInvocation2)      GetDOT() *AstToken{ return my._DOT}
func (my *ExplicitConstructorInvocation2)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation2)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ExplicitConstructorInvocation2)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ExplicitConstructorInvocation2)      Getsuper() *AstToken{ return my._super}
func (my *ExplicitConstructorInvocation2)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *ExplicitConstructorInvocation2)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ExplicitConstructorInvocation2)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation2)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ExplicitConstructorInvocation2)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ExplicitConstructorInvocation2)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ExplicitConstructorInvocation2)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *ExplicitConstructorInvocation2)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ExplicitConstructorInvocation2)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewExplicitConstructorInvocation2(leftIToken IToken, rightIToken IToken ,
              _Primary IPrimary,
              _DOT *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _super *AstToken,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _SEMICOLON *AstToken)*ExplicitConstructorInvocation2{
      my := new(ExplicitConstructorInvocation2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Primary = _Primary;
        if nil != _Primary{
        var trait_ interface{} = _Primary
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExplicitConstructorInvocation2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Primary{  list.Add(my._Primary) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._super{  list.Add(my._super) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ExplicitConstructorInvocation2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExplicitConstructorInvocation2)       Enter(v Visitor){
        var checkChildren = v.VisitExplicitConstructorInvocation2(my)
        if checkChildren{
            if nil != my._Primary{my._Primary.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
            if nil != my._super{my._super.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitExplicitConstructorInvocation2(my)
    }


func AnyCastToExplicitConstructorInvocation2(i interface{}) *ExplicitConstructorInvocation2 {
	if nil == i{
		return nil
	}else{
		return i.(*ExplicitConstructorInvocation2)
	}
}
/**
 *<b>
*<li>Rule 188:  InterfaceModifier ::= public
 *</b>
 */
type InterfaceModifier0 struct{
    *AstToken
}
func (my *InterfaceModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewInterfaceModifier0(token IToken )*InterfaceModifier0{
      my := new(InterfaceModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceModifier0)       Enter(v Visitor){
        v.VisitInterfaceModifier0(my)
        v.EndVisitInterfaceModifier0(my)
    }


func AnyCastToInterfaceModifier0(i interface{}) *InterfaceModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier0)
	}
}
/**
 *<b>
*<li>Rule 189:  InterfaceModifier ::= protected
 *</b>
 */
type InterfaceModifier1 struct{
    *AstToken
}
func (my *InterfaceModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewInterfaceModifier1(token IToken )*InterfaceModifier1{
      my := new(InterfaceModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceModifier1)       Enter(v Visitor){
        v.VisitInterfaceModifier1(my)
        v.EndVisitInterfaceModifier1(my)
    }


func AnyCastToInterfaceModifier1(i interface{}) *InterfaceModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier1)
	}
}
/**
 *<b>
*<li>Rule 190:  InterfaceModifier ::= private
 *</b>
 */
type InterfaceModifier2 struct{
    *AstToken
}
func (my *InterfaceModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewInterfaceModifier2(token IToken )*InterfaceModifier2{
      my := new(InterfaceModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceModifier2)       Enter(v Visitor){
        v.VisitInterfaceModifier2(my)
        v.EndVisitInterfaceModifier2(my)
    }


func AnyCastToInterfaceModifier2(i interface{}) *InterfaceModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier2)
	}
}
/**
 *<b>
*<li>Rule 191:  InterfaceModifier ::= abstract
 *</b>
 */
type InterfaceModifier3 struct{
    *AstToken
}
func (my *InterfaceModifier3)      Getabstract()IToken{ return my.leftIToken; }

func NewInterfaceModifier3(token IToken )*InterfaceModifier3{
      my := new(InterfaceModifier3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceModifier3)       Enter(v Visitor){
        v.VisitInterfaceModifier3(my)
        v.EndVisitInterfaceModifier3(my)
    }


func AnyCastToInterfaceModifier3(i interface{}) *InterfaceModifier3 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier3)
	}
}
/**
 *<b>
*<li>Rule 192:  InterfaceModifier ::= static
 *</b>
 */
type InterfaceModifier4 struct{
    *AstToken
}
func (my *InterfaceModifier4)      Getstatic()IToken{ return my.leftIToken; }

func NewInterfaceModifier4(token IToken )*InterfaceModifier4{
      my := new(InterfaceModifier4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceModifier4)       Enter(v Visitor){
        v.VisitInterfaceModifier4(my)
        v.EndVisitInterfaceModifier4(my)
    }


func AnyCastToInterfaceModifier4(i interface{}) *InterfaceModifier4 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier4)
	}
}
/**
 *<b>
*<li>Rule 193:  InterfaceModifier ::= strictfp
 *</b>
 */
type InterfaceModifier5 struct{
    *AstToken
}
func (my *InterfaceModifier5)      Getstrictfp()IToken{ return my.leftIToken; }

func NewInterfaceModifier5(token IToken )*InterfaceModifier5{
      my := new(InterfaceModifier5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier5)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *InterfaceModifier5)       Enter(v Visitor){
        v.VisitInterfaceModifier5(my)
        v.EndVisitInterfaceModifier5(my)
    }


func AnyCastToInterfaceModifier5(i interface{}) *InterfaceModifier5 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier5)
	}
}
/**
 *<b>
*<li>Rule 194:  ExtendsInterfaces ::= extends InterfaceType
 *</b>
 */
type ExtendsInterfaces0 struct{
    *Ast
      _extends *AstToken
      _InterfaceType *InterfaceType
}
func (my *ExtendsInterfaces0)      Getextends() *AstToken{ return my._extends}
func (my *ExtendsInterfaces0)      Setextends( _extends *AstToken)  { my._extends = _extends }
func (my *ExtendsInterfaces0)      GetInterfaceType() *InterfaceType{ return my._InterfaceType}
func (my *ExtendsInterfaces0)      SetInterfaceType( _InterfaceType *InterfaceType)  { my._InterfaceType = _InterfaceType }

func NewExtendsInterfaces0(leftIToken IToken, rightIToken IToken ,
              _extends *AstToken,
              _InterfaceType *InterfaceType)*ExtendsInterfaces0{
      my := new(ExtendsInterfaces0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._extends = _extends;
        if nil != _extends{
        var trait_ interface{} = _extends
         trait_.(IAst).SetParent(my)
}
        my._InterfaceType = _InterfaceType;
        if nil != _InterfaceType{
        var trait_ interface{} = _InterfaceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExtendsInterfaces0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._extends{  list.Add(my._extends) }
        if nil != my._InterfaceType{  list.Add(my._InterfaceType) }
        return list
    }

func (my *ExtendsInterfaces0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExtendsInterfaces0)       Enter(v Visitor){
        var checkChildren = v.VisitExtendsInterfaces0(my)
        if checkChildren{
            if nil != my._extends{my._extends.Accept(v)}
            if nil != my._InterfaceType{my._InterfaceType.Accept(v)}
        }
        v.EndVisitExtendsInterfaces0(my)
    }


func AnyCastToExtendsInterfaces0(i interface{}) *ExtendsInterfaces0 {
	if nil == i{
		return nil
	}else{
		return i.(*ExtendsInterfaces0)
	}
}
/**
 *<b>
*<li>Rule 195:  ExtendsInterfaces ::= ExtendsInterfaces , InterfaceType
 *</b>
 */
type ExtendsInterfaces1 struct{
    *Ast
      _ExtendsInterfaces IExtendsInterfaces
      _COMMA *AstToken
      _InterfaceType *InterfaceType
}
func (my *ExtendsInterfaces1)      GetExtendsInterfaces() IExtendsInterfaces{ return my._ExtendsInterfaces}
func (my *ExtendsInterfaces1)      SetExtendsInterfaces( _ExtendsInterfaces IExtendsInterfaces)  { my._ExtendsInterfaces = _ExtendsInterfaces }
func (my *ExtendsInterfaces1)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ExtendsInterfaces1)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ExtendsInterfaces1)      GetInterfaceType() *InterfaceType{ return my._InterfaceType}
func (my *ExtendsInterfaces1)      SetInterfaceType( _InterfaceType *InterfaceType)  { my._InterfaceType = _InterfaceType }

func NewExtendsInterfaces1(leftIToken IToken, rightIToken IToken ,
              _ExtendsInterfaces IExtendsInterfaces,
              _COMMA *AstToken,
              _InterfaceType *InterfaceType)*ExtendsInterfaces1{
      my := new(ExtendsInterfaces1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ExtendsInterfaces = _ExtendsInterfaces;
        if nil != _ExtendsInterfaces{
        var trait_ interface{} = _ExtendsInterfaces
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._InterfaceType = _InterfaceType;
        if nil != _InterfaceType{
        var trait_ interface{} = _InterfaceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExtendsInterfaces1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ExtendsInterfaces{  list.Add(my._ExtendsInterfaces) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._InterfaceType{  list.Add(my._InterfaceType) }
        return list
    }

func (my *ExtendsInterfaces1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ExtendsInterfaces1)       Enter(v Visitor){
        var checkChildren = v.VisitExtendsInterfaces1(my)
        if checkChildren{
            if nil != my._ExtendsInterfaces{my._ExtendsInterfaces.Accept(v)}
            if nil != my._COMMA{my._COMMA.Accept(v)}
            if nil != my._InterfaceType{my._InterfaceType.Accept(v)}
        }
        v.EndVisitExtendsInterfaces1(my)
    }


func AnyCastToExtendsInterfaces1(i interface{}) *ExtendsInterfaces1 {
	if nil == i{
		return nil
	}else{
		return i.(*ExtendsInterfaces1)
	}
}
/**
 *<b>
*<li>Rule 208:  ConstantModifier ::= public
 *</b>
 */
type ConstantModifier0 struct{
    *AstToken
}
func (my *ConstantModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewConstantModifier0(token IToken )*ConstantModifier0{
      my := new(ConstantModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstantModifier0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstantModifier0)       Enter(v Visitor){
        v.VisitConstantModifier0(my)
        v.EndVisitConstantModifier0(my)
    }


func AnyCastToConstantModifier0(i interface{}) *ConstantModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantModifier0)
	}
}
/**
 *<b>
*<li>Rule 209:  ConstantModifier ::= static
 *</b>
 */
type ConstantModifier1 struct{
    *AstToken
}
func (my *ConstantModifier1)      Getstatic()IToken{ return my.leftIToken; }

func NewConstantModifier1(token IToken )*ConstantModifier1{
      my := new(ConstantModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstantModifier1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstantModifier1)       Enter(v Visitor){
        v.VisitConstantModifier1(my)
        v.EndVisitConstantModifier1(my)
    }


func AnyCastToConstantModifier1(i interface{}) *ConstantModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantModifier1)
	}
}
/**
 *<b>
*<li>Rule 210:  ConstantModifier ::= final
 *</b>
 */
type ConstantModifier2 struct{
    *AstToken
}
func (my *ConstantModifier2)      Getfinal()IToken{ return my.leftIToken; }

func NewConstantModifier2(token IToken )*ConstantModifier2{
      my := new(ConstantModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstantModifier2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ConstantModifier2)       Enter(v Visitor){
        v.VisitConstantModifier2(my)
        v.EndVisitConstantModifier2(my)
    }


func AnyCastToConstantModifier2(i interface{}) *ConstantModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantModifier2)
	}
}
/**
 *<b>
*<li>Rule 215:  AbstractMethodModifier ::= public
 *</b>
 */
type AbstractMethodModifier0 struct{
    *AstToken
}
func (my *AbstractMethodModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewAbstractMethodModifier0(token IToken )*AbstractMethodModifier0{
      my := new(AbstractMethodModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AbstractMethodModifier0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AbstractMethodModifier0)       Enter(v Visitor){
        v.VisitAbstractMethodModifier0(my)
        v.EndVisitAbstractMethodModifier0(my)
    }


func AnyCastToAbstractMethodModifier0(i interface{}) *AbstractMethodModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractMethodModifier0)
	}
}
/**
 *<b>
*<li>Rule 216:  AbstractMethodModifier ::= abstract
 *</b>
 */
type AbstractMethodModifier1 struct{
    *AstToken
}
func (my *AbstractMethodModifier1)      Getabstract()IToken{ return my.leftIToken; }

func NewAbstractMethodModifier1(token IToken )*AbstractMethodModifier1{
      my := new(AbstractMethodModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AbstractMethodModifier1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AbstractMethodModifier1)       Enter(v Visitor){
        v.VisitAbstractMethodModifier1(my)
        v.EndVisitAbstractMethodModifier1(my)
    }


func AnyCastToAbstractMethodModifier1(i interface{}) *AbstractMethodModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractMethodModifier1)
	}
}
/**
 *<b>
*<li>Rule 221:  AnnotationTypeElementDeclaration ::= AbstractMethodModifiersopt Type identifier ( ) DefaultValueopt ;
 *</b>
 */
type AnnotationTypeElementDeclaration0 struct{
    *Ast
      _AbstractMethodModifiersopt IAbstractMethodModifiersopt
      _Type IType
      _identifier *identifier
      _LPAREN *AstToken
      _RPAREN *AstToken
      _DefaultValueopt *DefaultValue
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetAbstractMethodModifiersopt</b> may be <b>null</b>
     */
func (my *AnnotationTypeElementDeclaration0)      GetAbstractMethodModifiersopt() IAbstractMethodModifiersopt{ return my._AbstractMethodModifiersopt}
func (my *AnnotationTypeElementDeclaration0)      SetAbstractMethodModifiersopt( _AbstractMethodModifiersopt IAbstractMethodModifiersopt)  { my._AbstractMethodModifiersopt = _AbstractMethodModifiersopt }
func (my *AnnotationTypeElementDeclaration0)      GetType() IType{ return my._Type}
func (my *AnnotationTypeElementDeclaration0)      SetType( _Type IType)  { my._Type = _Type }
func (my *AnnotationTypeElementDeclaration0)      Getidentifier() *identifier{ return my._identifier}
func (my *AnnotationTypeElementDeclaration0)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *AnnotationTypeElementDeclaration0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *AnnotationTypeElementDeclaration0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *AnnotationTypeElementDeclaration0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *AnnotationTypeElementDeclaration0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
    /**
     * The value returned by <b>GetDefaultValueopt</b> may be <b>null</b>
     */
func (my *AnnotationTypeElementDeclaration0)      GetDefaultValueopt() *DefaultValue{ return my._DefaultValueopt}
func (my *AnnotationTypeElementDeclaration0)      SetDefaultValueopt( _DefaultValueopt *DefaultValue)  { my._DefaultValueopt = _DefaultValueopt }
func (my *AnnotationTypeElementDeclaration0)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *AnnotationTypeElementDeclaration0)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewAnnotationTypeElementDeclaration0(leftIToken IToken, rightIToken IToken ,
              _AbstractMethodModifiersopt IAbstractMethodModifiersopt,
              _Type IType,
              _identifier *identifier,
              _LPAREN *AstToken,
              _RPAREN *AstToken,
              _DefaultValueopt *DefaultValue,
              _SEMICOLON *AstToken)*AnnotationTypeElementDeclaration0{
      my := new(AnnotationTypeElementDeclaration0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AbstractMethodModifiersopt = _AbstractMethodModifiersopt;
        if nil != _AbstractMethodModifiersopt{
        var trait_ interface{} = _AbstractMethodModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._DefaultValueopt = _DefaultValueopt;
        if nil != _DefaultValueopt{
        var trait_ interface{} = _DefaultValueopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AnnotationTypeElementDeclaration0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AbstractMethodModifiersopt{  list.Add(my._AbstractMethodModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._DefaultValueopt{  list.Add(my._DefaultValueopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *AnnotationTypeElementDeclaration0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AnnotationTypeElementDeclaration0)       Enter(v Visitor){
        var checkChildren = v.VisitAnnotationTypeElementDeclaration0(my)
        if checkChildren{
            if nil != my._AbstractMethodModifiersopt{my._AbstractMethodModifiersopt.Accept(v)}
            if nil != my._Type{my._Type.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._DefaultValueopt{my._DefaultValueopt.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitAnnotationTypeElementDeclaration0(my)
    }


func AnyCastToAnnotationTypeElementDeclaration0(i interface{}) *AnnotationTypeElementDeclaration0 {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeElementDeclaration0)
	}
}
/**
 *<b>
*<li>Rule 227:  AnnotationTypeElementDeclaration ::= ;
 *</b>
 */
type AnnotationTypeElementDeclaration1 struct{
    *AstToken
}
func (my *AnnotationTypeElementDeclaration1)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewAnnotationTypeElementDeclaration1(token IToken )*AnnotationTypeElementDeclaration1{
      my := new(AnnotationTypeElementDeclaration1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AnnotationTypeElementDeclaration1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AnnotationTypeElementDeclaration1)       Enter(v Visitor){
        v.VisitAnnotationTypeElementDeclaration1(my)
        v.EndVisitAnnotationTypeElementDeclaration1(my)
    }


func AnyCastToAnnotationTypeElementDeclaration1(i interface{}) *AnnotationTypeElementDeclaration1 {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeElementDeclaration1)
	}
}
/**
 *<b>
*<li>Rule 295:  AssertStatement ::= assert Expression ;
 *</b>
 */
type AssertStatement0 struct{
    *Ast
      _assert *AstToken
      _Expression IExpression
      _SEMICOLON *AstToken
}
func (my *AssertStatement0)      Getassert() *AstToken{ return my._assert}
func (my *AssertStatement0)      Setassert( _assert *AstToken)  { my._assert = _assert }
func (my *AssertStatement0)      GetExpression() IExpression{ return my._Expression}
func (my *AssertStatement0)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *AssertStatement0)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *AssertStatement0)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewAssertStatement0(leftIToken IToken, rightIToken IToken ,
              _assert *AstToken,
              _Expression IExpression,
              _SEMICOLON *AstToken)*AssertStatement0{
      my := new(AssertStatement0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._assert = _assert;
        if nil != _assert{
        var trait_ interface{} = _assert
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AssertStatement0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._assert{  list.Add(my._assert) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *AssertStatement0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssertStatement0)       Enter(v Visitor){
        var checkChildren = v.VisitAssertStatement0(my)
        if checkChildren{
            if nil != my._assert{my._assert.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitAssertStatement0(my)
    }


func AnyCastToAssertStatement0(i interface{}) *AssertStatement0 {
	if nil == i{
		return nil
	}else{
		return i.(*AssertStatement0)
	}
}
/**
 *<b>
*<li>Rule 296:  AssertStatement ::= assert Expression : Expression ;
 *</b>
 */
type AssertStatement1 struct{
    *Ast
      _assert *AstToken
      _Expression IExpression
      _COLON *AstToken
      _Expression4 IExpression
      _SEMICOLON *AstToken
}
func (my *AssertStatement1)      Getassert() *AstToken{ return my._assert}
func (my *AssertStatement1)      Setassert( _assert *AstToken)  { my._assert = _assert }
func (my *AssertStatement1)      GetExpression() IExpression{ return my._Expression}
func (my *AssertStatement1)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *AssertStatement1)      GetCOLON() *AstToken{ return my._COLON}
func (my *AssertStatement1)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *AssertStatement1)      GetExpression4() IExpression{ return my._Expression4}
func (my *AssertStatement1)      SetExpression4( _Expression4 IExpression)  { my._Expression4 = _Expression4 }
func (my *AssertStatement1)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *AssertStatement1)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewAssertStatement1(leftIToken IToken, rightIToken IToken ,
              _assert *AstToken,
              _Expression IExpression,
              _COLON *AstToken,
              _Expression4 IExpression,
              _SEMICOLON *AstToken)*AssertStatement1{
      my := new(AssertStatement1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._assert = _assert;
        if nil != _assert{
        var trait_ interface{} = _assert
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._Expression4 = _Expression4;
        if nil != _Expression4{
        var trait_ interface{} = _Expression4
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AssertStatement1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._assert{  list.Add(my._assert) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._Expression4{  list.Add(my._Expression4) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *AssertStatement1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssertStatement1)       Enter(v Visitor){
        var checkChildren = v.VisitAssertStatement1(my)
        if checkChildren{
            if nil != my._assert{my._assert.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._COLON{my._COLON.Accept(v)}
            if nil != my._Expression4{my._Expression4.Accept(v)}
            if nil != my._SEMICOLON{my._SEMICOLON.Accept(v)}
        }
        v.EndVisitAssertStatement1(my)
    }


func AnyCastToAssertStatement1(i interface{}) *AssertStatement1 {
	if nil == i{
		return nil
	}else{
		return i.(*AssertStatement1)
	}
}
/**
 *<b>
*<li>Rule 304:  SwitchLabel ::= case ConstantExpression :
 *</b>
 */
type SwitchLabel0 struct{
    *Ast
      _case *AstToken
      _ConstantExpression IConstantExpression
      _COLON *AstToken
}
func (my *SwitchLabel0)      Getcase() *AstToken{ return my._case}
func (my *SwitchLabel0)      Setcase( _case *AstToken)  { my._case = _case }
func (my *SwitchLabel0)      GetConstantExpression() IConstantExpression{ return my._ConstantExpression}
func (my *SwitchLabel0)      SetConstantExpression( _ConstantExpression IConstantExpression)  { my._ConstantExpression = _ConstantExpression }
func (my *SwitchLabel0)      GetCOLON() *AstToken{ return my._COLON}
func (my *SwitchLabel0)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }

func NewSwitchLabel0(leftIToken IToken, rightIToken IToken ,
              _case *AstToken,
              _ConstantExpression IConstantExpression,
              _COLON *AstToken)*SwitchLabel0{
      my := new(SwitchLabel0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._case = _case;
        if nil != _case{
        var trait_ interface{} = _case
         trait_.(IAst).SetParent(my)
}
        my._ConstantExpression = _ConstantExpression;
        if nil != _ConstantExpression{
        var trait_ interface{} = _ConstantExpression
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchLabel0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._case{  list.Add(my._case) }
        if nil != my._ConstantExpression{  list.Add(my._ConstantExpression) }
        if nil != my._COLON{  list.Add(my._COLON) }
        return list
    }

func (my *SwitchLabel0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SwitchLabel0)       Enter(v Visitor){
        var checkChildren = v.VisitSwitchLabel0(my)
        if checkChildren{
            if nil != my._case{my._case.Accept(v)}
            if nil != my._ConstantExpression{my._ConstantExpression.Accept(v)}
            if nil != my._COLON{my._COLON.Accept(v)}
        }
        v.EndVisitSwitchLabel0(my)
    }


func AnyCastToSwitchLabel0(i interface{}) *SwitchLabel0 {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchLabel0)
	}
}
/**
 *<b>
*<li>Rule 305:  SwitchLabel ::= case EnumConstant :
 *</b>
 */
type SwitchLabel1 struct{
    *Ast
      _case *AstToken
      _EnumConstant IEnumConstant
      _COLON *AstToken
}
func (my *SwitchLabel1)      Getcase() *AstToken{ return my._case}
func (my *SwitchLabel1)      Setcase( _case *AstToken)  { my._case = _case }
func (my *SwitchLabel1)      GetEnumConstant() IEnumConstant{ return my._EnumConstant}
func (my *SwitchLabel1)      SetEnumConstant( _EnumConstant IEnumConstant)  { my._EnumConstant = _EnumConstant }
func (my *SwitchLabel1)      GetCOLON() *AstToken{ return my._COLON}
func (my *SwitchLabel1)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }

func NewSwitchLabel1(leftIToken IToken, rightIToken IToken ,
              _case *AstToken,
              _EnumConstant IEnumConstant,
              _COLON *AstToken)*SwitchLabel1{
      my := new(SwitchLabel1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._case = _case;
        if nil != _case{
        var trait_ interface{} = _case
         trait_.(IAst).SetParent(my)
}
        my._EnumConstant = _EnumConstant;
        if nil != _EnumConstant{
        var trait_ interface{} = _EnumConstant
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchLabel1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._case{  list.Add(my._case) }
        if nil != my._EnumConstant{  list.Add(my._EnumConstant) }
        if nil != my._COLON{  list.Add(my._COLON) }
        return list
    }

func (my *SwitchLabel1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SwitchLabel1)       Enter(v Visitor){
        var checkChildren = v.VisitSwitchLabel1(my)
        if checkChildren{
            if nil != my._case{my._case.Accept(v)}
            if nil != my._EnumConstant{my._EnumConstant.Accept(v)}
            if nil != my._COLON{my._COLON.Accept(v)}
        }
        v.EndVisitSwitchLabel1(my)
    }


func AnyCastToSwitchLabel1(i interface{}) *SwitchLabel1 {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchLabel1)
	}
}
/**
 *<b>
*<li>Rule 306:  SwitchLabel ::= default :
 *</b>
 */
type SwitchLabel2 struct{
    *Ast
      _default *AstToken
      _COLON *AstToken
}
func (my *SwitchLabel2)      Getdefault() *AstToken{ return my._default}
func (my *SwitchLabel2)      Setdefault( _default *AstToken)  { my._default = _default }
func (my *SwitchLabel2)      GetCOLON() *AstToken{ return my._COLON}
func (my *SwitchLabel2)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }

func NewSwitchLabel2(leftIToken IToken, rightIToken IToken ,
              _default *AstToken,
              _COLON *AstToken)*SwitchLabel2{
      my := new(SwitchLabel2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._default = _default;
        if nil != _default{
        var trait_ interface{} = _default
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchLabel2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._default{  list.Add(my._default) }
        if nil != my._COLON{  list.Add(my._COLON) }
        return list
    }

func (my *SwitchLabel2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *SwitchLabel2)       Enter(v Visitor){
        var checkChildren = v.VisitSwitchLabel2(my)
        if checkChildren{
            if nil != my._default{my._default.Accept(v)}
            if nil != my._COLON{my._COLON.Accept(v)}
        }
        v.EndVisitSwitchLabel2(my)
    }


func AnyCastToSwitchLabel2(i interface{}) *SwitchLabel2 {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchLabel2)
	}
}
/**
 *<b>
*<li>Rule 326:  TryStatement ::= try Block Catches
 *</b>
 */
type TryStatement0 struct{
    *Ast
      _try *AstToken
      _Block *Block
      _Catches ICatches
}
func (my *TryStatement0)      Gettry() *AstToken{ return my._try}
func (my *TryStatement0)      Settry( _try *AstToken)  { my._try = _try }
func (my *TryStatement0)      GetBlock() *Block{ return my._Block}
func (my *TryStatement0)      SetBlock( _Block *Block)  { my._Block = _Block }
func (my *TryStatement0)      GetCatches() ICatches{ return my._Catches}
func (my *TryStatement0)      SetCatches( _Catches ICatches)  { my._Catches = _Catches }

func NewTryStatement0(leftIToken IToken, rightIToken IToken ,
              _try *AstToken,
              _Block *Block,
              _Catches ICatches)*TryStatement0{
      my := new(TryStatement0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._try = _try;
        if nil != _try{
        var trait_ interface{} = _try
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my._Catches = _Catches;
        if nil != _Catches{
        var trait_ interface{} = _Catches
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TryStatement0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._try{  list.Add(my._try) }
        if nil != my._Block{  list.Add(my._Block) }
        if nil != my._Catches{  list.Add(my._Catches) }
        return list
    }

func (my *TryStatement0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TryStatement0)       Enter(v Visitor){
        var checkChildren = v.VisitTryStatement0(my)
        if checkChildren{
            if nil != my._try{my._try.Accept(v)}
            if nil != my._Block{my._Block.Accept(v)}
            if nil != my._Catches{my._Catches.Accept(v)}
        }
        v.EndVisitTryStatement0(my)
    }


func AnyCastToTryStatement0(i interface{}) *TryStatement0 {
	if nil == i{
		return nil
	}else{
		return i.(*TryStatement0)
	}
}
/**
 *<b>
*<li>Rule 327:  TryStatement ::= try Block Catchesopt Finally
 *</b>
 */
type TryStatement1 struct{
    *Ast
      _try *AstToken
      _Block *Block
      _Catchesopt ICatchesopt
      _Finally *Finally
}
func (my *TryStatement1)      Gettry() *AstToken{ return my._try}
func (my *TryStatement1)      Settry( _try *AstToken)  { my._try = _try }
func (my *TryStatement1)      GetBlock() *Block{ return my._Block}
func (my *TryStatement1)      SetBlock( _Block *Block)  { my._Block = _Block }
    /**
     * The value returned by <b>GetCatchesopt</b> may be <b>null</b>
     */
func (my *TryStatement1)      GetCatchesopt() ICatchesopt{ return my._Catchesopt}
func (my *TryStatement1)      SetCatchesopt( _Catchesopt ICatchesopt)  { my._Catchesopt = _Catchesopt }
func (my *TryStatement1)      GetFinally() *Finally{ return my._Finally}
func (my *TryStatement1)      SetFinally( _Finally *Finally)  { my._Finally = _Finally }

func NewTryStatement1(leftIToken IToken, rightIToken IToken ,
              _try *AstToken,
              _Block *Block,
              _Catchesopt ICatchesopt,
              _Finally *Finally)*TryStatement1{
      my := new(TryStatement1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._try = _try;
        if nil != _try{
        var trait_ interface{} = _try
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my._Catchesopt = _Catchesopt;
        if nil != _Catchesopt{
        var trait_ interface{} = _Catchesopt
         trait_.(IAst).SetParent(my)
}
        my._Finally = _Finally;
        if nil != _Finally{
        var trait_ interface{} = _Finally
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TryStatement1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._try{  list.Add(my._try) }
        if nil != my._Block{  list.Add(my._Block) }
        if nil != my._Catchesopt{  list.Add(my._Catchesopt) }
        if nil != my._Finally{  list.Add(my._Finally) }
        return list
    }

func (my *TryStatement1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *TryStatement1)       Enter(v Visitor){
        var checkChildren = v.VisitTryStatement1(my)
        if checkChildren{
            if nil != my._try{my._try.Accept(v)}
            if nil != my._Block{my._Block.Accept(v)}
            if nil != my._Catchesopt{my._Catchesopt.Accept(v)}
            if nil != my._Finally{my._Finally.Accept(v)}
        }
        v.EndVisitTryStatement1(my)
    }


func AnyCastToTryStatement1(i interface{}) *TryStatement1 {
	if nil == i{
		return nil
	}else{
		return i.(*TryStatement1)
	}
}
/**
 *<b>
*<li>Rule 335:  PrimaryNoNewArray ::= Type . class
 *</b>
 */
type PrimaryNoNewArray0 struct{
    *Ast
      _Type IType
      _DOT *AstToken
      _class *AstToken
}
func (my *PrimaryNoNewArray0)      GetType() IType{ return my._Type}
func (my *PrimaryNoNewArray0)      SetType( _Type IType)  { my._Type = _Type }
func (my *PrimaryNoNewArray0)      GetDOT() *AstToken{ return my._DOT}
func (my *PrimaryNoNewArray0)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PrimaryNoNewArray0)      Getclass() *AstToken{ return my._class}
func (my *PrimaryNoNewArray0)      Setclass( _class *AstToken)  { my._class = _class }

func NewPrimaryNoNewArray0(leftIToken IToken, rightIToken IToken ,
              _Type IType,
              _DOT *AstToken,
              _class *AstToken)*PrimaryNoNewArray0{
      my := new(PrimaryNoNewArray0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._class = _class;
        if nil != _class{
        var trait_ interface{} = _class
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PrimaryNoNewArray0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._class{  list.Add(my._class) }
        return list
    }

func (my *PrimaryNoNewArray0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PrimaryNoNewArray0)       Enter(v Visitor){
        var checkChildren = v.VisitPrimaryNoNewArray0(my)
        if checkChildren{
            if nil != my._Type{my._Type.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._class{my._class.Accept(v)}
        }
        v.EndVisitPrimaryNoNewArray0(my)
    }


func AnyCastToPrimaryNoNewArray0(i interface{}) *PrimaryNoNewArray0 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray0)
	}
}
/**
 *<b>
*<li>Rule 336:  PrimaryNoNewArray ::= void . class
 *</b>
 */
type PrimaryNoNewArray1 struct{
    *Ast
      _void *AstToken
      _DOT *AstToken
      _class *AstToken
}
func (my *PrimaryNoNewArray1)      Getvoid() *AstToken{ return my._void}
func (my *PrimaryNoNewArray1)      Setvoid( _void *AstToken)  { my._void = _void }
func (my *PrimaryNoNewArray1)      GetDOT() *AstToken{ return my._DOT}
func (my *PrimaryNoNewArray1)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PrimaryNoNewArray1)      Getclass() *AstToken{ return my._class}
func (my *PrimaryNoNewArray1)      Setclass( _class *AstToken)  { my._class = _class }

func NewPrimaryNoNewArray1(leftIToken IToken, rightIToken IToken ,
              _void *AstToken,
              _DOT *AstToken,
              _class *AstToken)*PrimaryNoNewArray1{
      my := new(PrimaryNoNewArray1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._void = _void;
        if nil != _void{
        var trait_ interface{} = _void
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._class = _class;
        if nil != _class{
        var trait_ interface{} = _class
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PrimaryNoNewArray1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._void{  list.Add(my._void) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._class{  list.Add(my._class) }
        return list
    }

func (my *PrimaryNoNewArray1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PrimaryNoNewArray1)       Enter(v Visitor){
        var checkChildren = v.VisitPrimaryNoNewArray1(my)
        if checkChildren{
            if nil != my._void{my._void.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._class{my._class.Accept(v)}
        }
        v.EndVisitPrimaryNoNewArray1(my)
    }


func AnyCastToPrimaryNoNewArray1(i interface{}) *PrimaryNoNewArray1 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray1)
	}
}
/**
 *<b>
*<li>Rule 337:  PrimaryNoNewArray ::= this
 *</b>
 */
type PrimaryNoNewArray2 struct{
    *AstToken
}
func (my *PrimaryNoNewArray2)      Getthis()IToken{ return my.leftIToken; }

func NewPrimaryNoNewArray2(token IToken )*PrimaryNoNewArray2{
      my := new(PrimaryNoNewArray2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *PrimaryNoNewArray2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PrimaryNoNewArray2)       Enter(v Visitor){
        v.VisitPrimaryNoNewArray2(my)
        v.EndVisitPrimaryNoNewArray2(my)
    }


func AnyCastToPrimaryNoNewArray2(i interface{}) *PrimaryNoNewArray2 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray2)
	}
}
/**
 *<b>
*<li>Rule 338:  PrimaryNoNewArray ::= ClassName . this
 *</b>
 */
type PrimaryNoNewArray3 struct{
    *Ast
      _ClassName IClassName
      _DOT *AstToken
      _this *AstToken
}
func (my *PrimaryNoNewArray3)      GetClassName() IClassName{ return my._ClassName}
func (my *PrimaryNoNewArray3)      SetClassName( _ClassName IClassName)  { my._ClassName = _ClassName }
func (my *PrimaryNoNewArray3)      GetDOT() *AstToken{ return my._DOT}
func (my *PrimaryNoNewArray3)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PrimaryNoNewArray3)      Getthis() *AstToken{ return my._this}
func (my *PrimaryNoNewArray3)      Setthis( _this *AstToken)  { my._this = _this }

func NewPrimaryNoNewArray3(leftIToken IToken, rightIToken IToken ,
              _ClassName IClassName,
              _DOT *AstToken,
              _this *AstToken)*PrimaryNoNewArray3{
      my := new(PrimaryNoNewArray3)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassName = _ClassName;
        if nil != _ClassName{
        var trait_ interface{} = _ClassName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._this = _this;
        if nil != _this{
        var trait_ interface{} = _this
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PrimaryNoNewArray3)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassName{  list.Add(my._ClassName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._this{  list.Add(my._this) }
        return list
    }

func (my *PrimaryNoNewArray3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PrimaryNoNewArray3)       Enter(v Visitor){
        var checkChildren = v.VisitPrimaryNoNewArray3(my)
        if checkChildren{
            if nil != my._ClassName{my._ClassName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._this{my._this.Accept(v)}
        }
        v.EndVisitPrimaryNoNewArray3(my)
    }


func AnyCastToPrimaryNoNewArray3(i interface{}) *PrimaryNoNewArray3 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray3)
	}
}
/**
 *<b>
*<li>Rule 339:  PrimaryNoNewArray ::= ( Expression )
 *</b>
 */
type PrimaryNoNewArray4 struct{
    *Ast
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
}
func (my *PrimaryNoNewArray4)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *PrimaryNoNewArray4)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *PrimaryNoNewArray4)      GetExpression() IExpression{ return my._Expression}
func (my *PrimaryNoNewArray4)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *PrimaryNoNewArray4)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *PrimaryNoNewArray4)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewPrimaryNoNewArray4(leftIToken IToken, rightIToken IToken ,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken)*PrimaryNoNewArray4{
      my := new(PrimaryNoNewArray4)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PrimaryNoNewArray4)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *PrimaryNoNewArray4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *PrimaryNoNewArray4)       Enter(v Visitor){
        var checkChildren = v.VisitPrimaryNoNewArray4(my)
        if checkChildren{
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitPrimaryNoNewArray4(my)
    }


func AnyCastToPrimaryNoNewArray4(i interface{}) *PrimaryNoNewArray4 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray4)
	}
}
/**
 *<b>
*<li>Rule 344:  Literal ::= IntegerLiteral
 *</b>
 */
type Literal0 struct{
    *AstToken
}
func (my *Literal0)      GetIntegerLiteral()IToken{ return my.leftIToken; }

func NewLiteral0(token IToken )*Literal0{
      my := new(Literal0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Literal0)       Enter(v Visitor){
        v.VisitLiteral0(my)
        v.EndVisitLiteral0(my)
    }


func AnyCastToLiteral0(i interface{}) *Literal0 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal0)
	}
}
/**
 *<b>
*<li>Rule 345:  Literal ::= LongLiteral
 *</b>
 */
type Literal1 struct{
    *AstToken
}
func (my *Literal1)      GetLongLiteral()IToken{ return my.leftIToken; }

func NewLiteral1(token IToken )*Literal1{
      my := new(Literal1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Literal1)       Enter(v Visitor){
        v.VisitLiteral1(my)
        v.EndVisitLiteral1(my)
    }


func AnyCastToLiteral1(i interface{}) *Literal1 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal1)
	}
}
/**
 *<b>
*<li>Rule 346:  Literal ::= FloatingPointLiteral
 *</b>
 */
type Literal2 struct{
    *AstToken
}
func (my *Literal2)      GetFloatingPointLiteral()IToken{ return my.leftIToken; }

func NewLiteral2(token IToken )*Literal2{
      my := new(Literal2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Literal2)       Enter(v Visitor){
        v.VisitLiteral2(my)
        v.EndVisitLiteral2(my)
    }


func AnyCastToLiteral2(i interface{}) *Literal2 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal2)
	}
}
/**
 *<b>
*<li>Rule 347:  Literal ::= DoubleLiteral
 *</b>
 */
type Literal3 struct{
    *AstToken
}
func (my *Literal3)      GetDoubleLiteral()IToken{ return my.leftIToken; }

func NewLiteral3(token IToken )*Literal3{
      my := new(Literal3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Literal3)       Enter(v Visitor){
        v.VisitLiteral3(my)
        v.EndVisitLiteral3(my)
    }


func AnyCastToLiteral3(i interface{}) *Literal3 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal3)
	}
}
/**
 *<b>
*<li>Rule 349:  Literal ::= CharacterLiteral
 *</b>
 */
type Literal4 struct{
    *AstToken
}
func (my *Literal4)      GetCharacterLiteral()IToken{ return my.leftIToken; }

func NewLiteral4(token IToken )*Literal4{
      my := new(Literal4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Literal4)       Enter(v Visitor){
        v.VisitLiteral4(my)
        v.EndVisitLiteral4(my)
    }


func AnyCastToLiteral4(i interface{}) *Literal4 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal4)
	}
}
/**
 *<b>
*<li>Rule 350:  Literal ::= StringLiteral
 *</b>
 */
type Literal5 struct{
    *AstToken
}
func (my *Literal5)      GetStringLiteral()IToken{ return my.leftIToken; }

func NewLiteral5(token IToken )*Literal5{
      my := new(Literal5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal5)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Literal5)       Enter(v Visitor){
        v.VisitLiteral5(my)
        v.EndVisitLiteral5(my)
    }


func AnyCastToLiteral5(i interface{}) *Literal5 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal5)
	}
}
/**
 *<b>
*<li>Rule 351:  Literal ::= null
 *</b>
 */
type Literal6 struct{
    *AstToken
}
func (my *Literal6)      Getnull()IToken{ return my.leftIToken; }

func NewLiteral6(token IToken )*Literal6{
      my := new(Literal6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal6)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Literal6)       Enter(v Visitor){
        v.VisitLiteral6(my)
        v.EndVisitLiteral6(my)
    }


func AnyCastToLiteral6(i interface{}) *Literal6 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal6)
	}
}
/**
 *<b>
*<li>Rule 352:  BooleanLiteral ::= true
 *</b>
 */
type BooleanLiteral0 struct{
    *AstToken
}
func (my *BooleanLiteral0)      Gettrue()IToken{ return my.leftIToken; }

func NewBooleanLiteral0(token IToken )*BooleanLiteral0{
      my := new(BooleanLiteral0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *BooleanLiteral0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *BooleanLiteral0)       Enter(v Visitor){
        v.VisitBooleanLiteral0(my)
        v.EndVisitBooleanLiteral0(my)
    }


func AnyCastToBooleanLiteral0(i interface{}) *BooleanLiteral0 {
	if nil == i{
		return nil
	}else{
		return i.(*BooleanLiteral0)
	}
}
/**
 *<b>
*<li>Rule 353:  BooleanLiteral ::= false
 *</b>
 */
type BooleanLiteral1 struct{
    *AstToken
}
func (my *BooleanLiteral1)      Getfalse()IToken{ return my.leftIToken; }

func NewBooleanLiteral1(token IToken )*BooleanLiteral1{
      my := new(BooleanLiteral1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *BooleanLiteral1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *BooleanLiteral1)       Enter(v Visitor){
        v.VisitBooleanLiteral1(my)
        v.EndVisitBooleanLiteral1(my)
    }


func AnyCastToBooleanLiteral1(i interface{}) *BooleanLiteral1 {
	if nil == i{
		return nil
	}else{
		return i.(*BooleanLiteral1)
	}
}
/**
 *<b>
*<li>Rule 354:  ClassInstanceCreationExpression ::= new TypeArgumentsopt ClassOrInterfaceType TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
 *</b>
 */
type ClassInstanceCreationExpression0 struct{
    *Ast
      _new *AstToken
      _TypeArgumentsopt *TypeArguments
      _ClassOrInterfaceType *ClassType
      _TypeArgumentsopt4 *TypeArguments
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _ClassBodyopt *ClassBody
}
func (my *ClassInstanceCreationExpression0)      Getnew() *AstToken{ return my._new}
func (my *ClassInstanceCreationExpression0)      Setnew( _new *AstToken)  { my._new = _new }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression0)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ClassInstanceCreationExpression0)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ClassInstanceCreationExpression0)      GetClassOrInterfaceType() *ClassType{ return my._ClassOrInterfaceType}
func (my *ClassInstanceCreationExpression0)      SetClassOrInterfaceType( _ClassOrInterfaceType *ClassType)  { my._ClassOrInterfaceType = _ClassOrInterfaceType }
    /**
     * The value returned by <b>GetTypeArgumentsopt4</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression0)      GetTypeArgumentsopt4() *TypeArguments{ return my._TypeArgumentsopt4}
func (my *ClassInstanceCreationExpression0)      SetTypeArgumentsopt4( _TypeArgumentsopt4 *TypeArguments)  { my._TypeArgumentsopt4 = _TypeArgumentsopt4 }
func (my *ClassInstanceCreationExpression0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ClassInstanceCreationExpression0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression0)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ClassInstanceCreationExpression0)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ClassInstanceCreationExpression0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ClassInstanceCreationExpression0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
    /**
     * The value returned by <b>GetClassBodyopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression0)      GetClassBodyopt() *ClassBody{ return my._ClassBodyopt}
func (my *ClassInstanceCreationExpression0)      SetClassBodyopt( _ClassBodyopt *ClassBody)  { my._ClassBodyopt = _ClassBodyopt }

func NewClassInstanceCreationExpression0(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _ClassOrInterfaceType *ClassType,
              _TypeArgumentsopt4 *TypeArguments,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _ClassBodyopt *ClassBody)*ClassInstanceCreationExpression0{
      my := new(ClassInstanceCreationExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._ClassOrInterfaceType = _ClassOrInterfaceType;
        if nil != _ClassOrInterfaceType{
        var trait_ interface{} = _ClassOrInterfaceType
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt4 = _TypeArgumentsopt4;
        if nil != _TypeArgumentsopt4{
        var trait_ interface{} = _TypeArgumentsopt4
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyopt = _ClassBodyopt;
        if nil != _ClassBodyopt{
        var trait_ interface{} = _ClassBodyopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassInstanceCreationExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._ClassOrInterfaceType{  list.Add(my._ClassOrInterfaceType) }
        if nil != my._TypeArgumentsopt4{  list.Add(my._TypeArgumentsopt4) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._ClassBodyopt{  list.Add(my._ClassBodyopt) }
        return list
    }

func (my *ClassInstanceCreationExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassInstanceCreationExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitClassInstanceCreationExpression0(my)
        if checkChildren{
            if nil != my._new{my._new.Accept(v)}
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
            if nil != my._ClassOrInterfaceType{my._ClassOrInterfaceType.Accept(v)}
            if nil != my._TypeArgumentsopt4{my._TypeArgumentsopt4.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._ClassBodyopt{my._ClassBodyopt.Accept(v)}
        }
        v.EndVisitClassInstanceCreationExpression0(my)
    }


func AnyCastToClassInstanceCreationExpression0(i interface{}) *ClassInstanceCreationExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassInstanceCreationExpression0)
	}
}
/**
 *<b>
*<li>Rule 355:  ClassInstanceCreationExpression ::= Primary . new TypeArgumentsopt identifier TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
 *</b>
 */
type ClassInstanceCreationExpression1 struct{
    *Ast
      _Primary IPrimary
      _DOT *AstToken
      _new *AstToken
      _TypeArgumentsopt *TypeArguments
      _identifier *identifier
      _TypeArgumentsopt6 *TypeArguments
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _ClassBodyopt *ClassBody
}
func (my *ClassInstanceCreationExpression1)      GetPrimary() IPrimary{ return my._Primary}
func (my *ClassInstanceCreationExpression1)      SetPrimary( _Primary IPrimary)  { my._Primary = _Primary }
func (my *ClassInstanceCreationExpression1)      GetDOT() *AstToken{ return my._DOT}
func (my *ClassInstanceCreationExpression1)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *ClassInstanceCreationExpression1)      Getnew() *AstToken{ return my._new}
func (my *ClassInstanceCreationExpression1)      Setnew( _new *AstToken)  { my._new = _new }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression1)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ClassInstanceCreationExpression1)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ClassInstanceCreationExpression1)      Getidentifier() *identifier{ return my._identifier}
func (my *ClassInstanceCreationExpression1)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetTypeArgumentsopt6</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression1)      GetTypeArgumentsopt6() *TypeArguments{ return my._TypeArgumentsopt6}
func (my *ClassInstanceCreationExpression1)      SetTypeArgumentsopt6( _TypeArgumentsopt6 *TypeArguments)  { my._TypeArgumentsopt6 = _TypeArgumentsopt6 }
func (my *ClassInstanceCreationExpression1)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ClassInstanceCreationExpression1)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression1)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ClassInstanceCreationExpression1)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ClassInstanceCreationExpression1)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ClassInstanceCreationExpression1)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
    /**
     * The value returned by <b>GetClassBodyopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression1)      GetClassBodyopt() *ClassBody{ return my._ClassBodyopt}
func (my *ClassInstanceCreationExpression1)      SetClassBodyopt( _ClassBodyopt *ClassBody)  { my._ClassBodyopt = _ClassBodyopt }

func NewClassInstanceCreationExpression1(leftIToken IToken, rightIToken IToken ,
              _Primary IPrimary,
              _DOT *AstToken,
              _new *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _identifier *identifier,
              _TypeArgumentsopt6 *TypeArguments,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _ClassBodyopt *ClassBody)*ClassInstanceCreationExpression1{
      my := new(ClassInstanceCreationExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Primary = _Primary;
        if nil != _Primary{
        var trait_ interface{} = _Primary
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt6 = _TypeArgumentsopt6;
        if nil != _TypeArgumentsopt6{
        var trait_ interface{} = _TypeArgumentsopt6
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyopt = _ClassBodyopt;
        if nil != _ClassBodyopt{
        var trait_ interface{} = _ClassBodyopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassInstanceCreationExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Primary{  list.Add(my._Primary) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._new{  list.Add(my._new) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._TypeArgumentsopt6{  list.Add(my._TypeArgumentsopt6) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._ClassBodyopt{  list.Add(my._ClassBodyopt) }
        return list
    }

func (my *ClassInstanceCreationExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ClassInstanceCreationExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitClassInstanceCreationExpression1(my)
        if checkChildren{
            if nil != my._Primary{my._Primary.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._new{my._new.Accept(v)}
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._TypeArgumentsopt6{my._TypeArgumentsopt6.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._ClassBodyopt{my._ClassBodyopt.Accept(v)}
        }
        v.EndVisitClassInstanceCreationExpression1(my)
    }


func AnyCastToClassInstanceCreationExpression1(i interface{}) *ClassInstanceCreationExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassInstanceCreationExpression1)
	}
}
/**
 *<b>
*<li>Rule 358:  ArrayCreationExpression ::= new PrimitiveType DimExprs Dimsopt
 *</b>
 */
type ArrayCreationExpression0 struct{
    *Ast
      _new *AstToken
      _PrimitiveType IPrimitiveType
      _DimExprs IDimExprs
      _Dimsopt IDimsopt
}
func (my *ArrayCreationExpression0)      Getnew() *AstToken{ return my._new}
func (my *ArrayCreationExpression0)      Setnew( _new *AstToken)  { my._new = _new }
func (my *ArrayCreationExpression0)      GetPrimitiveType() IPrimitiveType{ return my._PrimitiveType}
func (my *ArrayCreationExpression0)      SetPrimitiveType( _PrimitiveType IPrimitiveType)  { my._PrimitiveType = _PrimitiveType }
func (my *ArrayCreationExpression0)      GetDimExprs() IDimExprs{ return my._DimExprs}
func (my *ArrayCreationExpression0)      SetDimExprs( _DimExprs IDimExprs)  { my._DimExprs = _DimExprs }
    /**
     * The value returned by <b>GetDimsopt</b> may be <b>null</b>
     */
func (my *ArrayCreationExpression0)      GetDimsopt() IDimsopt{ return my._Dimsopt}
func (my *ArrayCreationExpression0)      SetDimsopt( _Dimsopt IDimsopt)  { my._Dimsopt = _Dimsopt }

func NewArrayCreationExpression0(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _PrimitiveType IPrimitiveType,
              _DimExprs IDimExprs,
              _Dimsopt IDimsopt)*ArrayCreationExpression0{
      my := new(ArrayCreationExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._PrimitiveType = _PrimitiveType;
        if nil != _PrimitiveType{
        var trait_ interface{} = _PrimitiveType
         trait_.(IAst).SetParent(my)
}
        my._DimExprs = _DimExprs;
        if nil != _DimExprs{
        var trait_ interface{} = _DimExprs
         trait_.(IAst).SetParent(my)
}
        my._Dimsopt = _Dimsopt;
        if nil != _Dimsopt{
        var trait_ interface{} = _Dimsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayCreationExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._PrimitiveType{  list.Add(my._PrimitiveType) }
        if nil != my._DimExprs{  list.Add(my._DimExprs) }
        if nil != my._Dimsopt{  list.Add(my._Dimsopt) }
        return list
    }

func (my *ArrayCreationExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArrayCreationExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitArrayCreationExpression0(my)
        if checkChildren{
            if nil != my._new{my._new.Accept(v)}
            if nil != my._PrimitiveType{my._PrimitiveType.Accept(v)}
            if nil != my._DimExprs{my._DimExprs.Accept(v)}
            if nil != my._Dimsopt{my._Dimsopt.Accept(v)}
        }
        v.EndVisitArrayCreationExpression0(my)
    }


func AnyCastToArrayCreationExpression0(i interface{}) *ArrayCreationExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayCreationExpression0)
	}
}
/**
 *<b>
*<li>Rule 359:  ArrayCreationExpression ::= new ClassOrInterfaceType DimExprs Dimsopt
 *</b>
 */
type ArrayCreationExpression1 struct{
    *Ast
      _new *AstToken
      _ClassOrInterfaceType *ClassType
      _DimExprs IDimExprs
      _Dimsopt IDimsopt
}
func (my *ArrayCreationExpression1)      Getnew() *AstToken{ return my._new}
func (my *ArrayCreationExpression1)      Setnew( _new *AstToken)  { my._new = _new }
func (my *ArrayCreationExpression1)      GetClassOrInterfaceType() *ClassType{ return my._ClassOrInterfaceType}
func (my *ArrayCreationExpression1)      SetClassOrInterfaceType( _ClassOrInterfaceType *ClassType)  { my._ClassOrInterfaceType = _ClassOrInterfaceType }
func (my *ArrayCreationExpression1)      GetDimExprs() IDimExprs{ return my._DimExprs}
func (my *ArrayCreationExpression1)      SetDimExprs( _DimExprs IDimExprs)  { my._DimExprs = _DimExprs }
    /**
     * The value returned by <b>GetDimsopt</b> may be <b>null</b>
     */
func (my *ArrayCreationExpression1)      GetDimsopt() IDimsopt{ return my._Dimsopt}
func (my *ArrayCreationExpression1)      SetDimsopt( _Dimsopt IDimsopt)  { my._Dimsopt = _Dimsopt }

func NewArrayCreationExpression1(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _ClassOrInterfaceType *ClassType,
              _DimExprs IDimExprs,
              _Dimsopt IDimsopt)*ArrayCreationExpression1{
      my := new(ArrayCreationExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._ClassOrInterfaceType = _ClassOrInterfaceType;
        if nil != _ClassOrInterfaceType{
        var trait_ interface{} = _ClassOrInterfaceType
         trait_.(IAst).SetParent(my)
}
        my._DimExprs = _DimExprs;
        if nil != _DimExprs{
        var trait_ interface{} = _DimExprs
         trait_.(IAst).SetParent(my)
}
        my._Dimsopt = _Dimsopt;
        if nil != _Dimsopt{
        var trait_ interface{} = _Dimsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayCreationExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._ClassOrInterfaceType{  list.Add(my._ClassOrInterfaceType) }
        if nil != my._DimExprs{  list.Add(my._DimExprs) }
        if nil != my._Dimsopt{  list.Add(my._Dimsopt) }
        return list
    }

func (my *ArrayCreationExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArrayCreationExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitArrayCreationExpression1(my)
        if checkChildren{
            if nil != my._new{my._new.Accept(v)}
            if nil != my._ClassOrInterfaceType{my._ClassOrInterfaceType.Accept(v)}
            if nil != my._DimExprs{my._DimExprs.Accept(v)}
            if nil != my._Dimsopt{my._Dimsopt.Accept(v)}
        }
        v.EndVisitArrayCreationExpression1(my)
    }


func AnyCastToArrayCreationExpression1(i interface{}) *ArrayCreationExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayCreationExpression1)
	}
}
/**
 *<b>
*<li>Rule 360:  ArrayCreationExpression ::= new PrimitiveType Dims ArrayInitializer
 *</b>
 */
type ArrayCreationExpression2 struct{
    *Ast
      _new *AstToken
      _PrimitiveType IPrimitiveType
      _Dims IDims
      _ArrayInitializer *ArrayInitializer
}
func (my *ArrayCreationExpression2)      Getnew() *AstToken{ return my._new}
func (my *ArrayCreationExpression2)      Setnew( _new *AstToken)  { my._new = _new }
func (my *ArrayCreationExpression2)      GetPrimitiveType() IPrimitiveType{ return my._PrimitiveType}
func (my *ArrayCreationExpression2)      SetPrimitiveType( _PrimitiveType IPrimitiveType)  { my._PrimitiveType = _PrimitiveType }
func (my *ArrayCreationExpression2)      GetDims() IDims{ return my._Dims}
func (my *ArrayCreationExpression2)      SetDims( _Dims IDims)  { my._Dims = _Dims }
func (my *ArrayCreationExpression2)      GetArrayInitializer() *ArrayInitializer{ return my._ArrayInitializer}
func (my *ArrayCreationExpression2)      SetArrayInitializer( _ArrayInitializer *ArrayInitializer)  { my._ArrayInitializer = _ArrayInitializer }

func NewArrayCreationExpression2(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _PrimitiveType IPrimitiveType,
              _Dims IDims,
              _ArrayInitializer *ArrayInitializer)*ArrayCreationExpression2{
      my := new(ArrayCreationExpression2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._PrimitiveType = _PrimitiveType;
        if nil != _PrimitiveType{
        var trait_ interface{} = _PrimitiveType
         trait_.(IAst).SetParent(my)
}
        my._Dims = _Dims;
        if nil != _Dims{
        var trait_ interface{} = _Dims
         trait_.(IAst).SetParent(my)
}
        my._ArrayInitializer = _ArrayInitializer;
        if nil != _ArrayInitializer{
        var trait_ interface{} = _ArrayInitializer
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayCreationExpression2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._PrimitiveType{  list.Add(my._PrimitiveType) }
        if nil != my._Dims{  list.Add(my._Dims) }
        if nil != my._ArrayInitializer{  list.Add(my._ArrayInitializer) }
        return list
    }

func (my *ArrayCreationExpression2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArrayCreationExpression2)       Enter(v Visitor){
        var checkChildren = v.VisitArrayCreationExpression2(my)
        if checkChildren{
            if nil != my._new{my._new.Accept(v)}
            if nil != my._PrimitiveType{my._PrimitiveType.Accept(v)}
            if nil != my._Dims{my._Dims.Accept(v)}
            if nil != my._ArrayInitializer{my._ArrayInitializer.Accept(v)}
        }
        v.EndVisitArrayCreationExpression2(my)
    }


func AnyCastToArrayCreationExpression2(i interface{}) *ArrayCreationExpression2 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayCreationExpression2)
	}
}
/**
 *<b>
*<li>Rule 361:  ArrayCreationExpression ::= new ClassOrInterfaceType Dims ArrayInitializer
 *</b>
 */
type ArrayCreationExpression3 struct{
    *Ast
      _new *AstToken
      _ClassOrInterfaceType *ClassType
      _Dims IDims
      _ArrayInitializer *ArrayInitializer
}
func (my *ArrayCreationExpression3)      Getnew() *AstToken{ return my._new}
func (my *ArrayCreationExpression3)      Setnew( _new *AstToken)  { my._new = _new }
func (my *ArrayCreationExpression3)      GetClassOrInterfaceType() *ClassType{ return my._ClassOrInterfaceType}
func (my *ArrayCreationExpression3)      SetClassOrInterfaceType( _ClassOrInterfaceType *ClassType)  { my._ClassOrInterfaceType = _ClassOrInterfaceType }
func (my *ArrayCreationExpression3)      GetDims() IDims{ return my._Dims}
func (my *ArrayCreationExpression3)      SetDims( _Dims IDims)  { my._Dims = _Dims }
func (my *ArrayCreationExpression3)      GetArrayInitializer() *ArrayInitializer{ return my._ArrayInitializer}
func (my *ArrayCreationExpression3)      SetArrayInitializer( _ArrayInitializer *ArrayInitializer)  { my._ArrayInitializer = _ArrayInitializer }

func NewArrayCreationExpression3(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _ClassOrInterfaceType *ClassType,
              _Dims IDims,
              _ArrayInitializer *ArrayInitializer)*ArrayCreationExpression3{
      my := new(ArrayCreationExpression3)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._ClassOrInterfaceType = _ClassOrInterfaceType;
        if nil != _ClassOrInterfaceType{
        var trait_ interface{} = _ClassOrInterfaceType
         trait_.(IAst).SetParent(my)
}
        my._Dims = _Dims;
        if nil != _Dims{
        var trait_ interface{} = _Dims
         trait_.(IAst).SetParent(my)
}
        my._ArrayInitializer = _ArrayInitializer;
        if nil != _ArrayInitializer{
        var trait_ interface{} = _ArrayInitializer
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayCreationExpression3)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._ClassOrInterfaceType{  list.Add(my._ClassOrInterfaceType) }
        if nil != my._Dims{  list.Add(my._Dims) }
        if nil != my._ArrayInitializer{  list.Add(my._ArrayInitializer) }
        return list
    }

func (my *ArrayCreationExpression3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArrayCreationExpression3)       Enter(v Visitor){
        var checkChildren = v.VisitArrayCreationExpression3(my)
        if checkChildren{
            if nil != my._new{my._new.Accept(v)}
            if nil != my._ClassOrInterfaceType{my._ClassOrInterfaceType.Accept(v)}
            if nil != my._Dims{my._Dims.Accept(v)}
            if nil != my._ArrayInitializer{my._ArrayInitializer.Accept(v)}
        }
        v.EndVisitArrayCreationExpression3(my)
    }


func AnyCastToArrayCreationExpression3(i interface{}) *ArrayCreationExpression3 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayCreationExpression3)
	}
}
/**
 *<b>
*<li>Rule 365:  Dims ::= [ ]
 *</b>
 */
type Dims0 struct{
    *Ast
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *Dims0)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *Dims0)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *Dims0)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *Dims0)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewDims0(leftIToken IToken, rightIToken IToken ,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*Dims0{
      my := new(Dims0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Dims0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *Dims0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Dims0)       Enter(v Visitor){
        var checkChildren = v.VisitDims0(my)
        if checkChildren{
            if nil != my._LBRACKET{my._LBRACKET.Accept(v)}
            if nil != my._RBRACKET{my._RBRACKET.Accept(v)}
        }
        v.EndVisitDims0(my)
    }


func AnyCastToDims0(i interface{}) *Dims0 {
	if nil == i{
		return nil
	}else{
		return i.(*Dims0)
	}
}
/**
 *<b>
*<li>Rule 366:  Dims ::= Dims [ ]
 *</b>
 */
type Dims1 struct{
    *Ast
      _Dims IDims
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *Dims1)      GetDims() IDims{ return my._Dims}
func (my *Dims1)      SetDims( _Dims IDims)  { my._Dims = _Dims }
func (my *Dims1)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *Dims1)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *Dims1)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *Dims1)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewDims1(leftIToken IToken, rightIToken IToken ,
              _Dims IDims,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*Dims1{
      my := new(Dims1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Dims = _Dims;
        if nil != _Dims{
        var trait_ interface{} = _Dims
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Dims1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Dims{  list.Add(my._Dims) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *Dims1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *Dims1)       Enter(v Visitor){
        var checkChildren = v.VisitDims1(my)
        if checkChildren{
            if nil != my._Dims{my._Dims.Accept(v)}
            if nil != my._LBRACKET{my._LBRACKET.Accept(v)}
            if nil != my._RBRACKET{my._RBRACKET.Accept(v)}
        }
        v.EndVisitDims1(my)
    }


func AnyCastToDims1(i interface{}) *Dims1 {
	if nil == i{
		return nil
	}else{
		return i.(*Dims1)
	}
}
/**
 *<b>
*<li>Rule 367:  FieldAccess ::= Primary . identifier
 *</b>
 */
type FieldAccess0 struct{
    *Ast
      _Primary IPrimary
      _DOT *AstToken
      _identifier *identifier
}
func (my *FieldAccess0)      GetPrimary() IPrimary{ return my._Primary}
func (my *FieldAccess0)      SetPrimary( _Primary IPrimary)  { my._Primary = _Primary }
func (my *FieldAccess0)      GetDOT() *AstToken{ return my._DOT}
func (my *FieldAccess0)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *FieldAccess0)      Getidentifier() *identifier{ return my._identifier}
func (my *FieldAccess0)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewFieldAccess0(leftIToken IToken, rightIToken IToken ,
              _Primary IPrimary,
              _DOT *AstToken,
              _identifier *identifier)*FieldAccess0{
      my := new(FieldAccess0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Primary = _Primary;
        if nil != _Primary{
        var trait_ interface{} = _Primary
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldAccess0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Primary{  list.Add(my._Primary) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *FieldAccess0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldAccess0)       Enter(v Visitor){
        var checkChildren = v.VisitFieldAccess0(my)
        if checkChildren{
            if nil != my._Primary{my._Primary.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitFieldAccess0(my)
    }


func AnyCastToFieldAccess0(i interface{}) *FieldAccess0 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldAccess0)
	}
}
/**
 *<b>
*<li>Rule 368:  FieldAccess ::= super . identifier
 *</b>
 */
type FieldAccess1 struct{
    *Ast
      _super *AstToken
      _DOT *AstToken
      _identifier *identifier
}
func (my *FieldAccess1)      Getsuper() *AstToken{ return my._super}
func (my *FieldAccess1)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *FieldAccess1)      GetDOT() *AstToken{ return my._DOT}
func (my *FieldAccess1)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *FieldAccess1)      Getidentifier() *identifier{ return my._identifier}
func (my *FieldAccess1)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewFieldAccess1(leftIToken IToken, rightIToken IToken ,
              _super *AstToken,
              _DOT *AstToken,
              _identifier *identifier)*FieldAccess1{
      my := new(FieldAccess1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldAccess1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._super{  list.Add(my._super) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *FieldAccess1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldAccess1)       Enter(v Visitor){
        var checkChildren = v.VisitFieldAccess1(my)
        if checkChildren{
            if nil != my._super{my._super.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitFieldAccess1(my)
    }


func AnyCastToFieldAccess1(i interface{}) *FieldAccess1 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldAccess1)
	}
}
/**
 *<b>
*<li>Rule 369:  FieldAccess ::= ClassName . super . identifier
 *</b>
 */
type FieldAccess2 struct{
    *Ast
      _ClassName IClassName
      _DOT *AstToken
      _super *AstToken
      _DOT4 *AstToken
      _identifier *identifier
}
func (my *FieldAccess2)      GetClassName() IClassName{ return my._ClassName}
func (my *FieldAccess2)      SetClassName( _ClassName IClassName)  { my._ClassName = _ClassName }
func (my *FieldAccess2)      GetDOT() *AstToken{ return my._DOT}
func (my *FieldAccess2)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *FieldAccess2)      Getsuper() *AstToken{ return my._super}
func (my *FieldAccess2)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *FieldAccess2)      GetDOT4() *AstToken{ return my._DOT4}
func (my *FieldAccess2)      SetDOT4( _DOT4 *AstToken)  { my._DOT4 = _DOT4 }
func (my *FieldAccess2)      Getidentifier() *identifier{ return my._identifier}
func (my *FieldAccess2)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewFieldAccess2(leftIToken IToken, rightIToken IToken ,
              _ClassName IClassName,
              _DOT *AstToken,
              _super *AstToken,
              _DOT4 *AstToken,
              _identifier *identifier)*FieldAccess2{
      my := new(FieldAccess2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassName = _ClassName;
        if nil != _ClassName{
        var trait_ interface{} = _ClassName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._DOT4 = _DOT4;
        if nil != _DOT4{
        var trait_ interface{} = _DOT4
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldAccess2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassName{  list.Add(my._ClassName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._super{  list.Add(my._super) }
        if nil != my._DOT4{  list.Add(my._DOT4) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *FieldAccess2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *FieldAccess2)       Enter(v Visitor){
        var checkChildren = v.VisitFieldAccess2(my)
        if checkChildren{
            if nil != my._ClassName{my._ClassName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._super{my._super.Accept(v)}
            if nil != my._DOT4{my._DOT4.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
        }
        v.EndVisitFieldAccess2(my)
    }


func AnyCastToFieldAccess2(i interface{}) *FieldAccess2 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldAccess2)
	}
}
/**
 *<b>
*<li>Rule 370:  MethodInvocation ::= MethodName ( ArgumentListopt )
 *</b>
 */
type MethodInvocation0 struct{
    *Ast
      _MethodName IMethodName
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation0)      GetMethodName() IMethodName{ return my._MethodName}
func (my *MethodInvocation0)      SetMethodName( _MethodName IMethodName)  { my._MethodName = _MethodName }
func (my *MethodInvocation0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation0)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation0)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation0(leftIToken IToken, rightIToken IToken ,
              _MethodName IMethodName,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation0{
      my := new(MethodInvocation0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodName = _MethodName;
        if nil != _MethodName{
        var trait_ interface{} = _MethodName
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodName{  list.Add(my._MethodName) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodInvocation0)       Enter(v Visitor){
        var checkChildren = v.VisitMethodInvocation0(my)
        if checkChildren{
            if nil != my._MethodName{my._MethodName.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitMethodInvocation0(my)
    }


func AnyCastToMethodInvocation0(i interface{}) *MethodInvocation0 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation0)
	}
}
/**
 *<b>
*<li>Rule 371:  MethodInvocation ::= Primary . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
type MethodInvocation1 struct{
    *Ast
      _Primary IPrimary
      _DOT *AstToken
      _TypeArgumentsopt *TypeArguments
      _identifier *identifier
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation1)      GetPrimary() IPrimary{ return my._Primary}
func (my *MethodInvocation1)      SetPrimary( _Primary IPrimary)  { my._Primary = _Primary }
func (my *MethodInvocation1)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodInvocation1)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *MethodInvocation1)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *MethodInvocation1)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *MethodInvocation1)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodInvocation1)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodInvocation1)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation1)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation1)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation1)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation1)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation1)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation1(leftIToken IToken, rightIToken IToken ,
              _Primary IPrimary,
              _DOT *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _identifier *identifier,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation1{
      my := new(MethodInvocation1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Primary = _Primary;
        if nil != _Primary{
        var trait_ interface{} = _Primary
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Primary{  list.Add(my._Primary) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodInvocation1)       Enter(v Visitor){
        var checkChildren = v.VisitMethodInvocation1(my)
        if checkChildren{
            if nil != my._Primary{my._Primary.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitMethodInvocation1(my)
    }


func AnyCastToMethodInvocation1(i interface{}) *MethodInvocation1 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation1)
	}
}
/**
 *<b>
*<li>Rule 372:  MethodInvocation ::= super . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
type MethodInvocation2 struct{
    *Ast
      _super *AstToken
      _DOT *AstToken
      _TypeArgumentsopt *TypeArguments
      _identifier *identifier
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation2)      Getsuper() *AstToken{ return my._super}
func (my *MethodInvocation2)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *MethodInvocation2)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodInvocation2)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *MethodInvocation2)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *MethodInvocation2)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *MethodInvocation2)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodInvocation2)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodInvocation2)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation2)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation2)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation2)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation2)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation2)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation2(leftIToken IToken, rightIToken IToken ,
              _super *AstToken,
              _DOT *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _identifier *identifier,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation2{
      my := new(MethodInvocation2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._super{  list.Add(my._super) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodInvocation2)       Enter(v Visitor){
        var checkChildren = v.VisitMethodInvocation2(my)
        if checkChildren{
            if nil != my._super{my._super.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitMethodInvocation2(my)
    }


func AnyCastToMethodInvocation2(i interface{}) *MethodInvocation2 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation2)
	}
}
/**
 *<b>
*<li>Rule 373:  MethodInvocation ::= ClassName . super . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
type MethodInvocation3 struct{
    *Ast
      _ClassName IClassName
      _DOT *AstToken
      _super *AstToken
      _DOT4 *AstToken
      _TypeArgumentsopt *TypeArguments
      _identifier *identifier
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation3)      GetClassName() IClassName{ return my._ClassName}
func (my *MethodInvocation3)      SetClassName( _ClassName IClassName)  { my._ClassName = _ClassName }
func (my *MethodInvocation3)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodInvocation3)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *MethodInvocation3)      Getsuper() *AstToken{ return my._super}
func (my *MethodInvocation3)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *MethodInvocation3)      GetDOT4() *AstToken{ return my._DOT4}
func (my *MethodInvocation3)      SetDOT4( _DOT4 *AstToken)  { my._DOT4 = _DOT4 }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *MethodInvocation3)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *MethodInvocation3)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *MethodInvocation3)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodInvocation3)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodInvocation3)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation3)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation3)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation3)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation3)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation3)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation3(leftIToken IToken, rightIToken IToken ,
              _ClassName IClassName,
              _DOT *AstToken,
              _super *AstToken,
              _DOT4 *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _identifier *identifier,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation3{
      my := new(MethodInvocation3)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassName = _ClassName;
        if nil != _ClassName{
        var trait_ interface{} = _ClassName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._DOT4 = _DOT4;
        if nil != _DOT4{
        var trait_ interface{} = _DOT4
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation3)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassName{  list.Add(my._ClassName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._super{  list.Add(my._super) }
        if nil != my._DOT4{  list.Add(my._DOT4) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodInvocation3)       Enter(v Visitor){
        var checkChildren = v.VisitMethodInvocation3(my)
        if checkChildren{
            if nil != my._ClassName{my._ClassName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._super{my._super.Accept(v)}
            if nil != my._DOT4{my._DOT4.Accept(v)}
            if nil != my._TypeArgumentsopt{my._TypeArgumentsopt.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitMethodInvocation3(my)
    }


func AnyCastToMethodInvocation3(i interface{}) *MethodInvocation3 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation3)
	}
}
/**
 *<b>
*<li>Rule 374:  MethodInvocation ::= TypeName . TypeArguments identifier ( ArgumentListopt )
 *</b>
 */
type MethodInvocation4 struct{
    *Ast
      _TypeName ITypeName
      _DOT *AstToken
      _TypeArguments *TypeArguments
      _identifier *identifier
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation4)      GetTypeName() ITypeName{ return my._TypeName}
func (my *MethodInvocation4)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *MethodInvocation4)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodInvocation4)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *MethodInvocation4)      GetTypeArguments() *TypeArguments{ return my._TypeArguments}
func (my *MethodInvocation4)      SetTypeArguments( _TypeArguments *TypeArguments)  { my._TypeArguments = _TypeArguments }
func (my *MethodInvocation4)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodInvocation4)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodInvocation4)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation4)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation4)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation4)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation4)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation4)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation4(leftIToken IToken, rightIToken IToken ,
              _TypeName ITypeName,
              _DOT *AstToken,
              _TypeArguments *TypeArguments,
              _identifier *identifier,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation4{
      my := new(MethodInvocation4)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._TypeArguments = _TypeArguments;
        if nil != _TypeArguments{
        var trait_ interface{} = _TypeArguments
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation4)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._TypeArguments{  list.Add(my._TypeArguments) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MethodInvocation4)       Enter(v Visitor){
        var checkChildren = v.VisitMethodInvocation4(my)
        if checkChildren{
            if nil != my._TypeName{my._TypeName.Accept(v)}
            if nil != my._DOT{my._DOT.Accept(v)}
            if nil != my._TypeArguments{my._TypeArguments.Accept(v)}
            if nil != my._identifier{my._identifier.Accept(v)}
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ArgumentListopt{my._ArgumentListopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
        }
        v.EndVisitMethodInvocation4(my)
    }


func AnyCastToMethodInvocation4(i interface{}) *MethodInvocation4 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation4)
	}
}
/**
 *<b>
*<li>Rule 375:  ArrayAccess ::= ExpressionName [ Expression ]
 *</b>
 */
type ArrayAccess0 struct{
    *Ast
      _ExpressionName IExpressionName
      _LBRACKET *AstToken
      _Expression IExpression
      _RBRACKET *AstToken
}
func (my *ArrayAccess0)      GetExpressionName() IExpressionName{ return my._ExpressionName}
func (my *ArrayAccess0)      SetExpressionName( _ExpressionName IExpressionName)  { my._ExpressionName = _ExpressionName }
func (my *ArrayAccess0)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *ArrayAccess0)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *ArrayAccess0)      GetExpression() IExpression{ return my._Expression}
func (my *ArrayAccess0)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *ArrayAccess0)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *ArrayAccess0)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewArrayAccess0(leftIToken IToken, rightIToken IToken ,
              _ExpressionName IExpressionName,
              _LBRACKET *AstToken,
              _Expression IExpression,
              _RBRACKET *AstToken)*ArrayAccess0{
      my := new(ArrayAccess0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ExpressionName = _ExpressionName;
        if nil != _ExpressionName{
        var trait_ interface{} = _ExpressionName
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayAccess0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ExpressionName{  list.Add(my._ExpressionName) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *ArrayAccess0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArrayAccess0)       Enter(v Visitor){
        var checkChildren = v.VisitArrayAccess0(my)
        if checkChildren{
            if nil != my._ExpressionName{my._ExpressionName.Accept(v)}
            if nil != my._LBRACKET{my._LBRACKET.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RBRACKET{my._RBRACKET.Accept(v)}
        }
        v.EndVisitArrayAccess0(my)
    }


func AnyCastToArrayAccess0(i interface{}) *ArrayAccess0 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayAccess0)
	}
}
/**
 *<b>
*<li>Rule 376:  ArrayAccess ::= PrimaryNoNewArray [ Expression ]
 *</b>
 */
type ArrayAccess1 struct{
    *Ast
      _PrimaryNoNewArray IPrimaryNoNewArray
      _LBRACKET *AstToken
      _Expression IExpression
      _RBRACKET *AstToken
}
func (my *ArrayAccess1)      GetPrimaryNoNewArray() IPrimaryNoNewArray{ return my._PrimaryNoNewArray}
func (my *ArrayAccess1)      SetPrimaryNoNewArray( _PrimaryNoNewArray IPrimaryNoNewArray)  { my._PrimaryNoNewArray = _PrimaryNoNewArray }
func (my *ArrayAccess1)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *ArrayAccess1)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *ArrayAccess1)      GetExpression() IExpression{ return my._Expression}
func (my *ArrayAccess1)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *ArrayAccess1)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *ArrayAccess1)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewArrayAccess1(leftIToken IToken, rightIToken IToken ,
              _PrimaryNoNewArray IPrimaryNoNewArray,
              _LBRACKET *AstToken,
              _Expression IExpression,
              _RBRACKET *AstToken)*ArrayAccess1{
      my := new(ArrayAccess1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PrimaryNoNewArray = _PrimaryNoNewArray;
        if nil != _PrimaryNoNewArray{
        var trait_ interface{} = _PrimaryNoNewArray
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayAccess1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PrimaryNoNewArray{  list.Add(my._PrimaryNoNewArray) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *ArrayAccess1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ArrayAccess1)       Enter(v Visitor){
        var checkChildren = v.VisitArrayAccess1(my)
        if checkChildren{
            if nil != my._PrimaryNoNewArray{my._PrimaryNoNewArray.Accept(v)}
            if nil != my._LBRACKET{my._LBRACKET.Accept(v)}
            if nil != my._Expression{my._Expression.Accept(v)}
            if nil != my._RBRACKET{my._RBRACKET.Accept(v)}
        }
        v.EndVisitArrayAccess1(my)
    }


func AnyCastToArrayAccess1(i interface{}) *ArrayAccess1 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayAccess1)
	}
}
/**
 *<b>
*<li>Rule 385:  UnaryExpression ::= + UnaryExpression
 *</b>
 */
type UnaryExpression0 struct{
    *Ast
      _PLUS *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *UnaryExpression0)      GetPLUS() *AstToken{ return my._PLUS}
func (my *UnaryExpression0)      SetPLUS( _PLUS *AstToken)  { my._PLUS = _PLUS }
func (my *UnaryExpression0)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *UnaryExpression0)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewUnaryExpression0(leftIToken IToken, rightIToken IToken ,
              _PLUS *AstToken,
              _UnaryExpression IUnaryExpression)*UnaryExpression0{
      my := new(UnaryExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PLUS = _PLUS;
        if nil != _PLUS{
        var trait_ interface{} = _PLUS
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *UnaryExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PLUS{  list.Add(my._PLUS) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *UnaryExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *UnaryExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitUnaryExpression0(my)
        if checkChildren{
            if nil != my._PLUS{my._PLUS.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitUnaryExpression0(my)
    }


func AnyCastToUnaryExpression0(i interface{}) *UnaryExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*UnaryExpression0)
	}
}
/**
 *<b>
*<li>Rule 386:  UnaryExpression ::= - UnaryExpression
 *</b>
 */
type UnaryExpression1 struct{
    *Ast
      _MINUS *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *UnaryExpression1)      GetMINUS() *AstToken{ return my._MINUS}
func (my *UnaryExpression1)      SetMINUS( _MINUS *AstToken)  { my._MINUS = _MINUS }
func (my *UnaryExpression1)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *UnaryExpression1)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewUnaryExpression1(leftIToken IToken, rightIToken IToken ,
              _MINUS *AstToken,
              _UnaryExpression IUnaryExpression)*UnaryExpression1{
      my := new(UnaryExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MINUS = _MINUS;
        if nil != _MINUS{
        var trait_ interface{} = _MINUS
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *UnaryExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MINUS{  list.Add(my._MINUS) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *UnaryExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *UnaryExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitUnaryExpression1(my)
        if checkChildren{
            if nil != my._MINUS{my._MINUS.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitUnaryExpression1(my)
    }


func AnyCastToUnaryExpression1(i interface{}) *UnaryExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*UnaryExpression1)
	}
}
/**
 *<b>
*<li>Rule 391:  UnaryExpressionNotPlusMinus ::= ~ UnaryExpression
 *</b>
 */
type UnaryExpressionNotPlusMinus0 struct{
    *Ast
      _TWIDDLE *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *UnaryExpressionNotPlusMinus0)      GetTWIDDLE() *AstToken{ return my._TWIDDLE}
func (my *UnaryExpressionNotPlusMinus0)      SetTWIDDLE( _TWIDDLE *AstToken)  { my._TWIDDLE = _TWIDDLE }
func (my *UnaryExpressionNotPlusMinus0)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *UnaryExpressionNotPlusMinus0)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewUnaryExpressionNotPlusMinus0(leftIToken IToken, rightIToken IToken ,
              _TWIDDLE *AstToken,
              _UnaryExpression IUnaryExpression)*UnaryExpressionNotPlusMinus0{
      my := new(UnaryExpressionNotPlusMinus0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TWIDDLE = _TWIDDLE;
        if nil != _TWIDDLE{
        var trait_ interface{} = _TWIDDLE
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *UnaryExpressionNotPlusMinus0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TWIDDLE{  list.Add(my._TWIDDLE) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *UnaryExpressionNotPlusMinus0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *UnaryExpressionNotPlusMinus0)       Enter(v Visitor){
        var checkChildren = v.VisitUnaryExpressionNotPlusMinus0(my)
        if checkChildren{
            if nil != my._TWIDDLE{my._TWIDDLE.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitUnaryExpressionNotPlusMinus0(my)
    }


func AnyCastToUnaryExpressionNotPlusMinus0(i interface{}) *UnaryExpressionNotPlusMinus0 {
	if nil == i{
		return nil
	}else{
		return i.(*UnaryExpressionNotPlusMinus0)
	}
}
/**
 *<b>
*<li>Rule 392:  UnaryExpressionNotPlusMinus ::= ! UnaryExpression
 *</b>
 */
type UnaryExpressionNotPlusMinus1 struct{
    *Ast
      _NOT *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *UnaryExpressionNotPlusMinus1)      GetNOT() *AstToken{ return my._NOT}
func (my *UnaryExpressionNotPlusMinus1)      SetNOT( _NOT *AstToken)  { my._NOT = _NOT }
func (my *UnaryExpressionNotPlusMinus1)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *UnaryExpressionNotPlusMinus1)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewUnaryExpressionNotPlusMinus1(leftIToken IToken, rightIToken IToken ,
              _NOT *AstToken,
              _UnaryExpression IUnaryExpression)*UnaryExpressionNotPlusMinus1{
      my := new(UnaryExpressionNotPlusMinus1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._NOT = _NOT;
        if nil != _NOT{
        var trait_ interface{} = _NOT
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *UnaryExpressionNotPlusMinus1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._NOT{  list.Add(my._NOT) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *UnaryExpressionNotPlusMinus1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *UnaryExpressionNotPlusMinus1)       Enter(v Visitor){
        var checkChildren = v.VisitUnaryExpressionNotPlusMinus1(my)
        if checkChildren{
            if nil != my._NOT{my._NOT.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitUnaryExpressionNotPlusMinus1(my)
    }


func AnyCastToUnaryExpressionNotPlusMinus1(i interface{}) *UnaryExpressionNotPlusMinus1 {
	if nil == i{
		return nil
	}else{
		return i.(*UnaryExpressionNotPlusMinus1)
	}
}
/**
 *<b>
*<li>Rule 394:  CastExpression ::= ( PrimitiveType Dimsopt ) UnaryExpression
 *</b>
 */
type CastExpression0 struct{
    *Ast
      _LPAREN *AstToken
      _PrimitiveType IPrimitiveType
      _Dimsopt IDimsopt
      _RPAREN *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *CastExpression0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *CastExpression0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *CastExpression0)      GetPrimitiveType() IPrimitiveType{ return my._PrimitiveType}
func (my *CastExpression0)      SetPrimitiveType( _PrimitiveType IPrimitiveType)  { my._PrimitiveType = _PrimitiveType }
    /**
     * The value returned by <b>GetDimsopt</b> may be <b>null</b>
     */
func (my *CastExpression0)      GetDimsopt() IDimsopt{ return my._Dimsopt}
func (my *CastExpression0)      SetDimsopt( _Dimsopt IDimsopt)  { my._Dimsopt = _Dimsopt }
func (my *CastExpression0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *CastExpression0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *CastExpression0)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *CastExpression0)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewCastExpression0(leftIToken IToken, rightIToken IToken ,
              _LPAREN *AstToken,
              _PrimitiveType IPrimitiveType,
              _Dimsopt IDimsopt,
              _RPAREN *AstToken,
              _UnaryExpression IUnaryExpression)*CastExpression0{
      my := new(CastExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._PrimitiveType = _PrimitiveType;
        if nil != _PrimitiveType{
        var trait_ interface{} = _PrimitiveType
         trait_.(IAst).SetParent(my)
}
        my._Dimsopt = _Dimsopt;
        if nil != _Dimsopt{
        var trait_ interface{} = _Dimsopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *CastExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._PrimitiveType{  list.Add(my._PrimitiveType) }
        if nil != my._Dimsopt{  list.Add(my._Dimsopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *CastExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *CastExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitCastExpression0(my)
        if checkChildren{
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._PrimitiveType{my._PrimitiveType.Accept(v)}
            if nil != my._Dimsopt{my._Dimsopt.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitCastExpression0(my)
    }


func AnyCastToCastExpression0(i interface{}) *CastExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*CastExpression0)
	}
}
/**
 *<b>
*<li>Rule 395:  CastExpression ::= ( ReferenceType ) UnaryExpressionNotPlusMinus
 *</b>
 */
type CastExpression1 struct{
    *Ast
      _LPAREN *AstToken
      _ReferenceType IReferenceType
      _RPAREN *AstToken
      _UnaryExpressionNotPlusMinus IUnaryExpressionNotPlusMinus
}
func (my *CastExpression1)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *CastExpression1)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *CastExpression1)      GetReferenceType() IReferenceType{ return my._ReferenceType}
func (my *CastExpression1)      SetReferenceType( _ReferenceType IReferenceType)  { my._ReferenceType = _ReferenceType }
func (my *CastExpression1)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *CastExpression1)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *CastExpression1)      GetUnaryExpressionNotPlusMinus() IUnaryExpressionNotPlusMinus{ return my._UnaryExpressionNotPlusMinus}
func (my *CastExpression1)      SetUnaryExpressionNotPlusMinus( _UnaryExpressionNotPlusMinus IUnaryExpressionNotPlusMinus)  { my._UnaryExpressionNotPlusMinus = _UnaryExpressionNotPlusMinus }

func NewCastExpression1(leftIToken IToken, rightIToken IToken ,
              _LPAREN *AstToken,
              _ReferenceType IReferenceType,
              _RPAREN *AstToken,
              _UnaryExpressionNotPlusMinus IUnaryExpressionNotPlusMinus)*CastExpression1{
      my := new(CastExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ReferenceType = _ReferenceType;
        if nil != _ReferenceType{
        var trait_ interface{} = _ReferenceType
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpressionNotPlusMinus = _UnaryExpressionNotPlusMinus;
        if nil != _UnaryExpressionNotPlusMinus{
        var trait_ interface{} = _UnaryExpressionNotPlusMinus
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *CastExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ReferenceType{  list.Add(my._ReferenceType) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._UnaryExpressionNotPlusMinus{  list.Add(my._UnaryExpressionNotPlusMinus) }
        return list
    }

func (my *CastExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *CastExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitCastExpression1(my)
        if checkChildren{
            if nil != my._LPAREN{my._LPAREN.Accept(v)}
            if nil != my._ReferenceType{my._ReferenceType.Accept(v)}
            if nil != my._RPAREN{my._RPAREN.Accept(v)}
            if nil != my._UnaryExpressionNotPlusMinus{my._UnaryExpressionNotPlusMinus.Accept(v)}
        }
        v.EndVisitCastExpression1(my)
    }


func AnyCastToCastExpression1(i interface{}) *CastExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*CastExpression1)
	}
}
/**
 *<b>
*<li>Rule 397:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
 *</b>
 */
type MultiplicativeExpression0 struct{
    *Ast
      _MultiplicativeExpression IMultiplicativeExpression
      _MULTIPLY *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *MultiplicativeExpression0)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *MultiplicativeExpression0)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }
func (my *MultiplicativeExpression0)      GetMULTIPLY() *AstToken{ return my._MULTIPLY}
func (my *MultiplicativeExpression0)      SetMULTIPLY( _MULTIPLY *AstToken)  { my._MULTIPLY = _MULTIPLY }
func (my *MultiplicativeExpression0)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *MultiplicativeExpression0)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewMultiplicativeExpression0(leftIToken IToken, rightIToken IToken ,
              _MultiplicativeExpression IMultiplicativeExpression,
              _MULTIPLY *AstToken,
              _UnaryExpression IUnaryExpression)*MultiplicativeExpression0{
      my := new(MultiplicativeExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my._MULTIPLY = _MULTIPLY;
        if nil != _MULTIPLY{
        var trait_ interface{} = _MULTIPLY
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MultiplicativeExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        if nil != my._MULTIPLY{  list.Add(my._MULTIPLY) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *MultiplicativeExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MultiplicativeExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitMultiplicativeExpression0(my)
        if checkChildren{
            if nil != my._MultiplicativeExpression{my._MultiplicativeExpression.Accept(v)}
            if nil != my._MULTIPLY{my._MULTIPLY.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitMultiplicativeExpression0(my)
    }


func AnyCastToMultiplicativeExpression0(i interface{}) *MultiplicativeExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*MultiplicativeExpression0)
	}
}
/**
 *<b>
*<li>Rule 398:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
 *</b>
 */
type MultiplicativeExpression1 struct{
    *Ast
      _MultiplicativeExpression IMultiplicativeExpression
      _DIVIDE *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *MultiplicativeExpression1)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *MultiplicativeExpression1)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }
func (my *MultiplicativeExpression1)      GetDIVIDE() *AstToken{ return my._DIVIDE}
func (my *MultiplicativeExpression1)      SetDIVIDE( _DIVIDE *AstToken)  { my._DIVIDE = _DIVIDE }
func (my *MultiplicativeExpression1)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *MultiplicativeExpression1)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewMultiplicativeExpression1(leftIToken IToken, rightIToken IToken ,
              _MultiplicativeExpression IMultiplicativeExpression,
              _DIVIDE *AstToken,
              _UnaryExpression IUnaryExpression)*MultiplicativeExpression1{
      my := new(MultiplicativeExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my._DIVIDE = _DIVIDE;
        if nil != _DIVIDE{
        var trait_ interface{} = _DIVIDE
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MultiplicativeExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        if nil != my._DIVIDE{  list.Add(my._DIVIDE) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *MultiplicativeExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MultiplicativeExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitMultiplicativeExpression1(my)
        if checkChildren{
            if nil != my._MultiplicativeExpression{my._MultiplicativeExpression.Accept(v)}
            if nil != my._DIVIDE{my._DIVIDE.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitMultiplicativeExpression1(my)
    }


func AnyCastToMultiplicativeExpression1(i interface{}) *MultiplicativeExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*MultiplicativeExpression1)
	}
}
/**
 *<b>
*<li>Rule 399:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
 *</b>
 */
type MultiplicativeExpression2 struct{
    *Ast
      _MultiplicativeExpression IMultiplicativeExpression
      _REMAINDER *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *MultiplicativeExpression2)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *MultiplicativeExpression2)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }
func (my *MultiplicativeExpression2)      GetREMAINDER() *AstToken{ return my._REMAINDER}
func (my *MultiplicativeExpression2)      SetREMAINDER( _REMAINDER *AstToken)  { my._REMAINDER = _REMAINDER }
func (my *MultiplicativeExpression2)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *MultiplicativeExpression2)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewMultiplicativeExpression2(leftIToken IToken, rightIToken IToken ,
              _MultiplicativeExpression IMultiplicativeExpression,
              _REMAINDER *AstToken,
              _UnaryExpression IUnaryExpression)*MultiplicativeExpression2{
      my := new(MultiplicativeExpression2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my._REMAINDER = _REMAINDER;
        if nil != _REMAINDER{
        var trait_ interface{} = _REMAINDER
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MultiplicativeExpression2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        if nil != my._REMAINDER{  list.Add(my._REMAINDER) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *MultiplicativeExpression2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *MultiplicativeExpression2)       Enter(v Visitor){
        var checkChildren = v.VisitMultiplicativeExpression2(my)
        if checkChildren{
            if nil != my._MultiplicativeExpression{my._MultiplicativeExpression.Accept(v)}
            if nil != my._REMAINDER{my._REMAINDER.Accept(v)}
            if nil != my._UnaryExpression{my._UnaryExpression.Accept(v)}
        }
        v.EndVisitMultiplicativeExpression2(my)
    }


func AnyCastToMultiplicativeExpression2(i interface{}) *MultiplicativeExpression2 {
	if nil == i{
		return nil
	}else{
		return i.(*MultiplicativeExpression2)
	}
}
/**
 *<b>
*<li>Rule 401:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
 *</b>
 */
type AdditiveExpression0 struct{
    *Ast
      _AdditiveExpression IAdditiveExpression
      _PLUS *AstToken
      _MultiplicativeExpression IMultiplicativeExpression
}
func (my *AdditiveExpression0)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *AdditiveExpression0)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }
func (my *AdditiveExpression0)      GetPLUS() *AstToken{ return my._PLUS}
func (my *AdditiveExpression0)      SetPLUS( _PLUS *AstToken)  { my._PLUS = _PLUS }
func (my *AdditiveExpression0)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *AdditiveExpression0)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }

func NewAdditiveExpression0(leftIToken IToken, rightIToken IToken ,
              _AdditiveExpression IAdditiveExpression,
              _PLUS *AstToken,
              _MultiplicativeExpression IMultiplicativeExpression)*AdditiveExpression0{
      my := new(AdditiveExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my._PLUS = _PLUS;
        if nil != _PLUS{
        var trait_ interface{} = _PLUS
         trait_.(IAst).SetParent(my)
}
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AdditiveExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        if nil != my._PLUS{  list.Add(my._PLUS) }
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        return list
    }

func (my *AdditiveExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AdditiveExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitAdditiveExpression0(my)
        if checkChildren{
            if nil != my._AdditiveExpression{my._AdditiveExpression.Accept(v)}
            if nil != my._PLUS{my._PLUS.Accept(v)}
            if nil != my._MultiplicativeExpression{my._MultiplicativeExpression.Accept(v)}
        }
        v.EndVisitAdditiveExpression0(my)
    }


func AnyCastToAdditiveExpression0(i interface{}) *AdditiveExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*AdditiveExpression0)
	}
}
/**
 *<b>
*<li>Rule 402:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
 *</b>
 */
type AdditiveExpression1 struct{
    *Ast
      _AdditiveExpression IAdditiveExpression
      _MINUS *AstToken
      _MultiplicativeExpression IMultiplicativeExpression
}
func (my *AdditiveExpression1)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *AdditiveExpression1)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }
func (my *AdditiveExpression1)      GetMINUS() *AstToken{ return my._MINUS}
func (my *AdditiveExpression1)      SetMINUS( _MINUS *AstToken)  { my._MINUS = _MINUS }
func (my *AdditiveExpression1)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *AdditiveExpression1)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }

func NewAdditiveExpression1(leftIToken IToken, rightIToken IToken ,
              _AdditiveExpression IAdditiveExpression,
              _MINUS *AstToken,
              _MultiplicativeExpression IMultiplicativeExpression)*AdditiveExpression1{
      my := new(AdditiveExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my._MINUS = _MINUS;
        if nil != _MINUS{
        var trait_ interface{} = _MINUS
         trait_.(IAst).SetParent(my)
}
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AdditiveExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        if nil != my._MINUS{  list.Add(my._MINUS) }
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        return list
    }

func (my *AdditiveExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AdditiveExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitAdditiveExpression1(my)
        if checkChildren{
            if nil != my._AdditiveExpression{my._AdditiveExpression.Accept(v)}
            if nil != my._MINUS{my._MINUS.Accept(v)}
            if nil != my._MultiplicativeExpression{my._MultiplicativeExpression.Accept(v)}
        }
        v.EndVisitAdditiveExpression1(my)
    }


func AnyCastToAdditiveExpression1(i interface{}) *AdditiveExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*AdditiveExpression1)
	}
}
/**
 *<b>
*<li>Rule 404:  ShiftExpression ::= ShiftExpression << AdditiveExpression
 *</b>
 */
type ShiftExpression0 struct{
    *Ast
      _ShiftExpression IShiftExpression
      _LEFT_SHIFT *AstToken
      _AdditiveExpression IAdditiveExpression
}
func (my *ShiftExpression0)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *ShiftExpression0)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }
func (my *ShiftExpression0)      GetLEFT_SHIFT() *AstToken{ return my._LEFT_SHIFT}
func (my *ShiftExpression0)      SetLEFT_SHIFT( _LEFT_SHIFT *AstToken)  { my._LEFT_SHIFT = _LEFT_SHIFT }
func (my *ShiftExpression0)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *ShiftExpression0)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }

func NewShiftExpression0(leftIToken IToken, rightIToken IToken ,
              _ShiftExpression IShiftExpression,
              _LEFT_SHIFT *AstToken,
              _AdditiveExpression IAdditiveExpression)*ShiftExpression0{
      my := new(ShiftExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my._LEFT_SHIFT = _LEFT_SHIFT;
        if nil != _LEFT_SHIFT{
        var trait_ interface{} = _LEFT_SHIFT
         trait_.(IAst).SetParent(my)
}
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ShiftExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        if nil != my._LEFT_SHIFT{  list.Add(my._LEFT_SHIFT) }
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        return list
    }

func (my *ShiftExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ShiftExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitShiftExpression0(my)
        if checkChildren{
            if nil != my._ShiftExpression{my._ShiftExpression.Accept(v)}
            if nil != my._LEFT_SHIFT{my._LEFT_SHIFT.Accept(v)}
            if nil != my._AdditiveExpression{my._AdditiveExpression.Accept(v)}
        }
        v.EndVisitShiftExpression0(my)
    }


func AnyCastToShiftExpression0(i interface{}) *ShiftExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*ShiftExpression0)
	}
}
/**
 *<b>
*<li>Rule 405:  ShiftExpression ::= ShiftExpression > > AdditiveExpression
 *</b>
 */
type ShiftExpression1 struct{
    *Ast
      _ShiftExpression IShiftExpression
      _GREATER *AstToken
      _GREATER3 *AstToken
      _AdditiveExpression IAdditiveExpression
}
func (my *ShiftExpression1)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *ShiftExpression1)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }
func (my *ShiftExpression1)      GetGREATER() *AstToken{ return my._GREATER}
func (my *ShiftExpression1)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *ShiftExpression1)      GetGREATER3() *AstToken{ return my._GREATER3}
func (my *ShiftExpression1)      SetGREATER3( _GREATER3 *AstToken)  { my._GREATER3 = _GREATER3 }
func (my *ShiftExpression1)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *ShiftExpression1)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }

func NewShiftExpression1(leftIToken IToken, rightIToken IToken ,
              _ShiftExpression IShiftExpression,
              _GREATER *AstToken,
              _GREATER3 *AstToken,
              _AdditiveExpression IAdditiveExpression)*ShiftExpression1{
      my := new(ShiftExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._GREATER3 = _GREATER3;
        if nil != _GREATER3{
        var trait_ interface{} = _GREATER3
         trait_.(IAst).SetParent(my)
}
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ShiftExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._GREATER3{  list.Add(my._GREATER3) }
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        return list
    }

func (my *ShiftExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ShiftExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitShiftExpression1(my)
        if checkChildren{
            if nil != my._ShiftExpression{my._ShiftExpression.Accept(v)}
            if nil != my._GREATER{my._GREATER.Accept(v)}
            if nil != my._GREATER3{my._GREATER3.Accept(v)}
            if nil != my._AdditiveExpression{my._AdditiveExpression.Accept(v)}
        }
        v.EndVisitShiftExpression1(my)
    }


func AnyCastToShiftExpression1(i interface{}) *ShiftExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*ShiftExpression1)
	}
}
/**
 *<b>
*<li>Rule 406:  ShiftExpression ::= ShiftExpression > > > AdditiveExpression
 *</b>
 */
type ShiftExpression2 struct{
    *Ast
      _ShiftExpression IShiftExpression
      _GREATER *AstToken
      _GREATER3 *AstToken
      _GREATER4 *AstToken
      _AdditiveExpression IAdditiveExpression
}
func (my *ShiftExpression2)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *ShiftExpression2)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }
func (my *ShiftExpression2)      GetGREATER() *AstToken{ return my._GREATER}
func (my *ShiftExpression2)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *ShiftExpression2)      GetGREATER3() *AstToken{ return my._GREATER3}
func (my *ShiftExpression2)      SetGREATER3( _GREATER3 *AstToken)  { my._GREATER3 = _GREATER3 }
func (my *ShiftExpression2)      GetGREATER4() *AstToken{ return my._GREATER4}
func (my *ShiftExpression2)      SetGREATER4( _GREATER4 *AstToken)  { my._GREATER4 = _GREATER4 }
func (my *ShiftExpression2)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *ShiftExpression2)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }

func NewShiftExpression2(leftIToken IToken, rightIToken IToken ,
              _ShiftExpression IShiftExpression,
              _GREATER *AstToken,
              _GREATER3 *AstToken,
              _GREATER4 *AstToken,
              _AdditiveExpression IAdditiveExpression)*ShiftExpression2{
      my := new(ShiftExpression2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._GREATER3 = _GREATER3;
        if nil != _GREATER3{
        var trait_ interface{} = _GREATER3
         trait_.(IAst).SetParent(my)
}
        my._GREATER4 = _GREATER4;
        if nil != _GREATER4{
        var trait_ interface{} = _GREATER4
         trait_.(IAst).SetParent(my)
}
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ShiftExpression2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._GREATER3{  list.Add(my._GREATER3) }
        if nil != my._GREATER4{  list.Add(my._GREATER4) }
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        return list
    }

func (my *ShiftExpression2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *ShiftExpression2)       Enter(v Visitor){
        var checkChildren = v.VisitShiftExpression2(my)
        if checkChildren{
            if nil != my._ShiftExpression{my._ShiftExpression.Accept(v)}
            if nil != my._GREATER{my._GREATER.Accept(v)}
            if nil != my._GREATER3{my._GREATER3.Accept(v)}
            if nil != my._GREATER4{my._GREATER4.Accept(v)}
            if nil != my._AdditiveExpression{my._AdditiveExpression.Accept(v)}
        }
        v.EndVisitShiftExpression2(my)
    }


func AnyCastToShiftExpression2(i interface{}) *ShiftExpression2 {
	if nil == i{
		return nil
	}else{
		return i.(*ShiftExpression2)
	}
}
/**
 *<b>
*<li>Rule 408:  RelationalExpression ::= RelationalExpression < ShiftExpression
 *</b>
 */
type RelationalExpression0 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _LESS *AstToken
      _ShiftExpression IShiftExpression
}
func (my *RelationalExpression0)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression0)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression0)      GetLESS() *AstToken{ return my._LESS}
func (my *RelationalExpression0)      SetLESS( _LESS *AstToken)  { my._LESS = _LESS }
func (my *RelationalExpression0)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *RelationalExpression0)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }

func NewRelationalExpression0(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _LESS *AstToken,
              _ShiftExpression IShiftExpression)*RelationalExpression0{
      my := new(RelationalExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._LESS = _LESS;
        if nil != _LESS{
        var trait_ interface{} = _LESS
         trait_.(IAst).SetParent(my)
}
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._LESS{  list.Add(my._LESS) }
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        return list
    }

func (my *RelationalExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *RelationalExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitRelationalExpression0(my)
        if checkChildren{
            if nil != my._RelationalExpression{my._RelationalExpression.Accept(v)}
            if nil != my._LESS{my._LESS.Accept(v)}
            if nil != my._ShiftExpression{my._ShiftExpression.Accept(v)}
        }
        v.EndVisitRelationalExpression0(my)
    }


func AnyCastToRelationalExpression0(i interface{}) *RelationalExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression0)
	}
}
/**
 *<b>
*<li>Rule 409:  RelationalExpression ::= RelationalExpression > ShiftExpression
 *</b>
 */
type RelationalExpression1 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _GREATER *AstToken
      _ShiftExpression IShiftExpression
}
func (my *RelationalExpression1)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression1)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression1)      GetGREATER() *AstToken{ return my._GREATER}
func (my *RelationalExpression1)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *RelationalExpression1)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *RelationalExpression1)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }

func NewRelationalExpression1(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _GREATER *AstToken,
              _ShiftExpression IShiftExpression)*RelationalExpression1{
      my := new(RelationalExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        return list
    }

func (my *RelationalExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *RelationalExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitRelationalExpression1(my)
        if checkChildren{
            if nil != my._RelationalExpression{my._RelationalExpression.Accept(v)}
            if nil != my._GREATER{my._GREATER.Accept(v)}
            if nil != my._ShiftExpression{my._ShiftExpression.Accept(v)}
        }
        v.EndVisitRelationalExpression1(my)
    }


func AnyCastToRelationalExpression1(i interface{}) *RelationalExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression1)
	}
}
/**
 *<b>
*<li>Rule 410:  RelationalExpression ::= RelationalExpression <= ShiftExpression
 *</b>
 */
type RelationalExpression2 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _LESS_EQUAL *AstToken
      _ShiftExpression IShiftExpression
}
func (my *RelationalExpression2)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression2)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression2)      GetLESS_EQUAL() *AstToken{ return my._LESS_EQUAL}
func (my *RelationalExpression2)      SetLESS_EQUAL( _LESS_EQUAL *AstToken)  { my._LESS_EQUAL = _LESS_EQUAL }
func (my *RelationalExpression2)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *RelationalExpression2)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }

func NewRelationalExpression2(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _LESS_EQUAL *AstToken,
              _ShiftExpression IShiftExpression)*RelationalExpression2{
      my := new(RelationalExpression2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._LESS_EQUAL = _LESS_EQUAL;
        if nil != _LESS_EQUAL{
        var trait_ interface{} = _LESS_EQUAL
         trait_.(IAst).SetParent(my)
}
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._LESS_EQUAL{  list.Add(my._LESS_EQUAL) }
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        return list
    }

func (my *RelationalExpression2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *RelationalExpression2)       Enter(v Visitor){
        var checkChildren = v.VisitRelationalExpression2(my)
        if checkChildren{
            if nil != my._RelationalExpression{my._RelationalExpression.Accept(v)}
            if nil != my._LESS_EQUAL{my._LESS_EQUAL.Accept(v)}
            if nil != my._ShiftExpression{my._ShiftExpression.Accept(v)}
        }
        v.EndVisitRelationalExpression2(my)
    }


func AnyCastToRelationalExpression2(i interface{}) *RelationalExpression2 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression2)
	}
}
/**
 *<b>
*<li>Rule 411:  RelationalExpression ::= RelationalExpression > = ShiftExpression
 *</b>
 */
type RelationalExpression3 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _GREATER *AstToken
      _EQUAL *AstToken
      _ShiftExpression IShiftExpression
}
func (my *RelationalExpression3)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression3)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression3)      GetGREATER() *AstToken{ return my._GREATER}
func (my *RelationalExpression3)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *RelationalExpression3)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *RelationalExpression3)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }
func (my *RelationalExpression3)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *RelationalExpression3)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }

func NewRelationalExpression3(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _GREATER *AstToken,
              _EQUAL *AstToken,
              _ShiftExpression IShiftExpression)*RelationalExpression3{
      my := new(RelationalExpression3)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression3)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        return list
    }

func (my *RelationalExpression3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *RelationalExpression3)       Enter(v Visitor){
        var checkChildren = v.VisitRelationalExpression3(my)
        if checkChildren{
            if nil != my._RelationalExpression{my._RelationalExpression.Accept(v)}
            if nil != my._GREATER{my._GREATER.Accept(v)}
            if nil != my._EQUAL{my._EQUAL.Accept(v)}
            if nil != my._ShiftExpression{my._ShiftExpression.Accept(v)}
        }
        v.EndVisitRelationalExpression3(my)
    }


func AnyCastToRelationalExpression3(i interface{}) *RelationalExpression3 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression3)
	}
}
/**
 *<b>
*<li>Rule 412:  RelationalExpression ::= RelationalExpression instanceof ReferenceType
 *</b>
 */
type RelationalExpression4 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _instanceof *AstToken
      _ReferenceType IReferenceType
}
func (my *RelationalExpression4)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression4)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression4)      Getinstanceof() *AstToken{ return my._instanceof}
func (my *RelationalExpression4)      Setinstanceof( _instanceof *AstToken)  { my._instanceof = _instanceof }
func (my *RelationalExpression4)      GetReferenceType() IReferenceType{ return my._ReferenceType}
func (my *RelationalExpression4)      SetReferenceType( _ReferenceType IReferenceType)  { my._ReferenceType = _ReferenceType }

func NewRelationalExpression4(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _instanceof *AstToken,
              _ReferenceType IReferenceType)*RelationalExpression4{
      my := new(RelationalExpression4)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._instanceof = _instanceof;
        if nil != _instanceof{
        var trait_ interface{} = _instanceof
         trait_.(IAst).SetParent(my)
}
        my._ReferenceType = _ReferenceType;
        if nil != _ReferenceType{
        var trait_ interface{} = _ReferenceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression4)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._instanceof{  list.Add(my._instanceof) }
        if nil != my._ReferenceType{  list.Add(my._ReferenceType) }
        return list
    }

func (my *RelationalExpression4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *RelationalExpression4)       Enter(v Visitor){
        var checkChildren = v.VisitRelationalExpression4(my)
        if checkChildren{
            if nil != my._RelationalExpression{my._RelationalExpression.Accept(v)}
            if nil != my._instanceof{my._instanceof.Accept(v)}
            if nil != my._ReferenceType{my._ReferenceType.Accept(v)}
        }
        v.EndVisitRelationalExpression4(my)
    }


func AnyCastToRelationalExpression4(i interface{}) *RelationalExpression4 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression4)
	}
}
/**
 *<b>
*<li>Rule 414:  EqualityExpression ::= EqualityExpression == RelationalExpression
 *</b>
 */
type EqualityExpression0 struct{
    *Ast
      _EqualityExpression IEqualityExpression
      _EQUAL_EQUAL *AstToken
      _RelationalExpression IRelationalExpression
}
func (my *EqualityExpression0)      GetEqualityExpression() IEqualityExpression{ return my._EqualityExpression}
func (my *EqualityExpression0)      SetEqualityExpression( _EqualityExpression IEqualityExpression)  { my._EqualityExpression = _EqualityExpression }
func (my *EqualityExpression0)      GetEQUAL_EQUAL() *AstToken{ return my._EQUAL_EQUAL}
func (my *EqualityExpression0)      SetEQUAL_EQUAL( _EQUAL_EQUAL *AstToken)  { my._EQUAL_EQUAL = _EQUAL_EQUAL }
func (my *EqualityExpression0)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *EqualityExpression0)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }

func NewEqualityExpression0(leftIToken IToken, rightIToken IToken ,
              _EqualityExpression IEqualityExpression,
              _EQUAL_EQUAL *AstToken,
              _RelationalExpression IRelationalExpression)*EqualityExpression0{
      my := new(EqualityExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._EqualityExpression = _EqualityExpression;
        if nil != _EqualityExpression{
        var trait_ interface{} = _EqualityExpression
         trait_.(IAst).SetParent(my)
}
        my._EQUAL_EQUAL = _EQUAL_EQUAL;
        if nil != _EQUAL_EQUAL{
        var trait_ interface{} = _EQUAL_EQUAL
         trait_.(IAst).SetParent(my)
}
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EqualityExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._EqualityExpression{  list.Add(my._EqualityExpression) }
        if nil != my._EQUAL_EQUAL{  list.Add(my._EQUAL_EQUAL) }
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        return list
    }

func (my *EqualityExpression0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EqualityExpression0)       Enter(v Visitor){
        var checkChildren = v.VisitEqualityExpression0(my)
        if checkChildren{
            if nil != my._EqualityExpression{my._EqualityExpression.Accept(v)}
            if nil != my._EQUAL_EQUAL{my._EQUAL_EQUAL.Accept(v)}
            if nil != my._RelationalExpression{my._RelationalExpression.Accept(v)}
        }
        v.EndVisitEqualityExpression0(my)
    }


func AnyCastToEqualityExpression0(i interface{}) *EqualityExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*EqualityExpression0)
	}
}
/**
 *<b>
*<li>Rule 415:  EqualityExpression ::= EqualityExpression != RelationalExpression
 *</b>
 */
type EqualityExpression1 struct{
    *Ast
      _EqualityExpression IEqualityExpression
      _NOT_EQUAL *AstToken
      _RelationalExpression IRelationalExpression
}
func (my *EqualityExpression1)      GetEqualityExpression() IEqualityExpression{ return my._EqualityExpression}
func (my *EqualityExpression1)      SetEqualityExpression( _EqualityExpression IEqualityExpression)  { my._EqualityExpression = _EqualityExpression }
func (my *EqualityExpression1)      GetNOT_EQUAL() *AstToken{ return my._NOT_EQUAL}
func (my *EqualityExpression1)      SetNOT_EQUAL( _NOT_EQUAL *AstToken)  { my._NOT_EQUAL = _NOT_EQUAL }
func (my *EqualityExpression1)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *EqualityExpression1)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }

func NewEqualityExpression1(leftIToken IToken, rightIToken IToken ,
              _EqualityExpression IEqualityExpression,
              _NOT_EQUAL *AstToken,
              _RelationalExpression IRelationalExpression)*EqualityExpression1{
      my := new(EqualityExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._EqualityExpression = _EqualityExpression;
        if nil != _EqualityExpression{
        var trait_ interface{} = _EqualityExpression
         trait_.(IAst).SetParent(my)
}
        my._NOT_EQUAL = _NOT_EQUAL;
        if nil != _NOT_EQUAL{
        var trait_ interface{} = _NOT_EQUAL
         trait_.(IAst).SetParent(my)
}
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EqualityExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._EqualityExpression{  list.Add(my._EqualityExpression) }
        if nil != my._NOT_EQUAL{  list.Add(my._NOT_EQUAL) }
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        return list
    }

func (my *EqualityExpression1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *EqualityExpression1)       Enter(v Visitor){
        var checkChildren = v.VisitEqualityExpression1(my)
        if checkChildren{
            if nil != my._EqualityExpression{my._EqualityExpression.Accept(v)}
            if nil != my._NOT_EQUAL{my._NOT_EQUAL.Accept(v)}
            if nil != my._RelationalExpression{my._RelationalExpression.Accept(v)}
        }
        v.EndVisitEqualityExpression1(my)
    }


func AnyCastToEqualityExpression1(i interface{}) *EqualityExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*EqualityExpression1)
	}
}
/**
 *<b>
*<li>Rule 434:  AssignmentOperator ::= =
 *</b>
 */
type AssignmentOperator0 struct{
    *AstToken
}
func (my *AssignmentOperator0)      GetEQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator0(token IToken )*AssignmentOperator0{
      my := new(AssignmentOperator0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator0)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator0)       Enter(v Visitor){
        v.VisitAssignmentOperator0(my)
        v.EndVisitAssignmentOperator0(my)
    }


func AnyCastToAssignmentOperator0(i interface{}) *AssignmentOperator0 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator0)
	}
}
/**
 *<b>
*<li>Rule 435:  AssignmentOperator ::= *=
 *</b>
 */
type AssignmentOperator1 struct{
    *AstToken
}
func (my *AssignmentOperator1)      GetMULTIPLY_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator1(token IToken )*AssignmentOperator1{
      my := new(AssignmentOperator1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator1)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator1)       Enter(v Visitor){
        v.VisitAssignmentOperator1(my)
        v.EndVisitAssignmentOperator1(my)
    }


func AnyCastToAssignmentOperator1(i interface{}) *AssignmentOperator1 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator1)
	}
}
/**
 *<b>
*<li>Rule 436:  AssignmentOperator ::= /=
 *</b>
 */
type AssignmentOperator2 struct{
    *AstToken
}
func (my *AssignmentOperator2)      GetDIVIDE_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator2(token IToken )*AssignmentOperator2{
      my := new(AssignmentOperator2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator2)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator2)       Enter(v Visitor){
        v.VisitAssignmentOperator2(my)
        v.EndVisitAssignmentOperator2(my)
    }


func AnyCastToAssignmentOperator2(i interface{}) *AssignmentOperator2 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator2)
	}
}
/**
 *<b>
*<li>Rule 437:  AssignmentOperator ::= %=
 *</b>
 */
type AssignmentOperator3 struct{
    *AstToken
}
func (my *AssignmentOperator3)      GetREMAINDER_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator3(token IToken )*AssignmentOperator3{
      my := new(AssignmentOperator3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator3)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator3)       Enter(v Visitor){
        v.VisitAssignmentOperator3(my)
        v.EndVisitAssignmentOperator3(my)
    }


func AnyCastToAssignmentOperator3(i interface{}) *AssignmentOperator3 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator3)
	}
}
/**
 *<b>
*<li>Rule 438:  AssignmentOperator ::= +=
 *</b>
 */
type AssignmentOperator4 struct{
    *AstToken
}
func (my *AssignmentOperator4)      GetPLUS_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator4(token IToken )*AssignmentOperator4{
      my := new(AssignmentOperator4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator4)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator4)       Enter(v Visitor){
        v.VisitAssignmentOperator4(my)
        v.EndVisitAssignmentOperator4(my)
    }


func AnyCastToAssignmentOperator4(i interface{}) *AssignmentOperator4 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator4)
	}
}
/**
 *<b>
*<li>Rule 439:  AssignmentOperator ::= -=
 *</b>
 */
type AssignmentOperator5 struct{
    *AstToken
}
func (my *AssignmentOperator5)      GetMINUS_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator5(token IToken )*AssignmentOperator5{
      my := new(AssignmentOperator5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator5)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator5)       Enter(v Visitor){
        v.VisitAssignmentOperator5(my)
        v.EndVisitAssignmentOperator5(my)
    }


func AnyCastToAssignmentOperator5(i interface{}) *AssignmentOperator5 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator5)
	}
}
/**
 *<b>
*<li>Rule 440:  AssignmentOperator ::= <<=
 *</b>
 */
type AssignmentOperator6 struct{
    *AstToken
}
func (my *AssignmentOperator6)      GetLEFT_SHIFT_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator6(token IToken )*AssignmentOperator6{
      my := new(AssignmentOperator6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator6)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator6)       Enter(v Visitor){
        v.VisitAssignmentOperator6(my)
        v.EndVisitAssignmentOperator6(my)
    }


func AnyCastToAssignmentOperator6(i interface{}) *AssignmentOperator6 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator6)
	}
}
/**
 *<b>
*<li>Rule 441:  AssignmentOperator ::= > > =
 *</b>
 */
type AssignmentOperator7 struct{
    *Ast
      _GREATER *AstToken
      _GREATER2 *AstToken
      _EQUAL *AstToken
}
func (my *AssignmentOperator7)      GetGREATER() *AstToken{ return my._GREATER}
func (my *AssignmentOperator7)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *AssignmentOperator7)      GetGREATER2() *AstToken{ return my._GREATER2}
func (my *AssignmentOperator7)      SetGREATER2( _GREATER2 *AstToken)  { my._GREATER2 = _GREATER2 }
func (my *AssignmentOperator7)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *AssignmentOperator7)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }

func NewAssignmentOperator7(leftIToken IToken, rightIToken IToken ,
              _GREATER *AstToken,
              _GREATER2 *AstToken,
              _EQUAL *AstToken)*AssignmentOperator7{
      my := new(AssignmentOperator7)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._GREATER2 = _GREATER2;
        if nil != _GREATER2{
        var trait_ interface{} = _GREATER2
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AssignmentOperator7)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._GREATER2{  list.Add(my._GREATER2) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        return list
    }

func (my *AssignmentOperator7)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator7)       Enter(v Visitor){
        var checkChildren = v.VisitAssignmentOperator7(my)
        if checkChildren{
            if nil != my._GREATER{my._GREATER.Accept(v)}
            if nil != my._GREATER2{my._GREATER2.Accept(v)}
            if nil != my._EQUAL{my._EQUAL.Accept(v)}
        }
        v.EndVisitAssignmentOperator7(my)
    }


func AnyCastToAssignmentOperator7(i interface{}) *AssignmentOperator7 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator7)
	}
}
/**
 *<b>
*<li>Rule 442:  AssignmentOperator ::= > > > =
 *</b>
 */
type AssignmentOperator8 struct{
    *Ast
      _GREATER *AstToken
      _GREATER2 *AstToken
      _GREATER3 *AstToken
      _EQUAL *AstToken
}
func (my *AssignmentOperator8)      GetGREATER() *AstToken{ return my._GREATER}
func (my *AssignmentOperator8)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *AssignmentOperator8)      GetGREATER2() *AstToken{ return my._GREATER2}
func (my *AssignmentOperator8)      SetGREATER2( _GREATER2 *AstToken)  { my._GREATER2 = _GREATER2 }
func (my *AssignmentOperator8)      GetGREATER3() *AstToken{ return my._GREATER3}
func (my *AssignmentOperator8)      SetGREATER3( _GREATER3 *AstToken)  { my._GREATER3 = _GREATER3 }
func (my *AssignmentOperator8)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *AssignmentOperator8)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }

func NewAssignmentOperator8(leftIToken IToken, rightIToken IToken ,
              _GREATER *AstToken,
              _GREATER2 *AstToken,
              _GREATER3 *AstToken,
              _EQUAL *AstToken)*AssignmentOperator8{
      my := new(AssignmentOperator8)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._GREATER2 = _GREATER2;
        if nil != _GREATER2{
        var trait_ interface{} = _GREATER2
         trait_.(IAst).SetParent(my)
}
        my._GREATER3 = _GREATER3;
        if nil != _GREATER3{
        var trait_ interface{} = _GREATER3
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AssignmentOperator8)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._GREATER2{  list.Add(my._GREATER2) }
        if nil != my._GREATER3{  list.Add(my._GREATER3) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        return list
    }

func (my *AssignmentOperator8)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator8)       Enter(v Visitor){
        var checkChildren = v.VisitAssignmentOperator8(my)
        if checkChildren{
            if nil != my._GREATER{my._GREATER.Accept(v)}
            if nil != my._GREATER2{my._GREATER2.Accept(v)}
            if nil != my._GREATER3{my._GREATER3.Accept(v)}
            if nil != my._EQUAL{my._EQUAL.Accept(v)}
        }
        v.EndVisitAssignmentOperator8(my)
    }


func AnyCastToAssignmentOperator8(i interface{}) *AssignmentOperator8 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator8)
	}
}
/**
 *<b>
*<li>Rule 443:  AssignmentOperator ::= &=
 *</b>
 */
type AssignmentOperator9 struct{
    *AstToken
}
func (my *AssignmentOperator9)      GetAND_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator9(token IToken )*AssignmentOperator9{
      my := new(AssignmentOperator9)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator9)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator9)       Enter(v Visitor){
        v.VisitAssignmentOperator9(my)
        v.EndVisitAssignmentOperator9(my)
    }


func AnyCastToAssignmentOperator9(i interface{}) *AssignmentOperator9 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator9)
	}
}
/**
 *<b>
*<li>Rule 444:  AssignmentOperator ::= ^=
 *</b>
 */
type AssignmentOperator10 struct{
    *AstToken
}
func (my *AssignmentOperator10)      GetXOR_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator10(token IToken )*AssignmentOperator10{
      my := new(AssignmentOperator10)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator10)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator10)       Enter(v Visitor){
        v.VisitAssignmentOperator10(my)
        v.EndVisitAssignmentOperator10(my)
    }


func AnyCastToAssignmentOperator10(i interface{}) *AssignmentOperator10 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator10)
	}
}
/**
 *<b>
*<li>Rule 445:  AssignmentOperator ::= |=
 *</b>
 */
type AssignmentOperator11 struct{
    *AstToken
}
func (my *AssignmentOperator11)      GetOR_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator11(token IToken )*AssignmentOperator11{
      my := new(AssignmentOperator11)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator11)       Accept(v IAstVisitor){
        if ! v.PreVisit(my){ return }
        var _ctor ,_ = v.(Visitor)
        my.Enter(_ctor)
        v.PostVisit(my)
}

func (my *AssignmentOperator11)       Enter(v Visitor){
        v.VisitAssignmentOperator11(my)
        v.EndVisitAssignmentOperator11(my)
    }


func AnyCastToAssignmentOperator11(i interface{}) *AssignmentOperator11 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator11)
	}
}
type Visitor interface{
  IAstVisitor
    Visit(n  IAst) bool
    EndVisit(n IAst)

    VisitAstToken(n *AstToken) bool
    EndVisitAstToken(n *AstToken)

    Visitidentifier(n *identifier) bool
    EndVisitidentifier(n *identifier)

    VisitPrimitiveType(n *PrimitiveType) bool
    EndVisitPrimitiveType(n *PrimitiveType)

    VisitClassType(n *ClassType) bool
    EndVisitClassType(n *ClassType)

    VisitInterfaceType(n *InterfaceType) bool
    EndVisitInterfaceType(n *InterfaceType)

    VisitTypeName(n *TypeName) bool
    EndVisitTypeName(n *TypeName)

    VisitArrayType(n *ArrayType) bool
    EndVisitArrayType(n *ArrayType)

    VisitTypeParameter(n *TypeParameter) bool
    EndVisitTypeParameter(n *TypeParameter)

    VisitTypeBound(n *TypeBound) bool
    EndVisitTypeBound(n *TypeBound)

    VisitAdditionalBoundList(n *AdditionalBoundList) bool
    EndVisitAdditionalBoundList(n *AdditionalBoundList)

    VisitAdditionalBound(n *AdditionalBound) bool
    EndVisitAdditionalBound(n *AdditionalBound)

    VisitTypeArguments(n *TypeArguments) bool
    EndVisitTypeArguments(n *TypeArguments)

    VisitActualTypeArgumentList(n *ActualTypeArgumentList) bool
    EndVisitActualTypeArgumentList(n *ActualTypeArgumentList)

    VisitWildcard(n *Wildcard) bool
    EndVisitWildcard(n *Wildcard)

    VisitPackageName(n *PackageName) bool
    EndVisitPackageName(n *PackageName)

    VisitExpressionName(n *ExpressionName) bool
    EndVisitExpressionName(n *ExpressionName)

    VisitMethodName(n *MethodName) bool
    EndVisitMethodName(n *MethodName)

    VisitPackageOrTypeName(n *PackageOrTypeName) bool
    EndVisitPackageOrTypeName(n *PackageOrTypeName)

    VisitAmbiguousName(n *AmbiguousName) bool
    EndVisitAmbiguousName(n *AmbiguousName)

    VisitCompilationUnit(n *CompilationUnit) bool
    EndVisitCompilationUnit(n *CompilationUnit)

    VisitImportDeclarations(n *ImportDeclarations) bool
    EndVisitImportDeclarations(n *ImportDeclarations)

    VisitTypeDeclarations(n *TypeDeclarations) bool
    EndVisitTypeDeclarations(n *TypeDeclarations)

    VisitPackageDeclaration(n *PackageDeclaration) bool
    EndVisitPackageDeclaration(n *PackageDeclaration)

    VisitSingleTypeImportDeclaration(n *SingleTypeImportDeclaration) bool
    EndVisitSingleTypeImportDeclaration(n *SingleTypeImportDeclaration)

    VisitTypeImportOnDemandDeclaration(n *TypeImportOnDemandDeclaration) bool
    EndVisitTypeImportOnDemandDeclaration(n *TypeImportOnDemandDeclaration)

    VisitSingleStaticImportDeclaration(n *SingleStaticImportDeclaration) bool
    EndVisitSingleStaticImportDeclaration(n *SingleStaticImportDeclaration)

    VisitStaticImportOnDemandDeclaration(n *StaticImportOnDemandDeclaration) bool
    EndVisitStaticImportOnDemandDeclaration(n *StaticImportOnDemandDeclaration)

    VisitTypeDeclaration(n *TypeDeclaration) bool
    EndVisitTypeDeclaration(n *TypeDeclaration)

    VisitNormalClassDeclaration(n *NormalClassDeclaration) bool
    EndVisitNormalClassDeclaration(n *NormalClassDeclaration)

    VisitClassModifiers(n *ClassModifiers) bool
    EndVisitClassModifiers(n *ClassModifiers)

    VisitTypeParameters(n *TypeParameters) bool
    EndVisitTypeParameters(n *TypeParameters)

    VisitTypeParameterList(n *TypeParameterList) bool
    EndVisitTypeParameterList(n *TypeParameterList)

    VisitSuper(n *Super) bool
    EndVisitSuper(n *Super)

    VisitInterfaces(n *Interfaces) bool
    EndVisitInterfaces(n *Interfaces)

    VisitInterfaceTypeList(n *InterfaceTypeList) bool
    EndVisitInterfaceTypeList(n *InterfaceTypeList)

    VisitClassBody(n *ClassBody) bool
    EndVisitClassBody(n *ClassBody)

    VisitClassBodyDeclarations(n *ClassBodyDeclarations) bool
    EndVisitClassBodyDeclarations(n *ClassBodyDeclarations)

    VisitClassMemberDeclaration(n *ClassMemberDeclaration) bool
    EndVisitClassMemberDeclaration(n *ClassMemberDeclaration)

    VisitFieldDeclaration(n *FieldDeclaration) bool
    EndVisitFieldDeclaration(n *FieldDeclaration)

    VisitVariableDeclarators(n *VariableDeclarators) bool
    EndVisitVariableDeclarators(n *VariableDeclarators)

    VisitVariableDeclarator(n *VariableDeclarator) bool
    EndVisitVariableDeclarator(n *VariableDeclarator)

    VisitVariableDeclaratorId(n *VariableDeclaratorId) bool
    EndVisitVariableDeclaratorId(n *VariableDeclaratorId)

    VisitFieldModifiers(n *FieldModifiers) bool
    EndVisitFieldModifiers(n *FieldModifiers)

    VisitMethodDeclaration(n *MethodDeclaration) bool
    EndVisitMethodDeclaration(n *MethodDeclaration)

    VisitMethodHeader(n *MethodHeader) bool
    EndVisitMethodHeader(n *MethodHeader)

    VisitResultType(n *ResultType) bool
    EndVisitResultType(n *ResultType)

    VisitFormalParameterList(n *FormalParameterList) bool
    EndVisitFormalParameterList(n *FormalParameterList)

    VisitFormalParameters(n *FormalParameters) bool
    EndVisitFormalParameters(n *FormalParameters)

    VisitFormalParameter(n *FormalParameter) bool
    EndVisitFormalParameter(n *FormalParameter)

    VisitVariableModifiers(n *VariableModifiers) bool
    EndVisitVariableModifiers(n *VariableModifiers)

    VisitVariableModifier(n *VariableModifier) bool
    EndVisitVariableModifier(n *VariableModifier)

    VisitLastFormalParameter(n *LastFormalParameter) bool
    EndVisitLastFormalParameter(n *LastFormalParameter)

    VisitMethodModifiers(n *MethodModifiers) bool
    EndVisitMethodModifiers(n *MethodModifiers)

    VisitThrows(n *Throws) bool
    EndVisitThrows(n *Throws)

    VisitExceptionTypeList(n *ExceptionTypeList) bool
    EndVisitExceptionTypeList(n *ExceptionTypeList)

    VisitMethodBody(n *MethodBody) bool
    EndVisitMethodBody(n *MethodBody)

    VisitStaticInitializer(n *StaticInitializer) bool
    EndVisitStaticInitializer(n *StaticInitializer)

    VisitConstructorDeclaration(n *ConstructorDeclaration) bool
    EndVisitConstructorDeclaration(n *ConstructorDeclaration)

    VisitConstructorDeclarator(n *ConstructorDeclarator) bool
    EndVisitConstructorDeclarator(n *ConstructorDeclarator)

    VisitConstructorModifiers(n *ConstructorModifiers) bool
    EndVisitConstructorModifiers(n *ConstructorModifiers)

    VisitConstructorBody(n *ConstructorBody) bool
    EndVisitConstructorBody(n *ConstructorBody)

    VisitEnumDeclaration(n *EnumDeclaration) bool
    EndVisitEnumDeclaration(n *EnumDeclaration)

    VisitEnumBody(n *EnumBody) bool
    EndVisitEnumBody(n *EnumBody)

    VisitEnumConstants(n *EnumConstants) bool
    EndVisitEnumConstants(n *EnumConstants)

    VisitEnumConstant(n *EnumConstant) bool
    EndVisitEnumConstant(n *EnumConstant)

    VisitArguments(n *Arguments) bool
    EndVisitArguments(n *Arguments)

    VisitEnumBodyDeclarations(n *EnumBodyDeclarations) bool
    EndVisitEnumBodyDeclarations(n *EnumBodyDeclarations)

    VisitNormalInterfaceDeclaration(n *NormalInterfaceDeclaration) bool
    EndVisitNormalInterfaceDeclaration(n *NormalInterfaceDeclaration)

    VisitInterfaceModifiers(n *InterfaceModifiers) bool
    EndVisitInterfaceModifiers(n *InterfaceModifiers)

    VisitInterfaceBody(n *InterfaceBody) bool
    EndVisitInterfaceBody(n *InterfaceBody)

    VisitInterfaceMemberDeclarations(n *InterfaceMemberDeclarations) bool
    EndVisitInterfaceMemberDeclarations(n *InterfaceMemberDeclarations)

    VisitInterfaceMemberDeclaration(n *InterfaceMemberDeclaration) bool
    EndVisitInterfaceMemberDeclaration(n *InterfaceMemberDeclaration)

    VisitConstantDeclaration(n *ConstantDeclaration) bool
    EndVisitConstantDeclaration(n *ConstantDeclaration)

    VisitConstantModifiers(n *ConstantModifiers) bool
    EndVisitConstantModifiers(n *ConstantModifiers)

    VisitAbstractMethodDeclaration(n *AbstractMethodDeclaration) bool
    EndVisitAbstractMethodDeclaration(n *AbstractMethodDeclaration)

    VisitAbstractMethodModifiers(n *AbstractMethodModifiers) bool
    EndVisitAbstractMethodModifiers(n *AbstractMethodModifiers)

    VisitAnnotationTypeDeclaration(n *AnnotationTypeDeclaration) bool
    EndVisitAnnotationTypeDeclaration(n *AnnotationTypeDeclaration)

    VisitAnnotationTypeBody(n *AnnotationTypeBody) bool
    EndVisitAnnotationTypeBody(n *AnnotationTypeBody)

    VisitAnnotationTypeElementDeclarations(n *AnnotationTypeElementDeclarations) bool
    EndVisitAnnotationTypeElementDeclarations(n *AnnotationTypeElementDeclarations)

    VisitDefaultValue(n *DefaultValue) bool
    EndVisitDefaultValue(n *DefaultValue)

    VisitAnnotations(n *Annotations) bool
    EndVisitAnnotations(n *Annotations)

    VisitNormalAnnotation(n *NormalAnnotation) bool
    EndVisitNormalAnnotation(n *NormalAnnotation)

    VisitElementValuePairs(n *ElementValuePairs) bool
    EndVisitElementValuePairs(n *ElementValuePairs)

    VisitElementValuePair(n *ElementValuePair) bool
    EndVisitElementValuePair(n *ElementValuePair)

    VisitElementValueArrayInitializer(n *ElementValueArrayInitializer) bool
    EndVisitElementValueArrayInitializer(n *ElementValueArrayInitializer)

    VisitElementValues(n *ElementValues) bool
    EndVisitElementValues(n *ElementValues)

    VisitMarkerAnnotation(n *MarkerAnnotation) bool
    EndVisitMarkerAnnotation(n *MarkerAnnotation)

    VisitSingleElementAnnotation(n *SingleElementAnnotation) bool
    EndVisitSingleElementAnnotation(n *SingleElementAnnotation)

    VisitArrayInitializer(n *ArrayInitializer) bool
    EndVisitArrayInitializer(n *ArrayInitializer)

    VisitVariableInitializers(n *VariableInitializers) bool
    EndVisitVariableInitializers(n *VariableInitializers)

    VisitBlock(n *Block) bool
    EndVisitBlock(n *Block)

    VisitBlockStatements(n *BlockStatements) bool
    EndVisitBlockStatements(n *BlockStatements)

    VisitLocalVariableDeclarationStatement(n *LocalVariableDeclarationStatement) bool
    EndVisitLocalVariableDeclarationStatement(n *LocalVariableDeclarationStatement)

    VisitLocalVariableDeclaration(n *LocalVariableDeclaration) bool
    EndVisitLocalVariableDeclaration(n *LocalVariableDeclaration)

    VisitIfThenStatement(n *IfThenStatement) bool
    EndVisitIfThenStatement(n *IfThenStatement)

    VisitIfThenElseStatement(n *IfThenElseStatement) bool
    EndVisitIfThenElseStatement(n *IfThenElseStatement)

    VisitIfThenElseStatementNoShortIf(n *IfThenElseStatementNoShortIf) bool
    EndVisitIfThenElseStatementNoShortIf(n *IfThenElseStatementNoShortIf)

    VisitEmptyStatement(n *EmptyStatement) bool
    EndVisitEmptyStatement(n *EmptyStatement)

    VisitLabeledStatement(n *LabeledStatement) bool
    EndVisitLabeledStatement(n *LabeledStatement)

    VisitLabeledStatementNoShortIf(n *LabeledStatementNoShortIf) bool
    EndVisitLabeledStatementNoShortIf(n *LabeledStatementNoShortIf)

    VisitExpressionStatement(n *ExpressionStatement) bool
    EndVisitExpressionStatement(n *ExpressionStatement)

    VisitSwitchStatement(n *SwitchStatement) bool
    EndVisitSwitchStatement(n *SwitchStatement)

    VisitSwitchBlock(n *SwitchBlock) bool
    EndVisitSwitchBlock(n *SwitchBlock)

    VisitSwitchBlockStatementGroups(n *SwitchBlockStatementGroups) bool
    EndVisitSwitchBlockStatementGroups(n *SwitchBlockStatementGroups)

    VisitSwitchBlockStatementGroup(n *SwitchBlockStatementGroup) bool
    EndVisitSwitchBlockStatementGroup(n *SwitchBlockStatementGroup)

    VisitSwitchLabels(n *SwitchLabels) bool
    EndVisitSwitchLabels(n *SwitchLabels)

    VisitWhileStatement(n *WhileStatement) bool
    EndVisitWhileStatement(n *WhileStatement)

    VisitWhileStatementNoShortIf(n *WhileStatementNoShortIf) bool
    EndVisitWhileStatementNoShortIf(n *WhileStatementNoShortIf)

    VisitDoStatement(n *DoStatement) bool
    EndVisitDoStatement(n *DoStatement)

    VisitBasicForStatement(n *BasicForStatement) bool
    EndVisitBasicForStatement(n *BasicForStatement)

    VisitForStatementNoShortIf(n *ForStatementNoShortIf) bool
    EndVisitForStatementNoShortIf(n *ForStatementNoShortIf)

    VisitStatementExpressionList(n *StatementExpressionList) bool
    EndVisitStatementExpressionList(n *StatementExpressionList)

    VisitEnhancedForStatement(n *EnhancedForStatement) bool
    EndVisitEnhancedForStatement(n *EnhancedForStatement)

    VisitBreakStatement(n *BreakStatement) bool
    EndVisitBreakStatement(n *BreakStatement)

    VisitContinueStatement(n *ContinueStatement) bool
    EndVisitContinueStatement(n *ContinueStatement)

    VisitReturnStatement(n *ReturnStatement) bool
    EndVisitReturnStatement(n *ReturnStatement)

    VisitThrowStatement(n *ThrowStatement) bool
    EndVisitThrowStatement(n *ThrowStatement)

    VisitSynchronizedStatement(n *SynchronizedStatement) bool
    EndVisitSynchronizedStatement(n *SynchronizedStatement)

    VisitCatches(n *Catches) bool
    EndVisitCatches(n *Catches)

    VisitCatchClause(n *CatchClause) bool
    EndVisitCatchClause(n *CatchClause)

    VisitFinally(n *Finally) bool
    EndVisitFinally(n *Finally)

    VisitArgumentList(n *ArgumentList) bool
    EndVisitArgumentList(n *ArgumentList)

    VisitDimExprs(n *DimExprs) bool
    EndVisitDimExprs(n *DimExprs)

    VisitDimExpr(n *DimExpr) bool
    EndVisitDimExpr(n *DimExpr)

    VisitPostIncrementExpression(n *PostIncrementExpression) bool
    EndVisitPostIncrementExpression(n *PostIncrementExpression)

    VisitPostDecrementExpression(n *PostDecrementExpression) bool
    EndVisitPostDecrementExpression(n *PostDecrementExpression)

    VisitPreIncrementExpression(n *PreIncrementExpression) bool
    EndVisitPreIncrementExpression(n *PreIncrementExpression)

    VisitPreDecrementExpression(n *PreDecrementExpression) bool
    EndVisitPreDecrementExpression(n *PreDecrementExpression)

    VisitAndExpression(n *AndExpression) bool
    EndVisitAndExpression(n *AndExpression)

    VisitExclusiveOrExpression(n *ExclusiveOrExpression) bool
    EndVisitExclusiveOrExpression(n *ExclusiveOrExpression)

    VisitInclusiveOrExpression(n *InclusiveOrExpression) bool
    EndVisitInclusiveOrExpression(n *InclusiveOrExpression)

    VisitConditionalAndExpression(n *ConditionalAndExpression) bool
    EndVisitConditionalAndExpression(n *ConditionalAndExpression)

    VisitConditionalOrExpression(n *ConditionalOrExpression) bool
    EndVisitConditionalOrExpression(n *ConditionalOrExpression)

    VisitConditionalExpression(n *ConditionalExpression) bool
    EndVisitConditionalExpression(n *ConditionalExpression)

    VisitAssignment(n *Assignment) bool
    EndVisitAssignment(n *Assignment)

    VisitCommaopt(n *Commaopt) bool
    EndVisitCommaopt(n *Commaopt)

    VisitEllipsisopt(n *Ellipsisopt) bool
    EndVisitEllipsisopt(n *Ellipsisopt)

    VisitLPGUserAction0(n *LPGUserAction0) bool
    EndVisitLPGUserAction0(n *LPGUserAction0)

    VisitLPGUserAction1(n *LPGUserAction1) bool
    EndVisitLPGUserAction1(n *LPGUserAction1)

    VisitLPGUserAction2(n *LPGUserAction2) bool
    EndVisitLPGUserAction2(n *LPGUserAction2)

    VisitLPGUserAction3(n *LPGUserAction3) bool
    EndVisitLPGUserAction3(n *LPGUserAction3)

    VisitLPGUserAction4(n *LPGUserAction4) bool
    EndVisitLPGUserAction4(n *LPGUserAction4)

    VisitIntegralType0(n *IntegralType0) bool
    EndVisitIntegralType0(n *IntegralType0)

    VisitIntegralType1(n *IntegralType1) bool
    EndVisitIntegralType1(n *IntegralType1)

    VisitIntegralType2(n *IntegralType2) bool
    EndVisitIntegralType2(n *IntegralType2)

    VisitIntegralType3(n *IntegralType3) bool
    EndVisitIntegralType3(n *IntegralType3)

    VisitIntegralType4(n *IntegralType4) bool
    EndVisitIntegralType4(n *IntegralType4)

    VisitFloatingPointType0(n *FloatingPointType0) bool
    EndVisitFloatingPointType0(n *FloatingPointType0)

    VisitFloatingPointType1(n *FloatingPointType1) bool
    EndVisitFloatingPointType1(n *FloatingPointType1)

    VisitWildcardBounds0(n *WildcardBounds0) bool
    EndVisitWildcardBounds0(n *WildcardBounds0)

    VisitWildcardBounds1(n *WildcardBounds1) bool
    EndVisitWildcardBounds1(n *WildcardBounds1)

    VisitClassModifier0(n *ClassModifier0) bool
    EndVisitClassModifier0(n *ClassModifier0)

    VisitClassModifier1(n *ClassModifier1) bool
    EndVisitClassModifier1(n *ClassModifier1)

    VisitClassModifier2(n *ClassModifier2) bool
    EndVisitClassModifier2(n *ClassModifier2)

    VisitClassModifier3(n *ClassModifier3) bool
    EndVisitClassModifier3(n *ClassModifier3)

    VisitClassModifier4(n *ClassModifier4) bool
    EndVisitClassModifier4(n *ClassModifier4)

    VisitClassModifier5(n *ClassModifier5) bool
    EndVisitClassModifier5(n *ClassModifier5)

    VisitClassModifier6(n *ClassModifier6) bool
    EndVisitClassModifier6(n *ClassModifier6)

    VisitFieldModifier0(n *FieldModifier0) bool
    EndVisitFieldModifier0(n *FieldModifier0)

    VisitFieldModifier1(n *FieldModifier1) bool
    EndVisitFieldModifier1(n *FieldModifier1)

    VisitFieldModifier2(n *FieldModifier2) bool
    EndVisitFieldModifier2(n *FieldModifier2)

    VisitFieldModifier3(n *FieldModifier3) bool
    EndVisitFieldModifier3(n *FieldModifier3)

    VisitFieldModifier4(n *FieldModifier4) bool
    EndVisitFieldModifier4(n *FieldModifier4)

    VisitFieldModifier5(n *FieldModifier5) bool
    EndVisitFieldModifier5(n *FieldModifier5)

    VisitFieldModifier6(n *FieldModifier6) bool
    EndVisitFieldModifier6(n *FieldModifier6)

    VisitMethodDeclarator0(n *MethodDeclarator0) bool
    EndVisitMethodDeclarator0(n *MethodDeclarator0)

    VisitMethodDeclarator1(n *MethodDeclarator1) bool
    EndVisitMethodDeclarator1(n *MethodDeclarator1)

    VisitMethodModifier0(n *MethodModifier0) bool
    EndVisitMethodModifier0(n *MethodModifier0)

    VisitMethodModifier1(n *MethodModifier1) bool
    EndVisitMethodModifier1(n *MethodModifier1)

    VisitMethodModifier2(n *MethodModifier2) bool
    EndVisitMethodModifier2(n *MethodModifier2)

    VisitMethodModifier3(n *MethodModifier3) bool
    EndVisitMethodModifier3(n *MethodModifier3)

    VisitMethodModifier4(n *MethodModifier4) bool
    EndVisitMethodModifier4(n *MethodModifier4)

    VisitMethodModifier5(n *MethodModifier5) bool
    EndVisitMethodModifier5(n *MethodModifier5)

    VisitMethodModifier6(n *MethodModifier6) bool
    EndVisitMethodModifier6(n *MethodModifier6)

    VisitMethodModifier7(n *MethodModifier7) bool
    EndVisitMethodModifier7(n *MethodModifier7)

    VisitMethodModifier8(n *MethodModifier8) bool
    EndVisitMethodModifier8(n *MethodModifier8)

    VisitConstructorModifier0(n *ConstructorModifier0) bool
    EndVisitConstructorModifier0(n *ConstructorModifier0)

    VisitConstructorModifier1(n *ConstructorModifier1) bool
    EndVisitConstructorModifier1(n *ConstructorModifier1)

    VisitConstructorModifier2(n *ConstructorModifier2) bool
    EndVisitConstructorModifier2(n *ConstructorModifier2)

    VisitExplicitConstructorInvocation0(n *ExplicitConstructorInvocation0) bool
    EndVisitExplicitConstructorInvocation0(n *ExplicitConstructorInvocation0)

    VisitExplicitConstructorInvocation1(n *ExplicitConstructorInvocation1) bool
    EndVisitExplicitConstructorInvocation1(n *ExplicitConstructorInvocation1)

    VisitExplicitConstructorInvocation2(n *ExplicitConstructorInvocation2) bool
    EndVisitExplicitConstructorInvocation2(n *ExplicitConstructorInvocation2)

    VisitInterfaceModifier0(n *InterfaceModifier0) bool
    EndVisitInterfaceModifier0(n *InterfaceModifier0)

    VisitInterfaceModifier1(n *InterfaceModifier1) bool
    EndVisitInterfaceModifier1(n *InterfaceModifier1)

    VisitInterfaceModifier2(n *InterfaceModifier2) bool
    EndVisitInterfaceModifier2(n *InterfaceModifier2)

    VisitInterfaceModifier3(n *InterfaceModifier3) bool
    EndVisitInterfaceModifier3(n *InterfaceModifier3)

    VisitInterfaceModifier4(n *InterfaceModifier4) bool
    EndVisitInterfaceModifier4(n *InterfaceModifier4)

    VisitInterfaceModifier5(n *InterfaceModifier5) bool
    EndVisitInterfaceModifier5(n *InterfaceModifier5)

    VisitExtendsInterfaces0(n *ExtendsInterfaces0) bool
    EndVisitExtendsInterfaces0(n *ExtendsInterfaces0)

    VisitExtendsInterfaces1(n *ExtendsInterfaces1) bool
    EndVisitExtendsInterfaces1(n *ExtendsInterfaces1)

    VisitConstantModifier0(n *ConstantModifier0) bool
    EndVisitConstantModifier0(n *ConstantModifier0)

    VisitConstantModifier1(n *ConstantModifier1) bool
    EndVisitConstantModifier1(n *ConstantModifier1)

    VisitConstantModifier2(n *ConstantModifier2) bool
    EndVisitConstantModifier2(n *ConstantModifier2)

    VisitAbstractMethodModifier0(n *AbstractMethodModifier0) bool
    EndVisitAbstractMethodModifier0(n *AbstractMethodModifier0)

    VisitAbstractMethodModifier1(n *AbstractMethodModifier1) bool
    EndVisitAbstractMethodModifier1(n *AbstractMethodModifier1)

    VisitAnnotationTypeElementDeclaration0(n *AnnotationTypeElementDeclaration0) bool
    EndVisitAnnotationTypeElementDeclaration0(n *AnnotationTypeElementDeclaration0)

    VisitAnnotationTypeElementDeclaration1(n *AnnotationTypeElementDeclaration1) bool
    EndVisitAnnotationTypeElementDeclaration1(n *AnnotationTypeElementDeclaration1)

    VisitAssertStatement0(n *AssertStatement0) bool
    EndVisitAssertStatement0(n *AssertStatement0)

    VisitAssertStatement1(n *AssertStatement1) bool
    EndVisitAssertStatement1(n *AssertStatement1)

    VisitSwitchLabel0(n *SwitchLabel0) bool
    EndVisitSwitchLabel0(n *SwitchLabel0)

    VisitSwitchLabel1(n *SwitchLabel1) bool
    EndVisitSwitchLabel1(n *SwitchLabel1)

    VisitSwitchLabel2(n *SwitchLabel2) bool
    EndVisitSwitchLabel2(n *SwitchLabel2)

    VisitTryStatement0(n *TryStatement0) bool
    EndVisitTryStatement0(n *TryStatement0)

    VisitTryStatement1(n *TryStatement1) bool
    EndVisitTryStatement1(n *TryStatement1)

    VisitPrimaryNoNewArray0(n *PrimaryNoNewArray0) bool
    EndVisitPrimaryNoNewArray0(n *PrimaryNoNewArray0)

    VisitPrimaryNoNewArray1(n *PrimaryNoNewArray1) bool
    EndVisitPrimaryNoNewArray1(n *PrimaryNoNewArray1)

    VisitPrimaryNoNewArray2(n *PrimaryNoNewArray2) bool
    EndVisitPrimaryNoNewArray2(n *PrimaryNoNewArray2)

    VisitPrimaryNoNewArray3(n *PrimaryNoNewArray3) bool
    EndVisitPrimaryNoNewArray3(n *PrimaryNoNewArray3)

    VisitPrimaryNoNewArray4(n *PrimaryNoNewArray4) bool
    EndVisitPrimaryNoNewArray4(n *PrimaryNoNewArray4)

    VisitLiteral0(n *Literal0) bool
    EndVisitLiteral0(n *Literal0)

    VisitLiteral1(n *Literal1) bool
    EndVisitLiteral1(n *Literal1)

    VisitLiteral2(n *Literal2) bool
    EndVisitLiteral2(n *Literal2)

    VisitLiteral3(n *Literal3) bool
    EndVisitLiteral3(n *Literal3)

    VisitLiteral4(n *Literal4) bool
    EndVisitLiteral4(n *Literal4)

    VisitLiteral5(n *Literal5) bool
    EndVisitLiteral5(n *Literal5)

    VisitLiteral6(n *Literal6) bool
    EndVisitLiteral6(n *Literal6)

    VisitBooleanLiteral0(n *BooleanLiteral0) bool
    EndVisitBooleanLiteral0(n *BooleanLiteral0)

    VisitBooleanLiteral1(n *BooleanLiteral1) bool
    EndVisitBooleanLiteral1(n *BooleanLiteral1)

    VisitClassInstanceCreationExpression0(n *ClassInstanceCreationExpression0) bool
    EndVisitClassInstanceCreationExpression0(n *ClassInstanceCreationExpression0)

    VisitClassInstanceCreationExpression1(n *ClassInstanceCreationExpression1) bool
    EndVisitClassInstanceCreationExpression1(n *ClassInstanceCreationExpression1)

    VisitArrayCreationExpression0(n *ArrayCreationExpression0) bool
    EndVisitArrayCreationExpression0(n *ArrayCreationExpression0)

    VisitArrayCreationExpression1(n *ArrayCreationExpression1) bool
    EndVisitArrayCreationExpression1(n *ArrayCreationExpression1)

    VisitArrayCreationExpression2(n *ArrayCreationExpression2) bool
    EndVisitArrayCreationExpression2(n *ArrayCreationExpression2)

    VisitArrayCreationExpression3(n *ArrayCreationExpression3) bool
    EndVisitArrayCreationExpression3(n *ArrayCreationExpression3)

    VisitDims0(n *Dims0) bool
    EndVisitDims0(n *Dims0)

    VisitDims1(n *Dims1) bool
    EndVisitDims1(n *Dims1)

    VisitFieldAccess0(n *FieldAccess0) bool
    EndVisitFieldAccess0(n *FieldAccess0)

    VisitFieldAccess1(n *FieldAccess1) bool
    EndVisitFieldAccess1(n *FieldAccess1)

    VisitFieldAccess2(n *FieldAccess2) bool
    EndVisitFieldAccess2(n *FieldAccess2)

    VisitMethodInvocation0(n *MethodInvocation0) bool
    EndVisitMethodInvocation0(n *MethodInvocation0)

    VisitMethodInvocation1(n *MethodInvocation1) bool
    EndVisitMethodInvocation1(n *MethodInvocation1)

    VisitMethodInvocation2(n *MethodInvocation2) bool
    EndVisitMethodInvocation2(n *MethodInvocation2)

    VisitMethodInvocation3(n *MethodInvocation3) bool
    EndVisitMethodInvocation3(n *MethodInvocation3)

    VisitMethodInvocation4(n *MethodInvocation4) bool
    EndVisitMethodInvocation4(n *MethodInvocation4)

    VisitArrayAccess0(n *ArrayAccess0) bool
    EndVisitArrayAccess0(n *ArrayAccess0)

    VisitArrayAccess1(n *ArrayAccess1) bool
    EndVisitArrayAccess1(n *ArrayAccess1)

    VisitUnaryExpression0(n *UnaryExpression0) bool
    EndVisitUnaryExpression0(n *UnaryExpression0)

    VisitUnaryExpression1(n *UnaryExpression1) bool
    EndVisitUnaryExpression1(n *UnaryExpression1)

    VisitUnaryExpressionNotPlusMinus0(n *UnaryExpressionNotPlusMinus0) bool
    EndVisitUnaryExpressionNotPlusMinus0(n *UnaryExpressionNotPlusMinus0)

    VisitUnaryExpressionNotPlusMinus1(n *UnaryExpressionNotPlusMinus1) bool
    EndVisitUnaryExpressionNotPlusMinus1(n *UnaryExpressionNotPlusMinus1)

    VisitCastExpression0(n *CastExpression0) bool
    EndVisitCastExpression0(n *CastExpression0)

    VisitCastExpression1(n *CastExpression1) bool
    EndVisitCastExpression1(n *CastExpression1)

    VisitMultiplicativeExpression0(n *MultiplicativeExpression0) bool
    EndVisitMultiplicativeExpression0(n *MultiplicativeExpression0)

    VisitMultiplicativeExpression1(n *MultiplicativeExpression1) bool
    EndVisitMultiplicativeExpression1(n *MultiplicativeExpression1)

    VisitMultiplicativeExpression2(n *MultiplicativeExpression2) bool
    EndVisitMultiplicativeExpression2(n *MultiplicativeExpression2)

    VisitAdditiveExpression0(n *AdditiveExpression0) bool
    EndVisitAdditiveExpression0(n *AdditiveExpression0)

    VisitAdditiveExpression1(n *AdditiveExpression1) bool
    EndVisitAdditiveExpression1(n *AdditiveExpression1)

    VisitShiftExpression0(n *ShiftExpression0) bool
    EndVisitShiftExpression0(n *ShiftExpression0)

    VisitShiftExpression1(n *ShiftExpression1) bool
    EndVisitShiftExpression1(n *ShiftExpression1)

    VisitShiftExpression2(n *ShiftExpression2) bool
    EndVisitShiftExpression2(n *ShiftExpression2)

    VisitRelationalExpression0(n *RelationalExpression0) bool
    EndVisitRelationalExpression0(n *RelationalExpression0)

    VisitRelationalExpression1(n *RelationalExpression1) bool
    EndVisitRelationalExpression1(n *RelationalExpression1)

    VisitRelationalExpression2(n *RelationalExpression2) bool
    EndVisitRelationalExpression2(n *RelationalExpression2)

    VisitRelationalExpression3(n *RelationalExpression3) bool
    EndVisitRelationalExpression3(n *RelationalExpression3)

    VisitRelationalExpression4(n *RelationalExpression4) bool
    EndVisitRelationalExpression4(n *RelationalExpression4)

    VisitEqualityExpression0(n *EqualityExpression0) bool
    EndVisitEqualityExpression0(n *EqualityExpression0)

    VisitEqualityExpression1(n *EqualityExpression1) bool
    EndVisitEqualityExpression1(n *EqualityExpression1)

    VisitAssignmentOperator0(n *AssignmentOperator0) bool
    EndVisitAssignmentOperator0(n *AssignmentOperator0)

    VisitAssignmentOperator1(n *AssignmentOperator1) bool
    EndVisitAssignmentOperator1(n *AssignmentOperator1)

    VisitAssignmentOperator2(n *AssignmentOperator2) bool
    EndVisitAssignmentOperator2(n *AssignmentOperator2)

    VisitAssignmentOperator3(n *AssignmentOperator3) bool
    EndVisitAssignmentOperator3(n *AssignmentOperator3)

    VisitAssignmentOperator4(n *AssignmentOperator4) bool
    EndVisitAssignmentOperator4(n *AssignmentOperator4)

    VisitAssignmentOperator5(n *AssignmentOperator5) bool
    EndVisitAssignmentOperator5(n *AssignmentOperator5)

    VisitAssignmentOperator6(n *AssignmentOperator6) bool
    EndVisitAssignmentOperator6(n *AssignmentOperator6)

    VisitAssignmentOperator7(n *AssignmentOperator7) bool
    EndVisitAssignmentOperator7(n *AssignmentOperator7)

    VisitAssignmentOperator8(n *AssignmentOperator8) bool
    EndVisitAssignmentOperator8(n *AssignmentOperator8)

    VisitAssignmentOperator9(n *AssignmentOperator9) bool
    EndVisitAssignmentOperator9(n *AssignmentOperator9)

    VisitAssignmentOperator10(n *AssignmentOperator10) bool
    EndVisitAssignmentOperator10(n *AssignmentOperator10)

    VisitAssignmentOperator11(n *AssignmentOperator11) bool
    EndVisitAssignmentOperator11(n *AssignmentOperator11)

}

func AnyCastToVisitor(i interface{}) Visitor {
	  if nil == i{
		 return nil
	  }else{
		 return i.(Visitor)
	  }
}
type AbstractVisitor struct{
   dispatch Visitor
   }
func NewAbstractVisitor(dispatch Visitor) *AbstractVisitor{
         my := new(AbstractVisitor)
         if dispatch != nil{
           my.dispatch = dispatch
         }else{
           my.dispatch = my
         }
        return my
}

func (my *AbstractVisitor)     UnimplementedVisitor(s  string)bool { return true }

func (my *AbstractVisitor)     PreVisit(element IAst) bool{ return true }

func (my *AbstractVisitor)     PostVisit(element  IAst) {}

func (my *AbstractVisitor)     VisitAstToken(n  *AstToken) bool{ return my.UnimplementedVisitor("Visit(*AstToken)") }
func (my *AbstractVisitor)     EndVisitAstToken(n  *AstToken) { my.UnimplementedVisitor("EndVisit(*AstToken)") }

func (my *AbstractVisitor)     Visitidentifier(n  *identifier) bool{ return my.UnimplementedVisitor("Visit(*identifier)") }
func (my *AbstractVisitor)     EndVisitidentifier(n  *identifier) { my.UnimplementedVisitor("EndVisit(*identifier)") }

func (my *AbstractVisitor)     VisitPrimitiveType(n  *PrimitiveType) bool{ return my.UnimplementedVisitor("Visit(*PrimitiveType)") }
func (my *AbstractVisitor)     EndVisitPrimitiveType(n  *PrimitiveType) { my.UnimplementedVisitor("EndVisit(*PrimitiveType)") }

func (my *AbstractVisitor)     VisitClassType(n  *ClassType) bool{ return my.UnimplementedVisitor("Visit(*ClassType)") }
func (my *AbstractVisitor)     EndVisitClassType(n  *ClassType) { my.UnimplementedVisitor("EndVisit(*ClassType)") }

func (my *AbstractVisitor)     VisitInterfaceType(n  *InterfaceType) bool{ return my.UnimplementedVisitor("Visit(*InterfaceType)") }
func (my *AbstractVisitor)     EndVisitInterfaceType(n  *InterfaceType) { my.UnimplementedVisitor("EndVisit(*InterfaceType)") }

func (my *AbstractVisitor)     VisitTypeName(n  *TypeName) bool{ return my.UnimplementedVisitor("Visit(*TypeName)") }
func (my *AbstractVisitor)     EndVisitTypeName(n  *TypeName) { my.UnimplementedVisitor("EndVisit(*TypeName)") }

func (my *AbstractVisitor)     VisitArrayType(n  *ArrayType) bool{ return my.UnimplementedVisitor("Visit(*ArrayType)") }
func (my *AbstractVisitor)     EndVisitArrayType(n  *ArrayType) { my.UnimplementedVisitor("EndVisit(*ArrayType)") }

func (my *AbstractVisitor)     VisitTypeParameter(n  *TypeParameter) bool{ return my.UnimplementedVisitor("Visit(*TypeParameter)") }
func (my *AbstractVisitor)     EndVisitTypeParameter(n  *TypeParameter) { my.UnimplementedVisitor("EndVisit(*TypeParameter)") }

func (my *AbstractVisitor)     VisitTypeBound(n  *TypeBound) bool{ return my.UnimplementedVisitor("Visit(*TypeBound)") }
func (my *AbstractVisitor)     EndVisitTypeBound(n  *TypeBound) { my.UnimplementedVisitor("EndVisit(*TypeBound)") }

func (my *AbstractVisitor)     VisitAdditionalBoundList(n  *AdditionalBoundList) bool{ return my.UnimplementedVisitor("Visit(*AdditionalBoundList)") }
func (my *AbstractVisitor)     EndVisitAdditionalBoundList(n  *AdditionalBoundList) { my.UnimplementedVisitor("EndVisit(*AdditionalBoundList)") }

func (my *AbstractVisitor)     VisitAdditionalBound(n  *AdditionalBound) bool{ return my.UnimplementedVisitor("Visit(*AdditionalBound)") }
func (my *AbstractVisitor)     EndVisitAdditionalBound(n  *AdditionalBound) { my.UnimplementedVisitor("EndVisit(*AdditionalBound)") }

func (my *AbstractVisitor)     VisitTypeArguments(n  *TypeArguments) bool{ return my.UnimplementedVisitor("Visit(*TypeArguments)") }
func (my *AbstractVisitor)     EndVisitTypeArguments(n  *TypeArguments) { my.UnimplementedVisitor("EndVisit(*TypeArguments)") }

func (my *AbstractVisitor)     VisitActualTypeArgumentList(n  *ActualTypeArgumentList) bool{ return my.UnimplementedVisitor("Visit(*ActualTypeArgumentList)") }
func (my *AbstractVisitor)     EndVisitActualTypeArgumentList(n  *ActualTypeArgumentList) { my.UnimplementedVisitor("EndVisit(*ActualTypeArgumentList)") }

func (my *AbstractVisitor)     VisitWildcard(n  *Wildcard) bool{ return my.UnimplementedVisitor("Visit(*Wildcard)") }
func (my *AbstractVisitor)     EndVisitWildcard(n  *Wildcard) { my.UnimplementedVisitor("EndVisit(*Wildcard)") }

func (my *AbstractVisitor)     VisitPackageName(n  *PackageName) bool{ return my.UnimplementedVisitor("Visit(*PackageName)") }
func (my *AbstractVisitor)     EndVisitPackageName(n  *PackageName) { my.UnimplementedVisitor("EndVisit(*PackageName)") }

func (my *AbstractVisitor)     VisitExpressionName(n  *ExpressionName) bool{ return my.UnimplementedVisitor("Visit(*ExpressionName)") }
func (my *AbstractVisitor)     EndVisitExpressionName(n  *ExpressionName) { my.UnimplementedVisitor("EndVisit(*ExpressionName)") }

func (my *AbstractVisitor)     VisitMethodName(n  *MethodName) bool{ return my.UnimplementedVisitor("Visit(*MethodName)") }
func (my *AbstractVisitor)     EndVisitMethodName(n  *MethodName) { my.UnimplementedVisitor("EndVisit(*MethodName)") }

func (my *AbstractVisitor)     VisitPackageOrTypeName(n  *PackageOrTypeName) bool{ return my.UnimplementedVisitor("Visit(*PackageOrTypeName)") }
func (my *AbstractVisitor)     EndVisitPackageOrTypeName(n  *PackageOrTypeName) { my.UnimplementedVisitor("EndVisit(*PackageOrTypeName)") }

func (my *AbstractVisitor)     VisitAmbiguousName(n  *AmbiguousName) bool{ return my.UnimplementedVisitor("Visit(*AmbiguousName)") }
func (my *AbstractVisitor)     EndVisitAmbiguousName(n  *AmbiguousName) { my.UnimplementedVisitor("EndVisit(*AmbiguousName)") }

func (my *AbstractVisitor)     VisitCompilationUnit(n  *CompilationUnit) bool{ return my.UnimplementedVisitor("Visit(*CompilationUnit)") }
func (my *AbstractVisitor)     EndVisitCompilationUnit(n  *CompilationUnit) { my.UnimplementedVisitor("EndVisit(*CompilationUnit)") }

func (my *AbstractVisitor)     VisitImportDeclarations(n  *ImportDeclarations) bool{ return my.UnimplementedVisitor("Visit(*ImportDeclarations)") }
func (my *AbstractVisitor)     EndVisitImportDeclarations(n  *ImportDeclarations) { my.UnimplementedVisitor("EndVisit(*ImportDeclarations)") }

func (my *AbstractVisitor)     VisitTypeDeclarations(n  *TypeDeclarations) bool{ return my.UnimplementedVisitor("Visit(*TypeDeclarations)") }
func (my *AbstractVisitor)     EndVisitTypeDeclarations(n  *TypeDeclarations) { my.UnimplementedVisitor("EndVisit(*TypeDeclarations)") }

func (my *AbstractVisitor)     VisitPackageDeclaration(n  *PackageDeclaration) bool{ return my.UnimplementedVisitor("Visit(*PackageDeclaration)") }
func (my *AbstractVisitor)     EndVisitPackageDeclaration(n  *PackageDeclaration) { my.UnimplementedVisitor("EndVisit(*PackageDeclaration)") }

func (my *AbstractVisitor)     VisitSingleTypeImportDeclaration(n  *SingleTypeImportDeclaration) bool{ return my.UnimplementedVisitor("Visit(*SingleTypeImportDeclaration)") }
func (my *AbstractVisitor)     EndVisitSingleTypeImportDeclaration(n  *SingleTypeImportDeclaration) { my.UnimplementedVisitor("EndVisit(*SingleTypeImportDeclaration)") }

func (my *AbstractVisitor)     VisitTypeImportOnDemandDeclaration(n  *TypeImportOnDemandDeclaration) bool{ return my.UnimplementedVisitor("Visit(*TypeImportOnDemandDeclaration)") }
func (my *AbstractVisitor)     EndVisitTypeImportOnDemandDeclaration(n  *TypeImportOnDemandDeclaration) { my.UnimplementedVisitor("EndVisit(*TypeImportOnDemandDeclaration)") }

func (my *AbstractVisitor)     VisitSingleStaticImportDeclaration(n  *SingleStaticImportDeclaration) bool{ return my.UnimplementedVisitor("Visit(*SingleStaticImportDeclaration)") }
func (my *AbstractVisitor)     EndVisitSingleStaticImportDeclaration(n  *SingleStaticImportDeclaration) { my.UnimplementedVisitor("EndVisit(*SingleStaticImportDeclaration)") }

func (my *AbstractVisitor)     VisitStaticImportOnDemandDeclaration(n  *StaticImportOnDemandDeclaration) bool{ return my.UnimplementedVisitor("Visit(*StaticImportOnDemandDeclaration)") }
func (my *AbstractVisitor)     EndVisitStaticImportOnDemandDeclaration(n  *StaticImportOnDemandDeclaration) { my.UnimplementedVisitor("EndVisit(*StaticImportOnDemandDeclaration)") }

func (my *AbstractVisitor)     VisitTypeDeclaration(n  *TypeDeclaration) bool{ return my.UnimplementedVisitor("Visit(*TypeDeclaration)") }
func (my *AbstractVisitor)     EndVisitTypeDeclaration(n  *TypeDeclaration) { my.UnimplementedVisitor("EndVisit(*TypeDeclaration)") }

func (my *AbstractVisitor)     VisitNormalClassDeclaration(n  *NormalClassDeclaration) bool{ return my.UnimplementedVisitor("Visit(*NormalClassDeclaration)") }
func (my *AbstractVisitor)     EndVisitNormalClassDeclaration(n  *NormalClassDeclaration) { my.UnimplementedVisitor("EndVisit(*NormalClassDeclaration)") }

func (my *AbstractVisitor)     VisitClassModifiers(n  *ClassModifiers) bool{ return my.UnimplementedVisitor("Visit(*ClassModifiers)") }
func (my *AbstractVisitor)     EndVisitClassModifiers(n  *ClassModifiers) { my.UnimplementedVisitor("EndVisit(*ClassModifiers)") }

func (my *AbstractVisitor)     VisitTypeParameters(n  *TypeParameters) bool{ return my.UnimplementedVisitor("Visit(*TypeParameters)") }
func (my *AbstractVisitor)     EndVisitTypeParameters(n  *TypeParameters) { my.UnimplementedVisitor("EndVisit(*TypeParameters)") }

func (my *AbstractVisitor)     VisitTypeParameterList(n  *TypeParameterList) bool{ return my.UnimplementedVisitor("Visit(*TypeParameterList)") }
func (my *AbstractVisitor)     EndVisitTypeParameterList(n  *TypeParameterList) { my.UnimplementedVisitor("EndVisit(*TypeParameterList)") }

func (my *AbstractVisitor)     VisitSuper(n  *Super) bool{ return my.UnimplementedVisitor("Visit(*Super)") }
func (my *AbstractVisitor)     EndVisitSuper(n  *Super) { my.UnimplementedVisitor("EndVisit(*Super)") }

func (my *AbstractVisitor)     VisitInterfaces(n  *Interfaces) bool{ return my.UnimplementedVisitor("Visit(*Interfaces)") }
func (my *AbstractVisitor)     EndVisitInterfaces(n  *Interfaces) { my.UnimplementedVisitor("EndVisit(*Interfaces)") }

func (my *AbstractVisitor)     VisitInterfaceTypeList(n  *InterfaceTypeList) bool{ return my.UnimplementedVisitor("Visit(*InterfaceTypeList)") }
func (my *AbstractVisitor)     EndVisitInterfaceTypeList(n  *InterfaceTypeList) { my.UnimplementedVisitor("EndVisit(*InterfaceTypeList)") }

func (my *AbstractVisitor)     VisitClassBody(n  *ClassBody) bool{ return my.UnimplementedVisitor("Visit(*ClassBody)") }
func (my *AbstractVisitor)     EndVisitClassBody(n  *ClassBody) { my.UnimplementedVisitor("EndVisit(*ClassBody)") }

func (my *AbstractVisitor)     VisitClassBodyDeclarations(n  *ClassBodyDeclarations) bool{ return my.UnimplementedVisitor("Visit(*ClassBodyDeclarations)") }
func (my *AbstractVisitor)     EndVisitClassBodyDeclarations(n  *ClassBodyDeclarations) { my.UnimplementedVisitor("EndVisit(*ClassBodyDeclarations)") }

func (my *AbstractVisitor)     VisitClassMemberDeclaration(n  *ClassMemberDeclaration) bool{ return my.UnimplementedVisitor("Visit(*ClassMemberDeclaration)") }
func (my *AbstractVisitor)     EndVisitClassMemberDeclaration(n  *ClassMemberDeclaration) { my.UnimplementedVisitor("EndVisit(*ClassMemberDeclaration)") }

func (my *AbstractVisitor)     VisitFieldDeclaration(n  *FieldDeclaration) bool{ return my.UnimplementedVisitor("Visit(*FieldDeclaration)") }
func (my *AbstractVisitor)     EndVisitFieldDeclaration(n  *FieldDeclaration) { my.UnimplementedVisitor("EndVisit(*FieldDeclaration)") }

func (my *AbstractVisitor)     VisitVariableDeclarators(n  *VariableDeclarators) bool{ return my.UnimplementedVisitor("Visit(*VariableDeclarators)") }
func (my *AbstractVisitor)     EndVisitVariableDeclarators(n  *VariableDeclarators) { my.UnimplementedVisitor("EndVisit(*VariableDeclarators)") }

func (my *AbstractVisitor)     VisitVariableDeclarator(n  *VariableDeclarator) bool{ return my.UnimplementedVisitor("Visit(*VariableDeclarator)") }
func (my *AbstractVisitor)     EndVisitVariableDeclarator(n  *VariableDeclarator) { my.UnimplementedVisitor("EndVisit(*VariableDeclarator)") }

func (my *AbstractVisitor)     VisitVariableDeclaratorId(n  *VariableDeclaratorId) bool{ return my.UnimplementedVisitor("Visit(*VariableDeclaratorId)") }
func (my *AbstractVisitor)     EndVisitVariableDeclaratorId(n  *VariableDeclaratorId) { my.UnimplementedVisitor("EndVisit(*VariableDeclaratorId)") }

func (my *AbstractVisitor)     VisitFieldModifiers(n  *FieldModifiers) bool{ return my.UnimplementedVisitor("Visit(*FieldModifiers)") }
func (my *AbstractVisitor)     EndVisitFieldModifiers(n  *FieldModifiers) { my.UnimplementedVisitor("EndVisit(*FieldModifiers)") }

func (my *AbstractVisitor)     VisitMethodDeclaration(n  *MethodDeclaration) bool{ return my.UnimplementedVisitor("Visit(*MethodDeclaration)") }
func (my *AbstractVisitor)     EndVisitMethodDeclaration(n  *MethodDeclaration) { my.UnimplementedVisitor("EndVisit(*MethodDeclaration)") }

func (my *AbstractVisitor)     VisitMethodHeader(n  *MethodHeader) bool{ return my.UnimplementedVisitor("Visit(*MethodHeader)") }
func (my *AbstractVisitor)     EndVisitMethodHeader(n  *MethodHeader) { my.UnimplementedVisitor("EndVisit(*MethodHeader)") }

func (my *AbstractVisitor)     VisitResultType(n  *ResultType) bool{ return my.UnimplementedVisitor("Visit(*ResultType)") }
func (my *AbstractVisitor)     EndVisitResultType(n  *ResultType) { my.UnimplementedVisitor("EndVisit(*ResultType)") }

func (my *AbstractVisitor)     VisitFormalParameterList(n  *FormalParameterList) bool{ return my.UnimplementedVisitor("Visit(*FormalParameterList)") }
func (my *AbstractVisitor)     EndVisitFormalParameterList(n  *FormalParameterList) { my.UnimplementedVisitor("EndVisit(*FormalParameterList)") }

func (my *AbstractVisitor)     VisitFormalParameters(n  *FormalParameters) bool{ return my.UnimplementedVisitor("Visit(*FormalParameters)") }
func (my *AbstractVisitor)     EndVisitFormalParameters(n  *FormalParameters) { my.UnimplementedVisitor("EndVisit(*FormalParameters)") }

func (my *AbstractVisitor)     VisitFormalParameter(n  *FormalParameter) bool{ return my.UnimplementedVisitor("Visit(*FormalParameter)") }
func (my *AbstractVisitor)     EndVisitFormalParameter(n  *FormalParameter) { my.UnimplementedVisitor("EndVisit(*FormalParameter)") }

func (my *AbstractVisitor)     VisitVariableModifiers(n  *VariableModifiers) bool{ return my.UnimplementedVisitor("Visit(*VariableModifiers)") }
func (my *AbstractVisitor)     EndVisitVariableModifiers(n  *VariableModifiers) { my.UnimplementedVisitor("EndVisit(*VariableModifiers)") }

func (my *AbstractVisitor)     VisitVariableModifier(n  *VariableModifier) bool{ return my.UnimplementedVisitor("Visit(*VariableModifier)") }
func (my *AbstractVisitor)     EndVisitVariableModifier(n  *VariableModifier) { my.UnimplementedVisitor("EndVisit(*VariableModifier)") }

func (my *AbstractVisitor)     VisitLastFormalParameter(n  *LastFormalParameter) bool{ return my.UnimplementedVisitor("Visit(*LastFormalParameter)") }
func (my *AbstractVisitor)     EndVisitLastFormalParameter(n  *LastFormalParameter) { my.UnimplementedVisitor("EndVisit(*LastFormalParameter)") }

func (my *AbstractVisitor)     VisitMethodModifiers(n  *MethodModifiers) bool{ return my.UnimplementedVisitor("Visit(*MethodModifiers)") }
func (my *AbstractVisitor)     EndVisitMethodModifiers(n  *MethodModifiers) { my.UnimplementedVisitor("EndVisit(*MethodModifiers)") }

func (my *AbstractVisitor)     VisitThrows(n  *Throws) bool{ return my.UnimplementedVisitor("Visit(*Throws)") }
func (my *AbstractVisitor)     EndVisitThrows(n  *Throws) { my.UnimplementedVisitor("EndVisit(*Throws)") }

func (my *AbstractVisitor)     VisitExceptionTypeList(n  *ExceptionTypeList) bool{ return my.UnimplementedVisitor("Visit(*ExceptionTypeList)") }
func (my *AbstractVisitor)     EndVisitExceptionTypeList(n  *ExceptionTypeList) { my.UnimplementedVisitor("EndVisit(*ExceptionTypeList)") }

func (my *AbstractVisitor)     VisitMethodBody(n  *MethodBody) bool{ return my.UnimplementedVisitor("Visit(*MethodBody)") }
func (my *AbstractVisitor)     EndVisitMethodBody(n  *MethodBody) { my.UnimplementedVisitor("EndVisit(*MethodBody)") }

func (my *AbstractVisitor)     VisitStaticInitializer(n  *StaticInitializer) bool{ return my.UnimplementedVisitor("Visit(*StaticInitializer)") }
func (my *AbstractVisitor)     EndVisitStaticInitializer(n  *StaticInitializer) { my.UnimplementedVisitor("EndVisit(*StaticInitializer)") }

func (my *AbstractVisitor)     VisitConstructorDeclaration(n  *ConstructorDeclaration) bool{ return my.UnimplementedVisitor("Visit(*ConstructorDeclaration)") }
func (my *AbstractVisitor)     EndVisitConstructorDeclaration(n  *ConstructorDeclaration) { my.UnimplementedVisitor("EndVisit(*ConstructorDeclaration)") }

func (my *AbstractVisitor)     VisitConstructorDeclarator(n  *ConstructorDeclarator) bool{ return my.UnimplementedVisitor("Visit(*ConstructorDeclarator)") }
func (my *AbstractVisitor)     EndVisitConstructorDeclarator(n  *ConstructorDeclarator) { my.UnimplementedVisitor("EndVisit(*ConstructorDeclarator)") }

func (my *AbstractVisitor)     VisitConstructorModifiers(n  *ConstructorModifiers) bool{ return my.UnimplementedVisitor("Visit(*ConstructorModifiers)") }
func (my *AbstractVisitor)     EndVisitConstructorModifiers(n  *ConstructorModifiers) { my.UnimplementedVisitor("EndVisit(*ConstructorModifiers)") }

func (my *AbstractVisitor)     VisitConstructorBody(n  *ConstructorBody) bool{ return my.UnimplementedVisitor("Visit(*ConstructorBody)") }
func (my *AbstractVisitor)     EndVisitConstructorBody(n  *ConstructorBody) { my.UnimplementedVisitor("EndVisit(*ConstructorBody)") }

func (my *AbstractVisitor)     VisitEnumDeclaration(n  *EnumDeclaration) bool{ return my.UnimplementedVisitor("Visit(*EnumDeclaration)") }
func (my *AbstractVisitor)     EndVisitEnumDeclaration(n  *EnumDeclaration) { my.UnimplementedVisitor("EndVisit(*EnumDeclaration)") }

func (my *AbstractVisitor)     VisitEnumBody(n  *EnumBody) bool{ return my.UnimplementedVisitor("Visit(*EnumBody)") }
func (my *AbstractVisitor)     EndVisitEnumBody(n  *EnumBody) { my.UnimplementedVisitor("EndVisit(*EnumBody)") }

func (my *AbstractVisitor)     VisitEnumConstants(n  *EnumConstants) bool{ return my.UnimplementedVisitor("Visit(*EnumConstants)") }
func (my *AbstractVisitor)     EndVisitEnumConstants(n  *EnumConstants) { my.UnimplementedVisitor("EndVisit(*EnumConstants)") }

func (my *AbstractVisitor)     VisitEnumConstant(n  *EnumConstant) bool{ return my.UnimplementedVisitor("Visit(*EnumConstant)") }
func (my *AbstractVisitor)     EndVisitEnumConstant(n  *EnumConstant) { my.UnimplementedVisitor("EndVisit(*EnumConstant)") }

func (my *AbstractVisitor)     VisitArguments(n  *Arguments) bool{ return my.UnimplementedVisitor("Visit(*Arguments)") }
func (my *AbstractVisitor)     EndVisitArguments(n  *Arguments) { my.UnimplementedVisitor("EndVisit(*Arguments)") }

func (my *AbstractVisitor)     VisitEnumBodyDeclarations(n  *EnumBodyDeclarations) bool{ return my.UnimplementedVisitor("Visit(*EnumBodyDeclarations)") }
func (my *AbstractVisitor)     EndVisitEnumBodyDeclarations(n  *EnumBodyDeclarations) { my.UnimplementedVisitor("EndVisit(*EnumBodyDeclarations)") }

func (my *AbstractVisitor)     VisitNormalInterfaceDeclaration(n  *NormalInterfaceDeclaration) bool{ return my.UnimplementedVisitor("Visit(*NormalInterfaceDeclaration)") }
func (my *AbstractVisitor)     EndVisitNormalInterfaceDeclaration(n  *NormalInterfaceDeclaration) { my.UnimplementedVisitor("EndVisit(*NormalInterfaceDeclaration)") }

func (my *AbstractVisitor)     VisitInterfaceModifiers(n  *InterfaceModifiers) bool{ return my.UnimplementedVisitor("Visit(*InterfaceModifiers)") }
func (my *AbstractVisitor)     EndVisitInterfaceModifiers(n  *InterfaceModifiers) { my.UnimplementedVisitor("EndVisit(*InterfaceModifiers)") }

func (my *AbstractVisitor)     VisitInterfaceBody(n  *InterfaceBody) bool{ return my.UnimplementedVisitor("Visit(*InterfaceBody)") }
func (my *AbstractVisitor)     EndVisitInterfaceBody(n  *InterfaceBody) { my.UnimplementedVisitor("EndVisit(*InterfaceBody)") }

func (my *AbstractVisitor)     VisitInterfaceMemberDeclarations(n  *InterfaceMemberDeclarations) bool{ return my.UnimplementedVisitor("Visit(*InterfaceMemberDeclarations)") }
func (my *AbstractVisitor)     EndVisitInterfaceMemberDeclarations(n  *InterfaceMemberDeclarations) { my.UnimplementedVisitor("EndVisit(*InterfaceMemberDeclarations)") }

func (my *AbstractVisitor)     VisitInterfaceMemberDeclaration(n  *InterfaceMemberDeclaration) bool{ return my.UnimplementedVisitor("Visit(*InterfaceMemberDeclaration)") }
func (my *AbstractVisitor)     EndVisitInterfaceMemberDeclaration(n  *InterfaceMemberDeclaration) { my.UnimplementedVisitor("EndVisit(*InterfaceMemberDeclaration)") }

func (my *AbstractVisitor)     VisitConstantDeclaration(n  *ConstantDeclaration) bool{ return my.UnimplementedVisitor("Visit(*ConstantDeclaration)") }
func (my *AbstractVisitor)     EndVisitConstantDeclaration(n  *ConstantDeclaration) { my.UnimplementedVisitor("EndVisit(*ConstantDeclaration)") }

func (my *AbstractVisitor)     VisitConstantModifiers(n  *ConstantModifiers) bool{ return my.UnimplementedVisitor("Visit(*ConstantModifiers)") }
func (my *AbstractVisitor)     EndVisitConstantModifiers(n  *ConstantModifiers) { my.UnimplementedVisitor("EndVisit(*ConstantModifiers)") }

func (my *AbstractVisitor)     VisitAbstractMethodDeclaration(n  *AbstractMethodDeclaration) bool{ return my.UnimplementedVisitor("Visit(*AbstractMethodDeclaration)") }
func (my *AbstractVisitor)     EndVisitAbstractMethodDeclaration(n  *AbstractMethodDeclaration) { my.UnimplementedVisitor("EndVisit(*AbstractMethodDeclaration)") }

func (my *AbstractVisitor)     VisitAbstractMethodModifiers(n  *AbstractMethodModifiers) bool{ return my.UnimplementedVisitor("Visit(*AbstractMethodModifiers)") }
func (my *AbstractVisitor)     EndVisitAbstractMethodModifiers(n  *AbstractMethodModifiers) { my.UnimplementedVisitor("EndVisit(*AbstractMethodModifiers)") }

func (my *AbstractVisitor)     VisitAnnotationTypeDeclaration(n  *AnnotationTypeDeclaration) bool{ return my.UnimplementedVisitor("Visit(*AnnotationTypeDeclaration)") }
func (my *AbstractVisitor)     EndVisitAnnotationTypeDeclaration(n  *AnnotationTypeDeclaration) { my.UnimplementedVisitor("EndVisit(*AnnotationTypeDeclaration)") }

func (my *AbstractVisitor)     VisitAnnotationTypeBody(n  *AnnotationTypeBody) bool{ return my.UnimplementedVisitor("Visit(*AnnotationTypeBody)") }
func (my *AbstractVisitor)     EndVisitAnnotationTypeBody(n  *AnnotationTypeBody) { my.UnimplementedVisitor("EndVisit(*AnnotationTypeBody)") }

func (my *AbstractVisitor)     VisitAnnotationTypeElementDeclarations(n  *AnnotationTypeElementDeclarations) bool{ return my.UnimplementedVisitor("Visit(*AnnotationTypeElementDeclarations)") }
func (my *AbstractVisitor)     EndVisitAnnotationTypeElementDeclarations(n  *AnnotationTypeElementDeclarations) { my.UnimplementedVisitor("EndVisit(*AnnotationTypeElementDeclarations)") }

func (my *AbstractVisitor)     VisitDefaultValue(n  *DefaultValue) bool{ return my.UnimplementedVisitor("Visit(*DefaultValue)") }
func (my *AbstractVisitor)     EndVisitDefaultValue(n  *DefaultValue) { my.UnimplementedVisitor("EndVisit(*DefaultValue)") }

func (my *AbstractVisitor)     VisitAnnotations(n  *Annotations) bool{ return my.UnimplementedVisitor("Visit(*Annotations)") }
func (my *AbstractVisitor)     EndVisitAnnotations(n  *Annotations) { my.UnimplementedVisitor("EndVisit(*Annotations)") }

func (my *AbstractVisitor)     VisitNormalAnnotation(n  *NormalAnnotation) bool{ return my.UnimplementedVisitor("Visit(*NormalAnnotation)") }
func (my *AbstractVisitor)     EndVisitNormalAnnotation(n  *NormalAnnotation) { my.UnimplementedVisitor("EndVisit(*NormalAnnotation)") }

func (my *AbstractVisitor)     VisitElementValuePairs(n  *ElementValuePairs) bool{ return my.UnimplementedVisitor("Visit(*ElementValuePairs)") }
func (my *AbstractVisitor)     EndVisitElementValuePairs(n  *ElementValuePairs) { my.UnimplementedVisitor("EndVisit(*ElementValuePairs)") }

func (my *AbstractVisitor)     VisitElementValuePair(n  *ElementValuePair) bool{ return my.UnimplementedVisitor("Visit(*ElementValuePair)") }
func (my *AbstractVisitor)     EndVisitElementValuePair(n  *ElementValuePair) { my.UnimplementedVisitor("EndVisit(*ElementValuePair)") }

func (my *AbstractVisitor)     VisitElementValueArrayInitializer(n  *ElementValueArrayInitializer) bool{ return my.UnimplementedVisitor("Visit(*ElementValueArrayInitializer)") }
func (my *AbstractVisitor)     EndVisitElementValueArrayInitializer(n  *ElementValueArrayInitializer) { my.UnimplementedVisitor("EndVisit(*ElementValueArrayInitializer)") }

func (my *AbstractVisitor)     VisitElementValues(n  *ElementValues) bool{ return my.UnimplementedVisitor("Visit(*ElementValues)") }
func (my *AbstractVisitor)     EndVisitElementValues(n  *ElementValues) { my.UnimplementedVisitor("EndVisit(*ElementValues)") }

func (my *AbstractVisitor)     VisitMarkerAnnotation(n  *MarkerAnnotation) bool{ return my.UnimplementedVisitor("Visit(*MarkerAnnotation)") }
func (my *AbstractVisitor)     EndVisitMarkerAnnotation(n  *MarkerAnnotation) { my.UnimplementedVisitor("EndVisit(*MarkerAnnotation)") }

func (my *AbstractVisitor)     VisitSingleElementAnnotation(n  *SingleElementAnnotation) bool{ return my.UnimplementedVisitor("Visit(*SingleElementAnnotation)") }
func (my *AbstractVisitor)     EndVisitSingleElementAnnotation(n  *SingleElementAnnotation) { my.UnimplementedVisitor("EndVisit(*SingleElementAnnotation)") }

func (my *AbstractVisitor)     VisitArrayInitializer(n  *ArrayInitializer) bool{ return my.UnimplementedVisitor("Visit(*ArrayInitializer)") }
func (my *AbstractVisitor)     EndVisitArrayInitializer(n  *ArrayInitializer) { my.UnimplementedVisitor("EndVisit(*ArrayInitializer)") }

func (my *AbstractVisitor)     VisitVariableInitializers(n  *VariableInitializers) bool{ return my.UnimplementedVisitor("Visit(*VariableInitializers)") }
func (my *AbstractVisitor)     EndVisitVariableInitializers(n  *VariableInitializers) { my.UnimplementedVisitor("EndVisit(*VariableInitializers)") }

func (my *AbstractVisitor)     VisitBlock(n  *Block) bool{ return my.UnimplementedVisitor("Visit(*Block)") }
func (my *AbstractVisitor)     EndVisitBlock(n  *Block) { my.UnimplementedVisitor("EndVisit(*Block)") }

func (my *AbstractVisitor)     VisitBlockStatements(n  *BlockStatements) bool{ return my.UnimplementedVisitor("Visit(*BlockStatements)") }
func (my *AbstractVisitor)     EndVisitBlockStatements(n  *BlockStatements) { my.UnimplementedVisitor("EndVisit(*BlockStatements)") }

func (my *AbstractVisitor)     VisitLocalVariableDeclarationStatement(n  *LocalVariableDeclarationStatement) bool{ return my.UnimplementedVisitor("Visit(*LocalVariableDeclarationStatement)") }
func (my *AbstractVisitor)     EndVisitLocalVariableDeclarationStatement(n  *LocalVariableDeclarationStatement) { my.UnimplementedVisitor("EndVisit(*LocalVariableDeclarationStatement)") }

func (my *AbstractVisitor)     VisitLocalVariableDeclaration(n  *LocalVariableDeclaration) bool{ return my.UnimplementedVisitor("Visit(*LocalVariableDeclaration)") }
func (my *AbstractVisitor)     EndVisitLocalVariableDeclaration(n  *LocalVariableDeclaration) { my.UnimplementedVisitor("EndVisit(*LocalVariableDeclaration)") }

func (my *AbstractVisitor)     VisitIfThenStatement(n  *IfThenStatement) bool{ return my.UnimplementedVisitor("Visit(*IfThenStatement)") }
func (my *AbstractVisitor)     EndVisitIfThenStatement(n  *IfThenStatement) { my.UnimplementedVisitor("EndVisit(*IfThenStatement)") }

func (my *AbstractVisitor)     VisitIfThenElseStatement(n  *IfThenElseStatement) bool{ return my.UnimplementedVisitor("Visit(*IfThenElseStatement)") }
func (my *AbstractVisitor)     EndVisitIfThenElseStatement(n  *IfThenElseStatement) { my.UnimplementedVisitor("EndVisit(*IfThenElseStatement)") }

func (my *AbstractVisitor)     VisitIfThenElseStatementNoShortIf(n  *IfThenElseStatementNoShortIf) bool{ return my.UnimplementedVisitor("Visit(*IfThenElseStatementNoShortIf)") }
func (my *AbstractVisitor)     EndVisitIfThenElseStatementNoShortIf(n  *IfThenElseStatementNoShortIf) { my.UnimplementedVisitor("EndVisit(*IfThenElseStatementNoShortIf)") }

func (my *AbstractVisitor)     VisitEmptyStatement(n  *EmptyStatement) bool{ return my.UnimplementedVisitor("Visit(*EmptyStatement)") }
func (my *AbstractVisitor)     EndVisitEmptyStatement(n  *EmptyStatement) { my.UnimplementedVisitor("EndVisit(*EmptyStatement)") }

func (my *AbstractVisitor)     VisitLabeledStatement(n  *LabeledStatement) bool{ return my.UnimplementedVisitor("Visit(*LabeledStatement)") }
func (my *AbstractVisitor)     EndVisitLabeledStatement(n  *LabeledStatement) { my.UnimplementedVisitor("EndVisit(*LabeledStatement)") }

func (my *AbstractVisitor)     VisitLabeledStatementNoShortIf(n  *LabeledStatementNoShortIf) bool{ return my.UnimplementedVisitor("Visit(*LabeledStatementNoShortIf)") }
func (my *AbstractVisitor)     EndVisitLabeledStatementNoShortIf(n  *LabeledStatementNoShortIf) { my.UnimplementedVisitor("EndVisit(*LabeledStatementNoShortIf)") }

func (my *AbstractVisitor)     VisitExpressionStatement(n  *ExpressionStatement) bool{ return my.UnimplementedVisitor("Visit(*ExpressionStatement)") }
func (my *AbstractVisitor)     EndVisitExpressionStatement(n  *ExpressionStatement) { my.UnimplementedVisitor("EndVisit(*ExpressionStatement)") }

func (my *AbstractVisitor)     VisitSwitchStatement(n  *SwitchStatement) bool{ return my.UnimplementedVisitor("Visit(*SwitchStatement)") }
func (my *AbstractVisitor)     EndVisitSwitchStatement(n  *SwitchStatement) { my.UnimplementedVisitor("EndVisit(*SwitchStatement)") }

func (my *AbstractVisitor)     VisitSwitchBlock(n  *SwitchBlock) bool{ return my.UnimplementedVisitor("Visit(*SwitchBlock)") }
func (my *AbstractVisitor)     EndVisitSwitchBlock(n  *SwitchBlock) { my.UnimplementedVisitor("EndVisit(*SwitchBlock)") }

func (my *AbstractVisitor)     VisitSwitchBlockStatementGroups(n  *SwitchBlockStatementGroups) bool{ return my.UnimplementedVisitor("Visit(*SwitchBlockStatementGroups)") }
func (my *AbstractVisitor)     EndVisitSwitchBlockStatementGroups(n  *SwitchBlockStatementGroups) { my.UnimplementedVisitor("EndVisit(*SwitchBlockStatementGroups)") }

func (my *AbstractVisitor)     VisitSwitchBlockStatementGroup(n  *SwitchBlockStatementGroup) bool{ return my.UnimplementedVisitor("Visit(*SwitchBlockStatementGroup)") }
func (my *AbstractVisitor)     EndVisitSwitchBlockStatementGroup(n  *SwitchBlockStatementGroup) { my.UnimplementedVisitor("EndVisit(*SwitchBlockStatementGroup)") }

func (my *AbstractVisitor)     VisitSwitchLabels(n  *SwitchLabels) bool{ return my.UnimplementedVisitor("Visit(*SwitchLabels)") }
func (my *AbstractVisitor)     EndVisitSwitchLabels(n  *SwitchLabels) { my.UnimplementedVisitor("EndVisit(*SwitchLabels)") }

func (my *AbstractVisitor)     VisitWhileStatement(n  *WhileStatement) bool{ return my.UnimplementedVisitor("Visit(*WhileStatement)") }
func (my *AbstractVisitor)     EndVisitWhileStatement(n  *WhileStatement) { my.UnimplementedVisitor("EndVisit(*WhileStatement)") }

func (my *AbstractVisitor)     VisitWhileStatementNoShortIf(n  *WhileStatementNoShortIf) bool{ return my.UnimplementedVisitor("Visit(*WhileStatementNoShortIf)") }
func (my *AbstractVisitor)     EndVisitWhileStatementNoShortIf(n  *WhileStatementNoShortIf) { my.UnimplementedVisitor("EndVisit(*WhileStatementNoShortIf)") }

func (my *AbstractVisitor)     VisitDoStatement(n  *DoStatement) bool{ return my.UnimplementedVisitor("Visit(*DoStatement)") }
func (my *AbstractVisitor)     EndVisitDoStatement(n  *DoStatement) { my.UnimplementedVisitor("EndVisit(*DoStatement)") }

func (my *AbstractVisitor)     VisitBasicForStatement(n  *BasicForStatement) bool{ return my.UnimplementedVisitor("Visit(*BasicForStatement)") }
func (my *AbstractVisitor)     EndVisitBasicForStatement(n  *BasicForStatement) { my.UnimplementedVisitor("EndVisit(*BasicForStatement)") }

func (my *AbstractVisitor)     VisitForStatementNoShortIf(n  *ForStatementNoShortIf) bool{ return my.UnimplementedVisitor("Visit(*ForStatementNoShortIf)") }
func (my *AbstractVisitor)     EndVisitForStatementNoShortIf(n  *ForStatementNoShortIf) { my.UnimplementedVisitor("EndVisit(*ForStatementNoShortIf)") }

func (my *AbstractVisitor)     VisitStatementExpressionList(n  *StatementExpressionList) bool{ return my.UnimplementedVisitor("Visit(*StatementExpressionList)") }
func (my *AbstractVisitor)     EndVisitStatementExpressionList(n  *StatementExpressionList) { my.UnimplementedVisitor("EndVisit(*StatementExpressionList)") }

func (my *AbstractVisitor)     VisitEnhancedForStatement(n  *EnhancedForStatement) bool{ return my.UnimplementedVisitor("Visit(*EnhancedForStatement)") }
func (my *AbstractVisitor)     EndVisitEnhancedForStatement(n  *EnhancedForStatement) { my.UnimplementedVisitor("EndVisit(*EnhancedForStatement)") }

func (my *AbstractVisitor)     VisitBreakStatement(n  *BreakStatement) bool{ return my.UnimplementedVisitor("Visit(*BreakStatement)") }
func (my *AbstractVisitor)     EndVisitBreakStatement(n  *BreakStatement) { my.UnimplementedVisitor("EndVisit(*BreakStatement)") }

func (my *AbstractVisitor)     VisitContinueStatement(n  *ContinueStatement) bool{ return my.UnimplementedVisitor("Visit(*ContinueStatement)") }
func (my *AbstractVisitor)     EndVisitContinueStatement(n  *ContinueStatement) { my.UnimplementedVisitor("EndVisit(*ContinueStatement)") }

func (my *AbstractVisitor)     VisitReturnStatement(n  *ReturnStatement) bool{ return my.UnimplementedVisitor("Visit(*ReturnStatement)") }
func (my *AbstractVisitor)     EndVisitReturnStatement(n  *ReturnStatement) { my.UnimplementedVisitor("EndVisit(*ReturnStatement)") }

func (my *AbstractVisitor)     VisitThrowStatement(n  *ThrowStatement) bool{ return my.UnimplementedVisitor("Visit(*ThrowStatement)") }
func (my *AbstractVisitor)     EndVisitThrowStatement(n  *ThrowStatement) { my.UnimplementedVisitor("EndVisit(*ThrowStatement)") }

func (my *AbstractVisitor)     VisitSynchronizedStatement(n  *SynchronizedStatement) bool{ return my.UnimplementedVisitor("Visit(*SynchronizedStatement)") }
func (my *AbstractVisitor)     EndVisitSynchronizedStatement(n  *SynchronizedStatement) { my.UnimplementedVisitor("EndVisit(*SynchronizedStatement)") }

func (my *AbstractVisitor)     VisitCatches(n  *Catches) bool{ return my.UnimplementedVisitor("Visit(*Catches)") }
func (my *AbstractVisitor)     EndVisitCatches(n  *Catches) { my.UnimplementedVisitor("EndVisit(*Catches)") }

func (my *AbstractVisitor)     VisitCatchClause(n  *CatchClause) bool{ return my.UnimplementedVisitor("Visit(*CatchClause)") }
func (my *AbstractVisitor)     EndVisitCatchClause(n  *CatchClause) { my.UnimplementedVisitor("EndVisit(*CatchClause)") }

func (my *AbstractVisitor)     VisitFinally(n  *Finally) bool{ return my.UnimplementedVisitor("Visit(*Finally)") }
func (my *AbstractVisitor)     EndVisitFinally(n  *Finally) { my.UnimplementedVisitor("EndVisit(*Finally)") }

func (my *AbstractVisitor)     VisitArgumentList(n  *ArgumentList) bool{ return my.UnimplementedVisitor("Visit(*ArgumentList)") }
func (my *AbstractVisitor)     EndVisitArgumentList(n  *ArgumentList) { my.UnimplementedVisitor("EndVisit(*ArgumentList)") }

func (my *AbstractVisitor)     VisitDimExprs(n  *DimExprs) bool{ return my.UnimplementedVisitor("Visit(*DimExprs)") }
func (my *AbstractVisitor)     EndVisitDimExprs(n  *DimExprs) { my.UnimplementedVisitor("EndVisit(*DimExprs)") }

func (my *AbstractVisitor)     VisitDimExpr(n  *DimExpr) bool{ return my.UnimplementedVisitor("Visit(*DimExpr)") }
func (my *AbstractVisitor)     EndVisitDimExpr(n  *DimExpr) { my.UnimplementedVisitor("EndVisit(*DimExpr)") }

func (my *AbstractVisitor)     VisitPostIncrementExpression(n  *PostIncrementExpression) bool{ return my.UnimplementedVisitor("Visit(*PostIncrementExpression)") }
func (my *AbstractVisitor)     EndVisitPostIncrementExpression(n  *PostIncrementExpression) { my.UnimplementedVisitor("EndVisit(*PostIncrementExpression)") }

func (my *AbstractVisitor)     VisitPostDecrementExpression(n  *PostDecrementExpression) bool{ return my.UnimplementedVisitor("Visit(*PostDecrementExpression)") }
func (my *AbstractVisitor)     EndVisitPostDecrementExpression(n  *PostDecrementExpression) { my.UnimplementedVisitor("EndVisit(*PostDecrementExpression)") }

func (my *AbstractVisitor)     VisitPreIncrementExpression(n  *PreIncrementExpression) bool{ return my.UnimplementedVisitor("Visit(*PreIncrementExpression)") }
func (my *AbstractVisitor)     EndVisitPreIncrementExpression(n  *PreIncrementExpression) { my.UnimplementedVisitor("EndVisit(*PreIncrementExpression)") }

func (my *AbstractVisitor)     VisitPreDecrementExpression(n  *PreDecrementExpression) bool{ return my.UnimplementedVisitor("Visit(*PreDecrementExpression)") }
func (my *AbstractVisitor)     EndVisitPreDecrementExpression(n  *PreDecrementExpression) { my.UnimplementedVisitor("EndVisit(*PreDecrementExpression)") }

func (my *AbstractVisitor)     VisitAndExpression(n  *AndExpression) bool{ return my.UnimplementedVisitor("Visit(*AndExpression)") }
func (my *AbstractVisitor)     EndVisitAndExpression(n  *AndExpression) { my.UnimplementedVisitor("EndVisit(*AndExpression)") }

func (my *AbstractVisitor)     VisitExclusiveOrExpression(n  *ExclusiveOrExpression) bool{ return my.UnimplementedVisitor("Visit(*ExclusiveOrExpression)") }
func (my *AbstractVisitor)     EndVisitExclusiveOrExpression(n  *ExclusiveOrExpression) { my.UnimplementedVisitor("EndVisit(*ExclusiveOrExpression)") }

func (my *AbstractVisitor)     VisitInclusiveOrExpression(n  *InclusiveOrExpression) bool{ return my.UnimplementedVisitor("Visit(*InclusiveOrExpression)") }
func (my *AbstractVisitor)     EndVisitInclusiveOrExpression(n  *InclusiveOrExpression) { my.UnimplementedVisitor("EndVisit(*InclusiveOrExpression)") }

func (my *AbstractVisitor)     VisitConditionalAndExpression(n  *ConditionalAndExpression) bool{ return my.UnimplementedVisitor("Visit(*ConditionalAndExpression)") }
func (my *AbstractVisitor)     EndVisitConditionalAndExpression(n  *ConditionalAndExpression) { my.UnimplementedVisitor("EndVisit(*ConditionalAndExpression)") }

func (my *AbstractVisitor)     VisitConditionalOrExpression(n  *ConditionalOrExpression) bool{ return my.UnimplementedVisitor("Visit(*ConditionalOrExpression)") }
func (my *AbstractVisitor)     EndVisitConditionalOrExpression(n  *ConditionalOrExpression) { my.UnimplementedVisitor("EndVisit(*ConditionalOrExpression)") }

func (my *AbstractVisitor)     VisitConditionalExpression(n  *ConditionalExpression) bool{ return my.UnimplementedVisitor("Visit(*ConditionalExpression)") }
func (my *AbstractVisitor)     EndVisitConditionalExpression(n  *ConditionalExpression) { my.UnimplementedVisitor("EndVisit(*ConditionalExpression)") }

func (my *AbstractVisitor)     VisitAssignment(n  *Assignment) bool{ return my.UnimplementedVisitor("Visit(*Assignment)") }
func (my *AbstractVisitor)     EndVisitAssignment(n  *Assignment) { my.UnimplementedVisitor("EndVisit(*Assignment)") }

func (my *AbstractVisitor)     VisitCommaopt(n  *Commaopt) bool{ return my.UnimplementedVisitor("Visit(*Commaopt)") }
func (my *AbstractVisitor)     EndVisitCommaopt(n  *Commaopt) { my.UnimplementedVisitor("EndVisit(*Commaopt)") }

func (my *AbstractVisitor)     VisitEllipsisopt(n  *Ellipsisopt) bool{ return my.UnimplementedVisitor("Visit(*Ellipsisopt)") }
func (my *AbstractVisitor)     EndVisitEllipsisopt(n  *Ellipsisopt) { my.UnimplementedVisitor("EndVisit(*Ellipsisopt)") }

func (my *AbstractVisitor)     VisitLPGUserAction0(n  *LPGUserAction0) bool{ return my.UnimplementedVisitor("Visit(*LPGUserAction0)") }
func (my *AbstractVisitor)     EndVisitLPGUserAction0(n  *LPGUserAction0) { my.UnimplementedVisitor("EndVisit(*LPGUserAction0)") }

func (my *AbstractVisitor)     VisitLPGUserAction1(n  *LPGUserAction1) bool{ return my.UnimplementedVisitor("Visit(*LPGUserAction1)") }
func (my *AbstractVisitor)     EndVisitLPGUserAction1(n  *LPGUserAction1) { my.UnimplementedVisitor("EndVisit(*LPGUserAction1)") }

func (my *AbstractVisitor)     VisitLPGUserAction2(n  *LPGUserAction2) bool{ return my.UnimplementedVisitor("Visit(*LPGUserAction2)") }
func (my *AbstractVisitor)     EndVisitLPGUserAction2(n  *LPGUserAction2) { my.UnimplementedVisitor("EndVisit(*LPGUserAction2)") }

func (my *AbstractVisitor)     VisitLPGUserAction3(n  *LPGUserAction3) bool{ return my.UnimplementedVisitor("Visit(*LPGUserAction3)") }
func (my *AbstractVisitor)     EndVisitLPGUserAction3(n  *LPGUserAction3) { my.UnimplementedVisitor("EndVisit(*LPGUserAction3)") }

func (my *AbstractVisitor)     VisitLPGUserAction4(n  *LPGUserAction4) bool{ return my.UnimplementedVisitor("Visit(*LPGUserAction4)") }
func (my *AbstractVisitor)     EndVisitLPGUserAction4(n  *LPGUserAction4) { my.UnimplementedVisitor("EndVisit(*LPGUserAction4)") }

func (my *AbstractVisitor)     VisitIntegralType0(n  *IntegralType0) bool{ return my.UnimplementedVisitor("Visit(*IntegralType0)") }
func (my *AbstractVisitor)     EndVisitIntegralType0(n  *IntegralType0) { my.UnimplementedVisitor("EndVisit(*IntegralType0)") }

func (my *AbstractVisitor)     VisitIntegralType1(n  *IntegralType1) bool{ return my.UnimplementedVisitor("Visit(*IntegralType1)") }
func (my *AbstractVisitor)     EndVisitIntegralType1(n  *IntegralType1) { my.UnimplementedVisitor("EndVisit(*IntegralType1)") }

func (my *AbstractVisitor)     VisitIntegralType2(n  *IntegralType2) bool{ return my.UnimplementedVisitor("Visit(*IntegralType2)") }
func (my *AbstractVisitor)     EndVisitIntegralType2(n  *IntegralType2) { my.UnimplementedVisitor("EndVisit(*IntegralType2)") }

func (my *AbstractVisitor)     VisitIntegralType3(n  *IntegralType3) bool{ return my.UnimplementedVisitor("Visit(*IntegralType3)") }
func (my *AbstractVisitor)     EndVisitIntegralType3(n  *IntegralType3) { my.UnimplementedVisitor("EndVisit(*IntegralType3)") }

func (my *AbstractVisitor)     VisitIntegralType4(n  *IntegralType4) bool{ return my.UnimplementedVisitor("Visit(*IntegralType4)") }
func (my *AbstractVisitor)     EndVisitIntegralType4(n  *IntegralType4) { my.UnimplementedVisitor("EndVisit(*IntegralType4)") }

func (my *AbstractVisitor)     VisitFloatingPointType0(n  *FloatingPointType0) bool{ return my.UnimplementedVisitor("Visit(*FloatingPointType0)") }
func (my *AbstractVisitor)     EndVisitFloatingPointType0(n  *FloatingPointType0) { my.UnimplementedVisitor("EndVisit(*FloatingPointType0)") }

func (my *AbstractVisitor)     VisitFloatingPointType1(n  *FloatingPointType1) bool{ return my.UnimplementedVisitor("Visit(*FloatingPointType1)") }
func (my *AbstractVisitor)     EndVisitFloatingPointType1(n  *FloatingPointType1) { my.UnimplementedVisitor("EndVisit(*FloatingPointType1)") }

func (my *AbstractVisitor)     VisitWildcardBounds0(n  *WildcardBounds0) bool{ return my.UnimplementedVisitor("Visit(*WildcardBounds0)") }
func (my *AbstractVisitor)     EndVisitWildcardBounds0(n  *WildcardBounds0) { my.UnimplementedVisitor("EndVisit(*WildcardBounds0)") }

func (my *AbstractVisitor)     VisitWildcardBounds1(n  *WildcardBounds1) bool{ return my.UnimplementedVisitor("Visit(*WildcardBounds1)") }
func (my *AbstractVisitor)     EndVisitWildcardBounds1(n  *WildcardBounds1) { my.UnimplementedVisitor("EndVisit(*WildcardBounds1)") }

func (my *AbstractVisitor)     VisitClassModifier0(n  *ClassModifier0) bool{ return my.UnimplementedVisitor("Visit(*ClassModifier0)") }
func (my *AbstractVisitor)     EndVisitClassModifier0(n  *ClassModifier0) { my.UnimplementedVisitor("EndVisit(*ClassModifier0)") }

func (my *AbstractVisitor)     VisitClassModifier1(n  *ClassModifier1) bool{ return my.UnimplementedVisitor("Visit(*ClassModifier1)") }
func (my *AbstractVisitor)     EndVisitClassModifier1(n  *ClassModifier1) { my.UnimplementedVisitor("EndVisit(*ClassModifier1)") }

func (my *AbstractVisitor)     VisitClassModifier2(n  *ClassModifier2) bool{ return my.UnimplementedVisitor("Visit(*ClassModifier2)") }
func (my *AbstractVisitor)     EndVisitClassModifier2(n  *ClassModifier2) { my.UnimplementedVisitor("EndVisit(*ClassModifier2)") }

func (my *AbstractVisitor)     VisitClassModifier3(n  *ClassModifier3) bool{ return my.UnimplementedVisitor("Visit(*ClassModifier3)") }
func (my *AbstractVisitor)     EndVisitClassModifier3(n  *ClassModifier3) { my.UnimplementedVisitor("EndVisit(*ClassModifier3)") }

func (my *AbstractVisitor)     VisitClassModifier4(n  *ClassModifier4) bool{ return my.UnimplementedVisitor("Visit(*ClassModifier4)") }
func (my *AbstractVisitor)     EndVisitClassModifier4(n  *ClassModifier4) { my.UnimplementedVisitor("EndVisit(*ClassModifier4)") }

func (my *AbstractVisitor)     VisitClassModifier5(n  *ClassModifier5) bool{ return my.UnimplementedVisitor("Visit(*ClassModifier5)") }
func (my *AbstractVisitor)     EndVisitClassModifier5(n  *ClassModifier5) { my.UnimplementedVisitor("EndVisit(*ClassModifier5)") }

func (my *AbstractVisitor)     VisitClassModifier6(n  *ClassModifier6) bool{ return my.UnimplementedVisitor("Visit(*ClassModifier6)") }
func (my *AbstractVisitor)     EndVisitClassModifier6(n  *ClassModifier6) { my.UnimplementedVisitor("EndVisit(*ClassModifier6)") }

func (my *AbstractVisitor)     VisitFieldModifier0(n  *FieldModifier0) bool{ return my.UnimplementedVisitor("Visit(*FieldModifier0)") }
func (my *AbstractVisitor)     EndVisitFieldModifier0(n  *FieldModifier0) { my.UnimplementedVisitor("EndVisit(*FieldModifier0)") }

func (my *AbstractVisitor)     VisitFieldModifier1(n  *FieldModifier1) bool{ return my.UnimplementedVisitor("Visit(*FieldModifier1)") }
func (my *AbstractVisitor)     EndVisitFieldModifier1(n  *FieldModifier1) { my.UnimplementedVisitor("EndVisit(*FieldModifier1)") }

func (my *AbstractVisitor)     VisitFieldModifier2(n  *FieldModifier2) bool{ return my.UnimplementedVisitor("Visit(*FieldModifier2)") }
func (my *AbstractVisitor)     EndVisitFieldModifier2(n  *FieldModifier2) { my.UnimplementedVisitor("EndVisit(*FieldModifier2)") }

func (my *AbstractVisitor)     VisitFieldModifier3(n  *FieldModifier3) bool{ return my.UnimplementedVisitor("Visit(*FieldModifier3)") }
func (my *AbstractVisitor)     EndVisitFieldModifier3(n  *FieldModifier3) { my.UnimplementedVisitor("EndVisit(*FieldModifier3)") }

func (my *AbstractVisitor)     VisitFieldModifier4(n  *FieldModifier4) bool{ return my.UnimplementedVisitor("Visit(*FieldModifier4)") }
func (my *AbstractVisitor)     EndVisitFieldModifier4(n  *FieldModifier4) { my.UnimplementedVisitor("EndVisit(*FieldModifier4)") }

func (my *AbstractVisitor)     VisitFieldModifier5(n  *FieldModifier5) bool{ return my.UnimplementedVisitor("Visit(*FieldModifier5)") }
func (my *AbstractVisitor)     EndVisitFieldModifier5(n  *FieldModifier5) { my.UnimplementedVisitor("EndVisit(*FieldModifier5)") }

func (my *AbstractVisitor)     VisitFieldModifier6(n  *FieldModifier6) bool{ return my.UnimplementedVisitor("Visit(*FieldModifier6)") }
func (my *AbstractVisitor)     EndVisitFieldModifier6(n  *FieldModifier6) { my.UnimplementedVisitor("EndVisit(*FieldModifier6)") }

func (my *AbstractVisitor)     VisitMethodDeclarator0(n  *MethodDeclarator0) bool{ return my.UnimplementedVisitor("Visit(*MethodDeclarator0)") }
func (my *AbstractVisitor)     EndVisitMethodDeclarator0(n  *MethodDeclarator0) { my.UnimplementedVisitor("EndVisit(*MethodDeclarator0)") }

func (my *AbstractVisitor)     VisitMethodDeclarator1(n  *MethodDeclarator1) bool{ return my.UnimplementedVisitor("Visit(*MethodDeclarator1)") }
func (my *AbstractVisitor)     EndVisitMethodDeclarator1(n  *MethodDeclarator1) { my.UnimplementedVisitor("EndVisit(*MethodDeclarator1)") }

func (my *AbstractVisitor)     VisitMethodModifier0(n  *MethodModifier0) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier0)") }
func (my *AbstractVisitor)     EndVisitMethodModifier0(n  *MethodModifier0) { my.UnimplementedVisitor("EndVisit(*MethodModifier0)") }

func (my *AbstractVisitor)     VisitMethodModifier1(n  *MethodModifier1) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier1)") }
func (my *AbstractVisitor)     EndVisitMethodModifier1(n  *MethodModifier1) { my.UnimplementedVisitor("EndVisit(*MethodModifier1)") }

func (my *AbstractVisitor)     VisitMethodModifier2(n  *MethodModifier2) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier2)") }
func (my *AbstractVisitor)     EndVisitMethodModifier2(n  *MethodModifier2) { my.UnimplementedVisitor("EndVisit(*MethodModifier2)") }

func (my *AbstractVisitor)     VisitMethodModifier3(n  *MethodModifier3) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier3)") }
func (my *AbstractVisitor)     EndVisitMethodModifier3(n  *MethodModifier3) { my.UnimplementedVisitor("EndVisit(*MethodModifier3)") }

func (my *AbstractVisitor)     VisitMethodModifier4(n  *MethodModifier4) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier4)") }
func (my *AbstractVisitor)     EndVisitMethodModifier4(n  *MethodModifier4) { my.UnimplementedVisitor("EndVisit(*MethodModifier4)") }

func (my *AbstractVisitor)     VisitMethodModifier5(n  *MethodModifier5) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier5)") }
func (my *AbstractVisitor)     EndVisitMethodModifier5(n  *MethodModifier5) { my.UnimplementedVisitor("EndVisit(*MethodModifier5)") }

func (my *AbstractVisitor)     VisitMethodModifier6(n  *MethodModifier6) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier6)") }
func (my *AbstractVisitor)     EndVisitMethodModifier6(n  *MethodModifier6) { my.UnimplementedVisitor("EndVisit(*MethodModifier6)") }

func (my *AbstractVisitor)     VisitMethodModifier7(n  *MethodModifier7) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier7)") }
func (my *AbstractVisitor)     EndVisitMethodModifier7(n  *MethodModifier7) { my.UnimplementedVisitor("EndVisit(*MethodModifier7)") }

func (my *AbstractVisitor)     VisitMethodModifier8(n  *MethodModifier8) bool{ return my.UnimplementedVisitor("Visit(*MethodModifier8)") }
func (my *AbstractVisitor)     EndVisitMethodModifier8(n  *MethodModifier8) { my.UnimplementedVisitor("EndVisit(*MethodModifier8)") }

func (my *AbstractVisitor)     VisitConstructorModifier0(n  *ConstructorModifier0) bool{ return my.UnimplementedVisitor("Visit(*ConstructorModifier0)") }
func (my *AbstractVisitor)     EndVisitConstructorModifier0(n  *ConstructorModifier0) { my.UnimplementedVisitor("EndVisit(*ConstructorModifier0)") }

func (my *AbstractVisitor)     VisitConstructorModifier1(n  *ConstructorModifier1) bool{ return my.UnimplementedVisitor("Visit(*ConstructorModifier1)") }
func (my *AbstractVisitor)     EndVisitConstructorModifier1(n  *ConstructorModifier1) { my.UnimplementedVisitor("EndVisit(*ConstructorModifier1)") }

func (my *AbstractVisitor)     VisitConstructorModifier2(n  *ConstructorModifier2) bool{ return my.UnimplementedVisitor("Visit(*ConstructorModifier2)") }
func (my *AbstractVisitor)     EndVisitConstructorModifier2(n  *ConstructorModifier2) { my.UnimplementedVisitor("EndVisit(*ConstructorModifier2)") }

func (my *AbstractVisitor)     VisitExplicitConstructorInvocation0(n  *ExplicitConstructorInvocation0) bool{ return my.UnimplementedVisitor("Visit(*ExplicitConstructorInvocation0)") }
func (my *AbstractVisitor)     EndVisitExplicitConstructorInvocation0(n  *ExplicitConstructorInvocation0) { my.UnimplementedVisitor("EndVisit(*ExplicitConstructorInvocation0)") }

func (my *AbstractVisitor)     VisitExplicitConstructorInvocation1(n  *ExplicitConstructorInvocation1) bool{ return my.UnimplementedVisitor("Visit(*ExplicitConstructorInvocation1)") }
func (my *AbstractVisitor)     EndVisitExplicitConstructorInvocation1(n  *ExplicitConstructorInvocation1) { my.UnimplementedVisitor("EndVisit(*ExplicitConstructorInvocation1)") }

func (my *AbstractVisitor)     VisitExplicitConstructorInvocation2(n  *ExplicitConstructorInvocation2) bool{ return my.UnimplementedVisitor("Visit(*ExplicitConstructorInvocation2)") }
func (my *AbstractVisitor)     EndVisitExplicitConstructorInvocation2(n  *ExplicitConstructorInvocation2) { my.UnimplementedVisitor("EndVisit(*ExplicitConstructorInvocation2)") }

func (my *AbstractVisitor)     VisitInterfaceModifier0(n  *InterfaceModifier0) bool{ return my.UnimplementedVisitor("Visit(*InterfaceModifier0)") }
func (my *AbstractVisitor)     EndVisitInterfaceModifier0(n  *InterfaceModifier0) { my.UnimplementedVisitor("EndVisit(*InterfaceModifier0)") }

func (my *AbstractVisitor)     VisitInterfaceModifier1(n  *InterfaceModifier1) bool{ return my.UnimplementedVisitor("Visit(*InterfaceModifier1)") }
func (my *AbstractVisitor)     EndVisitInterfaceModifier1(n  *InterfaceModifier1) { my.UnimplementedVisitor("EndVisit(*InterfaceModifier1)") }

func (my *AbstractVisitor)     VisitInterfaceModifier2(n  *InterfaceModifier2) bool{ return my.UnimplementedVisitor("Visit(*InterfaceModifier2)") }
func (my *AbstractVisitor)     EndVisitInterfaceModifier2(n  *InterfaceModifier2) { my.UnimplementedVisitor("EndVisit(*InterfaceModifier2)") }

func (my *AbstractVisitor)     VisitInterfaceModifier3(n  *InterfaceModifier3) bool{ return my.UnimplementedVisitor("Visit(*InterfaceModifier3)") }
func (my *AbstractVisitor)     EndVisitInterfaceModifier3(n  *InterfaceModifier3) { my.UnimplementedVisitor("EndVisit(*InterfaceModifier3)") }

func (my *AbstractVisitor)     VisitInterfaceModifier4(n  *InterfaceModifier4) bool{ return my.UnimplementedVisitor("Visit(*InterfaceModifier4)") }
func (my *AbstractVisitor)     EndVisitInterfaceModifier4(n  *InterfaceModifier4) { my.UnimplementedVisitor("EndVisit(*InterfaceModifier4)") }

func (my *AbstractVisitor)     VisitInterfaceModifier5(n  *InterfaceModifier5) bool{ return my.UnimplementedVisitor("Visit(*InterfaceModifier5)") }
func (my *AbstractVisitor)     EndVisitInterfaceModifier5(n  *InterfaceModifier5) { my.UnimplementedVisitor("EndVisit(*InterfaceModifier5)") }

func (my *AbstractVisitor)     VisitExtendsInterfaces0(n  *ExtendsInterfaces0) bool{ return my.UnimplementedVisitor("Visit(*ExtendsInterfaces0)") }
func (my *AbstractVisitor)     EndVisitExtendsInterfaces0(n  *ExtendsInterfaces0) { my.UnimplementedVisitor("EndVisit(*ExtendsInterfaces0)") }

func (my *AbstractVisitor)     VisitExtendsInterfaces1(n  *ExtendsInterfaces1) bool{ return my.UnimplementedVisitor("Visit(*ExtendsInterfaces1)") }
func (my *AbstractVisitor)     EndVisitExtendsInterfaces1(n  *ExtendsInterfaces1) { my.UnimplementedVisitor("EndVisit(*ExtendsInterfaces1)") }

func (my *AbstractVisitor)     VisitConstantModifier0(n  *ConstantModifier0) bool{ return my.UnimplementedVisitor("Visit(*ConstantModifier0)") }
func (my *AbstractVisitor)     EndVisitConstantModifier0(n  *ConstantModifier0) { my.UnimplementedVisitor("EndVisit(*ConstantModifier0)") }

func (my *AbstractVisitor)     VisitConstantModifier1(n  *ConstantModifier1) bool{ return my.UnimplementedVisitor("Visit(*ConstantModifier1)") }
func (my *AbstractVisitor)     EndVisitConstantModifier1(n  *ConstantModifier1) { my.UnimplementedVisitor("EndVisit(*ConstantModifier1)") }

func (my *AbstractVisitor)     VisitConstantModifier2(n  *ConstantModifier2) bool{ return my.UnimplementedVisitor("Visit(*ConstantModifier2)") }
func (my *AbstractVisitor)     EndVisitConstantModifier2(n  *ConstantModifier2) { my.UnimplementedVisitor("EndVisit(*ConstantModifier2)") }

func (my *AbstractVisitor)     VisitAbstractMethodModifier0(n  *AbstractMethodModifier0) bool{ return my.UnimplementedVisitor("Visit(*AbstractMethodModifier0)") }
func (my *AbstractVisitor)     EndVisitAbstractMethodModifier0(n  *AbstractMethodModifier0) { my.UnimplementedVisitor("EndVisit(*AbstractMethodModifier0)") }

func (my *AbstractVisitor)     VisitAbstractMethodModifier1(n  *AbstractMethodModifier1) bool{ return my.UnimplementedVisitor("Visit(*AbstractMethodModifier1)") }
func (my *AbstractVisitor)     EndVisitAbstractMethodModifier1(n  *AbstractMethodModifier1) { my.UnimplementedVisitor("EndVisit(*AbstractMethodModifier1)") }

func (my *AbstractVisitor)     VisitAnnotationTypeElementDeclaration0(n  *AnnotationTypeElementDeclaration0) bool{ return my.UnimplementedVisitor("Visit(*AnnotationTypeElementDeclaration0)") }
func (my *AbstractVisitor)     EndVisitAnnotationTypeElementDeclaration0(n  *AnnotationTypeElementDeclaration0) { my.UnimplementedVisitor("EndVisit(*AnnotationTypeElementDeclaration0)") }

func (my *AbstractVisitor)     VisitAnnotationTypeElementDeclaration1(n  *AnnotationTypeElementDeclaration1) bool{ return my.UnimplementedVisitor("Visit(*AnnotationTypeElementDeclaration1)") }
func (my *AbstractVisitor)     EndVisitAnnotationTypeElementDeclaration1(n  *AnnotationTypeElementDeclaration1) { my.UnimplementedVisitor("EndVisit(*AnnotationTypeElementDeclaration1)") }

func (my *AbstractVisitor)     VisitAssertStatement0(n  *AssertStatement0) bool{ return my.UnimplementedVisitor("Visit(*AssertStatement0)") }
func (my *AbstractVisitor)     EndVisitAssertStatement0(n  *AssertStatement0) { my.UnimplementedVisitor("EndVisit(*AssertStatement0)") }

func (my *AbstractVisitor)     VisitAssertStatement1(n  *AssertStatement1) bool{ return my.UnimplementedVisitor("Visit(*AssertStatement1)") }
func (my *AbstractVisitor)     EndVisitAssertStatement1(n  *AssertStatement1) { my.UnimplementedVisitor("EndVisit(*AssertStatement1)") }

func (my *AbstractVisitor)     VisitSwitchLabel0(n  *SwitchLabel0) bool{ return my.UnimplementedVisitor("Visit(*SwitchLabel0)") }
func (my *AbstractVisitor)     EndVisitSwitchLabel0(n  *SwitchLabel0) { my.UnimplementedVisitor("EndVisit(*SwitchLabel0)") }

func (my *AbstractVisitor)     VisitSwitchLabel1(n  *SwitchLabel1) bool{ return my.UnimplementedVisitor("Visit(*SwitchLabel1)") }
func (my *AbstractVisitor)     EndVisitSwitchLabel1(n  *SwitchLabel1) { my.UnimplementedVisitor("EndVisit(*SwitchLabel1)") }

func (my *AbstractVisitor)     VisitSwitchLabel2(n  *SwitchLabel2) bool{ return my.UnimplementedVisitor("Visit(*SwitchLabel2)") }
func (my *AbstractVisitor)     EndVisitSwitchLabel2(n  *SwitchLabel2) { my.UnimplementedVisitor("EndVisit(*SwitchLabel2)") }

func (my *AbstractVisitor)     VisitTryStatement0(n  *TryStatement0) bool{ return my.UnimplementedVisitor("Visit(*TryStatement0)") }
func (my *AbstractVisitor)     EndVisitTryStatement0(n  *TryStatement0) { my.UnimplementedVisitor("EndVisit(*TryStatement0)") }

func (my *AbstractVisitor)     VisitTryStatement1(n  *TryStatement1) bool{ return my.UnimplementedVisitor("Visit(*TryStatement1)") }
func (my *AbstractVisitor)     EndVisitTryStatement1(n  *TryStatement1) { my.UnimplementedVisitor("EndVisit(*TryStatement1)") }

func (my *AbstractVisitor)     VisitPrimaryNoNewArray0(n  *PrimaryNoNewArray0) bool{ return my.UnimplementedVisitor("Visit(*PrimaryNoNewArray0)") }
func (my *AbstractVisitor)     EndVisitPrimaryNoNewArray0(n  *PrimaryNoNewArray0) { my.UnimplementedVisitor("EndVisit(*PrimaryNoNewArray0)") }

func (my *AbstractVisitor)     VisitPrimaryNoNewArray1(n  *PrimaryNoNewArray1) bool{ return my.UnimplementedVisitor("Visit(*PrimaryNoNewArray1)") }
func (my *AbstractVisitor)     EndVisitPrimaryNoNewArray1(n  *PrimaryNoNewArray1) { my.UnimplementedVisitor("EndVisit(*PrimaryNoNewArray1)") }

func (my *AbstractVisitor)     VisitPrimaryNoNewArray2(n  *PrimaryNoNewArray2) bool{ return my.UnimplementedVisitor("Visit(*PrimaryNoNewArray2)") }
func (my *AbstractVisitor)     EndVisitPrimaryNoNewArray2(n  *PrimaryNoNewArray2) { my.UnimplementedVisitor("EndVisit(*PrimaryNoNewArray2)") }

func (my *AbstractVisitor)     VisitPrimaryNoNewArray3(n  *PrimaryNoNewArray3) bool{ return my.UnimplementedVisitor("Visit(*PrimaryNoNewArray3)") }
func (my *AbstractVisitor)     EndVisitPrimaryNoNewArray3(n  *PrimaryNoNewArray3) { my.UnimplementedVisitor("EndVisit(*PrimaryNoNewArray3)") }

func (my *AbstractVisitor)     VisitPrimaryNoNewArray4(n  *PrimaryNoNewArray4) bool{ return my.UnimplementedVisitor("Visit(*PrimaryNoNewArray4)") }
func (my *AbstractVisitor)     EndVisitPrimaryNoNewArray4(n  *PrimaryNoNewArray4) { my.UnimplementedVisitor("EndVisit(*PrimaryNoNewArray4)") }

func (my *AbstractVisitor)     VisitLiteral0(n  *Literal0) bool{ return my.UnimplementedVisitor("Visit(*Literal0)") }
func (my *AbstractVisitor)     EndVisitLiteral0(n  *Literal0) { my.UnimplementedVisitor("EndVisit(*Literal0)") }

func (my *AbstractVisitor)     VisitLiteral1(n  *Literal1) bool{ return my.UnimplementedVisitor("Visit(*Literal1)") }
func (my *AbstractVisitor)     EndVisitLiteral1(n  *Literal1) { my.UnimplementedVisitor("EndVisit(*Literal1)") }

func (my *AbstractVisitor)     VisitLiteral2(n  *Literal2) bool{ return my.UnimplementedVisitor("Visit(*Literal2)") }
func (my *AbstractVisitor)     EndVisitLiteral2(n  *Literal2) { my.UnimplementedVisitor("EndVisit(*Literal2)") }

func (my *AbstractVisitor)     VisitLiteral3(n  *Literal3) bool{ return my.UnimplementedVisitor("Visit(*Literal3)") }
func (my *AbstractVisitor)     EndVisitLiteral3(n  *Literal3) { my.UnimplementedVisitor("EndVisit(*Literal3)") }

func (my *AbstractVisitor)     VisitLiteral4(n  *Literal4) bool{ return my.UnimplementedVisitor("Visit(*Literal4)") }
func (my *AbstractVisitor)     EndVisitLiteral4(n  *Literal4) { my.UnimplementedVisitor("EndVisit(*Literal4)") }

func (my *AbstractVisitor)     VisitLiteral5(n  *Literal5) bool{ return my.UnimplementedVisitor("Visit(*Literal5)") }
func (my *AbstractVisitor)     EndVisitLiteral5(n  *Literal5) { my.UnimplementedVisitor("EndVisit(*Literal5)") }

func (my *AbstractVisitor)     VisitLiteral6(n  *Literal6) bool{ return my.UnimplementedVisitor("Visit(*Literal6)") }
func (my *AbstractVisitor)     EndVisitLiteral6(n  *Literal6) { my.UnimplementedVisitor("EndVisit(*Literal6)") }

func (my *AbstractVisitor)     VisitBooleanLiteral0(n  *BooleanLiteral0) bool{ return my.UnimplementedVisitor("Visit(*BooleanLiteral0)") }
func (my *AbstractVisitor)     EndVisitBooleanLiteral0(n  *BooleanLiteral0) { my.UnimplementedVisitor("EndVisit(*BooleanLiteral0)") }

func (my *AbstractVisitor)     VisitBooleanLiteral1(n  *BooleanLiteral1) bool{ return my.UnimplementedVisitor("Visit(*BooleanLiteral1)") }
func (my *AbstractVisitor)     EndVisitBooleanLiteral1(n  *BooleanLiteral1) { my.UnimplementedVisitor("EndVisit(*BooleanLiteral1)") }

func (my *AbstractVisitor)     VisitClassInstanceCreationExpression0(n  *ClassInstanceCreationExpression0) bool{ return my.UnimplementedVisitor("Visit(*ClassInstanceCreationExpression0)") }
func (my *AbstractVisitor)     EndVisitClassInstanceCreationExpression0(n  *ClassInstanceCreationExpression0) { my.UnimplementedVisitor("EndVisit(*ClassInstanceCreationExpression0)") }

func (my *AbstractVisitor)     VisitClassInstanceCreationExpression1(n  *ClassInstanceCreationExpression1) bool{ return my.UnimplementedVisitor("Visit(*ClassInstanceCreationExpression1)") }
func (my *AbstractVisitor)     EndVisitClassInstanceCreationExpression1(n  *ClassInstanceCreationExpression1) { my.UnimplementedVisitor("EndVisit(*ClassInstanceCreationExpression1)") }

func (my *AbstractVisitor)     VisitArrayCreationExpression0(n  *ArrayCreationExpression0) bool{ return my.UnimplementedVisitor("Visit(*ArrayCreationExpression0)") }
func (my *AbstractVisitor)     EndVisitArrayCreationExpression0(n  *ArrayCreationExpression0) { my.UnimplementedVisitor("EndVisit(*ArrayCreationExpression0)") }

func (my *AbstractVisitor)     VisitArrayCreationExpression1(n  *ArrayCreationExpression1) bool{ return my.UnimplementedVisitor("Visit(*ArrayCreationExpression1)") }
func (my *AbstractVisitor)     EndVisitArrayCreationExpression1(n  *ArrayCreationExpression1) { my.UnimplementedVisitor("EndVisit(*ArrayCreationExpression1)") }

func (my *AbstractVisitor)     VisitArrayCreationExpression2(n  *ArrayCreationExpression2) bool{ return my.UnimplementedVisitor("Visit(*ArrayCreationExpression2)") }
func (my *AbstractVisitor)     EndVisitArrayCreationExpression2(n  *ArrayCreationExpression2) { my.UnimplementedVisitor("EndVisit(*ArrayCreationExpression2)") }

func (my *AbstractVisitor)     VisitArrayCreationExpression3(n  *ArrayCreationExpression3) bool{ return my.UnimplementedVisitor("Visit(*ArrayCreationExpression3)") }
func (my *AbstractVisitor)     EndVisitArrayCreationExpression3(n  *ArrayCreationExpression3) { my.UnimplementedVisitor("EndVisit(*ArrayCreationExpression3)") }

func (my *AbstractVisitor)     VisitDims0(n  *Dims0) bool{ return my.UnimplementedVisitor("Visit(*Dims0)") }
func (my *AbstractVisitor)     EndVisitDims0(n  *Dims0) { my.UnimplementedVisitor("EndVisit(*Dims0)") }

func (my *AbstractVisitor)     VisitDims1(n  *Dims1) bool{ return my.UnimplementedVisitor("Visit(*Dims1)") }
func (my *AbstractVisitor)     EndVisitDims1(n  *Dims1) { my.UnimplementedVisitor("EndVisit(*Dims1)") }

func (my *AbstractVisitor)     VisitFieldAccess0(n  *FieldAccess0) bool{ return my.UnimplementedVisitor("Visit(*FieldAccess0)") }
func (my *AbstractVisitor)     EndVisitFieldAccess0(n  *FieldAccess0) { my.UnimplementedVisitor("EndVisit(*FieldAccess0)") }

func (my *AbstractVisitor)     VisitFieldAccess1(n  *FieldAccess1) bool{ return my.UnimplementedVisitor("Visit(*FieldAccess1)") }
func (my *AbstractVisitor)     EndVisitFieldAccess1(n  *FieldAccess1) { my.UnimplementedVisitor("EndVisit(*FieldAccess1)") }

func (my *AbstractVisitor)     VisitFieldAccess2(n  *FieldAccess2) bool{ return my.UnimplementedVisitor("Visit(*FieldAccess2)") }
func (my *AbstractVisitor)     EndVisitFieldAccess2(n  *FieldAccess2) { my.UnimplementedVisitor("EndVisit(*FieldAccess2)") }

func (my *AbstractVisitor)     VisitMethodInvocation0(n  *MethodInvocation0) bool{ return my.UnimplementedVisitor("Visit(*MethodInvocation0)") }
func (my *AbstractVisitor)     EndVisitMethodInvocation0(n  *MethodInvocation0) { my.UnimplementedVisitor("EndVisit(*MethodInvocation0)") }

func (my *AbstractVisitor)     VisitMethodInvocation1(n  *MethodInvocation1) bool{ return my.UnimplementedVisitor("Visit(*MethodInvocation1)") }
func (my *AbstractVisitor)     EndVisitMethodInvocation1(n  *MethodInvocation1) { my.UnimplementedVisitor("EndVisit(*MethodInvocation1)") }

func (my *AbstractVisitor)     VisitMethodInvocation2(n  *MethodInvocation2) bool{ return my.UnimplementedVisitor("Visit(*MethodInvocation2)") }
func (my *AbstractVisitor)     EndVisitMethodInvocation2(n  *MethodInvocation2) { my.UnimplementedVisitor("EndVisit(*MethodInvocation2)") }

func (my *AbstractVisitor)     VisitMethodInvocation3(n  *MethodInvocation3) bool{ return my.UnimplementedVisitor("Visit(*MethodInvocation3)") }
func (my *AbstractVisitor)     EndVisitMethodInvocation3(n  *MethodInvocation3) { my.UnimplementedVisitor("EndVisit(*MethodInvocation3)") }

func (my *AbstractVisitor)     VisitMethodInvocation4(n  *MethodInvocation4) bool{ return my.UnimplementedVisitor("Visit(*MethodInvocation4)") }
func (my *AbstractVisitor)     EndVisitMethodInvocation4(n  *MethodInvocation4) { my.UnimplementedVisitor("EndVisit(*MethodInvocation4)") }

func (my *AbstractVisitor)     VisitArrayAccess0(n  *ArrayAccess0) bool{ return my.UnimplementedVisitor("Visit(*ArrayAccess0)") }
func (my *AbstractVisitor)     EndVisitArrayAccess0(n  *ArrayAccess0) { my.UnimplementedVisitor("EndVisit(*ArrayAccess0)") }

func (my *AbstractVisitor)     VisitArrayAccess1(n  *ArrayAccess1) bool{ return my.UnimplementedVisitor("Visit(*ArrayAccess1)") }
func (my *AbstractVisitor)     EndVisitArrayAccess1(n  *ArrayAccess1) { my.UnimplementedVisitor("EndVisit(*ArrayAccess1)") }

func (my *AbstractVisitor)     VisitUnaryExpression0(n  *UnaryExpression0) bool{ return my.UnimplementedVisitor("Visit(*UnaryExpression0)") }
func (my *AbstractVisitor)     EndVisitUnaryExpression0(n  *UnaryExpression0) { my.UnimplementedVisitor("EndVisit(*UnaryExpression0)") }

func (my *AbstractVisitor)     VisitUnaryExpression1(n  *UnaryExpression1) bool{ return my.UnimplementedVisitor("Visit(*UnaryExpression1)") }
func (my *AbstractVisitor)     EndVisitUnaryExpression1(n  *UnaryExpression1) { my.UnimplementedVisitor("EndVisit(*UnaryExpression1)") }

func (my *AbstractVisitor)     VisitUnaryExpressionNotPlusMinus0(n  *UnaryExpressionNotPlusMinus0) bool{ return my.UnimplementedVisitor("Visit(*UnaryExpressionNotPlusMinus0)") }
func (my *AbstractVisitor)     EndVisitUnaryExpressionNotPlusMinus0(n  *UnaryExpressionNotPlusMinus0) { my.UnimplementedVisitor("EndVisit(*UnaryExpressionNotPlusMinus0)") }

func (my *AbstractVisitor)     VisitUnaryExpressionNotPlusMinus1(n  *UnaryExpressionNotPlusMinus1) bool{ return my.UnimplementedVisitor("Visit(*UnaryExpressionNotPlusMinus1)") }
func (my *AbstractVisitor)     EndVisitUnaryExpressionNotPlusMinus1(n  *UnaryExpressionNotPlusMinus1) { my.UnimplementedVisitor("EndVisit(*UnaryExpressionNotPlusMinus1)") }

func (my *AbstractVisitor)     VisitCastExpression0(n  *CastExpression0) bool{ return my.UnimplementedVisitor("Visit(*CastExpression0)") }
func (my *AbstractVisitor)     EndVisitCastExpression0(n  *CastExpression0) { my.UnimplementedVisitor("EndVisit(*CastExpression0)") }

func (my *AbstractVisitor)     VisitCastExpression1(n  *CastExpression1) bool{ return my.UnimplementedVisitor("Visit(*CastExpression1)") }
func (my *AbstractVisitor)     EndVisitCastExpression1(n  *CastExpression1) { my.UnimplementedVisitor("EndVisit(*CastExpression1)") }

func (my *AbstractVisitor)     VisitMultiplicativeExpression0(n  *MultiplicativeExpression0) bool{ return my.UnimplementedVisitor("Visit(*MultiplicativeExpression0)") }
func (my *AbstractVisitor)     EndVisitMultiplicativeExpression0(n  *MultiplicativeExpression0) { my.UnimplementedVisitor("EndVisit(*MultiplicativeExpression0)") }

func (my *AbstractVisitor)     VisitMultiplicativeExpression1(n  *MultiplicativeExpression1) bool{ return my.UnimplementedVisitor("Visit(*MultiplicativeExpression1)") }
func (my *AbstractVisitor)     EndVisitMultiplicativeExpression1(n  *MultiplicativeExpression1) { my.UnimplementedVisitor("EndVisit(*MultiplicativeExpression1)") }

func (my *AbstractVisitor)     VisitMultiplicativeExpression2(n  *MultiplicativeExpression2) bool{ return my.UnimplementedVisitor("Visit(*MultiplicativeExpression2)") }
func (my *AbstractVisitor)     EndVisitMultiplicativeExpression2(n  *MultiplicativeExpression2) { my.UnimplementedVisitor("EndVisit(*MultiplicativeExpression2)") }

func (my *AbstractVisitor)     VisitAdditiveExpression0(n  *AdditiveExpression0) bool{ return my.UnimplementedVisitor("Visit(*AdditiveExpression0)") }
func (my *AbstractVisitor)     EndVisitAdditiveExpression0(n  *AdditiveExpression0) { my.UnimplementedVisitor("EndVisit(*AdditiveExpression0)") }

func (my *AbstractVisitor)     VisitAdditiveExpression1(n  *AdditiveExpression1) bool{ return my.UnimplementedVisitor("Visit(*AdditiveExpression1)") }
func (my *AbstractVisitor)     EndVisitAdditiveExpression1(n  *AdditiveExpression1) { my.UnimplementedVisitor("EndVisit(*AdditiveExpression1)") }

func (my *AbstractVisitor)     VisitShiftExpression0(n  *ShiftExpression0) bool{ return my.UnimplementedVisitor("Visit(*ShiftExpression0)") }
func (my *AbstractVisitor)     EndVisitShiftExpression0(n  *ShiftExpression0) { my.UnimplementedVisitor("EndVisit(*ShiftExpression0)") }

func (my *AbstractVisitor)     VisitShiftExpression1(n  *ShiftExpression1) bool{ return my.UnimplementedVisitor("Visit(*ShiftExpression1)") }
func (my *AbstractVisitor)     EndVisitShiftExpression1(n  *ShiftExpression1) { my.UnimplementedVisitor("EndVisit(*ShiftExpression1)") }

func (my *AbstractVisitor)     VisitShiftExpression2(n  *ShiftExpression2) bool{ return my.UnimplementedVisitor("Visit(*ShiftExpression2)") }
func (my *AbstractVisitor)     EndVisitShiftExpression2(n  *ShiftExpression2) { my.UnimplementedVisitor("EndVisit(*ShiftExpression2)") }

func (my *AbstractVisitor)     VisitRelationalExpression0(n  *RelationalExpression0) bool{ return my.UnimplementedVisitor("Visit(*RelationalExpression0)") }
func (my *AbstractVisitor)     EndVisitRelationalExpression0(n  *RelationalExpression0) { my.UnimplementedVisitor("EndVisit(*RelationalExpression0)") }

func (my *AbstractVisitor)     VisitRelationalExpression1(n  *RelationalExpression1) bool{ return my.UnimplementedVisitor("Visit(*RelationalExpression1)") }
func (my *AbstractVisitor)     EndVisitRelationalExpression1(n  *RelationalExpression1) { my.UnimplementedVisitor("EndVisit(*RelationalExpression1)") }

func (my *AbstractVisitor)     VisitRelationalExpression2(n  *RelationalExpression2) bool{ return my.UnimplementedVisitor("Visit(*RelationalExpression2)") }
func (my *AbstractVisitor)     EndVisitRelationalExpression2(n  *RelationalExpression2) { my.UnimplementedVisitor("EndVisit(*RelationalExpression2)") }

func (my *AbstractVisitor)     VisitRelationalExpression3(n  *RelationalExpression3) bool{ return my.UnimplementedVisitor("Visit(*RelationalExpression3)") }
func (my *AbstractVisitor)     EndVisitRelationalExpression3(n  *RelationalExpression3) { my.UnimplementedVisitor("EndVisit(*RelationalExpression3)") }

func (my *AbstractVisitor)     VisitRelationalExpression4(n  *RelationalExpression4) bool{ return my.UnimplementedVisitor("Visit(*RelationalExpression4)") }
func (my *AbstractVisitor)     EndVisitRelationalExpression4(n  *RelationalExpression4) { my.UnimplementedVisitor("EndVisit(*RelationalExpression4)") }

func (my *AbstractVisitor)     VisitEqualityExpression0(n  *EqualityExpression0) bool{ return my.UnimplementedVisitor("Visit(*EqualityExpression0)") }
func (my *AbstractVisitor)     EndVisitEqualityExpression0(n  *EqualityExpression0) { my.UnimplementedVisitor("EndVisit(*EqualityExpression0)") }

func (my *AbstractVisitor)     VisitEqualityExpression1(n  *EqualityExpression1) bool{ return my.UnimplementedVisitor("Visit(*EqualityExpression1)") }
func (my *AbstractVisitor)     EndVisitEqualityExpression1(n  *EqualityExpression1) { my.UnimplementedVisitor("EndVisit(*EqualityExpression1)") }

func (my *AbstractVisitor)     VisitAssignmentOperator0(n  *AssignmentOperator0) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator0)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator0(n  *AssignmentOperator0) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator0)") }

func (my *AbstractVisitor)     VisitAssignmentOperator1(n  *AssignmentOperator1) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator1)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator1(n  *AssignmentOperator1) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator1)") }

func (my *AbstractVisitor)     VisitAssignmentOperator2(n  *AssignmentOperator2) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator2)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator2(n  *AssignmentOperator2) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator2)") }

func (my *AbstractVisitor)     VisitAssignmentOperator3(n  *AssignmentOperator3) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator3)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator3(n  *AssignmentOperator3) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator3)") }

func (my *AbstractVisitor)     VisitAssignmentOperator4(n  *AssignmentOperator4) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator4)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator4(n  *AssignmentOperator4) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator4)") }

func (my *AbstractVisitor)     VisitAssignmentOperator5(n  *AssignmentOperator5) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator5)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator5(n  *AssignmentOperator5) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator5)") }

func (my *AbstractVisitor)     VisitAssignmentOperator6(n  *AssignmentOperator6) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator6)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator6(n  *AssignmentOperator6) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator6)") }

func (my *AbstractVisitor)     VisitAssignmentOperator7(n  *AssignmentOperator7) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator7)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator7(n  *AssignmentOperator7) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator7)") }

func (my *AbstractVisitor)     VisitAssignmentOperator8(n  *AssignmentOperator8) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator8)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator8(n  *AssignmentOperator8) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator8)") }

func (my *AbstractVisitor)     VisitAssignmentOperator9(n  *AssignmentOperator9) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator9)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator9(n  *AssignmentOperator9) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator9)") }

func (my *AbstractVisitor)     VisitAssignmentOperator10(n  *AssignmentOperator10) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator10)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator10(n  *AssignmentOperator10) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator10)") }

func (my *AbstractVisitor)     VisitAssignmentOperator11(n  *AssignmentOperator11) bool{ return my.UnimplementedVisitor("Visit(*AssignmentOperator11)") }
func (my *AbstractVisitor)     EndVisitAssignmentOperator11(n  *AssignmentOperator11) { my.UnimplementedVisitor("EndVisit(*AssignmentOperator11)") }


func (my *AbstractVisitor)     Visit(n IAst) bool{
     switch n2 := n.(type) {
        case *AstToken:{
            return my.dispatch.VisitAstToken(n2)
        }
        case *identifier:{
            return my.dispatch.Visitidentifier(n2)
        }
        case *PrimitiveType:{
            return my.dispatch.VisitPrimitiveType(n2)
        }
        case *ClassType:{
            return my.dispatch.VisitClassType(n2)
        }
        case *InterfaceType:{
            return my.dispatch.VisitInterfaceType(n2)
        }
        case *TypeName:{
            return my.dispatch.VisitTypeName(n2)
        }
        case *ArrayType:{
            return my.dispatch.VisitArrayType(n2)
        }
        case *TypeParameter:{
            return my.dispatch.VisitTypeParameter(n2)
        }
        case *TypeBound:{
            return my.dispatch.VisitTypeBound(n2)
        }
        case *AdditionalBoundList:{
            return my.dispatch.VisitAdditionalBoundList(n2)
        }
        case *AdditionalBound:{
            return my.dispatch.VisitAdditionalBound(n2)
        }
        case *TypeArguments:{
            return my.dispatch.VisitTypeArguments(n2)
        }
        case *ActualTypeArgumentList:{
            return my.dispatch.VisitActualTypeArgumentList(n2)
        }
        case *Wildcard:{
            return my.dispatch.VisitWildcard(n2)
        }
        case *PackageName:{
            return my.dispatch.VisitPackageName(n2)
        }
        case *ExpressionName:{
            return my.dispatch.VisitExpressionName(n2)
        }
        case *MethodName:{
            return my.dispatch.VisitMethodName(n2)
        }
        case *PackageOrTypeName:{
            return my.dispatch.VisitPackageOrTypeName(n2)
        }
        case *AmbiguousName:{
            return my.dispatch.VisitAmbiguousName(n2)
        }
        case *CompilationUnit:{
            return my.dispatch.VisitCompilationUnit(n2)
        }
        case *ImportDeclarations:{
            return my.dispatch.VisitImportDeclarations(n2)
        }
        case *TypeDeclarations:{
            return my.dispatch.VisitTypeDeclarations(n2)
        }
        case *PackageDeclaration:{
            return my.dispatch.VisitPackageDeclaration(n2)
        }
        case *SingleTypeImportDeclaration:{
            return my.dispatch.VisitSingleTypeImportDeclaration(n2)
        }
        case *TypeImportOnDemandDeclaration:{
            return my.dispatch.VisitTypeImportOnDemandDeclaration(n2)
        }
        case *SingleStaticImportDeclaration:{
            return my.dispatch.VisitSingleStaticImportDeclaration(n2)
        }
        case *StaticImportOnDemandDeclaration:{
            return my.dispatch.VisitStaticImportOnDemandDeclaration(n2)
        }
        case *TypeDeclaration:{
            return my.dispatch.VisitTypeDeclaration(n2)
        }
        case *NormalClassDeclaration:{
            return my.dispatch.VisitNormalClassDeclaration(n2)
        }
        case *ClassModifiers:{
            return my.dispatch.VisitClassModifiers(n2)
        }
        case *TypeParameters:{
            return my.dispatch.VisitTypeParameters(n2)
        }
        case *TypeParameterList:{
            return my.dispatch.VisitTypeParameterList(n2)
        }
        case *Super:{
            return my.dispatch.VisitSuper(n2)
        }
        case *Interfaces:{
            return my.dispatch.VisitInterfaces(n2)
        }
        case *InterfaceTypeList:{
            return my.dispatch.VisitInterfaceTypeList(n2)
        }
        case *ClassBody:{
            return my.dispatch.VisitClassBody(n2)
        }
        case *ClassBodyDeclarations:{
            return my.dispatch.VisitClassBodyDeclarations(n2)
        }
        case *ClassMemberDeclaration:{
            return my.dispatch.VisitClassMemberDeclaration(n2)
        }
        case *FieldDeclaration:{
            return my.dispatch.VisitFieldDeclaration(n2)
        }
        case *VariableDeclarators:{
            return my.dispatch.VisitVariableDeclarators(n2)
        }
        case *VariableDeclarator:{
            return my.dispatch.VisitVariableDeclarator(n2)
        }
        case *VariableDeclaratorId:{
            return my.dispatch.VisitVariableDeclaratorId(n2)
        }
        case *FieldModifiers:{
            return my.dispatch.VisitFieldModifiers(n2)
        }
        case *MethodDeclaration:{
            return my.dispatch.VisitMethodDeclaration(n2)
        }
        case *MethodHeader:{
            return my.dispatch.VisitMethodHeader(n2)
        }
        case *ResultType:{
            return my.dispatch.VisitResultType(n2)
        }
        case *FormalParameterList:{
            return my.dispatch.VisitFormalParameterList(n2)
        }
        case *FormalParameters:{
            return my.dispatch.VisitFormalParameters(n2)
        }
        case *FormalParameter:{
            return my.dispatch.VisitFormalParameter(n2)
        }
        case *VariableModifiers:{
            return my.dispatch.VisitVariableModifiers(n2)
        }
        case *VariableModifier:{
            return my.dispatch.VisitVariableModifier(n2)
        }
        case *LastFormalParameter:{
            return my.dispatch.VisitLastFormalParameter(n2)
        }
        case *MethodModifiers:{
            return my.dispatch.VisitMethodModifiers(n2)
        }
        case *Throws:{
            return my.dispatch.VisitThrows(n2)
        }
        case *ExceptionTypeList:{
            return my.dispatch.VisitExceptionTypeList(n2)
        }
        case *MethodBody:{
            return my.dispatch.VisitMethodBody(n2)
        }
        case *StaticInitializer:{
            return my.dispatch.VisitStaticInitializer(n2)
        }
        case *ConstructorDeclaration:{
            return my.dispatch.VisitConstructorDeclaration(n2)
        }
        case *ConstructorDeclarator:{
            return my.dispatch.VisitConstructorDeclarator(n2)
        }
        case *ConstructorModifiers:{
            return my.dispatch.VisitConstructorModifiers(n2)
        }
        case *ConstructorBody:{
            return my.dispatch.VisitConstructorBody(n2)
        }
        case *EnumDeclaration:{
            return my.dispatch.VisitEnumDeclaration(n2)
        }
        case *EnumBody:{
            return my.dispatch.VisitEnumBody(n2)
        }
        case *EnumConstants:{
            return my.dispatch.VisitEnumConstants(n2)
        }
        case *EnumConstant:{
            return my.dispatch.VisitEnumConstant(n2)
        }
        case *Arguments:{
            return my.dispatch.VisitArguments(n2)
        }
        case *EnumBodyDeclarations:{
            return my.dispatch.VisitEnumBodyDeclarations(n2)
        }
        case *NormalInterfaceDeclaration:{
            return my.dispatch.VisitNormalInterfaceDeclaration(n2)
        }
        case *InterfaceModifiers:{
            return my.dispatch.VisitInterfaceModifiers(n2)
        }
        case *InterfaceBody:{
            return my.dispatch.VisitInterfaceBody(n2)
        }
        case *InterfaceMemberDeclarations:{
            return my.dispatch.VisitInterfaceMemberDeclarations(n2)
        }
        case *InterfaceMemberDeclaration:{
            return my.dispatch.VisitInterfaceMemberDeclaration(n2)
        }
        case *ConstantDeclaration:{
            return my.dispatch.VisitConstantDeclaration(n2)
        }
        case *ConstantModifiers:{
            return my.dispatch.VisitConstantModifiers(n2)
        }
        case *AbstractMethodDeclaration:{
            return my.dispatch.VisitAbstractMethodDeclaration(n2)
        }
        case *AbstractMethodModifiers:{
            return my.dispatch.VisitAbstractMethodModifiers(n2)
        }
        case *AnnotationTypeDeclaration:{
            return my.dispatch.VisitAnnotationTypeDeclaration(n2)
        }
        case *AnnotationTypeBody:{
            return my.dispatch.VisitAnnotationTypeBody(n2)
        }
        case *AnnotationTypeElementDeclarations:{
            return my.dispatch.VisitAnnotationTypeElementDeclarations(n2)
        }
        case *DefaultValue:{
            return my.dispatch.VisitDefaultValue(n2)
        }
        case *Annotations:{
            return my.dispatch.VisitAnnotations(n2)
        }
        case *NormalAnnotation:{
            return my.dispatch.VisitNormalAnnotation(n2)
        }
        case *ElementValuePairs:{
            return my.dispatch.VisitElementValuePairs(n2)
        }
        case *ElementValuePair:{
            return my.dispatch.VisitElementValuePair(n2)
        }
        case *ElementValueArrayInitializer:{
            return my.dispatch.VisitElementValueArrayInitializer(n2)
        }
        case *ElementValues:{
            return my.dispatch.VisitElementValues(n2)
        }
        case *MarkerAnnotation:{
            return my.dispatch.VisitMarkerAnnotation(n2)
        }
        case *SingleElementAnnotation:{
            return my.dispatch.VisitSingleElementAnnotation(n2)
        }
        case *ArrayInitializer:{
            return my.dispatch.VisitArrayInitializer(n2)
        }
        case *VariableInitializers:{
            return my.dispatch.VisitVariableInitializers(n2)
        }
        case *Block:{
            return my.dispatch.VisitBlock(n2)
        }
        case *BlockStatements:{
            return my.dispatch.VisitBlockStatements(n2)
        }
        case *LocalVariableDeclarationStatement:{
            return my.dispatch.VisitLocalVariableDeclarationStatement(n2)
        }
        case *LocalVariableDeclaration:{
            return my.dispatch.VisitLocalVariableDeclaration(n2)
        }
        case *IfThenStatement:{
            return my.dispatch.VisitIfThenStatement(n2)
        }
        case *IfThenElseStatement:{
            return my.dispatch.VisitIfThenElseStatement(n2)
        }
        case *IfThenElseStatementNoShortIf:{
            return my.dispatch.VisitIfThenElseStatementNoShortIf(n2)
        }
        case *EmptyStatement:{
            return my.dispatch.VisitEmptyStatement(n2)
        }
        case *LabeledStatement:{
            return my.dispatch.VisitLabeledStatement(n2)
        }
        case *LabeledStatementNoShortIf:{
            return my.dispatch.VisitLabeledStatementNoShortIf(n2)
        }
        case *ExpressionStatement:{
            return my.dispatch.VisitExpressionStatement(n2)
        }
        case *SwitchStatement:{
            return my.dispatch.VisitSwitchStatement(n2)
        }
        case *SwitchBlock:{
            return my.dispatch.VisitSwitchBlock(n2)
        }
        case *SwitchBlockStatementGroups:{
            return my.dispatch.VisitSwitchBlockStatementGroups(n2)
        }
        case *SwitchBlockStatementGroup:{
            return my.dispatch.VisitSwitchBlockStatementGroup(n2)
        }
        case *SwitchLabels:{
            return my.dispatch.VisitSwitchLabels(n2)
        }
        case *WhileStatement:{
            return my.dispatch.VisitWhileStatement(n2)
        }
        case *WhileStatementNoShortIf:{
            return my.dispatch.VisitWhileStatementNoShortIf(n2)
        }
        case *DoStatement:{
            return my.dispatch.VisitDoStatement(n2)
        }
        case *BasicForStatement:{
            return my.dispatch.VisitBasicForStatement(n2)
        }
        case *ForStatementNoShortIf:{
            return my.dispatch.VisitForStatementNoShortIf(n2)
        }
        case *StatementExpressionList:{
            return my.dispatch.VisitStatementExpressionList(n2)
        }
        case *EnhancedForStatement:{
            return my.dispatch.VisitEnhancedForStatement(n2)
        }
        case *BreakStatement:{
            return my.dispatch.VisitBreakStatement(n2)
        }
        case *ContinueStatement:{
            return my.dispatch.VisitContinueStatement(n2)
        }
        case *ReturnStatement:{
            return my.dispatch.VisitReturnStatement(n2)
        }
        case *ThrowStatement:{
            return my.dispatch.VisitThrowStatement(n2)
        }
        case *SynchronizedStatement:{
            return my.dispatch.VisitSynchronizedStatement(n2)
        }
        case *Catches:{
            return my.dispatch.VisitCatches(n2)
        }
        case *CatchClause:{
            return my.dispatch.VisitCatchClause(n2)
        }
        case *Finally:{
            return my.dispatch.VisitFinally(n2)
        }
        case *ArgumentList:{
            return my.dispatch.VisitArgumentList(n2)
        }
        case *DimExprs:{
            return my.dispatch.VisitDimExprs(n2)
        }
        case *DimExpr:{
            return my.dispatch.VisitDimExpr(n2)
        }
        case *PostIncrementExpression:{
            return my.dispatch.VisitPostIncrementExpression(n2)
        }
        case *PostDecrementExpression:{
            return my.dispatch.VisitPostDecrementExpression(n2)
        }
        case *PreIncrementExpression:{
            return my.dispatch.VisitPreIncrementExpression(n2)
        }
        case *PreDecrementExpression:{
            return my.dispatch.VisitPreDecrementExpression(n2)
        }
        case *AndExpression:{
            return my.dispatch.VisitAndExpression(n2)
        }
        case *ExclusiveOrExpression:{
            return my.dispatch.VisitExclusiveOrExpression(n2)
        }
        case *InclusiveOrExpression:{
            return my.dispatch.VisitInclusiveOrExpression(n2)
        }
        case *ConditionalAndExpression:{
            return my.dispatch.VisitConditionalAndExpression(n2)
        }
        case *ConditionalOrExpression:{
            return my.dispatch.VisitConditionalOrExpression(n2)
        }
        case *ConditionalExpression:{
            return my.dispatch.VisitConditionalExpression(n2)
        }
        case *Assignment:{
            return my.dispatch.VisitAssignment(n2)
        }
        case *Commaopt:{
            return my.dispatch.VisitCommaopt(n2)
        }
        case *Ellipsisopt:{
            return my.dispatch.VisitEllipsisopt(n2)
        }
        case *LPGUserAction0:{
            return my.dispatch.VisitLPGUserAction0(n2)
        }
        case *LPGUserAction1:{
            return my.dispatch.VisitLPGUserAction1(n2)
        }
        case *LPGUserAction2:{
            return my.dispatch.VisitLPGUserAction2(n2)
        }
        case *LPGUserAction3:{
            return my.dispatch.VisitLPGUserAction3(n2)
        }
        case *LPGUserAction4:{
            return my.dispatch.VisitLPGUserAction4(n2)
        }
        case *IntegralType0:{
            return my.dispatch.VisitIntegralType0(n2)
        }
        case *IntegralType1:{
            return my.dispatch.VisitIntegralType1(n2)
        }
        case *IntegralType2:{
            return my.dispatch.VisitIntegralType2(n2)
        }
        case *IntegralType3:{
            return my.dispatch.VisitIntegralType3(n2)
        }
        case *IntegralType4:{
            return my.dispatch.VisitIntegralType4(n2)
        }
        case *FloatingPointType0:{
            return my.dispatch.VisitFloatingPointType0(n2)
        }
        case *FloatingPointType1:{
            return my.dispatch.VisitFloatingPointType1(n2)
        }
        case *WildcardBounds0:{
            return my.dispatch.VisitWildcardBounds0(n2)
        }
        case *WildcardBounds1:{
            return my.dispatch.VisitWildcardBounds1(n2)
        }
        case *ClassModifier0:{
            return my.dispatch.VisitClassModifier0(n2)
        }
        case *ClassModifier1:{
            return my.dispatch.VisitClassModifier1(n2)
        }
        case *ClassModifier2:{
            return my.dispatch.VisitClassModifier2(n2)
        }
        case *ClassModifier3:{
            return my.dispatch.VisitClassModifier3(n2)
        }
        case *ClassModifier4:{
            return my.dispatch.VisitClassModifier4(n2)
        }
        case *ClassModifier5:{
            return my.dispatch.VisitClassModifier5(n2)
        }
        case *ClassModifier6:{
            return my.dispatch.VisitClassModifier6(n2)
        }
        case *FieldModifier0:{
            return my.dispatch.VisitFieldModifier0(n2)
        }
        case *FieldModifier1:{
            return my.dispatch.VisitFieldModifier1(n2)
        }
        case *FieldModifier2:{
            return my.dispatch.VisitFieldModifier2(n2)
        }
        case *FieldModifier3:{
            return my.dispatch.VisitFieldModifier3(n2)
        }
        case *FieldModifier4:{
            return my.dispatch.VisitFieldModifier4(n2)
        }
        case *FieldModifier5:{
            return my.dispatch.VisitFieldModifier5(n2)
        }
        case *FieldModifier6:{
            return my.dispatch.VisitFieldModifier6(n2)
        }
        case *MethodDeclarator0:{
            return my.dispatch.VisitMethodDeclarator0(n2)
        }
        case *MethodDeclarator1:{
            return my.dispatch.VisitMethodDeclarator1(n2)
        }
        case *MethodModifier0:{
            return my.dispatch.VisitMethodModifier0(n2)
        }
        case *MethodModifier1:{
            return my.dispatch.VisitMethodModifier1(n2)
        }
        case *MethodModifier2:{
            return my.dispatch.VisitMethodModifier2(n2)
        }
        case *MethodModifier3:{
            return my.dispatch.VisitMethodModifier3(n2)
        }
        case *MethodModifier4:{
            return my.dispatch.VisitMethodModifier4(n2)
        }
        case *MethodModifier5:{
            return my.dispatch.VisitMethodModifier5(n2)
        }
        case *MethodModifier6:{
            return my.dispatch.VisitMethodModifier6(n2)
        }
        case *MethodModifier7:{
            return my.dispatch.VisitMethodModifier7(n2)
        }
        case *MethodModifier8:{
            return my.dispatch.VisitMethodModifier8(n2)
        }
        case *ConstructorModifier0:{
            return my.dispatch.VisitConstructorModifier0(n2)
        }
        case *ConstructorModifier1:{
            return my.dispatch.VisitConstructorModifier1(n2)
        }
        case *ConstructorModifier2:{
            return my.dispatch.VisitConstructorModifier2(n2)
        }
        case *ExplicitConstructorInvocation0:{
            return my.dispatch.VisitExplicitConstructorInvocation0(n2)
        }
        case *ExplicitConstructorInvocation1:{
            return my.dispatch.VisitExplicitConstructorInvocation1(n2)
        }
        case *ExplicitConstructorInvocation2:{
            return my.dispatch.VisitExplicitConstructorInvocation2(n2)
        }
        case *InterfaceModifier0:{
            return my.dispatch.VisitInterfaceModifier0(n2)
        }
        case *InterfaceModifier1:{
            return my.dispatch.VisitInterfaceModifier1(n2)
        }
        case *InterfaceModifier2:{
            return my.dispatch.VisitInterfaceModifier2(n2)
        }
        case *InterfaceModifier3:{
            return my.dispatch.VisitInterfaceModifier3(n2)
        }
        case *InterfaceModifier4:{
            return my.dispatch.VisitInterfaceModifier4(n2)
        }
        case *InterfaceModifier5:{
            return my.dispatch.VisitInterfaceModifier5(n2)
        }
        case *ExtendsInterfaces0:{
            return my.dispatch.VisitExtendsInterfaces0(n2)
        }
        case *ExtendsInterfaces1:{
            return my.dispatch.VisitExtendsInterfaces1(n2)
        }
        case *ConstantModifier0:{
            return my.dispatch.VisitConstantModifier0(n2)
        }
        case *ConstantModifier1:{
            return my.dispatch.VisitConstantModifier1(n2)
        }
        case *ConstantModifier2:{
            return my.dispatch.VisitConstantModifier2(n2)
        }
        case *AbstractMethodModifier0:{
            return my.dispatch.VisitAbstractMethodModifier0(n2)
        }
        case *AbstractMethodModifier1:{
            return my.dispatch.VisitAbstractMethodModifier1(n2)
        }
        case *AnnotationTypeElementDeclaration0:{
            return my.dispatch.VisitAnnotationTypeElementDeclaration0(n2)
        }
        case *AnnotationTypeElementDeclaration1:{
            return my.dispatch.VisitAnnotationTypeElementDeclaration1(n2)
        }
        case *AssertStatement0:{
            return my.dispatch.VisitAssertStatement0(n2)
        }
        case *AssertStatement1:{
            return my.dispatch.VisitAssertStatement1(n2)
        }
        case *SwitchLabel0:{
            return my.dispatch.VisitSwitchLabel0(n2)
        }
        case *SwitchLabel1:{
            return my.dispatch.VisitSwitchLabel1(n2)
        }
        case *SwitchLabel2:{
            return my.dispatch.VisitSwitchLabel2(n2)
        }
        case *TryStatement0:{
            return my.dispatch.VisitTryStatement0(n2)
        }
        case *TryStatement1:{
            return my.dispatch.VisitTryStatement1(n2)
        }
        case *PrimaryNoNewArray0:{
            return my.dispatch.VisitPrimaryNoNewArray0(n2)
        }
        case *PrimaryNoNewArray1:{
            return my.dispatch.VisitPrimaryNoNewArray1(n2)
        }
        case *PrimaryNoNewArray2:{
            return my.dispatch.VisitPrimaryNoNewArray2(n2)
        }
        case *PrimaryNoNewArray3:{
            return my.dispatch.VisitPrimaryNoNewArray3(n2)
        }
        case *PrimaryNoNewArray4:{
            return my.dispatch.VisitPrimaryNoNewArray4(n2)
        }
        case *Literal0:{
            return my.dispatch.VisitLiteral0(n2)
        }
        case *Literal1:{
            return my.dispatch.VisitLiteral1(n2)
        }
        case *Literal2:{
            return my.dispatch.VisitLiteral2(n2)
        }
        case *Literal3:{
            return my.dispatch.VisitLiteral3(n2)
        }
        case *Literal4:{
            return my.dispatch.VisitLiteral4(n2)
        }
        case *Literal5:{
            return my.dispatch.VisitLiteral5(n2)
        }
        case *Literal6:{
            return my.dispatch.VisitLiteral6(n2)
        }
        case *BooleanLiteral0:{
            return my.dispatch.VisitBooleanLiteral0(n2)
        }
        case *BooleanLiteral1:{
            return my.dispatch.VisitBooleanLiteral1(n2)
        }
        case *ClassInstanceCreationExpression0:{
            return my.dispatch.VisitClassInstanceCreationExpression0(n2)
        }
        case *ClassInstanceCreationExpression1:{
            return my.dispatch.VisitClassInstanceCreationExpression1(n2)
        }
        case *ArrayCreationExpression0:{
            return my.dispatch.VisitArrayCreationExpression0(n2)
        }
        case *ArrayCreationExpression1:{
            return my.dispatch.VisitArrayCreationExpression1(n2)
        }
        case *ArrayCreationExpression2:{
            return my.dispatch.VisitArrayCreationExpression2(n2)
        }
        case *ArrayCreationExpression3:{
            return my.dispatch.VisitArrayCreationExpression3(n2)
        }
        case *Dims0:{
            return my.dispatch.VisitDims0(n2)
        }
        case *Dims1:{
            return my.dispatch.VisitDims1(n2)
        }
        case *FieldAccess0:{
            return my.dispatch.VisitFieldAccess0(n2)
        }
        case *FieldAccess1:{
            return my.dispatch.VisitFieldAccess1(n2)
        }
        case *FieldAccess2:{
            return my.dispatch.VisitFieldAccess2(n2)
        }
        case *MethodInvocation0:{
            return my.dispatch.VisitMethodInvocation0(n2)
        }
        case *MethodInvocation1:{
            return my.dispatch.VisitMethodInvocation1(n2)
        }
        case *MethodInvocation2:{
            return my.dispatch.VisitMethodInvocation2(n2)
        }
        case *MethodInvocation3:{
            return my.dispatch.VisitMethodInvocation3(n2)
        }
        case *MethodInvocation4:{
            return my.dispatch.VisitMethodInvocation4(n2)
        }
        case *ArrayAccess0:{
            return my.dispatch.VisitArrayAccess0(n2)
        }
        case *ArrayAccess1:{
            return my.dispatch.VisitArrayAccess1(n2)
        }
        case *UnaryExpression0:{
            return my.dispatch.VisitUnaryExpression0(n2)
        }
        case *UnaryExpression1:{
            return my.dispatch.VisitUnaryExpression1(n2)
        }
        case *UnaryExpressionNotPlusMinus0:{
            return my.dispatch.VisitUnaryExpressionNotPlusMinus0(n2)
        }
        case *UnaryExpressionNotPlusMinus1:{
            return my.dispatch.VisitUnaryExpressionNotPlusMinus1(n2)
        }
        case *CastExpression0:{
            return my.dispatch.VisitCastExpression0(n2)
        }
        case *CastExpression1:{
            return my.dispatch.VisitCastExpression1(n2)
        }
        case *MultiplicativeExpression0:{
            return my.dispatch.VisitMultiplicativeExpression0(n2)
        }
        case *MultiplicativeExpression1:{
            return my.dispatch.VisitMultiplicativeExpression1(n2)
        }
        case *MultiplicativeExpression2:{
            return my.dispatch.VisitMultiplicativeExpression2(n2)
        }
        case *AdditiveExpression0:{
            return my.dispatch.VisitAdditiveExpression0(n2)
        }
        case *AdditiveExpression1:{
            return my.dispatch.VisitAdditiveExpression1(n2)
        }
        case *ShiftExpression0:{
            return my.dispatch.VisitShiftExpression0(n2)
        }
        case *ShiftExpression1:{
            return my.dispatch.VisitShiftExpression1(n2)
        }
        case *ShiftExpression2:{
            return my.dispatch.VisitShiftExpression2(n2)
        }
        case *RelationalExpression0:{
            return my.dispatch.VisitRelationalExpression0(n2)
        }
        case *RelationalExpression1:{
            return my.dispatch.VisitRelationalExpression1(n2)
        }
        case *RelationalExpression2:{
            return my.dispatch.VisitRelationalExpression2(n2)
        }
        case *RelationalExpression3:{
            return my.dispatch.VisitRelationalExpression3(n2)
        }
        case *RelationalExpression4:{
            return my.dispatch.VisitRelationalExpression4(n2)
        }
        case *EqualityExpression0:{
            return my.dispatch.VisitEqualityExpression0(n2)
        }
        case *EqualityExpression1:{
            return my.dispatch.VisitEqualityExpression1(n2)
        }
        case *AssignmentOperator0:{
            return my.dispatch.VisitAssignmentOperator0(n2)
        }
        case *AssignmentOperator1:{
            return my.dispatch.VisitAssignmentOperator1(n2)
        }
        case *AssignmentOperator2:{
            return my.dispatch.VisitAssignmentOperator2(n2)
        }
        case *AssignmentOperator3:{
            return my.dispatch.VisitAssignmentOperator3(n2)
        }
        case *AssignmentOperator4:{
            return my.dispatch.VisitAssignmentOperator4(n2)
        }
        case *AssignmentOperator5:{
            return my.dispatch.VisitAssignmentOperator5(n2)
        }
        case *AssignmentOperator6:{
            return my.dispatch.VisitAssignmentOperator6(n2)
        }
        case *AssignmentOperator7:{
            return my.dispatch.VisitAssignmentOperator7(n2)
        }
        case *AssignmentOperator8:{
            return my.dispatch.VisitAssignmentOperator8(n2)
        }
        case *AssignmentOperator9:{
            return my.dispatch.VisitAssignmentOperator9(n2)
        }
        case *AssignmentOperator10:{
            return my.dispatch.VisitAssignmentOperator10(n2)
        }
        case *AssignmentOperator11:{
            return my.dispatch.VisitAssignmentOperator11(n2)
        }
        default:{ return false}
     }
}
func (my *AbstractVisitor)     EndVisit(n  IAst){
     switch n2 := n.(type) {
        case *AstToken:{
            my.dispatch.EndVisitAstToken(n2)
        }
        case *identifier:{
            my.dispatch.EndVisitidentifier(n2)
        }
        case *PrimitiveType:{
            my.dispatch.EndVisitPrimitiveType(n2)
        }
        case *ClassType:{
            my.dispatch.EndVisitClassType(n2)
        }
        case *InterfaceType:{
            my.dispatch.EndVisitInterfaceType(n2)
        }
        case *TypeName:{
            my.dispatch.EndVisitTypeName(n2)
        }
        case *ArrayType:{
            my.dispatch.EndVisitArrayType(n2)
        }
        case *TypeParameter:{
            my.dispatch.EndVisitTypeParameter(n2)
        }
        case *TypeBound:{
            my.dispatch.EndVisitTypeBound(n2)
        }
        case *AdditionalBoundList:{
            my.dispatch.EndVisitAdditionalBoundList(n2)
        }
        case *AdditionalBound:{
            my.dispatch.EndVisitAdditionalBound(n2)
        }
        case *TypeArguments:{
            my.dispatch.EndVisitTypeArguments(n2)
        }
        case *ActualTypeArgumentList:{
            my.dispatch.EndVisitActualTypeArgumentList(n2)
        }
        case *Wildcard:{
            my.dispatch.EndVisitWildcard(n2)
        }
        case *PackageName:{
            my.dispatch.EndVisitPackageName(n2)
        }
        case *ExpressionName:{
            my.dispatch.EndVisitExpressionName(n2)
        }
        case *MethodName:{
            my.dispatch.EndVisitMethodName(n2)
        }
        case *PackageOrTypeName:{
            my.dispatch.EndVisitPackageOrTypeName(n2)
        }
        case *AmbiguousName:{
            my.dispatch.EndVisitAmbiguousName(n2)
        }
        case *CompilationUnit:{
            my.dispatch.EndVisitCompilationUnit(n2)
        }
        case *ImportDeclarations:{
            my.dispatch.EndVisitImportDeclarations(n2)
        }
        case *TypeDeclarations:{
            my.dispatch.EndVisitTypeDeclarations(n2)
        }
        case *PackageDeclaration:{
            my.dispatch.EndVisitPackageDeclaration(n2)
        }
        case *SingleTypeImportDeclaration:{
            my.dispatch.EndVisitSingleTypeImportDeclaration(n2)
        }
        case *TypeImportOnDemandDeclaration:{
            my.dispatch.EndVisitTypeImportOnDemandDeclaration(n2)
        }
        case *SingleStaticImportDeclaration:{
            my.dispatch.EndVisitSingleStaticImportDeclaration(n2)
        }
        case *StaticImportOnDemandDeclaration:{
            my.dispatch.EndVisitStaticImportOnDemandDeclaration(n2)
        }
        case *TypeDeclaration:{
            my.dispatch.EndVisitTypeDeclaration(n2)
        }
        case *NormalClassDeclaration:{
            my.dispatch.EndVisitNormalClassDeclaration(n2)
        }
        case *ClassModifiers:{
            my.dispatch.EndVisitClassModifiers(n2)
        }
        case *TypeParameters:{
            my.dispatch.EndVisitTypeParameters(n2)
        }
        case *TypeParameterList:{
            my.dispatch.EndVisitTypeParameterList(n2)
        }
        case *Super:{
            my.dispatch.EndVisitSuper(n2)
        }
        case *Interfaces:{
            my.dispatch.EndVisitInterfaces(n2)
        }
        case *InterfaceTypeList:{
            my.dispatch.EndVisitInterfaceTypeList(n2)
        }
        case *ClassBody:{
            my.dispatch.EndVisitClassBody(n2)
        }
        case *ClassBodyDeclarations:{
            my.dispatch.EndVisitClassBodyDeclarations(n2)
        }
        case *ClassMemberDeclaration:{
            my.dispatch.EndVisitClassMemberDeclaration(n2)
        }
        case *FieldDeclaration:{
            my.dispatch.EndVisitFieldDeclaration(n2)
        }
        case *VariableDeclarators:{
            my.dispatch.EndVisitVariableDeclarators(n2)
        }
        case *VariableDeclarator:{
            my.dispatch.EndVisitVariableDeclarator(n2)
        }
        case *VariableDeclaratorId:{
            my.dispatch.EndVisitVariableDeclaratorId(n2)
        }
        case *FieldModifiers:{
            my.dispatch.EndVisitFieldModifiers(n2)
        }
        case *MethodDeclaration:{
            my.dispatch.EndVisitMethodDeclaration(n2)
        }
        case *MethodHeader:{
            my.dispatch.EndVisitMethodHeader(n2)
        }
        case *ResultType:{
            my.dispatch.EndVisitResultType(n2)
        }
        case *FormalParameterList:{
            my.dispatch.EndVisitFormalParameterList(n2)
        }
        case *FormalParameters:{
            my.dispatch.EndVisitFormalParameters(n2)
        }
        case *FormalParameter:{
            my.dispatch.EndVisitFormalParameter(n2)
        }
        case *VariableModifiers:{
            my.dispatch.EndVisitVariableModifiers(n2)
        }
        case *VariableModifier:{
            my.dispatch.EndVisitVariableModifier(n2)
        }
        case *LastFormalParameter:{
            my.dispatch.EndVisitLastFormalParameter(n2)
        }
        case *MethodModifiers:{
            my.dispatch.EndVisitMethodModifiers(n2)
        }
        case *Throws:{
            my.dispatch.EndVisitThrows(n2)
        }
        case *ExceptionTypeList:{
            my.dispatch.EndVisitExceptionTypeList(n2)
        }
        case *MethodBody:{
            my.dispatch.EndVisitMethodBody(n2)
        }
        case *StaticInitializer:{
            my.dispatch.EndVisitStaticInitializer(n2)
        }
        case *ConstructorDeclaration:{
            my.dispatch.EndVisitConstructorDeclaration(n2)
        }
        case *ConstructorDeclarator:{
            my.dispatch.EndVisitConstructorDeclarator(n2)
        }
        case *ConstructorModifiers:{
            my.dispatch.EndVisitConstructorModifiers(n2)
        }
        case *ConstructorBody:{
            my.dispatch.EndVisitConstructorBody(n2)
        }
        case *EnumDeclaration:{
            my.dispatch.EndVisitEnumDeclaration(n2)
        }
        case *EnumBody:{
            my.dispatch.EndVisitEnumBody(n2)
        }
        case *EnumConstants:{
            my.dispatch.EndVisitEnumConstants(n2)
        }
        case *EnumConstant:{
            my.dispatch.EndVisitEnumConstant(n2)
        }
        case *Arguments:{
            my.dispatch.EndVisitArguments(n2)
        }
        case *EnumBodyDeclarations:{
            my.dispatch.EndVisitEnumBodyDeclarations(n2)
        }
        case *NormalInterfaceDeclaration:{
            my.dispatch.EndVisitNormalInterfaceDeclaration(n2)
        }
        case *InterfaceModifiers:{
            my.dispatch.EndVisitInterfaceModifiers(n2)
        }
        case *InterfaceBody:{
            my.dispatch.EndVisitInterfaceBody(n2)
        }
        case *InterfaceMemberDeclarations:{
            my.dispatch.EndVisitInterfaceMemberDeclarations(n2)
        }
        case *InterfaceMemberDeclaration:{
            my.dispatch.EndVisitInterfaceMemberDeclaration(n2)
        }
        case *ConstantDeclaration:{
            my.dispatch.EndVisitConstantDeclaration(n2)
        }
        case *ConstantModifiers:{
            my.dispatch.EndVisitConstantModifiers(n2)
        }
        case *AbstractMethodDeclaration:{
            my.dispatch.EndVisitAbstractMethodDeclaration(n2)
        }
        case *AbstractMethodModifiers:{
            my.dispatch.EndVisitAbstractMethodModifiers(n2)
        }
        case *AnnotationTypeDeclaration:{
            my.dispatch.EndVisitAnnotationTypeDeclaration(n2)
        }
        case *AnnotationTypeBody:{
            my.dispatch.EndVisitAnnotationTypeBody(n2)
        }
        case *AnnotationTypeElementDeclarations:{
            my.dispatch.EndVisitAnnotationTypeElementDeclarations(n2)
        }
        case *DefaultValue:{
            my.dispatch.EndVisitDefaultValue(n2)
        }
        case *Annotations:{
            my.dispatch.EndVisitAnnotations(n2)
        }
        case *NormalAnnotation:{
            my.dispatch.EndVisitNormalAnnotation(n2)
        }
        case *ElementValuePairs:{
            my.dispatch.EndVisitElementValuePairs(n2)
        }
        case *ElementValuePair:{
            my.dispatch.EndVisitElementValuePair(n2)
        }
        case *ElementValueArrayInitializer:{
            my.dispatch.EndVisitElementValueArrayInitializer(n2)
        }
        case *ElementValues:{
            my.dispatch.EndVisitElementValues(n2)
        }
        case *MarkerAnnotation:{
            my.dispatch.EndVisitMarkerAnnotation(n2)
        }
        case *SingleElementAnnotation:{
            my.dispatch.EndVisitSingleElementAnnotation(n2)
        }
        case *ArrayInitializer:{
            my.dispatch.EndVisitArrayInitializer(n2)
        }
        case *VariableInitializers:{
            my.dispatch.EndVisitVariableInitializers(n2)
        }
        case *Block:{
            my.dispatch.EndVisitBlock(n2)
        }
        case *BlockStatements:{
            my.dispatch.EndVisitBlockStatements(n2)
        }
        case *LocalVariableDeclarationStatement:{
            my.dispatch.EndVisitLocalVariableDeclarationStatement(n2)
        }
        case *LocalVariableDeclaration:{
            my.dispatch.EndVisitLocalVariableDeclaration(n2)
        }
        case *IfThenStatement:{
            my.dispatch.EndVisitIfThenStatement(n2)
        }
        case *IfThenElseStatement:{
            my.dispatch.EndVisitIfThenElseStatement(n2)
        }
        case *IfThenElseStatementNoShortIf:{
            my.dispatch.EndVisitIfThenElseStatementNoShortIf(n2)
        }
        case *EmptyStatement:{
            my.dispatch.EndVisitEmptyStatement(n2)
        }
        case *LabeledStatement:{
            my.dispatch.EndVisitLabeledStatement(n2)
        }
        case *LabeledStatementNoShortIf:{
            my.dispatch.EndVisitLabeledStatementNoShortIf(n2)
        }
        case *ExpressionStatement:{
            my.dispatch.EndVisitExpressionStatement(n2)
        }
        case *SwitchStatement:{
            my.dispatch.EndVisitSwitchStatement(n2)
        }
        case *SwitchBlock:{
            my.dispatch.EndVisitSwitchBlock(n2)
        }
        case *SwitchBlockStatementGroups:{
            my.dispatch.EndVisitSwitchBlockStatementGroups(n2)
        }
        case *SwitchBlockStatementGroup:{
            my.dispatch.EndVisitSwitchBlockStatementGroup(n2)
        }
        case *SwitchLabels:{
            my.dispatch.EndVisitSwitchLabels(n2)
        }
        case *WhileStatement:{
            my.dispatch.EndVisitWhileStatement(n2)
        }
        case *WhileStatementNoShortIf:{
            my.dispatch.EndVisitWhileStatementNoShortIf(n2)
        }
        case *DoStatement:{
            my.dispatch.EndVisitDoStatement(n2)
        }
        case *BasicForStatement:{
            my.dispatch.EndVisitBasicForStatement(n2)
        }
        case *ForStatementNoShortIf:{
            my.dispatch.EndVisitForStatementNoShortIf(n2)
        }
        case *StatementExpressionList:{
            my.dispatch.EndVisitStatementExpressionList(n2)
        }
        case *EnhancedForStatement:{
            my.dispatch.EndVisitEnhancedForStatement(n2)
        }
        case *BreakStatement:{
            my.dispatch.EndVisitBreakStatement(n2)
        }
        case *ContinueStatement:{
            my.dispatch.EndVisitContinueStatement(n2)
        }
        case *ReturnStatement:{
            my.dispatch.EndVisitReturnStatement(n2)
        }
        case *ThrowStatement:{
            my.dispatch.EndVisitThrowStatement(n2)
        }
        case *SynchronizedStatement:{
            my.dispatch.EndVisitSynchronizedStatement(n2)
        }
        case *Catches:{
            my.dispatch.EndVisitCatches(n2)
        }
        case *CatchClause:{
            my.dispatch.EndVisitCatchClause(n2)
        }
        case *Finally:{
            my.dispatch.EndVisitFinally(n2)
        }
        case *ArgumentList:{
            my.dispatch.EndVisitArgumentList(n2)
        }
        case *DimExprs:{
            my.dispatch.EndVisitDimExprs(n2)
        }
        case *DimExpr:{
            my.dispatch.EndVisitDimExpr(n2)
        }
        case *PostIncrementExpression:{
            my.dispatch.EndVisitPostIncrementExpression(n2)
        }
        case *PostDecrementExpression:{
            my.dispatch.EndVisitPostDecrementExpression(n2)
        }
        case *PreIncrementExpression:{
            my.dispatch.EndVisitPreIncrementExpression(n2)
        }
        case *PreDecrementExpression:{
            my.dispatch.EndVisitPreDecrementExpression(n2)
        }
        case *AndExpression:{
            my.dispatch.EndVisitAndExpression(n2)
        }
        case *ExclusiveOrExpression:{
            my.dispatch.EndVisitExclusiveOrExpression(n2)
        }
        case *InclusiveOrExpression:{
            my.dispatch.EndVisitInclusiveOrExpression(n2)
        }
        case *ConditionalAndExpression:{
            my.dispatch.EndVisitConditionalAndExpression(n2)
        }
        case *ConditionalOrExpression:{
            my.dispatch.EndVisitConditionalOrExpression(n2)
        }
        case *ConditionalExpression:{
            my.dispatch.EndVisitConditionalExpression(n2)
        }
        case *Assignment:{
            my.dispatch.EndVisitAssignment(n2)
        }
        case *Commaopt:{
            my.dispatch.EndVisitCommaopt(n2)
        }
        case *Ellipsisopt:{
            my.dispatch.EndVisitEllipsisopt(n2)
        }
        case *LPGUserAction0:{
            my.dispatch.EndVisitLPGUserAction0(n2)
        }
        case *LPGUserAction1:{
            my.dispatch.EndVisitLPGUserAction1(n2)
        }
        case *LPGUserAction2:{
            my.dispatch.EndVisitLPGUserAction2(n2)
        }
        case *LPGUserAction3:{
            my.dispatch.EndVisitLPGUserAction3(n2)
        }
        case *LPGUserAction4:{
            my.dispatch.EndVisitLPGUserAction4(n2)
        }
        case *IntegralType0:{
            my.dispatch.EndVisitIntegralType0(n2)
        }
        case *IntegralType1:{
            my.dispatch.EndVisitIntegralType1(n2)
        }
        case *IntegralType2:{
            my.dispatch.EndVisitIntegralType2(n2)
        }
        case *IntegralType3:{
            my.dispatch.EndVisitIntegralType3(n2)
        }
        case *IntegralType4:{
            my.dispatch.EndVisitIntegralType4(n2)
        }
        case *FloatingPointType0:{
            my.dispatch.EndVisitFloatingPointType0(n2)
        }
        case *FloatingPointType1:{
            my.dispatch.EndVisitFloatingPointType1(n2)
        }
        case *WildcardBounds0:{
            my.dispatch.EndVisitWildcardBounds0(n2)
        }
        case *WildcardBounds1:{
            my.dispatch.EndVisitWildcardBounds1(n2)
        }
        case *ClassModifier0:{
            my.dispatch.EndVisitClassModifier0(n2)
        }
        case *ClassModifier1:{
            my.dispatch.EndVisitClassModifier1(n2)
        }
        case *ClassModifier2:{
            my.dispatch.EndVisitClassModifier2(n2)
        }
        case *ClassModifier3:{
            my.dispatch.EndVisitClassModifier3(n2)
        }
        case *ClassModifier4:{
            my.dispatch.EndVisitClassModifier4(n2)
        }
        case *ClassModifier5:{
            my.dispatch.EndVisitClassModifier5(n2)
        }
        case *ClassModifier6:{
            my.dispatch.EndVisitClassModifier6(n2)
        }
        case *FieldModifier0:{
            my.dispatch.EndVisitFieldModifier0(n2)
        }
        case *FieldModifier1:{
            my.dispatch.EndVisitFieldModifier1(n2)
        }
        case *FieldModifier2:{
            my.dispatch.EndVisitFieldModifier2(n2)
        }
        case *FieldModifier3:{
            my.dispatch.EndVisitFieldModifier3(n2)
        }
        case *FieldModifier4:{
            my.dispatch.EndVisitFieldModifier4(n2)
        }
        case *FieldModifier5:{
            my.dispatch.EndVisitFieldModifier5(n2)
        }
        case *FieldModifier6:{
            my.dispatch.EndVisitFieldModifier6(n2)
        }
        case *MethodDeclarator0:{
            my.dispatch.EndVisitMethodDeclarator0(n2)
        }
        case *MethodDeclarator1:{
            my.dispatch.EndVisitMethodDeclarator1(n2)
        }
        case *MethodModifier0:{
            my.dispatch.EndVisitMethodModifier0(n2)
        }
        case *MethodModifier1:{
            my.dispatch.EndVisitMethodModifier1(n2)
        }
        case *MethodModifier2:{
            my.dispatch.EndVisitMethodModifier2(n2)
        }
        case *MethodModifier3:{
            my.dispatch.EndVisitMethodModifier3(n2)
        }
        case *MethodModifier4:{
            my.dispatch.EndVisitMethodModifier4(n2)
        }
        case *MethodModifier5:{
            my.dispatch.EndVisitMethodModifier5(n2)
        }
        case *MethodModifier6:{
            my.dispatch.EndVisitMethodModifier6(n2)
        }
        case *MethodModifier7:{
            my.dispatch.EndVisitMethodModifier7(n2)
        }
        case *MethodModifier8:{
            my.dispatch.EndVisitMethodModifier8(n2)
        }
        case *ConstructorModifier0:{
            my.dispatch.EndVisitConstructorModifier0(n2)
        }
        case *ConstructorModifier1:{
            my.dispatch.EndVisitConstructorModifier1(n2)
        }
        case *ConstructorModifier2:{
            my.dispatch.EndVisitConstructorModifier2(n2)
        }
        case *ExplicitConstructorInvocation0:{
            my.dispatch.EndVisitExplicitConstructorInvocation0(n2)
        }
        case *ExplicitConstructorInvocation1:{
            my.dispatch.EndVisitExplicitConstructorInvocation1(n2)
        }
        case *ExplicitConstructorInvocation2:{
            my.dispatch.EndVisitExplicitConstructorInvocation2(n2)
        }
        case *InterfaceModifier0:{
            my.dispatch.EndVisitInterfaceModifier0(n2)
        }
        case *InterfaceModifier1:{
            my.dispatch.EndVisitInterfaceModifier1(n2)
        }
        case *InterfaceModifier2:{
            my.dispatch.EndVisitInterfaceModifier2(n2)
        }
        case *InterfaceModifier3:{
            my.dispatch.EndVisitInterfaceModifier3(n2)
        }
        case *InterfaceModifier4:{
            my.dispatch.EndVisitInterfaceModifier4(n2)
        }
        case *InterfaceModifier5:{
            my.dispatch.EndVisitInterfaceModifier5(n2)
        }
        case *ExtendsInterfaces0:{
            my.dispatch.EndVisitExtendsInterfaces0(n2)
        }
        case *ExtendsInterfaces1:{
            my.dispatch.EndVisitExtendsInterfaces1(n2)
        }
        case *ConstantModifier0:{
            my.dispatch.EndVisitConstantModifier0(n2)
        }
        case *ConstantModifier1:{
            my.dispatch.EndVisitConstantModifier1(n2)
        }
        case *ConstantModifier2:{
            my.dispatch.EndVisitConstantModifier2(n2)
        }
        case *AbstractMethodModifier0:{
            my.dispatch.EndVisitAbstractMethodModifier0(n2)
        }
        case *AbstractMethodModifier1:{
            my.dispatch.EndVisitAbstractMethodModifier1(n2)
        }
        case *AnnotationTypeElementDeclaration0:{
            my.dispatch.EndVisitAnnotationTypeElementDeclaration0(n2)
        }
        case *AnnotationTypeElementDeclaration1:{
            my.dispatch.EndVisitAnnotationTypeElementDeclaration1(n2)
        }
        case *AssertStatement0:{
            my.dispatch.EndVisitAssertStatement0(n2)
        }
        case *AssertStatement1:{
            my.dispatch.EndVisitAssertStatement1(n2)
        }
        case *SwitchLabel0:{
            my.dispatch.EndVisitSwitchLabel0(n2)
        }
        case *SwitchLabel1:{
            my.dispatch.EndVisitSwitchLabel1(n2)
        }
        case *SwitchLabel2:{
            my.dispatch.EndVisitSwitchLabel2(n2)
        }
        case *TryStatement0:{
            my.dispatch.EndVisitTryStatement0(n2)
        }
        case *TryStatement1:{
            my.dispatch.EndVisitTryStatement1(n2)
        }
        case *PrimaryNoNewArray0:{
            my.dispatch.EndVisitPrimaryNoNewArray0(n2)
        }
        case *PrimaryNoNewArray1:{
            my.dispatch.EndVisitPrimaryNoNewArray1(n2)
        }
        case *PrimaryNoNewArray2:{
            my.dispatch.EndVisitPrimaryNoNewArray2(n2)
        }
        case *PrimaryNoNewArray3:{
            my.dispatch.EndVisitPrimaryNoNewArray3(n2)
        }
        case *PrimaryNoNewArray4:{
            my.dispatch.EndVisitPrimaryNoNewArray4(n2)
        }
        case *Literal0:{
            my.dispatch.EndVisitLiteral0(n2)
        }
        case *Literal1:{
            my.dispatch.EndVisitLiteral1(n2)
        }
        case *Literal2:{
            my.dispatch.EndVisitLiteral2(n2)
        }
        case *Literal3:{
            my.dispatch.EndVisitLiteral3(n2)
        }
        case *Literal4:{
            my.dispatch.EndVisitLiteral4(n2)
        }
        case *Literal5:{
            my.dispatch.EndVisitLiteral5(n2)
        }
        case *Literal6:{
            my.dispatch.EndVisitLiteral6(n2)
        }
        case *BooleanLiteral0:{
            my.dispatch.EndVisitBooleanLiteral0(n2)
        }
        case *BooleanLiteral1:{
            my.dispatch.EndVisitBooleanLiteral1(n2)
        }
        case *ClassInstanceCreationExpression0:{
            my.dispatch.EndVisitClassInstanceCreationExpression0(n2)
        }
        case *ClassInstanceCreationExpression1:{
            my.dispatch.EndVisitClassInstanceCreationExpression1(n2)
        }
        case *ArrayCreationExpression0:{
            my.dispatch.EndVisitArrayCreationExpression0(n2)
        }
        case *ArrayCreationExpression1:{
            my.dispatch.EndVisitArrayCreationExpression1(n2)
        }
        case *ArrayCreationExpression2:{
            my.dispatch.EndVisitArrayCreationExpression2(n2)
        }
        case *ArrayCreationExpression3:{
            my.dispatch.EndVisitArrayCreationExpression3(n2)
        }
        case *Dims0:{
            my.dispatch.EndVisitDims0(n2)
        }
        case *Dims1:{
            my.dispatch.EndVisitDims1(n2)
        }
        case *FieldAccess0:{
            my.dispatch.EndVisitFieldAccess0(n2)
        }
        case *FieldAccess1:{
            my.dispatch.EndVisitFieldAccess1(n2)
        }
        case *FieldAccess2:{
            my.dispatch.EndVisitFieldAccess2(n2)
        }
        case *MethodInvocation0:{
            my.dispatch.EndVisitMethodInvocation0(n2)
        }
        case *MethodInvocation1:{
            my.dispatch.EndVisitMethodInvocation1(n2)
        }
        case *MethodInvocation2:{
            my.dispatch.EndVisitMethodInvocation2(n2)
        }
        case *MethodInvocation3:{
            my.dispatch.EndVisitMethodInvocation3(n2)
        }
        case *MethodInvocation4:{
            my.dispatch.EndVisitMethodInvocation4(n2)
        }
        case *ArrayAccess0:{
            my.dispatch.EndVisitArrayAccess0(n2)
        }
        case *ArrayAccess1:{
            my.dispatch.EndVisitArrayAccess1(n2)
        }
        case *UnaryExpression0:{
            my.dispatch.EndVisitUnaryExpression0(n2)
        }
        case *UnaryExpression1:{
            my.dispatch.EndVisitUnaryExpression1(n2)
        }
        case *UnaryExpressionNotPlusMinus0:{
            my.dispatch.EndVisitUnaryExpressionNotPlusMinus0(n2)
        }
        case *UnaryExpressionNotPlusMinus1:{
            my.dispatch.EndVisitUnaryExpressionNotPlusMinus1(n2)
        }
        case *CastExpression0:{
            my.dispatch.EndVisitCastExpression0(n2)
        }
        case *CastExpression1:{
            my.dispatch.EndVisitCastExpression1(n2)
        }
        case *MultiplicativeExpression0:{
            my.dispatch.EndVisitMultiplicativeExpression0(n2)
        }
        case *MultiplicativeExpression1:{
            my.dispatch.EndVisitMultiplicativeExpression1(n2)
        }
        case *MultiplicativeExpression2:{
            my.dispatch.EndVisitMultiplicativeExpression2(n2)
        }
        case *AdditiveExpression0:{
            my.dispatch.EndVisitAdditiveExpression0(n2)
        }
        case *AdditiveExpression1:{
            my.dispatch.EndVisitAdditiveExpression1(n2)
        }
        case *ShiftExpression0:{
            my.dispatch.EndVisitShiftExpression0(n2)
        }
        case *ShiftExpression1:{
            my.dispatch.EndVisitShiftExpression1(n2)
        }
        case *ShiftExpression2:{
            my.dispatch.EndVisitShiftExpression2(n2)
        }
        case *RelationalExpression0:{
            my.dispatch.EndVisitRelationalExpression0(n2)
        }
        case *RelationalExpression1:{
            my.dispatch.EndVisitRelationalExpression1(n2)
        }
        case *RelationalExpression2:{
            my.dispatch.EndVisitRelationalExpression2(n2)
        }
        case *RelationalExpression3:{
            my.dispatch.EndVisitRelationalExpression3(n2)
        }
        case *RelationalExpression4:{
            my.dispatch.EndVisitRelationalExpression4(n2)
        }
        case *EqualityExpression0:{
            my.dispatch.EndVisitEqualityExpression0(n2)
        }
        case *EqualityExpression1:{
            my.dispatch.EndVisitEqualityExpression1(n2)
        }
        case *AssignmentOperator0:{
            my.dispatch.EndVisitAssignmentOperator0(n2)
        }
        case *AssignmentOperator1:{
            my.dispatch.EndVisitAssignmentOperator1(n2)
        }
        case *AssignmentOperator2:{
            my.dispatch.EndVisitAssignmentOperator2(n2)
        }
        case *AssignmentOperator3:{
            my.dispatch.EndVisitAssignmentOperator3(n2)
        }
        case *AssignmentOperator4:{
            my.dispatch.EndVisitAssignmentOperator4(n2)
        }
        case *AssignmentOperator5:{
            my.dispatch.EndVisitAssignmentOperator5(n2)
        }
        case *AssignmentOperator6:{
            my.dispatch.EndVisitAssignmentOperator6(n2)
        }
        case *AssignmentOperator7:{
            my.dispatch.EndVisitAssignmentOperator7(n2)
        }
        case *AssignmentOperator8:{
            my.dispatch.EndVisitAssignmentOperator8(n2)
        }
        case *AssignmentOperator9:{
            my.dispatch.EndVisitAssignmentOperator9(n2)
        }
        case *AssignmentOperator10:{
            my.dispatch.EndVisitAssignmentOperator10(n2)
        }
        case *AssignmentOperator11:{
            my.dispatch.EndVisitAssignmentOperator11(n2)
        }
        default:{ }
     }
}
func AnyCastToAbstractVisitor(i interface{}) *AbstractVisitor {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractVisitor)
	}
}

