//
// This is the grammar specification from the Final Draft of the generic spec.
//
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2007 IBM Corporation.
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Eclipse Public License v1.0
// which accompanies this distribution, and is available at
// http://www.eclipse.org/legal/epl-v10.html
//
//Contributors:
//    Philippe Charles (pcharles@us.ibm.com) - initial API and implementation

////////////////////////////////////////////////////////////////////////////////

package java


    //#line 128 "btParserTemplateF.gi
 
import (
. "github.com/A-LPG/LPG-go-runtime/lpg2"
)

    //#line 18 "GJavaParser.g



    //#line 136 "btParserTemplateF.gi

type  JavaParser  struct{
    prsStream   *PrsStream
    btParser *BacktrackingParser
    unimplementedSymbolsWarning  bool
    prsTable  ParseTable
}
func NewJavaParser(lexStream ILexStream) (*JavaParser,error){
    my := new(JavaParser)
    my.prsTable = &JavaParserprs{}
    my.prsStream =  NewPrsStream(lexStream)
    my.unimplementedSymbolsWarning  = false
    var e error
    my.btParser,e =  NewBacktrackingParser(nil, my.prsTable,  my,nil) 
    if e == nil{
        if lexStream != nil{
            my.Reset(lexStream)
        }
        return  my,nil
    }
    var _,ok = e.(*NotBacktrackParseTableException)
    if ok{
        e = NewNotBacktrackParseTableException("Regenerate %prs_type.go with -BACKTRACK option")
        return  nil,e
    }
    _,ok = e.(*BadParseSymFileException)
    if ok{
        e= NewBadParseSymFileException("Bad Parser Symbol File -- %sym_type.go")
        return  nil,e
    }
    return nil,e
}
    

func (my *JavaParser)  GetParseTable() ParseTable{ 
    return my.prsTable 
}

func (my *JavaParser)  GetParser() *BacktrackingParser{
    return my.btParser 
}

func (my *JavaParser)  SetResult( object interface{}) {
    my.btParser.SetSym1(object)
}
func (my *JavaParser) GetRhsSym(i int) interface{} { 
    return my.btParser.GetSym(i) 
}

func (my *JavaParser)  GetRhsTokenIndex(i int)int {
    return my.btParser.GetToken(i)
    }
func (my *JavaParser)  GetRhsIToken(i int) IToken{
    return my.prsStream.GetIToken(my.GetRhsTokenIndex(i)) 
}

func (my *JavaParser)  GetRhsFirstTokenIndex(i int)int { 
return my.btParser.GetFirstTokenAt(i)
    }
func (my *JavaParser)  GetRhsFirstIToken(i int) IToken{
    return my.prsStream.GetIToken(my.GetRhsFirstTokenIndex(i)) 
    }

func (my *JavaParser)  GetRhsLastTokenIndex(i int)int {
    return my.btParser.GetLastTokenAt(i) 
    }
func (my *JavaParser)  GetRhsLastIToken(i int) IToken{ 
return my.prsStream.GetIToken(my.GetRhsLastTokenIndex(i)) 
}

func (my *JavaParser)  GetLeftSpan() int{ 
    return my.btParser.GetFirstToken() 
}
func (my *JavaParser)  GetLeftIToken() IToken {
    return my.prsStream.GetIToken(my.GetLeftSpan())
}

func (my *JavaParser)  GetRightSpan() int{
    return my.btParser.GetLastToken() 
}
func (my *JavaParser)  GetRightIToken()IToken {
    return my.prsStream.GetIToken(my.GetRightSpan())
}

func (my *JavaParser)  GetRhsErrorTokenIndex(i int)int{
    var index = my.btParser.GetToken(i)
    var err = my.prsStream.GetIToken(index)
    var _,ok = err.(*ErrorToken)
    if ok {
        return index
    }else{
        return 0
    }
}
func (my *JavaParser)  GetRhsErrorIToken(i int) *ErrorToken{
    var index = my.btParser.GetToken(i)
    var err = my.prsStream.GetIToken(index)
    var token,_ = err.(*ErrorToken)
    return token
}

func (my *JavaParser)  Reset(lexStream ILexStream ) error{
    my.prsStream = NewPrsStream(lexStream)
    my.btParser.Reset(my.prsStream,nil,nil,nil)

    var ex = my.prsStream.RemapTerminalSymbols(my.OrderedTerminalSymbols(), my.prsTable.GetEoftSymbol())
    if ex == nil{
        return nil
    }
    var _,ok = ex.(*NullExportedSymbolsException)
    if ok {
        return ex
    }
    _,ok = ex.(*NullTerminalSymbolsException)
    if ok {
        return ex
    }
    var e *UnimplementedTerminalsException
    e,ok = ex.(*UnimplementedTerminalsException)
    if ok {
        if my.unimplementedSymbolsWarning {
            var unimplemented_symbols = e.GetSymbols()
            println("The Lexer will not scan the following token(s):")
            var i int = 0
            for ; i < unimplemented_symbols.Size() ;i++{
                var id = unimplemented_symbols.Get(i)
                println("    " + JavaParsersym.OrderedTerminalSymbols[id])
            }
            println()
        }
        return  ex
    }
    _,ok = ex.(*UndefinedEofSymbolException)
    if ok {
        return NewUndefinedEofSymbolException("The Lexer does not implement the Eof symbol " +
        JavaParsersym.OrderedTerminalSymbols[my.prsTable.GetEoftSymbol()])
    }
    return ex
}


func (my *JavaParser)  NumTokenKinds()int {
        return JavaParsersym.NumTokenKinds 
}
func (my *JavaParser)  OrderedTerminalSymbols()[]string {
    return JavaParsersym.OrderedTerminalSymbols
}
func (my *JavaParser)  GetTokenKindName(kind int) string{
        return JavaParsersym.OrderedTerminalSymbols[kind] 
}
func (my *JavaParser)  GetEOFTokenKind() int{
    return my.prsTable.GetEoftSymbol()
    }
func (my *JavaParser)  GetIPrsStream() IPrsStream{
    return my.prsStream
    }
func (my *JavaParser) Parser() (interface{}, error) {
    return my.ParserWithMonitor(0,nil)
}
func (my *JavaParser) ParserWithMonitor(error_repair_count int ,  monitor Monitor) (interface{}, error){

    my.btParser.SetMonitor(monitor)
    
    var ast,ex= my.btParser.FuzzyParseEntry(0, error_repair_count)
    if ex == nil{
        return ast,ex
    }
    var e,ok= ex.(*BadParseException)
    if ok{
        my.prsStream.ResetTo(e.ErrorToken) // point to error token

        var diagnoseParser = NewDiagnoseParser(my.prsStream, my.prsTable,0,0,nil)
        diagnoseParser.Diagnose(e.ErrorToken)
    }
    return ast,ex
}
//
// Additional entry points, if any
//

    
func (my *JavaParser)  ParseClassBodyDeclarationsopt(error_repair_count int,monitor Monitor) (interface{}, error){
    my.btParser.SetMonitor(monitor)
    
    var ast,ex = my.btParser.FuzzyParseEntry(JavaParsersym.TK_ClassBodyDeclarationsoptMarker, error_repair_count)
    if nil != ex  {
        var e,ok= ex.(*BadParseException)
        if ok{
            my.prsStream.ResetTo(e.ErrorToken) // point to error token

            var diagnoseParser = NewDiagnoseParser(my.prsStream, my.prsTable, 0,0,nil)
            diagnoseParser.DiagnoseEntry(JavaParsersym.TK_ClassBodyDeclarationsoptMarker, e.ErrorToken)
        }
        return nil,ex
    }
    return ast,nil
}

    
func (my *JavaParser)  ParseLPGUserAction(error_repair_count int,monitor Monitor) (interface{}, error){
    my.btParser.SetMonitor(monitor)
    
    var ast,ex = my.btParser.FuzzyParseEntry(JavaParsersym.TK_LPGUserActionMarker, error_repair_count)
    if nil != ex  {
        var e,ok= ex.(*BadParseException)
        if ok{
            my.prsStream.ResetTo(e.ErrorToken) // point to error token

            var diagnoseParser = NewDiagnoseParser(my.prsStream, my.prsTable, 0,0,nil)
            diagnoseParser.DiagnoseEntry(JavaParsersym.TK_LPGUserActionMarker, e.ErrorToken)
        }
        return nil,ex
    }
    return ast,nil
}


    //#line 186 "GJavaParser.g


    
    //#line 321 "btParserTemplateF.gi

   
    func (my *JavaParser)  RuleAction(ruleNumber int){
        switch ruleNumber{

            //
            // Rule 3:  identifier ::= IDENTIFIER
            //
            case 3: {
               //#line 185 "GJavaParser.g"
                my.SetResult(
                    //#line 185 GJavaParser.g
                    Newidentifier(my, my.GetRhsIToken(1)),
                //#line 185 GJavaParser.g
                )
                break
            }
            //
            // Rule 4:  LPGUserAction ::= BlockStatementsopt
            //
            case 4:
                break
            //
            // Rule 5:  LPGUserAction ::= $BeginAction BlockStatementsopt $EndAction
            //
            case 5: {
               //#line 191 "GJavaParser.g"
                my.SetResult(
                    //#line 191 GJavaParser.g
                    NewLPGUserAction0(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 191 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 191 GJavaParser.g
                                      AnyCastToIBlockStatementsopt(my.GetRhsSym(2)),
                                      //#line 191 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 191 GJavaParser.g
                )
                break
            }
            //
            // Rule 6:  LPGUserAction ::= $BeginJava BlockStatementsopt $EndJava
            //
            case 6: {
               //#line 192 "GJavaParser.g"
                my.SetResult(
                    //#line 192 GJavaParser.g
                    NewLPGUserAction1(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 192 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 192 GJavaParser.g
                                      AnyCastToIBlockStatementsopt(my.GetRhsSym(2)),
                                      //#line 192 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 192 GJavaParser.g
                )
                break
            }
            //
            // Rule 7:  LPGUserAction ::= $NoAction
            //
            case 7: {
               //#line 193 "GJavaParser.g"
                my.SetResult(
                    //#line 193 GJavaParser.g
                    NewLPGUserAction2(my.GetRhsIToken(1)),
                //#line 193 GJavaParser.g
                )
                break
            }
            //
            // Rule 8:  LPGUserAction ::= $NullAction
            //
            case 8: {
               //#line 194 "GJavaParser.g"
                my.SetResult(
                    //#line 194 GJavaParser.g
                    NewLPGUserAction3(my.GetRhsIToken(1)),
                //#line 194 GJavaParser.g
                )
                break
            }
            //
            // Rule 9:  LPGUserAction ::= $BadAction
            //
            case 9: {
               //#line 195 "GJavaParser.g"
                my.SetResult(
                    //#line 195 GJavaParser.g
                    NewLPGUserAction4(my.GetRhsIToken(1)),
                //#line 195 GJavaParser.g
                )
                break
            }
            //
            // Rule 10:  Type ::= PrimitiveType
            //
            case 10:
                break
            //
            // Rule 11:  Type ::= ReferenceType
            //
            case 11:
                break
            //
            // Rule 12:  PrimitiveType ::= NumericType
            //
            case 12:
                break
            //
            // Rule 13:  PrimitiveType ::= boolean
            //
            case 13: {
               //#line 204 "GJavaParser.g"
                my.SetResult(
                    //#line 204 GJavaParser.g
                    NewPrimitiveType(my.GetRhsIToken(1)),
                //#line 204 GJavaParser.g
                )
                break
            }
            //
            // Rule 14:  NumericType ::= IntegralType
            //
            case 14:
                break
            //
            // Rule 15:  NumericType ::= FloatingPointType
            //
            case 15:
                break
            //
            // Rule 16:  IntegralType ::= byte
            //
            case 16: {
               //#line 209 "GJavaParser.g"
                my.SetResult(
                    //#line 209 GJavaParser.g
                    NewIntegralType0(my.GetRhsIToken(1)),
                //#line 209 GJavaParser.g
                )
                break
            }
            //
            // Rule 17:  IntegralType ::= short
            //
            case 17: {
               //#line 210 "GJavaParser.g"
                my.SetResult(
                    //#line 210 GJavaParser.g
                    NewIntegralType1(my.GetRhsIToken(1)),
                //#line 210 GJavaParser.g
                )
                break
            }
            //
            // Rule 18:  IntegralType ::= int
            //
            case 18: {
               //#line 211 "GJavaParser.g"
                my.SetResult(
                    //#line 211 GJavaParser.g
                    NewIntegralType2(my.GetRhsIToken(1)),
                //#line 211 GJavaParser.g
                )
                break
            }
            //
            // Rule 19:  IntegralType ::= long
            //
            case 19: {
               //#line 212 "GJavaParser.g"
                my.SetResult(
                    //#line 212 GJavaParser.g
                    NewIntegralType3(my.GetRhsIToken(1)),
                //#line 212 GJavaParser.g
                )
                break
            }
            //
            // Rule 20:  IntegralType ::= char
            //
            case 20: {
               //#line 213 "GJavaParser.g"
                my.SetResult(
                    //#line 213 GJavaParser.g
                    NewIntegralType4(my.GetRhsIToken(1)),
                //#line 213 GJavaParser.g
                )
                break
            }
            //
            // Rule 21:  FloatingPointType ::= float
            //
            case 21: {
               //#line 215 "GJavaParser.g"
                my.SetResult(
                    //#line 215 GJavaParser.g
                    NewFloatingPointType0(my.GetRhsIToken(1)),
                //#line 215 GJavaParser.g
                )
                break
            }
            //
            // Rule 22:  FloatingPointType ::= double
            //
            case 22: {
               //#line 216 "GJavaParser.g"
                my.SetResult(
                    //#line 216 GJavaParser.g
                    NewFloatingPointType1(my.GetRhsIToken(1)),
                //#line 216 GJavaParser.g
                )
                break
            }
            //
            // Rule 23:  ReferenceType ::= ClassOrInterfaceType
            //
            case 23:
                break
            //
            // Rule 24:  ReferenceType ::= TypeVariable
            //
            case 24:
                break
            //
            // Rule 25:  ReferenceType ::= ArrayType
            //
            case 25:
                break
            //
            // Rule 26:  ClassOrInterfaceType ::= ClassType
            //
            case 26:
                break
            //
            // Rule 27:  ClassType ::= TypeName TypeArgumentsopt
            //
            case 27: {
               //#line 228 "GJavaParser.g"
                my.SetResult(
                    //#line 228 GJavaParser.g
                    NewClassType(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 228 GJavaParser.g
                                 my.GetRhsSym(1).(ITypeName),
                                 //#line 228 GJavaParser.g
                                 AnyCastToTypeArguments(my.GetRhsSym(2))),
                //#line 228 GJavaParser.g
                )
                break
            }
            //
            // Rule 28:  InterfaceType ::= TypeName TypeArgumentsopt
            //
            case 28: {
               //#line 230 "GJavaParser.g"
                my.SetResult(
                    //#line 230 GJavaParser.g
                    NewInterfaceType(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 230 GJavaParser.g
                                     my.GetRhsSym(1).(ITypeName),
                                     //#line 230 GJavaParser.g
                                     AnyCastToTypeArguments(my.GetRhsSym(2))),
                //#line 230 GJavaParser.g
                )
                break
            }
            //
            // Rule 29:  TypeName ::= identifier
            //
            case 29:
                break
            //
            // Rule 30:  TypeName ::= TypeName . identifier
            //
            case 30: {
               //#line 233 "GJavaParser.g"
                my.SetResult(
                    //#line 233 GJavaParser.g
                    NewTypeName(my.GetLeftIToken(), my.GetRightIToken(),
                                //#line 233 GJavaParser.g
                                my.GetRhsSym(1).(ITypeName),
                                //#line 233 GJavaParser.g
                                NewAstToken(my.GetRhsIToken(2)),
                                //#line 233 GJavaParser.g
                                my.GetRhsSym(3).(*identifier)),
                //#line 233 GJavaParser.g
                )
                break
            }
            //
            // Rule 31:  ClassName ::= TypeName
            //
            case 31:
                break
            //
            // Rule 32:  TypeVariable ::= identifier
            //
            case 32:
                break
            //
            // Rule 33:  ArrayType ::= Type [ ]
            //
            case 33: {
               //#line 239 "GJavaParser.g"
                my.SetResult(
                    //#line 239 GJavaParser.g
                    NewArrayType(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 239 GJavaParser.g
                                 my.GetRhsSym(1).(IType),
                                 //#line 239 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(2)),
                                 //#line 239 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(3))),
                //#line 239 GJavaParser.g
                )
                break
            }
            //
            // Rule 34:  TypeParameter ::= TypeVariable TypeBoundopt
            //
            case 34: {
               //#line 241 "GJavaParser.g"
                my.SetResult(
                    //#line 241 GJavaParser.g
                    NewTypeParameter(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 241 GJavaParser.g
                                     my.GetRhsSym(1).(*identifier),
                                     //#line 241 GJavaParser.g
                                     AnyCastToTypeBound(my.GetRhsSym(2))),
                //#line 241 GJavaParser.g
                )
                break
            }
            //
            // Rule 35:  TypeBound ::= extends ClassOrInterfaceType AdditionalBoundListopt
            //
            case 35: {
               //#line 243 "GJavaParser.g"
                my.SetResult(
                    //#line 243 GJavaParser.g
                    NewTypeBound(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 243 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(1)),
                                 //#line 243 GJavaParser.g
                                 my.GetRhsSym(2).(*ClassType),
                                 //#line 243 GJavaParser.g
                                 AnyCastToIAdditionalBoundListopt(my.GetRhsSym(3))),
                //#line 243 GJavaParser.g
                )
                break
            }
            //
            // Rule 36:  AdditionalBoundList ::= AdditionalBound
            //
            case 36:
                break
            //
            // Rule 37:  AdditionalBoundList ::= AdditionalBoundList AdditionalBound
            //
            case 37: {
               //#line 246 "GJavaParser.g"
                my.SetResult(
                    //#line 246 GJavaParser.g
                    NewAdditionalBoundList(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 246 GJavaParser.g
                                           my.GetRhsSym(1).(IAdditionalBoundList),
                                           //#line 246 GJavaParser.g
                                           my.GetRhsSym(2).(*AdditionalBound)),
                //#line 246 GJavaParser.g
                )
                break
            }
            //
            // Rule 38:  AdditionalBound ::= & InterfaceType
            //
            case 38: {
               //#line 248 "GJavaParser.g"
                my.SetResult(
                    //#line 248 GJavaParser.g
                    NewAdditionalBound(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 248 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 248 GJavaParser.g
                                       my.GetRhsSym(2).(*InterfaceType)),
                //#line 248 GJavaParser.g
                )
                break
            }
            //
            // Rule 39:  TypeArguments ::= < ActualTypeArgumentList >
            //
            case 39: {
               //#line 250 "GJavaParser.g"
                my.SetResult(
                    //#line 250 GJavaParser.g
                    NewTypeArguments(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 250 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(1)),
                                     //#line 250 GJavaParser.g
                                     my.GetRhsSym(2).(IActualTypeArgumentList),
                                     //#line 250 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(3))),
                //#line 250 GJavaParser.g
                )
                break
            }
            //
            // Rule 40:  ActualTypeArgumentList ::= ActualTypeArgument
            //
            case 40:
                break
            //
            // Rule 41:  ActualTypeArgumentList ::= ActualTypeArgumentList , ActualTypeArgument
            //
            case 41: {
               //#line 253 "GJavaParser.g"
                my.SetResult(
                    //#line 253 GJavaParser.g
                    NewActualTypeArgumentList(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 253 GJavaParser.g
                                              my.GetRhsSym(1).(IActualTypeArgumentList),
                                              //#line 253 GJavaParser.g
                                              NewAstToken(my.GetRhsIToken(2)),
                                              //#line 253 GJavaParser.g
                                              my.GetRhsSym(3).(IActualTypeArgument)),
                //#line 253 GJavaParser.g
                )
                break
            }
            //
            // Rule 42:  ActualTypeArgument ::= ReferenceType
            //
            case 42:
                break
            //
            // Rule 43:  ActualTypeArgument ::= Wildcard
            //
            case 43:
                break
            //
            // Rule 44:  Wildcard ::= ? WildcardBoundsOpt
            //
            case 44: {
               //#line 258 "GJavaParser.g"
                my.SetResult(
                    //#line 258 GJavaParser.g
                    NewWildcard(my.GetLeftIToken(), my.GetRightIToken(),
                                //#line 258 GJavaParser.g
                                NewAstToken(my.GetRhsIToken(1)),
                                //#line 258 GJavaParser.g
                                AnyCastToIWildcardBoundsOpt(my.GetRhsSym(2))),
                //#line 258 GJavaParser.g
                )
                break
            }
            //
            // Rule 45:  WildcardBounds ::= extends ReferenceType
            //
            case 45: {
               //#line 260 "GJavaParser.g"
                my.SetResult(
                    //#line 260 GJavaParser.g
                    NewWildcardBounds0(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 260 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 260 GJavaParser.g
                                       my.GetRhsSym(2).(IReferenceType)),
                //#line 260 GJavaParser.g
                )
                break
            }
            //
            // Rule 46:  WildcardBounds ::= super ReferenceType
            //
            case 46: {
               //#line 261 "GJavaParser.g"
                my.SetResult(
                    //#line 261 GJavaParser.g
                    NewWildcardBounds1(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 261 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 261 GJavaParser.g
                                       my.GetRhsSym(2).(IReferenceType)),
                //#line 261 GJavaParser.g
                )
                break
            }
            //
            // Rule 47:  PackageName ::= identifier
            //
            case 47:
                break
            //
            // Rule 48:  PackageName ::= PackageName . identifier
            //
            case 48: {
               //#line 268 "GJavaParser.g"
                my.SetResult(
                    //#line 268 GJavaParser.g
                    NewPackageName(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 268 GJavaParser.g
                                   my.GetRhsSym(1).(IPackageName),
                                   //#line 268 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(2)),
                                   //#line 268 GJavaParser.g
                                   my.GetRhsSym(3).(*identifier)),
                //#line 268 GJavaParser.g
                )
                break
            }
            //
            // Rule 49:  ExpressionName ::= identifier
            //
            case 49:
                break
            //
            // Rule 50:  ExpressionName ::= AmbiguousName . identifier
            //
            case 50: {
               //#line 277 "GJavaParser.g"
                my.SetResult(
                    //#line 277 GJavaParser.g
                    NewExpressionName(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 277 GJavaParser.g
                                      my.GetRhsSym(1).(IAmbiguousName),
                                      //#line 277 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(2)),
                                      //#line 277 GJavaParser.g
                                      my.GetRhsSym(3).(*identifier)),
                //#line 277 GJavaParser.g
                )
                break
            }
            //
            // Rule 51:  MethodName ::= identifier
            //
            case 51:
                break
            //
            // Rule 52:  MethodName ::= AmbiguousName . identifier
            //
            case 52: {
               //#line 280 "GJavaParser.g"
                my.SetResult(
                    //#line 280 GJavaParser.g
                    NewMethodName(my.GetLeftIToken(), my.GetRightIToken(),
                                  //#line 280 GJavaParser.g
                                  my.GetRhsSym(1).(IAmbiguousName),
                                  //#line 280 GJavaParser.g
                                  NewAstToken(my.GetRhsIToken(2)),
                                  //#line 280 GJavaParser.g
                                  my.GetRhsSym(3).(*identifier)),
                //#line 280 GJavaParser.g
                )
                break
            }
            //
            // Rule 53:  PackageOrTypeName ::= identifier
            //
            case 53:
                break
            //
            // Rule 54:  PackageOrTypeName ::= PackageOrTypeName . identifier
            //
            case 54: {
               //#line 283 "GJavaParser.g"
                my.SetResult(
                    //#line 283 GJavaParser.g
                    NewPackageOrTypeName(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 283 GJavaParser.g
                                         my.GetRhsSym(1).(IPackageOrTypeName),
                                         //#line 283 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 283 GJavaParser.g
                                         my.GetRhsSym(3).(*identifier)),
                //#line 283 GJavaParser.g
                )
                break
            }
            //
            // Rule 55:  AmbiguousName ::= identifier
            //
            case 55:
                break
            //
            // Rule 56:  AmbiguousName ::= AmbiguousName . identifier
            //
            case 56: {
               //#line 286 "GJavaParser.g"
                my.SetResult(
                    //#line 286 GJavaParser.g
                    NewAmbiguousName(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 286 GJavaParser.g
                                     my.GetRhsSym(1).(IAmbiguousName),
                                     //#line 286 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(2)),
                                     //#line 286 GJavaParser.g
                                     my.GetRhsSym(3).(*identifier)),
                //#line 286 GJavaParser.g
                )
                break
            }
            //
            // Rule 57:  CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt
            //
            case 57: {
               //#line 290 "GJavaParser.g"
                my.SetResult(
                    //#line 290 GJavaParser.g
                    NewCompilationUnit(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 290 GJavaParser.g
                                       AnyCastToPackageDeclaration(my.GetRhsSym(1)),
                                       //#line 290 GJavaParser.g
                                       AnyCastToIImportDeclarationsopt(my.GetRhsSym(2)),
                                       //#line 290 GJavaParser.g
                                       AnyCastToITypeDeclarationsopt(my.GetRhsSym(3))),
                //#line 290 GJavaParser.g
                )
                break
            }
            //
            // Rule 58:  ImportDeclarations ::= ImportDeclaration
            //
            case 58:
                break
            //
            // Rule 59:  ImportDeclarations ::= ImportDeclarations ImportDeclaration
            //
            case 59: {
               //#line 293 "GJavaParser.g"
                my.SetResult(
                    //#line 293 GJavaParser.g
                    NewImportDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 293 GJavaParser.g
                                          my.GetRhsSym(1).(IImportDeclarations),
                                          //#line 293 GJavaParser.g
                                          my.GetRhsSym(2).(IImportDeclaration)),
                //#line 293 GJavaParser.g
                )
                break
            }
            //
            // Rule 60:  TypeDeclarations ::= TypeDeclaration
            //
            case 60:
                break
            //
            // Rule 61:  TypeDeclarations ::= TypeDeclarations TypeDeclaration
            //
            case 61: {
               //#line 296 "GJavaParser.g"
                my.SetResult(
                    //#line 296 GJavaParser.g
                    NewTypeDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 296 GJavaParser.g
                                        my.GetRhsSym(1).(ITypeDeclarations),
                                        //#line 296 GJavaParser.g
                                        my.GetRhsSym(2).(ITypeDeclaration)),
                //#line 296 GJavaParser.g
                )
                break
            }
            //
            // Rule 62:  PackageDeclaration ::= Annotationsopt package PackageName ;
            //
            case 62: {
               //#line 298 "GJavaParser.g"
                my.SetResult(
                    //#line 298 GJavaParser.g
                    NewPackageDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 298 GJavaParser.g
                                          AnyCastToIAnnotationsopt(my.GetRhsSym(1)),
                                          //#line 298 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 298 GJavaParser.g
                                          my.GetRhsSym(3).(IPackageName),
                                          //#line 298 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(4))),
                //#line 298 GJavaParser.g
                )
                break
            }
            //
            // Rule 63:  ImportDeclaration ::= SingleTypeImportDeclaration
            //
            case 63:
                break
            //
            // Rule 64:  ImportDeclaration ::= TypeImportOnDemandDeclaration
            //
            case 64:
                break
            //
            // Rule 65:  ImportDeclaration ::= SingleStaticImportDeclaration
            //
            case 65:
                break
            //
            // Rule 66:  ImportDeclaration ::= StaticImportOnDemandDeclaration
            //
            case 66:
                break
            //
            // Rule 67:  SingleTypeImportDeclaration ::= import TypeName ;
            //
            case 67: {
               //#line 305 "GJavaParser.g"
                my.SetResult(
                    //#line 305 GJavaParser.g
                    NewSingleTypeImportDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                   //#line 305 GJavaParser.g
                                                   NewAstToken(my.GetRhsIToken(1)),
                                                   //#line 305 GJavaParser.g
                                                   my.GetRhsSym(2).(ITypeName),
                                                   //#line 305 GJavaParser.g
                                                   NewAstToken(my.GetRhsIToken(3))),
                //#line 305 GJavaParser.g
                )
                break
            }
            //
            // Rule 68:  TypeImportOnDemandDeclaration ::= import PackageOrTypeName . * ;
            //
            case 68: {
               //#line 307 "GJavaParser.g"
                my.SetResult(
                    //#line 307 GJavaParser.g
                    NewTypeImportOnDemandDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                     //#line 307 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(1)),
                                                     //#line 307 GJavaParser.g
                                                     my.GetRhsSym(2).(IPackageOrTypeName),
                                                     //#line 307 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(3)),
                                                     //#line 307 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(4)),
                                                     //#line 307 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(5))),
                //#line 307 GJavaParser.g
                )
                break
            }
            //
            // Rule 69:  SingleStaticImportDeclaration ::= import static TypeName . identifier ;
            //
            case 69: {
               //#line 309 "GJavaParser.g"
                my.SetResult(
                    //#line 309 GJavaParser.g
                    NewSingleStaticImportDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                     //#line 309 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(1)),
                                                     //#line 309 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(2)),
                                                     //#line 309 GJavaParser.g
                                                     my.GetRhsSym(3).(ITypeName),
                                                     //#line 309 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(4)),
                                                     //#line 309 GJavaParser.g
                                                     my.GetRhsSym(5).(*identifier),
                                                     //#line 309 GJavaParser.g
                                                     NewAstToken(my.GetRhsIToken(6))),
                //#line 309 GJavaParser.g
                )
                break
            }
            //
            // Rule 70:  StaticImportOnDemandDeclaration ::= import static TypeName . * ;
            //
            case 70: {
               //#line 311 "GJavaParser.g"
                my.SetResult(
                    //#line 311 GJavaParser.g
                    NewStaticImportOnDemandDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(1)),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(2)),
                                                       //#line 311 GJavaParser.g
                                                       my.GetRhsSym(3).(ITypeName),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(4)),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(5)),
                                                       //#line 311 GJavaParser.g
                                                       NewAstToken(my.GetRhsIToken(6))),
                //#line 311 GJavaParser.g
                )
                break
            }
            //
            // Rule 71:  TypeDeclaration ::= ClassDeclaration
            //
            case 71:
                break
            //
            // Rule 72:  TypeDeclaration ::= InterfaceDeclaration
            //
            case 72:
                break
            //
            // Rule 73:  TypeDeclaration ::= ;
            //
            case 73: {
               //#line 315 "GJavaParser.g"
                my.SetResult(
                    //#line 315 GJavaParser.g
                    NewTypeDeclaration(my.GetRhsIToken(1)),
                //#line 315 GJavaParser.g
                )
                break
            }
            //
            // Rule 74:  ClassDeclaration ::= NormalClassDeclaration
            //
            case 74:
                break
            //
            // Rule 75:  ClassDeclaration ::= EnumDeclaration
            //
            case 75:
                break
            //
            // Rule 76:  NormalClassDeclaration ::= ClassModifiersopt class identifier TypeParametersopt Superopt Interfacesopt ClassBody
            //
            case 76: {
               //#line 322 "GJavaParser.g"
                my.SetResult(
                    //#line 322 GJavaParser.g
                    NewNormalClassDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 322 GJavaParser.g
                                              AnyCastToIClassModifiersopt(my.GetRhsSym(1)),
                                              //#line 322 GJavaParser.g
                                              NewAstToken(my.GetRhsIToken(2)),
                                              //#line 322 GJavaParser.g
                                              my.GetRhsSym(3).(*identifier),
                                              //#line 322 GJavaParser.g
                                              AnyCastToTypeParameters(my.GetRhsSym(4)),
                                              //#line 322 GJavaParser.g
                                              AnyCastToSuper(my.GetRhsSym(5)),
                                              //#line 322 GJavaParser.g
                                              AnyCastToInterfaces(my.GetRhsSym(6)),
                                              //#line 322 GJavaParser.g
                                              my.GetRhsSym(7).(*ClassBody)),
                //#line 322 GJavaParser.g
                )
                break
            }
            //
            // Rule 77:  ClassModifiers ::= ClassModifier
            //
            case 77:
                break
            //
            // Rule 78:  ClassModifiers ::= ClassModifiers ClassModifier
            //
            case 78: {
               //#line 325 "GJavaParser.g"
                my.SetResult(
                    //#line 325 GJavaParser.g
                    NewClassModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 325 GJavaParser.g
                                      my.GetRhsSym(1).(IClassModifiers),
                                      //#line 325 GJavaParser.g
                                      my.GetRhsSym(2).(IClassModifier)),
                //#line 325 GJavaParser.g
                )
                break
            }
            //
            // Rule 79:  ClassModifier ::= Annotation
            //
            case 79:
                break
            //
            // Rule 80:  ClassModifier ::= public
            //
            case 80: {
               //#line 328 "GJavaParser.g"
                my.SetResult(
                    //#line 328 GJavaParser.g
                    NewClassModifier0(my.GetRhsIToken(1)),
                //#line 328 GJavaParser.g
                )
                break
            }
            //
            // Rule 81:  ClassModifier ::= protected
            //
            case 81: {
               //#line 329 "GJavaParser.g"
                my.SetResult(
                    //#line 329 GJavaParser.g
                    NewClassModifier1(my.GetRhsIToken(1)),
                //#line 329 GJavaParser.g
                )
                break
            }
            //
            // Rule 82:  ClassModifier ::= private
            //
            case 82: {
               //#line 330 "GJavaParser.g"
                my.SetResult(
                    //#line 330 GJavaParser.g
                    NewClassModifier2(my.GetRhsIToken(1)),
                //#line 330 GJavaParser.g
                )
                break
            }
            //
            // Rule 83:  ClassModifier ::= abstract
            //
            case 83: {
               //#line 331 "GJavaParser.g"
                my.SetResult(
                    //#line 331 GJavaParser.g
                    NewClassModifier3(my.GetRhsIToken(1)),
                //#line 331 GJavaParser.g
                )
                break
            }
            //
            // Rule 84:  ClassModifier ::= static
            //
            case 84: {
               //#line 332 "GJavaParser.g"
                my.SetResult(
                    //#line 332 GJavaParser.g
                    NewClassModifier4(my.GetRhsIToken(1)),
                //#line 332 GJavaParser.g
                )
                break
            }
            //
            // Rule 85:  ClassModifier ::= final
            //
            case 85: {
               //#line 333 "GJavaParser.g"
                my.SetResult(
                    //#line 333 GJavaParser.g
                    NewClassModifier5(my.GetRhsIToken(1)),
                //#line 333 GJavaParser.g
                )
                break
            }
            //
            // Rule 86:  ClassModifier ::= strictfp
            //
            case 86: {
               //#line 334 "GJavaParser.g"
                my.SetResult(
                    //#line 334 GJavaParser.g
                    NewClassModifier6(my.GetRhsIToken(1)),
                //#line 334 GJavaParser.g
                )
                break
            }
            //
            // Rule 87:  TypeParameters ::= < TypeParameterList >
            //
            case 87: {
               //#line 336 "GJavaParser.g"
                my.SetResult(
                    //#line 336 GJavaParser.g
                    NewTypeParameters(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 336 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 336 GJavaParser.g
                                      my.GetRhsSym(2).(ITypeParameterList),
                                      //#line 336 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 336 GJavaParser.g
                )
                break
            }
            //
            // Rule 88:  TypeParameterList ::= TypeParameter
            //
            case 88:
                break
            //
            // Rule 89:  TypeParameterList ::= TypeParameterList , TypeParameter
            //
            case 89: {
               //#line 339 "GJavaParser.g"
                my.SetResult(
                    //#line 339 GJavaParser.g
                    NewTypeParameterList(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 339 GJavaParser.g
                                         my.GetRhsSym(1).(ITypeParameterList),
                                         //#line 339 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 339 GJavaParser.g
                                         my.GetRhsSym(3).(*TypeParameter)),
                //#line 339 GJavaParser.g
                )
                break
            }
            //
            // Rule 90:  Super ::= extends ClassType
            //
            case 90: {
               //#line 341 "GJavaParser.g"
                my.SetResult(
                    //#line 341 GJavaParser.g
                    NewSuper(my.GetLeftIToken(), my.GetRightIToken(),
                             //#line 341 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(1)),
                             //#line 341 GJavaParser.g
                             my.GetRhsSym(2).(*ClassType)),
                //#line 341 GJavaParser.g
                )
                break
            }
            //
            // Rule 91:  Interfaces ::= implements InterfaceTypeList
            //
            case 91: {
               //#line 348 "GJavaParser.g"
                my.SetResult(
                    //#line 348 GJavaParser.g
                    NewInterfaces(my.GetLeftIToken(), my.GetRightIToken(),
                                  //#line 348 GJavaParser.g
                                  NewAstToken(my.GetRhsIToken(1)),
                                  //#line 348 GJavaParser.g
                                  my.GetRhsSym(2).(IInterfaceTypeList)),
                //#line 348 GJavaParser.g
                )
                break
            }
            //
            // Rule 92:  InterfaceTypeList ::= InterfaceType
            //
            case 92:
                break
            //
            // Rule 93:  InterfaceTypeList ::= InterfaceTypeList , InterfaceType
            //
            case 93: {
               //#line 351 "GJavaParser.g"
                my.SetResult(
                    //#line 351 GJavaParser.g
                    NewInterfaceTypeList(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 351 GJavaParser.g
                                         my.GetRhsSym(1).(IInterfaceTypeList),
                                         //#line 351 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 351 GJavaParser.g
                                         my.GetRhsSym(3).(*InterfaceType)),
                //#line 351 GJavaParser.g
                )
                break
            }
            //
            // Rule 94:  ClassBody ::= { ClassBodyDeclarationsopt }
            //
            case 94: {
               //#line 358 "GJavaParser.g"
                my.SetResult(
                    //#line 358 GJavaParser.g
                    NewClassBody(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 358 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(1)),
                                 //#line 358 GJavaParser.g
                                 AnyCastToIClassBodyDeclarationsopt(my.GetRhsSym(2)),
                                 //#line 358 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(3))),
                //#line 358 GJavaParser.g
                )
                break
            }
            //
            // Rule 95:  ClassBodyDeclarations ::= ClassBodyDeclaration
            //
            case 95:
                break
            //
            // Rule 96:  ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
            //
            case 96: {
               //#line 361 "GJavaParser.g"
                my.SetResult(
                    //#line 361 GJavaParser.g
                    NewClassBodyDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 361 GJavaParser.g
                                             my.GetRhsSym(1).(IClassBodyDeclarations),
                                             //#line 361 GJavaParser.g
                                             my.GetRhsSym(2).(IClassBodyDeclaration)),
                //#line 361 GJavaParser.g
                )
                break
            }
            //
            // Rule 97:  ClassBodyDeclaration ::= ClassMemberDeclaration
            //
            case 97:
                break
            //
            // Rule 98:  ClassBodyDeclaration ::= InstanceInitializer
            //
            case 98:
                break
            //
            // Rule 99:  ClassBodyDeclaration ::= StaticInitializer
            //
            case 99:
                break
            //
            // Rule 100:  ClassBodyDeclaration ::= ConstructorDeclaration
            //
            case 100:
                break
            //
            // Rule 101:  ClassMemberDeclaration ::= FieldDeclaration
            //
            case 101:
                break
            //
            // Rule 102:  ClassMemberDeclaration ::= MethodDeclaration
            //
            case 102:
                break
            //
            // Rule 103:  ClassMemberDeclaration ::= ClassDeclaration
            //
            case 103:
                break
            //
            // Rule 104:  ClassMemberDeclaration ::= InterfaceDeclaration
            //
            case 104:
                break
            //
            // Rule 105:  ClassMemberDeclaration ::= ;
            //
            case 105: {
               //#line 372 "GJavaParser.g"
                my.SetResult(
                    //#line 372 GJavaParser.g
                    NewClassMemberDeclaration(my.GetRhsIToken(1)),
                //#line 372 GJavaParser.g
                )
                break
            }
            //
            // Rule 106:  FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ;
            //
            case 106: {
               //#line 374 "GJavaParser.g"
                my.SetResult(
                    //#line 374 GJavaParser.g
                    NewFieldDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 374 GJavaParser.g
                                        AnyCastToIFieldModifiersopt(my.GetRhsSym(1)),
                                        //#line 374 GJavaParser.g
                                        my.GetRhsSym(2).(IType),
                                        //#line 374 GJavaParser.g
                                        my.GetRhsSym(3).(IVariableDeclarators),
                                        //#line 374 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(4))),
                //#line 374 GJavaParser.g
                )
                break
            }
            //
            // Rule 107:  VariableDeclarators ::= VariableDeclarator
            //
            case 107:
                break
            //
            // Rule 108:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
            //
            case 108: {
               //#line 377 "GJavaParser.g"
                my.SetResult(
                    //#line 377 GJavaParser.g
                    NewVariableDeclarators(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 377 GJavaParser.g
                                           my.GetRhsSym(1).(IVariableDeclarators),
                                           //#line 377 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 377 GJavaParser.g
                                           my.GetRhsSym(3).(IVariableDeclarator)),
                //#line 377 GJavaParser.g
                )
                break
            }
            //
            // Rule 109:  VariableDeclarator ::= VariableDeclaratorId
            //
            case 109:
                break
            //
            // Rule 110:  VariableDeclarator ::= VariableDeclaratorId = VariableInitializer
            //
            case 110: {
               //#line 380 "GJavaParser.g"
                my.SetResult(
                    //#line 380 GJavaParser.g
                    NewVariableDeclarator(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 380 GJavaParser.g
                                          my.GetRhsSym(1).(IVariableDeclaratorId),
                                          //#line 380 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 380 GJavaParser.g
                                          my.GetRhsSym(3).(IVariableInitializer)),
                //#line 380 GJavaParser.g
                )
                break
            }
            //
            // Rule 111:  VariableDeclaratorId ::= identifier
            //
            case 111:
                break
            //
            // Rule 112:  VariableDeclaratorId ::= VariableDeclaratorId [ ]
            //
            case 112: {
               //#line 383 "GJavaParser.g"
                my.SetResult(
                    //#line 383 GJavaParser.g
                    NewVariableDeclaratorId(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 383 GJavaParser.g
                                            my.GetRhsSym(1).(IVariableDeclaratorId),
                                            //#line 383 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(2)),
                                            //#line 383 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(3))),
                //#line 383 GJavaParser.g
                )
                break
            }
            //
            // Rule 113:  VariableInitializer ::= Expression
            //
            case 113:
                break
            //
            // Rule 114:  VariableInitializer ::= ArrayInitializer
            //
            case 114:
                break
            //
            // Rule 115:  FieldModifiers ::= FieldModifier
            //
            case 115:
                break
            //
            // Rule 116:  FieldModifiers ::= FieldModifiers FieldModifier
            //
            case 116: {
               //#line 389 "GJavaParser.g"
                my.SetResult(
                    //#line 389 GJavaParser.g
                    NewFieldModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 389 GJavaParser.g
                                      my.GetRhsSym(1).(IFieldModifiers),
                                      //#line 389 GJavaParser.g
                                      my.GetRhsSym(2).(IFieldModifier)),
                //#line 389 GJavaParser.g
                )
                break
            }
            //
            // Rule 117:  FieldModifier ::= Annotation
            //
            case 117:
                break
            //
            // Rule 118:  FieldModifier ::= public
            //
            case 118: {
               //#line 392 "GJavaParser.g"
                my.SetResult(
                    //#line 392 GJavaParser.g
                    NewFieldModifier0(my.GetRhsIToken(1)),
                //#line 392 GJavaParser.g
                )
                break
            }
            //
            // Rule 119:  FieldModifier ::= protected
            //
            case 119: {
               //#line 393 "GJavaParser.g"
                my.SetResult(
                    //#line 393 GJavaParser.g
                    NewFieldModifier1(my.GetRhsIToken(1)),
                //#line 393 GJavaParser.g
                )
                break
            }
            //
            // Rule 120:  FieldModifier ::= private
            //
            case 120: {
               //#line 394 "GJavaParser.g"
                my.SetResult(
                    //#line 394 GJavaParser.g
                    NewFieldModifier2(my.GetRhsIToken(1)),
                //#line 394 GJavaParser.g
                )
                break
            }
            //
            // Rule 121:  FieldModifier ::= static
            //
            case 121: {
               //#line 395 "GJavaParser.g"
                my.SetResult(
                    //#line 395 GJavaParser.g
                    NewFieldModifier3(my.GetRhsIToken(1)),
                //#line 395 GJavaParser.g
                )
                break
            }
            //
            // Rule 122:  FieldModifier ::= final
            //
            case 122: {
               //#line 396 "GJavaParser.g"
                my.SetResult(
                    //#line 396 GJavaParser.g
                    NewFieldModifier4(my.GetRhsIToken(1)),
                //#line 396 GJavaParser.g
                )
                break
            }
            //
            // Rule 123:  FieldModifier ::= transient
            //
            case 123: {
               //#line 397 "GJavaParser.g"
                my.SetResult(
                    //#line 397 GJavaParser.g
                    NewFieldModifier5(my.GetRhsIToken(1)),
                //#line 397 GJavaParser.g
                )
                break
            }
            //
            // Rule 124:  FieldModifier ::= volatile
            //
            case 124: {
               //#line 398 "GJavaParser.g"
                my.SetResult(
                    //#line 398 GJavaParser.g
                    NewFieldModifier6(my.GetRhsIToken(1)),
                //#line 398 GJavaParser.g
                )
                break
            }
            //
            // Rule 125:  MethodDeclaration ::= MethodHeader MethodBody
            //
            case 125: {
               //#line 400 "GJavaParser.g"
                my.SetResult(
                    //#line 400 GJavaParser.g
                    NewMethodDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 400 GJavaParser.g
                                         my.GetRhsSym(1).(*MethodHeader),
                                         //#line 400 GJavaParser.g
                                         my.GetRhsSym(2).(IMethodBody)),
                //#line 400 GJavaParser.g
                )
                break
            }
            //
            // Rule 126:  MethodHeader ::= MethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt
            //
            case 126: {
               //#line 402 "GJavaParser.g"
                my.SetResult(
                    //#line 402 GJavaParser.g
                    NewMethodHeader(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 402 GJavaParser.g
                                    AnyCastToIMethodModifiersopt(my.GetRhsSym(1)),
                                    //#line 402 GJavaParser.g
                                    AnyCastToTypeParameters(my.GetRhsSym(2)),
                                    //#line 402 GJavaParser.g
                                    my.GetRhsSym(3).(IResultType),
                                    //#line 402 GJavaParser.g
                                    my.GetRhsSym(4).(IMethodDeclarator),
                                    //#line 402 GJavaParser.g
                                    AnyCastToThrows(my.GetRhsSym(5))),
                //#line 402 GJavaParser.g
                )
                break
            }
            //
            // Rule 127:  ResultType ::= Type
            //
            case 127:
                break
            //
            // Rule 128:  ResultType ::= void
            //
            case 128: {
               //#line 405 "GJavaParser.g"
                my.SetResult(
                    //#line 405 GJavaParser.g
                    NewResultType(my.GetRhsIToken(1)),
                //#line 405 GJavaParser.g
                )
                break
            }
            //
            // Rule 129:  MethodDeclarator ::= identifier ( FormalParameterListopt )
            //
            case 129: {
               //#line 407 "GJavaParser.g"
                my.SetResult(
                    //#line 407 GJavaParser.g
                    NewMethodDeclarator0(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 407 GJavaParser.g
                                         my.GetRhsSym(1).(*identifier),
                                         //#line 407 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 407 GJavaParser.g
                                         AnyCastToIFormalParameterListopt(my.GetRhsSym(3)),
                                         //#line 407 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(4))),
                //#line 407 GJavaParser.g
                )
                break
            }
            //
            // Rule 130:  MethodDeclarator ::= MethodDeclarator [ ]
            //
            case 130: {
               //#line 409 "GJavaParser.g"
                my.SetResult(
                    //#line 409 GJavaParser.g
                    NewMethodDeclarator1(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 409 GJavaParser.g
                                         my.GetRhsSym(1).(IMethodDeclarator),
                                         //#line 409 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 409 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(3))),
                //#line 409 GJavaParser.g
                )
                break
            }
            //
            // Rule 131:  FormalParameterList ::= LastFormalParameter
            //
            case 131:
                break
            //
            // Rule 132:  FormalParameterList ::= FormalParameters , LastFormalParameter
            //
            case 132: {
               //#line 412 "GJavaParser.g"
                my.SetResult(
                    //#line 412 GJavaParser.g
                    NewFormalParameterList(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 412 GJavaParser.g
                                           my.GetRhsSym(1).(IFormalParameters),
                                           //#line 412 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 412 GJavaParser.g
                                           my.GetRhsSym(3).(*LastFormalParameter)),
                //#line 412 GJavaParser.g
                )
                break
            }
            //
            // Rule 133:  FormalParameters ::= FormalParameter
            //
            case 133:
                break
            //
            // Rule 134:  FormalParameters ::= FormalParameters , FormalParameter
            //
            case 134: {
               //#line 415 "GJavaParser.g"
                my.SetResult(
                    //#line 415 GJavaParser.g
                    NewFormalParameters(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 415 GJavaParser.g
                                        my.GetRhsSym(1).(IFormalParameters),
                                        //#line 415 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 415 GJavaParser.g
                                        my.GetRhsSym(3).(*FormalParameter)),
                //#line 415 GJavaParser.g
                )
                break
            }
            //
            // Rule 135:  FormalParameter ::= VariableModifiersopt Type VariableDeclaratorId
            //
            case 135: {
               //#line 417 "GJavaParser.g"
                my.SetResult(
                    //#line 417 GJavaParser.g
                    NewFormalParameter(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 417 GJavaParser.g
                                       AnyCastToIVariableModifiersopt(my.GetRhsSym(1)),
                                       //#line 417 GJavaParser.g
                                       my.GetRhsSym(2).(IType),
                                       //#line 417 GJavaParser.g
                                       my.GetRhsSym(3).(IVariableDeclaratorId)),
                //#line 417 GJavaParser.g
                )
                break
            }
            //
            // Rule 136:  VariableModifiers ::= VariableModifier
            //
            case 136:
                break
            //
            // Rule 137:  VariableModifiers ::= VariableModifiers VariableModifier
            //
            case 137: {
               //#line 420 "GJavaParser.g"
                my.SetResult(
                    //#line 420 GJavaParser.g
                    NewVariableModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 420 GJavaParser.g
                                         my.GetRhsSym(1).(IVariableModifiers),
                                         //#line 420 GJavaParser.g
                                         my.GetRhsSym(2).(IVariableModifier)),
                //#line 420 GJavaParser.g
                )
                break
            }
            //
            // Rule 138:  VariableModifier ::= final
            //
            case 138: {
               //#line 422 "GJavaParser.g"
                my.SetResult(
                    //#line 422 GJavaParser.g
                    NewVariableModifier(my.GetRhsIToken(1)),
                //#line 422 GJavaParser.g
                )
                break
            }
            //
            // Rule 139:  VariableModifier ::= Annotations
            //
            case 139:
                break
            //
            // Rule 140:  LastFormalParameter ::= VariableModifiersopt Type ...opt VariableDeclaratorId
            //
            case 140: {
               //#line 425 "GJavaParser.g"
                my.SetResult(
                    //#line 425 GJavaParser.g
                    NewLastFormalParameter(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 425 GJavaParser.g
                                           AnyCastToIVariableModifiersopt(my.GetRhsSym(1)),
                                           //#line 425 GJavaParser.g
                                           my.GetRhsSym(2).(IType),
                                           //#line 425 GJavaParser.g
                                           AnyCastToEllipsisopt(my.GetRhsSym(3)),
                                           //#line 425 GJavaParser.g
                                           my.GetRhsSym(4).(IVariableDeclaratorId)),
                //#line 425 GJavaParser.g
                )
                break
            }
            //
            // Rule 141:  MethodModifiers ::= MethodModifier
            //
            case 141:
                break
            //
            // Rule 142:  MethodModifiers ::= MethodModifiers MethodModifier
            //
            case 142: {
               //#line 434 "GJavaParser.g"
                my.SetResult(
                    //#line 434 GJavaParser.g
                    NewMethodModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 434 GJavaParser.g
                                       my.GetRhsSym(1).(IMethodModifiers),
                                       //#line 434 GJavaParser.g
                                       my.GetRhsSym(2).(IMethodModifier)),
                //#line 434 GJavaParser.g
                )
                break
            }
            //
            // Rule 143:  MethodModifier ::= Annotations
            //
            case 143:
                break
            //
            // Rule 144:  MethodModifier ::= public
            //
            case 144: {
               //#line 437 "GJavaParser.g"
                my.SetResult(
                    //#line 437 GJavaParser.g
                    NewMethodModifier0(my.GetRhsIToken(1)),
                //#line 437 GJavaParser.g
                )
                break
            }
            //
            // Rule 145:  MethodModifier ::= protected
            //
            case 145: {
               //#line 438 "GJavaParser.g"
                my.SetResult(
                    //#line 438 GJavaParser.g
                    NewMethodModifier1(my.GetRhsIToken(1)),
                //#line 438 GJavaParser.g
                )
                break
            }
            //
            // Rule 146:  MethodModifier ::= private
            //
            case 146: {
               //#line 439 "GJavaParser.g"
                my.SetResult(
                    //#line 439 GJavaParser.g
                    NewMethodModifier2(my.GetRhsIToken(1)),
                //#line 439 GJavaParser.g
                )
                break
            }
            //
            // Rule 147:  MethodModifier ::= abstract
            //
            case 147: {
               //#line 440 "GJavaParser.g"
                my.SetResult(
                    //#line 440 GJavaParser.g
                    NewMethodModifier3(my.GetRhsIToken(1)),
                //#line 440 GJavaParser.g
                )
                break
            }
            //
            // Rule 148:  MethodModifier ::= static
            //
            case 148: {
               //#line 441 "GJavaParser.g"
                my.SetResult(
                    //#line 441 GJavaParser.g
                    NewMethodModifier4(my.GetRhsIToken(1)),
                //#line 441 GJavaParser.g
                )
                break
            }
            //
            // Rule 149:  MethodModifier ::= final
            //
            case 149: {
               //#line 442 "GJavaParser.g"
                my.SetResult(
                    //#line 442 GJavaParser.g
                    NewMethodModifier5(my.GetRhsIToken(1)),
                //#line 442 GJavaParser.g
                )
                break
            }
            //
            // Rule 150:  MethodModifier ::= synchronized
            //
            case 150: {
               //#line 443 "GJavaParser.g"
                my.SetResult(
                    //#line 443 GJavaParser.g
                    NewMethodModifier6(my.GetRhsIToken(1)),
                //#line 443 GJavaParser.g
                )
                break
            }
            //
            // Rule 151:  MethodModifier ::= native
            //
            case 151: {
               //#line 444 "GJavaParser.g"
                my.SetResult(
                    //#line 444 GJavaParser.g
                    NewMethodModifier7(my.GetRhsIToken(1)),
                //#line 444 GJavaParser.g
                )
                break
            }
            //
            // Rule 152:  MethodModifier ::= strictfp
            //
            case 152: {
               //#line 445 "GJavaParser.g"
                my.SetResult(
                    //#line 445 GJavaParser.g
                    NewMethodModifier8(my.GetRhsIToken(1)),
                //#line 445 GJavaParser.g
                )
                break
            }
            //
            // Rule 153:  Throws ::= throws ExceptionTypeList
            //
            case 153: {
               //#line 447 "GJavaParser.g"
                my.SetResult(
                    //#line 447 GJavaParser.g
                    NewThrows(my.GetLeftIToken(), my.GetRightIToken(),
                              //#line 447 GJavaParser.g
                              NewAstToken(my.GetRhsIToken(1)),
                              //#line 447 GJavaParser.g
                              my.GetRhsSym(2).(IExceptionTypeList)),
                //#line 447 GJavaParser.g
                )
                break
            }
            //
            // Rule 154:  ExceptionTypeList ::= ExceptionType
            //
            case 154:
                break
            //
            // Rule 155:  ExceptionTypeList ::= ExceptionTypeList , ExceptionType
            //
            case 155: {
               //#line 450 "GJavaParser.g"
                my.SetResult(
                    //#line 450 GJavaParser.g
                    NewExceptionTypeList(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 450 GJavaParser.g
                                         my.GetRhsSym(1).(IExceptionTypeList),
                                         //#line 450 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 450 GJavaParser.g
                                         my.GetRhsSym(3).(IExceptionType)),
                //#line 450 GJavaParser.g
                )
                break
            }
            //
            // Rule 156:  ExceptionType ::= ClassType
            //
            case 156:
                break
            //
            // Rule 157:  ExceptionType ::= TypeVariable
            //
            case 157:
                break
            //
            // Rule 158:  MethodBody ::= Block
            //
            case 158:
                break
            //
            // Rule 159:  MethodBody ::= ;
            //
            case 159: {
               //#line 456 "GJavaParser.g"
                my.SetResult(
                    //#line 456 GJavaParser.g
                    NewMethodBody(my.GetRhsIToken(1)),
                //#line 456 GJavaParser.g
                )
                break
            }
            //
            // Rule 160:  InstanceInitializer ::= Block
            //
            case 160:
                break
            //
            // Rule 161:  StaticInitializer ::= static Block
            //
            case 161: {
               //#line 460 "GJavaParser.g"
                my.SetResult(
                    //#line 460 GJavaParser.g
                    NewStaticInitializer(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 460 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(1)),
                                         //#line 460 GJavaParser.g
                                         my.GetRhsSym(2).(*Block)),
                //#line 460 GJavaParser.g
                )
                break
            }
            //
            // Rule 162:  ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator Throwsopt ConstructorBody
            //
            case 162: {
               //#line 462 "GJavaParser.g"
                my.SetResult(
                    //#line 462 GJavaParser.g
                    NewConstructorDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 462 GJavaParser.g
                                              AnyCastToIConstructorModifiersopt(my.GetRhsSym(1)),
                                              //#line 462 GJavaParser.g
                                              my.GetRhsSym(2).(*ConstructorDeclarator),
                                              //#line 462 GJavaParser.g
                                              AnyCastToThrows(my.GetRhsSym(3)),
                                              //#line 462 GJavaParser.g
                                              my.GetRhsSym(4).(*ConstructorBody)),
                //#line 462 GJavaParser.g
                )
                break
            }
            //
            // Rule 163:  ConstructorDeclarator ::= TypeParametersopt SimpleTypeName ( FormalParameterListopt )
            //
            case 163: {
               //#line 464 "GJavaParser.g"
                my.SetResult(
                    //#line 464 GJavaParser.g
                    NewConstructorDeclarator(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 464 GJavaParser.g
                                             AnyCastToTypeParameters(my.GetRhsSym(1)),
                                             //#line 464 GJavaParser.g
                                             my.GetRhsSym(2).(*identifier),
                                             //#line 464 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(3)),
                                             //#line 464 GJavaParser.g
                                             AnyCastToIFormalParameterListopt(my.GetRhsSym(4)),
                                             //#line 464 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(5))),
                //#line 464 GJavaParser.g
                )
                break
            }
            //
            // Rule 164:  SimpleTypeName ::= identifier
            //
            case 164:
                break
            //
            // Rule 165:  ConstructorModifiers ::= ConstructorModifier
            //
            case 165:
                break
            //
            // Rule 166:  ConstructorModifiers ::= ConstructorModifiers ConstructorModifier
            //
            case 166: {
               //#line 469 "GJavaParser.g"
                my.SetResult(
                    //#line 469 GJavaParser.g
                    NewConstructorModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 469 GJavaParser.g
                                            my.GetRhsSym(1).(IConstructorModifiers),
                                            //#line 469 GJavaParser.g
                                            my.GetRhsSym(2).(IConstructorModifier)),
                //#line 469 GJavaParser.g
                )
                break
            }
            //
            // Rule 167:  ConstructorModifier ::= Annotations
            //
            case 167:
                break
            //
            // Rule 168:  ConstructorModifier ::= public
            //
            case 168: {
               //#line 472 "GJavaParser.g"
                my.SetResult(
                    //#line 472 GJavaParser.g
                    NewConstructorModifier0(my.GetRhsIToken(1)),
                //#line 472 GJavaParser.g
                )
                break
            }
            //
            // Rule 169:  ConstructorModifier ::= protected
            //
            case 169: {
               //#line 473 "GJavaParser.g"
                my.SetResult(
                    //#line 473 GJavaParser.g
                    NewConstructorModifier1(my.GetRhsIToken(1)),
                //#line 473 GJavaParser.g
                )
                break
            }
            //
            // Rule 170:  ConstructorModifier ::= private
            //
            case 170: {
               //#line 474 "GJavaParser.g"
                my.SetResult(
                    //#line 474 GJavaParser.g
                    NewConstructorModifier2(my.GetRhsIToken(1)),
                //#line 474 GJavaParser.g
                )
                break
            }
            //
            // Rule 171:  ConstructorBody ::= { ExplicitConstructorInvocationopt BlockStatementsopt }
            //
            case 171: {
               //#line 476 "GJavaParser.g"
                my.SetResult(
                    //#line 476 GJavaParser.g
                    NewConstructorBody(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 476 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 476 GJavaParser.g
                                       AnyCastToIExplicitConstructorInvocationopt(my.GetRhsSym(2)),
                                       //#line 476 GJavaParser.g
                                       AnyCastToIBlockStatementsopt(my.GetRhsSym(3)),
                                       //#line 476 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(4))),
                //#line 476 GJavaParser.g
                )
                break
            }
            //
            // Rule 172:  ExplicitConstructorInvocation ::= TypeArgumentsopt this ( ArgumentListopt ) ;
            //
            case 172: {
               //#line 478 "GJavaParser.g"
                my.SetResult(
                    //#line 478 GJavaParser.g
                    NewExplicitConstructorInvocation0(my.GetLeftIToken(), my.GetRightIToken(),
                                                      //#line 478 GJavaParser.g
                                                      AnyCastToTypeArguments(my.GetRhsSym(1)),
                                                      //#line 478 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(2)),
                                                      //#line 478 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(3)),
                                                      //#line 478 GJavaParser.g
                                                      AnyCastToIArgumentListopt(my.GetRhsSym(4)),
                                                      //#line 478 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(5)),
                                                      //#line 478 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(6))),
                //#line 478 GJavaParser.g
                )
                break
            }
            //
            // Rule 173:  ExplicitConstructorInvocation ::= TypeArgumentsopt super ( ArgumentListopt ) ;
            //
            case 173: {
               //#line 479 "GJavaParser.g"
                my.SetResult(
                    //#line 479 GJavaParser.g
                    NewExplicitConstructorInvocation1(my.GetLeftIToken(), my.GetRightIToken(),
                                                      //#line 479 GJavaParser.g
                                                      AnyCastToTypeArguments(my.GetRhsSym(1)),
                                                      //#line 479 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(2)),
                                                      //#line 479 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(3)),
                                                      //#line 479 GJavaParser.g
                                                      AnyCastToIArgumentListopt(my.GetRhsSym(4)),
                                                      //#line 479 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(5)),
                                                      //#line 479 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(6))),
                //#line 479 GJavaParser.g
                )
                break
            }
            //
            // Rule 174:  ExplicitConstructorInvocation ::= Primary . TypeArgumentsopt super ( ArgumentListopt ) ;
            //
            case 174: {
               //#line 480 "GJavaParser.g"
                my.SetResult(
                    //#line 480 GJavaParser.g
                    NewExplicitConstructorInvocation2(my.GetLeftIToken(), my.GetRightIToken(),
                                                      //#line 480 GJavaParser.g
                                                      my.GetRhsSym(1).(IPrimary),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(2)),
                                                      //#line 480 GJavaParser.g
                                                      AnyCastToTypeArguments(my.GetRhsSym(3)),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(4)),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(5)),
                                                      //#line 480 GJavaParser.g
                                                      AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(7)),
                                                      //#line 480 GJavaParser.g
                                                      NewAstToken(my.GetRhsIToken(8))),
                //#line 480 GJavaParser.g
                )
                break
            }
            //
            // Rule 175:  EnumDeclaration ::= ClassModifiersopt enum identifier Interfacesopt EnumBody
            //
            case 175: {
               //#line 482 "GJavaParser.g"
                my.SetResult(
                    //#line 482 GJavaParser.g
                    NewEnumDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 482 GJavaParser.g
                                       AnyCastToIClassModifiersopt(my.GetRhsSym(1)),
                                       //#line 482 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(2)),
                                       //#line 482 GJavaParser.g
                                       my.GetRhsSym(3).(*identifier),
                                       //#line 482 GJavaParser.g
                                       AnyCastToInterfaces(my.GetRhsSym(4)),
                                       //#line 482 GJavaParser.g
                                       my.GetRhsSym(5).(*EnumBody)),
                //#line 482 GJavaParser.g
                )
                break
            }
            //
            // Rule 176:  EnumBody ::= { EnumConstantsopt ,opt EnumBodyDeclarationsopt }
            //
            case 176: {
               //#line 484 "GJavaParser.g"
                my.SetResult(
                    //#line 484 GJavaParser.g
                    NewEnumBody(my.GetLeftIToken(), my.GetRightIToken(),
                                //#line 484 GJavaParser.g
                                NewAstToken(my.GetRhsIToken(1)),
                                //#line 484 GJavaParser.g
                                AnyCastToIEnumConstantsopt(my.GetRhsSym(2)),
                                //#line 484 GJavaParser.g
                                AnyCastToCommaopt(my.GetRhsSym(3)),
                                //#line 484 GJavaParser.g
                                AnyCastToEnumBodyDeclarations(my.GetRhsSym(4)),
                                //#line 484 GJavaParser.g
                                NewAstToken(my.GetRhsIToken(5))),
                //#line 484 GJavaParser.g
                )
                break
            }
            //
            // Rule 177:  EnumConstants ::= EnumConstant
            //
            case 177:
                break
            //
            // Rule 178:  EnumConstants ::= EnumConstants , EnumConstant
            //
            case 178: {
               //#line 487 "GJavaParser.g"
                my.SetResult(
                    //#line 487 GJavaParser.g
                    NewEnumConstants(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 487 GJavaParser.g
                                     my.GetRhsSym(1).(IEnumConstants),
                                     //#line 487 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(2)),
                                     //#line 487 GJavaParser.g
                                     my.GetRhsSym(3).(IEnumConstant)),
                //#line 487 GJavaParser.g
                )
                break
            }
            //
            // Rule 179:  EnumConstant ::= Annotationsopt identifier Argumentsopt ClassBodyopt
            //
            case 179: {
               //#line 489 "GJavaParser.g"
                my.SetResult(
                    //#line 489 GJavaParser.g
                    NewEnumConstant(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 489 GJavaParser.g
                                    AnyCastToIAnnotationsopt(my.GetRhsSym(1)),
                                    //#line 489 GJavaParser.g
                                    my.GetRhsSym(2).(*identifier),
                                    //#line 489 GJavaParser.g
                                    AnyCastToArguments(my.GetRhsSym(3)),
                                    //#line 489 GJavaParser.g
                                    AnyCastToClassBody(my.GetRhsSym(4))),
                //#line 489 GJavaParser.g
                )
                break
            }
            //
            // Rule 180:  Arguments ::= ( ArgumentListopt )
            //
            case 180: {
               //#line 491 "GJavaParser.g"
                my.SetResult(
                    //#line 491 GJavaParser.g
                    NewArguments(my.GetLeftIToken(), my.GetRightIToken(),
                                 //#line 491 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(1)),
                                 //#line 491 GJavaParser.g
                                 AnyCastToIArgumentListopt(my.GetRhsSym(2)),
                                 //#line 491 GJavaParser.g
                                 NewAstToken(my.GetRhsIToken(3))),
                //#line 491 GJavaParser.g
                )
                break
            }
            //
            // Rule 181:  EnumBodyDeclarations ::= ; ClassBodyDeclarationsopt
            //
            case 181: {
               //#line 493 "GJavaParser.g"
                my.SetResult(
                    //#line 493 GJavaParser.g
                    NewEnumBodyDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 493 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(1)),
                                            //#line 493 GJavaParser.g
                                            AnyCastToIClassBodyDeclarationsopt(my.GetRhsSym(2))),
                //#line 493 GJavaParser.g
                )
                break
            }
            //
            // Rule 182:  InterfaceDeclaration ::= NormalInterfaceDeclaration
            //
            case 182:
                break
            //
            // Rule 183:  InterfaceDeclaration ::= AnnotationTypeDeclaration
            //
            case 183:
                break
            //
            // Rule 184:  NormalInterfaceDeclaration ::= InterfaceModifiersopt interface identifier TypeParametersopt ExtendsInterfacesopt InterfaceBody
            //
            case 184: {
               //#line 500 "GJavaParser.g"
                my.SetResult(
                    //#line 500 GJavaParser.g
                    NewNormalInterfaceDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                  //#line 500 GJavaParser.g
                                                  AnyCastToIInterfaceModifiersopt(my.GetRhsSym(1)),
                                                  //#line 500 GJavaParser.g
                                                  NewAstToken(my.GetRhsIToken(2)),
                                                  //#line 500 GJavaParser.g
                                                  my.GetRhsSym(3).(*identifier),
                                                  //#line 500 GJavaParser.g
                                                  AnyCastToTypeParameters(my.GetRhsSym(4)),
                                                  //#line 500 GJavaParser.g
                                                  AnyCastToIExtendsInterfacesopt(my.GetRhsSym(5)),
                                                  //#line 500 GJavaParser.g
                                                  my.GetRhsSym(6).(*InterfaceBody)),
                //#line 500 GJavaParser.g
                )
                break
            }
            //
            // Rule 185:  InterfaceModifiers ::= InterfaceModifier
            //
            case 185:
                break
            //
            // Rule 186:  InterfaceModifiers ::= InterfaceModifiers InterfaceModifier
            //
            case 186: {
               //#line 503 "GJavaParser.g"
                my.SetResult(
                    //#line 503 GJavaParser.g
                    NewInterfaceModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 503 GJavaParser.g
                                          my.GetRhsSym(1).(IInterfaceModifiers),
                                          //#line 503 GJavaParser.g
                                          my.GetRhsSym(2).(IInterfaceModifier)),
                //#line 503 GJavaParser.g
                )
                break
            }
            //
            // Rule 187:  InterfaceModifier ::= Annotation
            //
            case 187:
                break
            //
            // Rule 188:  InterfaceModifier ::= public
            //
            case 188: {
               //#line 506 "GJavaParser.g"
                my.SetResult(
                    //#line 506 GJavaParser.g
                    NewInterfaceModifier0(my.GetRhsIToken(1)),
                //#line 506 GJavaParser.g
                )
                break
            }
            //
            // Rule 189:  InterfaceModifier ::= protected
            //
            case 189: {
               //#line 507 "GJavaParser.g"
                my.SetResult(
                    //#line 507 GJavaParser.g
                    NewInterfaceModifier1(my.GetRhsIToken(1)),
                //#line 507 GJavaParser.g
                )
                break
            }
            //
            // Rule 190:  InterfaceModifier ::= private
            //
            case 190: {
               //#line 508 "GJavaParser.g"
                my.SetResult(
                    //#line 508 GJavaParser.g
                    NewInterfaceModifier2(my.GetRhsIToken(1)),
                //#line 508 GJavaParser.g
                )
                break
            }
            //
            // Rule 191:  InterfaceModifier ::= abstract
            //
            case 191: {
               //#line 509 "GJavaParser.g"
                my.SetResult(
                    //#line 509 GJavaParser.g
                    NewInterfaceModifier3(my.GetRhsIToken(1)),
                //#line 509 GJavaParser.g
                )
                break
            }
            //
            // Rule 192:  InterfaceModifier ::= static
            //
            case 192: {
               //#line 510 "GJavaParser.g"
                my.SetResult(
                    //#line 510 GJavaParser.g
                    NewInterfaceModifier4(my.GetRhsIToken(1)),
                //#line 510 GJavaParser.g
                )
                break
            }
            //
            // Rule 193:  InterfaceModifier ::= strictfp
            //
            case 193: {
               //#line 511 "GJavaParser.g"
                my.SetResult(
                    //#line 511 GJavaParser.g
                    NewInterfaceModifier5(my.GetRhsIToken(1)),
                //#line 511 GJavaParser.g
                )
                break
            }
            //
            // Rule 194:  ExtendsInterfaces ::= extends InterfaceType
            //
            case 194: {
               //#line 513 "GJavaParser.g"
                my.SetResult(
                    //#line 513 GJavaParser.g
                    NewExtendsInterfaces0(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 513 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(1)),
                                          //#line 513 GJavaParser.g
                                          my.GetRhsSym(2).(*InterfaceType)),
                //#line 513 GJavaParser.g
                )
                break
            }
            //
            // Rule 195:  ExtendsInterfaces ::= ExtendsInterfaces , InterfaceType
            //
            case 195: {
               //#line 514 "GJavaParser.g"
                my.SetResult(
                    //#line 514 GJavaParser.g
                    NewExtendsInterfaces1(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 514 GJavaParser.g
                                          my.GetRhsSym(1).(IExtendsInterfaces),
                                          //#line 514 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 514 GJavaParser.g
                                          my.GetRhsSym(3).(*InterfaceType)),
                //#line 514 GJavaParser.g
                )
                break
            }
            //
            // Rule 196:  InterfaceBody ::= { InterfaceMemberDeclarationsopt }
            //
            case 196: {
               //#line 521 "GJavaParser.g"
                my.SetResult(
                    //#line 521 GJavaParser.g
                    NewInterfaceBody(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 521 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(1)),
                                     //#line 521 GJavaParser.g
                                     AnyCastToIInterfaceMemberDeclarationsopt(my.GetRhsSym(2)),
                                     //#line 521 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(3))),
                //#line 521 GJavaParser.g
                )
                break
            }
            //
            // Rule 197:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
            //
            case 197:
                break
            //
            // Rule 198:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
            //
            case 198: {
               //#line 524 "GJavaParser.g"
                my.SetResult(
                    //#line 524 GJavaParser.g
                    NewInterfaceMemberDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                                   //#line 524 GJavaParser.g
                                                   my.GetRhsSym(1).(IInterfaceMemberDeclarations),
                                                   //#line 524 GJavaParser.g
                                                   my.GetRhsSym(2).(IInterfaceMemberDeclaration)),
                //#line 524 GJavaParser.g
                )
                break
            }
            //
            // Rule 199:  InterfaceMemberDeclaration ::= ConstantDeclaration
            //
            case 199:
                break
            //
            // Rule 200:  InterfaceMemberDeclaration ::= AbstractMethodDeclaration
            //
            case 200:
                break
            //
            // Rule 201:  InterfaceMemberDeclaration ::= ClassDeclaration
            //
            case 201:
                break
            //
            // Rule 202:  InterfaceMemberDeclaration ::= InterfaceDeclaration
            //
            case 202:
                break
            //
            // Rule 203:  InterfaceMemberDeclaration ::= ;
            //
            case 203: {
               //#line 530 "GJavaParser.g"
                my.SetResult(
                    //#line 530 GJavaParser.g
                    NewInterfaceMemberDeclaration(my.GetRhsIToken(1)),
                //#line 530 GJavaParser.g
                )
                break
            }
            //
            // Rule 204:  ConstantDeclaration ::= ConstantModifiersopt Type VariableDeclarators
            //
            case 204: {
               //#line 532 "GJavaParser.g"
                my.SetResult(
                    //#line 532 GJavaParser.g
                    NewConstantDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 532 GJavaParser.g
                                           AnyCastToIConstantModifiersopt(my.GetRhsSym(1)),
                                           //#line 532 GJavaParser.g
                                           my.GetRhsSym(2).(IType),
                                           //#line 532 GJavaParser.g
                                           my.GetRhsSym(3).(IVariableDeclarators)),
                //#line 532 GJavaParser.g
                )
                break
            }
            //
            // Rule 205:  ConstantModifiers ::= ConstantModifier
            //
            case 205:
                break
            //
            // Rule 206:  ConstantModifiers ::= ConstantModifiers ConstantModifier
            //
            case 206: {
               //#line 535 "GJavaParser.g"
                my.SetResult(
                    //#line 535 GJavaParser.g
                    NewConstantModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 535 GJavaParser.g
                                         my.GetRhsSym(1).(IConstantModifiers),
                                         //#line 535 GJavaParser.g
                                         my.GetRhsSym(2).(IConstantModifier)),
                //#line 535 GJavaParser.g
                )
                break
            }
            //
            // Rule 207:  ConstantModifier ::= Annotation
            //
            case 207:
                break
            //
            // Rule 208:  ConstantModifier ::= public
            //
            case 208: {
               //#line 538 "GJavaParser.g"
                my.SetResult(
                    //#line 538 GJavaParser.g
                    NewConstantModifier0(my.GetRhsIToken(1)),
                //#line 538 GJavaParser.g
                )
                break
            }
            //
            // Rule 209:  ConstantModifier ::= static
            //
            case 209: {
               //#line 539 "GJavaParser.g"
                my.SetResult(
                    //#line 539 GJavaParser.g
                    NewConstantModifier1(my.GetRhsIToken(1)),
                //#line 539 GJavaParser.g
                )
                break
            }
            //
            // Rule 210:  ConstantModifier ::= final
            //
            case 210: {
               //#line 540 "GJavaParser.g"
                my.SetResult(
                    //#line 540 GJavaParser.g
                    NewConstantModifier2(my.GetRhsIToken(1)),
                //#line 540 GJavaParser.g
                )
                break
            }
            //
            // Rule 211:  AbstractMethodDeclaration ::= AbstractMethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt ;
            //
            case 211: {
               //#line 542 "GJavaParser.g"
                my.SetResult(
                    //#line 542 GJavaParser.g
                    NewAbstractMethodDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 542 GJavaParser.g
                                                 AnyCastToIAbstractMethodModifiersopt(my.GetRhsSym(1)),
                                                 //#line 542 GJavaParser.g
                                                 AnyCastToTypeParameters(my.GetRhsSym(2)),
                                                 //#line 542 GJavaParser.g
                                                 my.GetRhsSym(3).(IResultType),
                                                 //#line 542 GJavaParser.g
                                                 my.GetRhsSym(4).(IMethodDeclarator),
                                                 //#line 542 GJavaParser.g
                                                 AnyCastToThrows(my.GetRhsSym(5)),
                                                 //#line 542 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(6))),
                //#line 542 GJavaParser.g
                )
                break
            }
            //
            // Rule 212:  AbstractMethodModifiers ::= AbstractMethodModifier
            //
            case 212:
                break
            //
            // Rule 213:  AbstractMethodModifiers ::= AbstractMethodModifiers AbstractMethodModifier
            //
            case 213: {
               //#line 545 "GJavaParser.g"
                my.SetResult(
                    //#line 545 GJavaParser.g
                    NewAbstractMethodModifiers(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 545 GJavaParser.g
                                               my.GetRhsSym(1).(IAbstractMethodModifiers),
                                               //#line 545 GJavaParser.g
                                               my.GetRhsSym(2).(IAbstractMethodModifier)),
                //#line 545 GJavaParser.g
                )
                break
            }
            //
            // Rule 214:  AbstractMethodModifier ::= Annotations
            //
            case 214:
                break
            //
            // Rule 215:  AbstractMethodModifier ::= public
            //
            case 215: {
               //#line 548 "GJavaParser.g"
                my.SetResult(
                    //#line 548 GJavaParser.g
                    NewAbstractMethodModifier0(my.GetRhsIToken(1)),
                //#line 548 GJavaParser.g
                )
                break
            }
            //
            // Rule 216:  AbstractMethodModifier ::= abstract
            //
            case 216: {
               //#line 549 "GJavaParser.g"
                my.SetResult(
                    //#line 549 GJavaParser.g
                    NewAbstractMethodModifier1(my.GetRhsIToken(1)),
                //#line 549 GJavaParser.g
                )
                break
            }
            //
            // Rule 217:  AnnotationTypeDeclaration ::= InterfaceModifiersopt @ interface identifier AnnotationTypeBody
            //
            case 217: {
               //#line 551 "GJavaParser.g"
                my.SetResult(
                    //#line 551 GJavaParser.g
                    NewAnnotationTypeDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 551 GJavaParser.g
                                                 AnyCastToIInterfaceModifiersopt(my.GetRhsSym(1)),
                                                 //#line 551 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 551 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(3)),
                                                 //#line 551 GJavaParser.g
                                                 my.GetRhsSym(4).(*identifier),
                                                 //#line 551 GJavaParser.g
                                                 my.GetRhsSym(5).(*AnnotationTypeBody)),
                //#line 551 GJavaParser.g
                )
                break
            }
            //
            // Rule 218:  AnnotationTypeBody ::= { AnnotationTypeElementDeclarationsopt }
            //
            case 218: {
               //#line 553 "GJavaParser.g"
                my.SetResult(
                    //#line 553 GJavaParser.g
                    NewAnnotationTypeBody(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 553 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(1)),
                                          //#line 553 GJavaParser.g
                                          AnyCastToIAnnotationTypeElementDeclarationsopt(my.GetRhsSym(2)),
                                          //#line 553 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 553 GJavaParser.g
                )
                break
            }
            //
            // Rule 219:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclaration
            //
            case 219:
                break
            //
            // Rule 220:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
            //
            case 220: {
               //#line 556 "GJavaParser.g"
                my.SetResult(
                    //#line 556 GJavaParser.g
                    NewAnnotationTypeElementDeclarations(my.GetLeftIToken(), my.GetRightIToken(),
                                                         //#line 556 GJavaParser.g
                                                         my.GetRhsSym(1).(IAnnotationTypeElementDeclarations),
                                                         //#line 556 GJavaParser.g
                                                         my.GetRhsSym(2).(IAnnotationTypeElementDeclaration)),
                //#line 556 GJavaParser.g
                )
                break
            }
            //
            // Rule 221:  AnnotationTypeElementDeclaration ::= AbstractMethodModifiersopt Type identifier ( ) DefaultValueopt ;
            //
            case 221: {
               //#line 558 "GJavaParser.g"
                my.SetResult(
                    //#line 558 GJavaParser.g
                    NewAnnotationTypeElementDeclaration0(my.GetLeftIToken(), my.GetRightIToken(),
                                                         //#line 558 GJavaParser.g
                                                         AnyCastToIAbstractMethodModifiersopt(my.GetRhsSym(1)),
                                                         //#line 558 GJavaParser.g
                                                         my.GetRhsSym(2).(IType),
                                                         //#line 558 GJavaParser.g
                                                         my.GetRhsSym(3).(*identifier),
                                                         //#line 558 GJavaParser.g
                                                         NewAstToken(my.GetRhsIToken(4)),
                                                         //#line 558 GJavaParser.g
                                                         NewAstToken(my.GetRhsIToken(5)),
                                                         //#line 558 GJavaParser.g
                                                         AnyCastToDefaultValue(my.GetRhsSym(6)),
                                                         //#line 558 GJavaParser.g
                                                         NewAstToken(my.GetRhsIToken(7))),
                //#line 558 GJavaParser.g
                )
                break
            }
            //
            // Rule 222:  AnnotationTypeElementDeclaration ::= ConstantDeclaration
            //
            case 222:
                break
            //
            // Rule 223:  AnnotationTypeElementDeclaration ::= ClassDeclaration
            //
            case 223:
                break
            //
            // Rule 224:  AnnotationTypeElementDeclaration ::= InterfaceDeclaration
            //
            case 224:
                break
            //
            // Rule 225:  AnnotationTypeElementDeclaration ::= EnumDeclaration
            //
            case 225:
                break
            //
            // Rule 226:  AnnotationTypeElementDeclaration ::= AnnotationTypeDeclaration
            //
            case 226:
                break
            //
            // Rule 227:  AnnotationTypeElementDeclaration ::= ;
            //
            case 227: {
               //#line 564 "GJavaParser.g"
                my.SetResult(
                    //#line 564 GJavaParser.g
                    NewAnnotationTypeElementDeclaration1(my.GetRhsIToken(1)),
                //#line 564 GJavaParser.g
                )
                break
            }
            //
            // Rule 228:  DefaultValue ::= default ElementValue
            //
            case 228: {
               //#line 566 "GJavaParser.g"
                my.SetResult(
                    //#line 566 GJavaParser.g
                    NewDefaultValue(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 566 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 566 GJavaParser.g
                                    my.GetRhsSym(2).(IElementValue)),
                //#line 566 GJavaParser.g
                )
                break
            }
            //
            // Rule 229:  Annotations ::= Annotation
            //
            case 229:
                break
            //
            // Rule 230:  Annotations ::= Annotations Annotation
            //
            case 230: {
               //#line 569 "GJavaParser.g"
                my.SetResult(
                    //#line 569 GJavaParser.g
                    NewAnnotations(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 569 GJavaParser.g
                                   my.GetRhsSym(1).(IAnnotations),
                                   //#line 569 GJavaParser.g
                                   my.GetRhsSym(2).(IAnnotation)),
                //#line 569 GJavaParser.g
                )
                break
            }
            //
            // Rule 231:  Annotation ::= NormalAnnotation
            //
            case 231:
                break
            //
            // Rule 232:  Annotation ::= MarkerAnnotation
            //
            case 232:
                break
            //
            // Rule 233:  Annotation ::= SingleElementAnnotation
            //
            case 233:
                break
            //
            // Rule 234:  NormalAnnotation ::= @ TypeName ( ElementValuePairsopt )
            //
            case 234: {
               //#line 575 "GJavaParser.g"
                my.SetResult(
                    //#line 575 GJavaParser.g
                    NewNormalAnnotation(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 575 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 575 GJavaParser.g
                                        my.GetRhsSym(2).(ITypeName),
                                        //#line 575 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3)),
                                        //#line 575 GJavaParser.g
                                        AnyCastToIElementValuePairsopt(my.GetRhsSym(4)),
                                        //#line 575 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(5))),
                //#line 575 GJavaParser.g
                )
                break
            }
            //
            // Rule 235:  ElementValuePairs ::= ElementValuePair
            //
            case 235:
                break
            //
            // Rule 236:  ElementValuePairs ::= ElementValuePairs , ElementValuePair
            //
            case 236: {
               //#line 578 "GJavaParser.g"
                my.SetResult(
                    //#line 578 GJavaParser.g
                    NewElementValuePairs(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 578 GJavaParser.g
                                         my.GetRhsSym(1).(IElementValuePairs),
                                         //#line 578 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 578 GJavaParser.g
                                         my.GetRhsSym(3).(*ElementValuePair)),
                //#line 578 GJavaParser.g
                )
                break
            }
            //
            // Rule 237:  ElementValuePair ::= SimpleName = ElementValue
            //
            case 237: {
               //#line 580 "GJavaParser.g"
                my.SetResult(
                    //#line 580 GJavaParser.g
                    NewElementValuePair(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 580 GJavaParser.g
                                        my.GetRhsSym(1).(*identifier),
                                        //#line 580 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 580 GJavaParser.g
                                        my.GetRhsSym(3).(IElementValue)),
                //#line 580 GJavaParser.g
                )
                break
            }
            //
            // Rule 238:  SimpleName ::= identifier
            //
            case 238:
                break
            //
            // Rule 239:  ElementValue ::= ConditionalExpression
            //
            case 239:
                break
            //
            // Rule 240:  ElementValue ::= Annotation
            //
            case 240:
                break
            //
            // Rule 241:  ElementValue ::= ElementValueArrayInitializer
            //
            case 241:
                break
            //
            // Rule 242:  ElementValueArrayInitializer ::= { ElementValuesopt ,opt }
            //
            case 242: {
               //#line 588 "GJavaParser.g"
                my.SetResult(
                    //#line 588 GJavaParser.g
                    NewElementValueArrayInitializer(my.GetLeftIToken(), my.GetRightIToken(),
                                                    //#line 588 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(1)),
                                                    //#line 588 GJavaParser.g
                                                    AnyCastToIElementValuesopt(my.GetRhsSym(2)),
                                                    //#line 588 GJavaParser.g
                                                    AnyCastToCommaopt(my.GetRhsSym(3)),
                                                    //#line 588 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(4))),
                //#line 588 GJavaParser.g
                )
                break
            }
            //
            // Rule 243:  ElementValues ::= ElementValue
            //
            case 243:
                break
            //
            // Rule 244:  ElementValues ::= ElementValues , ElementValue
            //
            case 244: {
               //#line 591 "GJavaParser.g"
                my.SetResult(
                    //#line 591 GJavaParser.g
                    NewElementValues(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 591 GJavaParser.g
                                     my.GetRhsSym(1).(IElementValues),
                                     //#line 591 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(2)),
                                     //#line 591 GJavaParser.g
                                     my.GetRhsSym(3).(IElementValue)),
                //#line 591 GJavaParser.g
                )
                break
            }
            //
            // Rule 245:  MarkerAnnotation ::= @ TypeName
            //
            case 245: {
               //#line 593 "GJavaParser.g"
                my.SetResult(
                    //#line 593 GJavaParser.g
                    NewMarkerAnnotation(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 593 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 593 GJavaParser.g
                                        my.GetRhsSym(2).(ITypeName)),
                //#line 593 GJavaParser.g
                )
                break
            }
            //
            // Rule 246:  SingleElementAnnotation ::= @ TypeName ( ElementValue )
            //
            case 246: {
               //#line 595 "GJavaParser.g"
                my.SetResult(
                    //#line 595 GJavaParser.g
                    NewSingleElementAnnotation(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 595 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(1)),
                                               //#line 595 GJavaParser.g
                                               my.GetRhsSym(2).(ITypeName),
                                               //#line 595 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(3)),
                                               //#line 595 GJavaParser.g
                                               my.GetRhsSym(4).(IElementValue),
                                               //#line 595 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(5))),
                //#line 595 GJavaParser.g
                )
                break
            }
            //
            // Rule 247:  ArrayInitializer ::= { VariableInitializersopt ,opt }
            //
            case 247: {
               //#line 599 "GJavaParser.g"
                my.SetResult(
                    //#line 599 GJavaParser.g
                    NewArrayInitializer(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 599 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 599 GJavaParser.g
                                        AnyCastToIVariableInitializersopt(my.GetRhsSym(2)),
                                        //#line 599 GJavaParser.g
                                        AnyCastToCommaopt(my.GetRhsSym(3)),
                                        //#line 599 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(4))),
                //#line 599 GJavaParser.g
                )
                break
            }
            //
            // Rule 248:  VariableInitializers ::= VariableInitializer
            //
            case 248:
                break
            //
            // Rule 249:  VariableInitializers ::= VariableInitializers , VariableInitializer
            //
            case 249: {
               //#line 602 "GJavaParser.g"
                my.SetResult(
                    //#line 602 GJavaParser.g
                    NewVariableInitializers(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 602 GJavaParser.g
                                            my.GetRhsSym(1).(IVariableInitializers),
                                            //#line 602 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(2)),
                                            //#line 602 GJavaParser.g
                                            my.GetRhsSym(3).(IVariableInitializer)),
                //#line 602 GJavaParser.g
                )
                break
            }
            //
            // Rule 250:  Block ::= { BlockStatementsopt }
            //
            case 250: {
               //#line 618 "GJavaParser.g"
                my.SetResult(
                    //#line 618 GJavaParser.g
                    NewBlock(my.GetLeftIToken(), my.GetRightIToken(),
                             //#line 618 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(1)),
                             //#line 618 GJavaParser.g
                             AnyCastToIBlockStatementsopt(my.GetRhsSym(2)),
                             //#line 618 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(3))),
                //#line 618 GJavaParser.g
                )
                break
            }
            //
            // Rule 251:  BlockStatements ::= BlockStatement
            //
            case 251:
                break
            //
            // Rule 252:  BlockStatements ::= BlockStatements BlockStatement
            //
            case 252: {
               //#line 621 "GJavaParser.g"
                my.SetResult(
                    //#line 621 GJavaParser.g
                    NewBlockStatements(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 621 GJavaParser.g
                                       my.GetRhsSym(1).(IBlockStatements),
                                       //#line 621 GJavaParser.g
                                       my.GetRhsSym(2).(IBlockStatement)),
                //#line 621 GJavaParser.g
                )
                break
            }
            //
            // Rule 253:  BlockStatement ::= LocalVariableDeclarationStatement
            //
            case 253:
                break
            //
            // Rule 254:  BlockStatement ::= ClassDeclaration
            //
            case 254:
                break
            //
            // Rule 255:  BlockStatement ::= Statement
            //
            case 255:
                break
            //
            // Rule 256:  LocalVariableDeclarationStatement ::= LocalVariableDeclaration ;
            //
            case 256: {
               //#line 627 "GJavaParser.g"
                my.SetResult(
                    //#line 627 GJavaParser.g
                    NewLocalVariableDeclarationStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                                         //#line 627 GJavaParser.g
                                                         my.GetRhsSym(1).(*LocalVariableDeclaration),
                                                         //#line 627 GJavaParser.g
                                                         NewAstToken(my.GetRhsIToken(2))),
                //#line 627 GJavaParser.g
                )
                break
            }
            //
            // Rule 257:  LocalVariableDeclaration ::= VariableModifiersopt Type VariableDeclarators
            //
            case 257: {
               //#line 629 "GJavaParser.g"
                my.SetResult(
                    //#line 629 GJavaParser.g
                    NewLocalVariableDeclaration(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 629 GJavaParser.g
                                                AnyCastToIVariableModifiersopt(my.GetRhsSym(1)),
                                                //#line 629 GJavaParser.g
                                                my.GetRhsSym(2).(IType),
                                                //#line 629 GJavaParser.g
                                                my.GetRhsSym(3).(IVariableDeclarators)),
                //#line 629 GJavaParser.g
                )
                break
            }
            //
            // Rule 258:  Statement ::= StatementWithoutTrailingSubstatement
            //
            case 258:
                break
            //
            // Rule 259:  Statement ::= LabeledStatement
            //
            case 259:
                break
            //
            // Rule 260:  Statement ::= IfThenStatement
            //
            case 260:
                break
            //
            // Rule 261:  Statement ::= IfThenElseStatement
            //
            case 261:
                break
            //
            // Rule 262:  Statement ::= WhileStatement
            //
            case 262:
                break
            //
            // Rule 263:  Statement ::= ForStatement
            //
            case 263:
                break
            //
            // Rule 264:  StatementWithoutTrailingSubstatement ::= Block
            //
            case 264:
                break
            //
            // Rule 265:  StatementWithoutTrailingSubstatement ::= EmptyStatement
            //
            case 265:
                break
            //
            // Rule 266:  StatementWithoutTrailingSubstatement ::= ExpressionStatement
            //
            case 266:
                break
            //
            // Rule 267:  StatementWithoutTrailingSubstatement ::= AssertStatement
            //
            case 267:
                break
            //
            // Rule 268:  StatementWithoutTrailingSubstatement ::= SwitchStatement
            //
            case 268:
                break
            //
            // Rule 269:  StatementWithoutTrailingSubstatement ::= DoStatement
            //
            case 269:
                break
            //
            // Rule 270:  StatementWithoutTrailingSubstatement ::= BreakStatement
            //
            case 270:
                break
            //
            // Rule 271:  StatementWithoutTrailingSubstatement ::= ContinueStatement
            //
            case 271:
                break
            //
            // Rule 272:  StatementWithoutTrailingSubstatement ::= ReturnStatement
            //
            case 272:
                break
            //
            // Rule 273:  StatementWithoutTrailingSubstatement ::= SynchronizedStatement
            //
            case 273:
                break
            //
            // Rule 274:  StatementWithoutTrailingSubstatement ::= ThrowStatement
            //
            case 274:
                break
            //
            // Rule 275:  StatementWithoutTrailingSubstatement ::= TryStatement
            //
            case 275:
                break
            //
            // Rule 276:  StatementNoShortIf ::= StatementWithoutTrailingSubstatement
            //
            case 276:
                break
            //
            // Rule 277:  StatementNoShortIf ::= LabeledStatementNoShortIf
            //
            case 277:
                break
            //
            // Rule 278:  StatementNoShortIf ::= IfThenElseStatementNoShortIf
            //
            case 278:
                break
            //
            // Rule 279:  StatementNoShortIf ::= WhileStatementNoShortIf
            //
            case 279:
                break
            //
            // Rule 280:  StatementNoShortIf ::= ForStatementNoShortIf
            //
            case 280:
                break
            //
            // Rule 281:  IfThenStatement ::= if ( Expression ) Statement
            //
            case 281: {
               //#line 672 "GJavaParser.g"
                my.SetResult(
                    //#line 672 GJavaParser.g
                    NewIfThenStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 672 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 672 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(2)),
                                       //#line 672 GJavaParser.g
                                       my.GetRhsSym(3).(IExpression),
                                       //#line 672 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(4)),
                                       //#line 672 GJavaParser.g
                                       my.GetRhsSym(5).(IStatement)),
                //#line 672 GJavaParser.g
                )
                break
            }
            //
            // Rule 282:  IfThenElseStatement ::= if ( Expression ) StatementNoShortIf else Statement
            //
            case 282: {
               //#line 674 "GJavaParser.g"
                my.SetResult(
                    //#line 674 GJavaParser.g
                    NewIfThenElseStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 674 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(1)),
                                           //#line 674 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 674 GJavaParser.g
                                           my.GetRhsSym(3).(IExpression),
                                           //#line 674 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(4)),
                                           //#line 674 GJavaParser.g
                                           my.GetRhsSym(5).(IStatementNoShortIf),
                                           //#line 674 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(6)),
                                           //#line 674 GJavaParser.g
                                           my.GetRhsSym(7).(IStatement)),
                //#line 674 GJavaParser.g
                )
                break
            }
            //
            // Rule 283:  IfThenElseStatementNoShortIf ::= if ( Expression ) StatementNoShortIf else StatementNoShortIf
            //
            case 283: {
               //#line 676 "GJavaParser.g"
                my.SetResult(
                    //#line 676 GJavaParser.g
                    NewIfThenElseStatementNoShortIf(my.GetLeftIToken(), my.GetRightIToken(),
                                                    //#line 676 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(1)),
                                                    //#line 676 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(2)),
                                                    //#line 676 GJavaParser.g
                                                    my.GetRhsSym(3).(IExpression),
                                                    //#line 676 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(4)),
                                                    //#line 676 GJavaParser.g
                                                    my.GetRhsSym(5).(IStatementNoShortIf),
                                                    //#line 676 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(6)),
                                                    //#line 676 GJavaParser.g
                                                    my.GetRhsSym(7).(IStatementNoShortIf)),
                //#line 676 GJavaParser.g
                )
                break
            }
            //
            // Rule 284:  EmptyStatement ::= ;
            //
            case 284: {
               //#line 678 "GJavaParser.g"
                my.SetResult(
                    //#line 678 GJavaParser.g
                    NewEmptyStatement(my.GetRhsIToken(1)),
                //#line 678 GJavaParser.g
                )
                break
            }
            //
            // Rule 285:  LabeledStatement ::= identifier : Statement
            //
            case 285: {
               //#line 680 "GJavaParser.g"
                my.SetResult(
                    //#line 680 GJavaParser.g
                    NewLabeledStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 680 GJavaParser.g
                                        my.GetRhsSym(1).(*identifier),
                                        //#line 680 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 680 GJavaParser.g
                                        my.GetRhsSym(3).(IStatement)),
                //#line 680 GJavaParser.g
                )
                break
            }
            //
            // Rule 286:  LabeledStatementNoShortIf ::= identifier : StatementNoShortIf
            //
            case 286: {
               //#line 682 "GJavaParser.g"
                my.SetResult(
                    //#line 682 GJavaParser.g
                    NewLabeledStatementNoShortIf(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 682 GJavaParser.g
                                                 my.GetRhsSym(1).(*identifier),
                                                 //#line 682 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 682 GJavaParser.g
                                                 my.GetRhsSym(3).(IStatementNoShortIf)),
                //#line 682 GJavaParser.g
                )
                break
            }
            //
            // Rule 287:  ExpressionStatement ::= StatementExpression ;
            //
            case 287: {
               //#line 684 "GJavaParser.g"
                my.SetResult(
                    //#line 684 GJavaParser.g
                    NewExpressionStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 684 GJavaParser.g
                                           my.GetRhsSym(1).(IStatementExpression),
                                           //#line 684 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2))),
                //#line 684 GJavaParser.g
                )
                break
            }
            //
            // Rule 288:  StatementExpression ::= Assignment
            //
            case 288:
                break
            //
            // Rule 289:  StatementExpression ::= PreIncrementExpression
            //
            case 289:
                break
            //
            // Rule 290:  StatementExpression ::= PreDecrementExpression
            //
            case 290:
                break
            //
            // Rule 291:  StatementExpression ::= PostIncrementExpression
            //
            case 291:
                break
            //
            // Rule 292:  StatementExpression ::= PostDecrementExpression
            //
            case 292:
                break
            //
            // Rule 293:  StatementExpression ::= MethodInvocation
            //
            case 293:
                break
            //
            // Rule 294:  StatementExpression ::= ClassInstanceCreationExpression
            //
            case 294:
                break
            //
            // Rule 295:  AssertStatement ::= assert Expression ;
            //
            case 295: {
               //#line 703 "GJavaParser.g"
                my.SetResult(
                    //#line 703 GJavaParser.g
                    NewAssertStatement0(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 703 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 703 GJavaParser.g
                                        my.GetRhsSym(2).(IExpression),
                                        //#line 703 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3))),
                //#line 703 GJavaParser.g
                )
                break
            }
            //
            // Rule 296:  AssertStatement ::= assert Expression : Expression ;
            //
            case 296: {
               //#line 704 "GJavaParser.g"
                my.SetResult(
                    //#line 704 GJavaParser.g
                    NewAssertStatement1(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 704 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 704 GJavaParser.g
                                        my.GetRhsSym(2).(IExpression),
                                        //#line 704 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3)),
                                        //#line 704 GJavaParser.g
                                        my.GetRhsSym(4).(IExpression),
                                        //#line 704 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(5))),
                //#line 704 GJavaParser.g
                )
                break
            }
            //
            // Rule 297:  SwitchStatement ::= switch ( Expression ) SwitchBlock
            //
            case 297: {
               //#line 706 "GJavaParser.g"
                my.SetResult(
                    //#line 706 GJavaParser.g
                    NewSwitchStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 706 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 706 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(2)),
                                       //#line 706 GJavaParser.g
                                       my.GetRhsSym(3).(IExpression),
                                       //#line 706 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(4)),
                                       //#line 706 GJavaParser.g
                                       my.GetRhsSym(5).(*SwitchBlock)),
                //#line 706 GJavaParser.g
                )
                break
            }
            //
            // Rule 298:  SwitchBlock ::= { SwitchBlockStatementGroupsopt SwitchLabelsopt }
            //
            case 298: {
               //#line 708 "GJavaParser.g"
                my.SetResult(
                    //#line 708 GJavaParser.g
                    NewSwitchBlock(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 708 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(1)),
                                   //#line 708 GJavaParser.g
                                   AnyCastToISwitchBlockStatementGroupsopt(my.GetRhsSym(2)),
                                   //#line 708 GJavaParser.g
                                   AnyCastToISwitchLabelsopt(my.GetRhsSym(3)),
                                   //#line 708 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(4))),
                //#line 708 GJavaParser.g
                )
                break
            }
            //
            // Rule 299:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroup
            //
            case 299:
                break
            //
            // Rule 300:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup
            //
            case 300: {
               //#line 711 "GJavaParser.g"
                my.SetResult(
                    //#line 711 GJavaParser.g
                    NewSwitchBlockStatementGroups(my.GetLeftIToken(), my.GetRightIToken(),
                                                  //#line 711 GJavaParser.g
                                                  my.GetRhsSym(1).(ISwitchBlockStatementGroups),
                                                  //#line 711 GJavaParser.g
                                                  my.GetRhsSym(2).(*SwitchBlockStatementGroup)),
                //#line 711 GJavaParser.g
                )
                break
            }
            //
            // Rule 301:  SwitchBlockStatementGroup ::= SwitchLabels BlockStatements
            //
            case 301: {
               //#line 713 "GJavaParser.g"
                my.SetResult(
                    //#line 713 GJavaParser.g
                    NewSwitchBlockStatementGroup(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 713 GJavaParser.g
                                                 my.GetRhsSym(1).(ISwitchLabels),
                                                 //#line 713 GJavaParser.g
                                                 my.GetRhsSym(2).(IBlockStatements)),
                //#line 713 GJavaParser.g
                )
                break
            }
            //
            // Rule 302:  SwitchLabels ::= SwitchLabel
            //
            case 302:
                break
            //
            // Rule 303:  SwitchLabels ::= SwitchLabels SwitchLabel
            //
            case 303: {
               //#line 716 "GJavaParser.g"
                my.SetResult(
                    //#line 716 GJavaParser.g
                    NewSwitchLabels(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 716 GJavaParser.g
                                    my.GetRhsSym(1).(ISwitchLabels),
                                    //#line 716 GJavaParser.g
                                    my.GetRhsSym(2).(ISwitchLabel)),
                //#line 716 GJavaParser.g
                )
                break
            }
            //
            // Rule 304:  SwitchLabel ::= case ConstantExpression :
            //
            case 304: {
               //#line 718 "GJavaParser.g"
                my.SetResult(
                    //#line 718 GJavaParser.g
                    NewSwitchLabel0(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 718 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 718 GJavaParser.g
                                    my.GetRhsSym(2).(IConstantExpression),
                                    //#line 718 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(3))),
                //#line 718 GJavaParser.g
                )
                break
            }
            //
            // Rule 305:  SwitchLabel ::= case EnumConstant :
            //
            case 305: {
               //#line 719 "GJavaParser.g"
                my.SetResult(
                    //#line 719 GJavaParser.g
                    NewSwitchLabel1(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 719 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 719 GJavaParser.g
                                    my.GetRhsSym(2).(IEnumConstant),
                                    //#line 719 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(3))),
                //#line 719 GJavaParser.g
                )
                break
            }
            //
            // Rule 306:  SwitchLabel ::= default :
            //
            case 306: {
               //#line 720 "GJavaParser.g"
                my.SetResult(
                    //#line 720 GJavaParser.g
                    NewSwitchLabel2(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 720 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 720 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2))),
                //#line 720 GJavaParser.g
                )
                break
            }
            //
            // Rule 307:  EnumConstant ::= identifier
            //
            case 307:
                break
            //
            // Rule 308:  WhileStatement ::= while ( Expression ) Statement
            //
            case 308: {
               //#line 724 "GJavaParser.g"
                my.SetResult(
                    //#line 724 GJavaParser.g
                    NewWhileStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 724 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 724 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(2)),
                                      //#line 724 GJavaParser.g
                                      my.GetRhsSym(3).(IExpression),
                                      //#line 724 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(4)),
                                      //#line 724 GJavaParser.g
                                      my.GetRhsSym(5).(IStatement)),
                //#line 724 GJavaParser.g
                )
                break
            }
            //
            // Rule 309:  WhileStatementNoShortIf ::= while ( Expression ) StatementNoShortIf
            //
            case 309: {
               //#line 726 "GJavaParser.g"
                my.SetResult(
                    //#line 726 GJavaParser.g
                    NewWhileStatementNoShortIf(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 726 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(1)),
                                               //#line 726 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2)),
                                               //#line 726 GJavaParser.g
                                               my.GetRhsSym(3).(IExpression),
                                               //#line 726 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(4)),
                                               //#line 726 GJavaParser.g
                                               my.GetRhsSym(5).(IStatementNoShortIf)),
                //#line 726 GJavaParser.g
                )
                break
            }
            //
            // Rule 310:  DoStatement ::= do Statement while ( Expression ) ;
            //
            case 310: {
               //#line 728 "GJavaParser.g"
                my.SetResult(
                    //#line 728 GJavaParser.g
                    NewDoStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(1)),
                                   //#line 728 GJavaParser.g
                                   my.GetRhsSym(2).(IStatement),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(3)),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(4)),
                                   //#line 728 GJavaParser.g
                                   my.GetRhsSym(5).(IExpression),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(6)),
                                   //#line 728 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(7))),
                //#line 728 GJavaParser.g
                )
                break
            }
            //
            // Rule 311:  ForStatement ::= BasicForStatement
            //
            case 311:
                break
            //
            // Rule 312:  ForStatement ::= EnhancedForStatement
            //
            case 312:
                break
            //
            // Rule 313:  BasicForStatement ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement
            //
            case 313: {
               //#line 733 "GJavaParser.g"
                my.SetResult(
                    //#line 733 GJavaParser.g
                    NewBasicForStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(1)),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 733 GJavaParser.g
                                         AnyCastToIForInitopt(my.GetRhsSym(3)),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(4)),
                                         //#line 733 GJavaParser.g
                                         AnyCastToIExpressionopt(my.GetRhsSym(5)),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(6)),
                                         //#line 733 GJavaParser.g
                                         AnyCastToIForUpdateopt(my.GetRhsSym(7)),
                                         //#line 733 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(8)),
                                         //#line 733 GJavaParser.g
                                         my.GetRhsSym(9).(IStatement)),
                //#line 733 GJavaParser.g
                )
                break
            }
            //
            // Rule 314:  ForStatementNoShortIf ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) StatementNoShortIf
            //
            case 314: {
               //#line 735 "GJavaParser.g"
                my.SetResult(
                    //#line 735 GJavaParser.g
                    NewForStatementNoShortIf(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(1)),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 735 GJavaParser.g
                                             AnyCastToIForInitopt(my.GetRhsSym(3)),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(4)),
                                             //#line 735 GJavaParser.g
                                             AnyCastToIExpressionopt(my.GetRhsSym(5)),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(6)),
                                             //#line 735 GJavaParser.g
                                             AnyCastToIForUpdateopt(my.GetRhsSym(7)),
                                             //#line 735 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(8)),
                                             //#line 735 GJavaParser.g
                                             my.GetRhsSym(9).(IStatementNoShortIf)),
                //#line 735 GJavaParser.g
                )
                break
            }
            //
            // Rule 315:  ForInit ::= StatementExpressionList
            //
            case 315:
                break
            //
            // Rule 316:  ForInit ::= LocalVariableDeclaration
            //
            case 316:
                break
            //
            // Rule 317:  ForUpdate ::= StatementExpressionList
            //
            case 317:
                break
            //
            // Rule 318:  StatementExpressionList ::= StatementExpression
            //
            case 318:
                break
            //
            // Rule 319:  StatementExpressionList ::= StatementExpressionList , StatementExpression
            //
            case 319: {
               //#line 743 "GJavaParser.g"
                my.SetResult(
                    //#line 743 GJavaParser.g
                    NewStatementExpressionList(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 743 GJavaParser.g
                                               my.GetRhsSym(1).(IStatementExpressionList),
                                               //#line 743 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2)),
                                               //#line 743 GJavaParser.g
                                               my.GetRhsSym(3).(IStatementExpression)),
                //#line 743 GJavaParser.g
                )
                break
            }
            //
            // Rule 320:  EnhancedForStatement ::= for ( FormalParameter : Expression ) Statement
            //
            case 320: {
               //#line 745 "GJavaParser.g"
                my.SetResult(
                    //#line 745 GJavaParser.g
                    NewEnhancedForStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                            //#line 745 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(1)),
                                            //#line 745 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(2)),
                                            //#line 745 GJavaParser.g
                                            my.GetRhsSym(3).(*FormalParameter),
                                            //#line 745 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(4)),
                                            //#line 745 GJavaParser.g
                                            my.GetRhsSym(5).(IExpression),
                                            //#line 745 GJavaParser.g
                                            NewAstToken(my.GetRhsIToken(6)),
                                            //#line 745 GJavaParser.g
                                            my.GetRhsSym(7).(IStatement)),
                //#line 745 GJavaParser.g
                )
                break
            }
            //
            // Rule 321:  BreakStatement ::= break identifieropt ;
            //
            case 321: {
               //#line 747 "GJavaParser.g"
                my.SetResult(
                    //#line 747 GJavaParser.g
                    NewBreakStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 747 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 747 GJavaParser.g
                                      AnyCastToidentifier(my.GetRhsSym(2)),
                                      //#line 747 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 747 GJavaParser.g
                )
                break
            }
            //
            // Rule 322:  ContinueStatement ::= continue identifieropt ;
            //
            case 322: {
               //#line 749 "GJavaParser.g"
                my.SetResult(
                    //#line 749 GJavaParser.g
                    NewContinueStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 749 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(1)),
                                         //#line 749 GJavaParser.g
                                         AnyCastToidentifier(my.GetRhsSym(2)),
                                         //#line 749 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(3))),
                //#line 749 GJavaParser.g
                )
                break
            }
            //
            // Rule 323:  ReturnStatement ::= return Expressionopt ;
            //
            case 323: {
               //#line 751 "GJavaParser.g"
                my.SetResult(
                    //#line 751 GJavaParser.g
                    NewReturnStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 751 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 751 GJavaParser.g
                                       AnyCastToIExpressionopt(my.GetRhsSym(2)),
                                       //#line 751 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(3))),
                //#line 751 GJavaParser.g
                )
                break
            }
            //
            // Rule 324:  ThrowStatement ::= throw Expression ;
            //
            case 324: {
               //#line 753 "GJavaParser.g"
                my.SetResult(
                    //#line 753 GJavaParser.g
                    NewThrowStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                      //#line 753 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(1)),
                                      //#line 753 GJavaParser.g
                                      my.GetRhsSym(2).(IExpression),
                                      //#line 753 GJavaParser.g
                                      NewAstToken(my.GetRhsIToken(3))),
                //#line 753 GJavaParser.g
                )
                break
            }
            //
            // Rule 325:  SynchronizedStatement ::= synchronized ( Expression ) Block
            //
            case 325: {
               //#line 755 "GJavaParser.g"
                my.SetResult(
                    //#line 755 GJavaParser.g
                    NewSynchronizedStatement(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 755 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(1)),
                                             //#line 755 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 755 GJavaParser.g
                                             my.GetRhsSym(3).(IExpression),
                                             //#line 755 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(4)),
                                             //#line 755 GJavaParser.g
                                             my.GetRhsSym(5).(*Block)),
                //#line 755 GJavaParser.g
                )
                break
            }
            //
            // Rule 326:  TryStatement ::= try Block Catches
            //
            case 326: {
               //#line 757 "GJavaParser.g"
                my.SetResult(
                    //#line 757 GJavaParser.g
                    NewTryStatement0(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 757 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(1)),
                                     //#line 757 GJavaParser.g
                                     my.GetRhsSym(2).(*Block),
                                     //#line 757 GJavaParser.g
                                     my.GetRhsSym(3).(ICatches)),
                //#line 757 GJavaParser.g
                )
                break
            }
            //
            // Rule 327:  TryStatement ::= try Block Catchesopt Finally
            //
            case 327: {
               //#line 758 "GJavaParser.g"
                my.SetResult(
                    //#line 758 GJavaParser.g
                    NewTryStatement1(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 758 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(1)),
                                     //#line 758 GJavaParser.g
                                     my.GetRhsSym(2).(*Block),
                                     //#line 758 GJavaParser.g
                                     AnyCastToICatchesopt(my.GetRhsSym(3)),
                                     //#line 758 GJavaParser.g
                                     my.GetRhsSym(4).(*Finally)),
                //#line 758 GJavaParser.g
                )
                break
            }
            //
            // Rule 328:  Catches ::= CatchClause
            //
            case 328:
                break
            //
            // Rule 329:  Catches ::= Catches CatchClause
            //
            case 329: {
               //#line 761 "GJavaParser.g"
                my.SetResult(
                    //#line 761 GJavaParser.g
                    NewCatches(my.GetLeftIToken(), my.GetRightIToken(),
                               //#line 761 GJavaParser.g
                               my.GetRhsSym(1).(ICatches),
                               //#line 761 GJavaParser.g
                               my.GetRhsSym(2).(*CatchClause)),
                //#line 761 GJavaParser.g
                )
                break
            }
            //
            // Rule 330:  CatchClause ::= catch ( FormalParameter ) Block
            //
            case 330: {
               //#line 763 "GJavaParser.g"
                my.SetResult(
                    //#line 763 GJavaParser.g
                    NewCatchClause(my.GetLeftIToken(), my.GetRightIToken(),
                                   //#line 763 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(1)),
                                   //#line 763 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(2)),
                                   //#line 763 GJavaParser.g
                                   my.GetRhsSym(3).(*FormalParameter),
                                   //#line 763 GJavaParser.g
                                   NewAstToken(my.GetRhsIToken(4)),
                                   //#line 763 GJavaParser.g
                                   my.GetRhsSym(5).(*Block)),
                //#line 763 GJavaParser.g
                )
                break
            }
            //
            // Rule 331:  Finally ::= finally Block
            //
            case 331: {
               //#line 765 "GJavaParser.g"
                my.SetResult(
                    //#line 765 GJavaParser.g
                    NewFinally(my.GetLeftIToken(), my.GetRightIToken(),
                               //#line 765 GJavaParser.g
                               NewAstToken(my.GetRhsIToken(1)),
                               //#line 765 GJavaParser.g
                               my.GetRhsSym(2).(*Block)),
                //#line 765 GJavaParser.g
                )
                break
            }
            //
            // Rule 332:  Primary ::= PrimaryNoNewArray
            //
            case 332:
                break
            //
            // Rule 333:  Primary ::= ArrayCreationExpression
            //
            case 333:
                break
            //
            // Rule 334:  PrimaryNoNewArray ::= Literal
            //
            case 334:
                break
            //
            // Rule 335:  PrimaryNoNewArray ::= Type . class
            //
            case 335: {
               //#line 781 "GJavaParser.g"
                my.SetResult(
                    //#line 781 GJavaParser.g
                    NewPrimaryNoNewArray0(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 781 GJavaParser.g
                                          my.GetRhsSym(1).(IType),
                                          //#line 781 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 781 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 781 GJavaParser.g
                )
                break
            }
            //
            // Rule 336:  PrimaryNoNewArray ::= void . class
            //
            case 336: {
               //#line 782 "GJavaParser.g"
                my.SetResult(
                    //#line 782 GJavaParser.g
                    NewPrimaryNoNewArray1(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 782 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(1)),
                                          //#line 782 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 782 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 782 GJavaParser.g
                )
                break
            }
            //
            // Rule 337:  PrimaryNoNewArray ::= this
            //
            case 337: {
               //#line 783 "GJavaParser.g"
                my.SetResult(
                    //#line 783 GJavaParser.g
                    NewPrimaryNoNewArray2(my.GetRhsIToken(1)),
                //#line 783 GJavaParser.g
                )
                break
            }
            //
            // Rule 338:  PrimaryNoNewArray ::= ClassName . this
            //
            case 338: {
               //#line 784 "GJavaParser.g"
                my.SetResult(
                    //#line 784 GJavaParser.g
                    NewPrimaryNoNewArray3(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 784 GJavaParser.g
                                          my.GetRhsSym(1).(IClassName),
                                          //#line 784 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(2)),
                                          //#line 784 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 784 GJavaParser.g
                )
                break
            }
            //
            // Rule 339:  PrimaryNoNewArray ::= ( Expression )
            //
            case 339: {
               //#line 785 "GJavaParser.g"
                my.SetResult(
                    //#line 785 GJavaParser.g
                    NewPrimaryNoNewArray4(my.GetLeftIToken(), my.GetRightIToken(),
                                          //#line 785 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(1)),
                                          //#line 785 GJavaParser.g
                                          my.GetRhsSym(2).(IExpression),
                                          //#line 785 GJavaParser.g
                                          NewAstToken(my.GetRhsIToken(3))),
                //#line 785 GJavaParser.g
                )
                break
            }
            //
            // Rule 340:  PrimaryNoNewArray ::= ClassInstanceCreationExpression
            //
            case 340:
                break
            //
            // Rule 341:  PrimaryNoNewArray ::= FieldAccess
            //
            case 341:
                break
            //
            // Rule 342:  PrimaryNoNewArray ::= MethodInvocation
            //
            case 342:
                break
            //
            // Rule 343:  PrimaryNoNewArray ::= ArrayAccess
            //
            case 343:
                break
            //
            // Rule 344:  Literal ::= IntegerLiteral
            //
            case 344: {
               //#line 791 "GJavaParser.g"
                my.SetResult(
                    //#line 791 GJavaParser.g
                    NewLiteral0(my.GetRhsIToken(1)),
                //#line 791 GJavaParser.g
                )
                break
            }
            //
            // Rule 345:  Literal ::= LongLiteral
            //
            case 345: {
               //#line 792 "GJavaParser.g"
                my.SetResult(
                    //#line 792 GJavaParser.g
                    NewLiteral1(my.GetRhsIToken(1)),
                //#line 792 GJavaParser.g
                )
                break
            }
            //
            // Rule 346:  Literal ::= FloatingPointLiteral
            //
            case 346: {
               //#line 793 "GJavaParser.g"
                my.SetResult(
                    //#line 793 GJavaParser.g
                    NewLiteral2(my.GetRhsIToken(1)),
                //#line 793 GJavaParser.g
                )
                break
            }
            //
            // Rule 347:  Literal ::= DoubleLiteral
            //
            case 347: {
               //#line 794 "GJavaParser.g"
                my.SetResult(
                    //#line 794 GJavaParser.g
                    NewLiteral3(my.GetRhsIToken(1)),
                //#line 794 GJavaParser.g
                )
                break
            }
            //
            // Rule 348:  Literal ::= BooleanLiteral
            //
            case 348:
                break
            //
            // Rule 349:  Literal ::= CharacterLiteral
            //
            case 349: {
               //#line 796 "GJavaParser.g"
                my.SetResult(
                    //#line 796 GJavaParser.g
                    NewLiteral4(my.GetRhsIToken(1)),
                //#line 796 GJavaParser.g
                )
                break
            }
            //
            // Rule 350:  Literal ::= StringLiteral
            //
            case 350: {
               //#line 797 "GJavaParser.g"
                my.SetResult(
                    //#line 797 GJavaParser.g
                    NewLiteral5(my.GetRhsIToken(1)),
                //#line 797 GJavaParser.g
                )
                break
            }
            //
            // Rule 351:  Literal ::= null
            //
            case 351: {
               //#line 798 "GJavaParser.g"
                my.SetResult(
                    //#line 798 GJavaParser.g
                    NewLiteral6(my.GetRhsIToken(1)),
                //#line 798 GJavaParser.g
                )
                break
            }
            //
            // Rule 352:  BooleanLiteral ::= true
            //
            case 352: {
               //#line 800 "GJavaParser.g"
                my.SetResult(
                    //#line 800 GJavaParser.g
                    NewBooleanLiteral0(my.GetRhsIToken(1)),
                //#line 800 GJavaParser.g
                )
                break
            }
            //
            // Rule 353:  BooleanLiteral ::= false
            //
            case 353: {
               //#line 801 "GJavaParser.g"
                my.SetResult(
                    //#line 801 GJavaParser.g
                    NewBooleanLiteral1(my.GetRhsIToken(1)),
                //#line 801 GJavaParser.g
                )
                break
            }
            //
            // Rule 354:  ClassInstanceCreationExpression ::= new TypeArgumentsopt ClassOrInterfaceType TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
            //
            case 354: {
               //#line 808 "GJavaParser.g"
                my.SetResult(
                    //#line 808 GJavaParser.g
                    NewClassInstanceCreationExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                                        //#line 808 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(1)),
                                                        //#line 808 GJavaParser.g
                                                        AnyCastToTypeArguments(my.GetRhsSym(2)),
                                                        //#line 808 GJavaParser.g
                                                        my.GetRhsSym(3).(*ClassType),
                                                        //#line 808 GJavaParser.g
                                                        AnyCastToTypeArguments(my.GetRhsSym(4)),
                                                        //#line 808 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(5)),
                                                        //#line 808 GJavaParser.g
                                                        AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                                        //#line 808 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(7)),
                                                        //#line 808 GJavaParser.g
                                                        AnyCastToClassBody(my.GetRhsSym(8))),
                //#line 808 GJavaParser.g
                )
                break
            }
            //
            // Rule 355:  ClassInstanceCreationExpression ::= Primary . new TypeArgumentsopt identifier TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
            //
            case 355: {
               //#line 809 "GJavaParser.g"
                my.SetResult(
                    //#line 809 GJavaParser.g
                    NewClassInstanceCreationExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                                        //#line 809 GJavaParser.g
                                                        my.GetRhsSym(1).(IPrimary),
                                                        //#line 809 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(2)),
                                                        //#line 809 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(3)),
                                                        //#line 809 GJavaParser.g
                                                        AnyCastToTypeArguments(my.GetRhsSym(4)),
                                                        //#line 809 GJavaParser.g
                                                        my.GetRhsSym(5).(*identifier),
                                                        //#line 809 GJavaParser.g
                                                        AnyCastToTypeArguments(my.GetRhsSym(6)),
                                                        //#line 809 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(7)),
                                                        //#line 809 GJavaParser.g
                                                        AnyCastToIArgumentListopt(my.GetRhsSym(8)),
                                                        //#line 809 GJavaParser.g
                                                        NewAstToken(my.GetRhsIToken(9)),
                                                        //#line 809 GJavaParser.g
                                                        AnyCastToClassBody(my.GetRhsSym(10))),
                //#line 809 GJavaParser.g
                )
                break
            }
            //
            // Rule 356:  ArgumentList ::= Expression
            //
            case 356:
                break
            //
            // Rule 357:  ArgumentList ::= ArgumentList , Expression
            //
            case 357: {
               //#line 813 "GJavaParser.g"
                my.SetResult(
                    //#line 813 GJavaParser.g
                    NewArgumentList(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 813 GJavaParser.g
                                    my.GetRhsSym(1).(IArgumentList),
                                    //#line 813 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 813 GJavaParser.g
                                    my.GetRhsSym(3).(IExpression)),
                //#line 813 GJavaParser.g
                )
                break
            }
            //
            // Rule 358:  ArrayCreationExpression ::= new PrimitiveType DimExprs Dimsopt
            //
            case 358: {
               //#line 823 "GJavaParser.g"
                my.SetResult(
                    //#line 823 GJavaParser.g
                    NewArrayCreationExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 823 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(1)),
                                                //#line 823 GJavaParser.g
                                                my.GetRhsSym(2).(IPrimitiveType),
                                                //#line 823 GJavaParser.g
                                                my.GetRhsSym(3).(IDimExprs),
                                                //#line 823 GJavaParser.g
                                                AnyCastToIDimsopt(my.GetRhsSym(4))),
                //#line 823 GJavaParser.g
                )
                break
            }
            //
            // Rule 359:  ArrayCreationExpression ::= new ClassOrInterfaceType DimExprs Dimsopt
            //
            case 359: {
               //#line 824 "GJavaParser.g"
                my.SetResult(
                    //#line 824 GJavaParser.g
                    NewArrayCreationExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 824 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(1)),
                                                //#line 824 GJavaParser.g
                                                my.GetRhsSym(2).(*ClassType),
                                                //#line 824 GJavaParser.g
                                                my.GetRhsSym(3).(IDimExprs),
                                                //#line 824 GJavaParser.g
                                                AnyCastToIDimsopt(my.GetRhsSym(4))),
                //#line 824 GJavaParser.g
                )
                break
            }
            //
            // Rule 360:  ArrayCreationExpression ::= new PrimitiveType Dims ArrayInitializer
            //
            case 360: {
               //#line 825 "GJavaParser.g"
                my.SetResult(
                    //#line 825 GJavaParser.g
                    NewArrayCreationExpression2(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 825 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(1)),
                                                //#line 825 GJavaParser.g
                                                my.GetRhsSym(2).(IPrimitiveType),
                                                //#line 825 GJavaParser.g
                                                my.GetRhsSym(3).(IDims),
                                                //#line 825 GJavaParser.g
                                                my.GetRhsSym(4).(*ArrayInitializer)),
                //#line 825 GJavaParser.g
                )
                break
            }
            //
            // Rule 361:  ArrayCreationExpression ::= new ClassOrInterfaceType Dims ArrayInitializer
            //
            case 361: {
               //#line 826 "GJavaParser.g"
                my.SetResult(
                    //#line 826 GJavaParser.g
                    NewArrayCreationExpression3(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 826 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(1)),
                                                //#line 826 GJavaParser.g
                                                my.GetRhsSym(2).(*ClassType),
                                                //#line 826 GJavaParser.g
                                                my.GetRhsSym(3).(IDims),
                                                //#line 826 GJavaParser.g
                                                my.GetRhsSym(4).(*ArrayInitializer)),
                //#line 826 GJavaParser.g
                )
                break
            }
            //
            // Rule 362:  DimExprs ::= DimExpr
            //
            case 362:
                break
            //
            // Rule 363:  DimExprs ::= DimExprs DimExpr
            //
            case 363: {
               //#line 829 "GJavaParser.g"
                my.SetResult(
                    //#line 829 GJavaParser.g
                    NewDimExprs(my.GetLeftIToken(), my.GetRightIToken(),
                                //#line 829 GJavaParser.g
                                my.GetRhsSym(1).(IDimExprs),
                                //#line 829 GJavaParser.g
                                my.GetRhsSym(2).(*DimExpr)),
                //#line 829 GJavaParser.g
                )
                break
            }
            //
            // Rule 364:  DimExpr ::= [ Expression ]
            //
            case 364: {
               //#line 831 "GJavaParser.g"
                my.SetResult(
                    //#line 831 GJavaParser.g
                    NewDimExpr(my.GetLeftIToken(), my.GetRightIToken(),
                               //#line 831 GJavaParser.g
                               NewAstToken(my.GetRhsIToken(1)),
                               //#line 831 GJavaParser.g
                               my.GetRhsSym(2).(IExpression),
                               //#line 831 GJavaParser.g
                               NewAstToken(my.GetRhsIToken(3))),
                //#line 831 GJavaParser.g
                )
                break
            }
            //
            // Rule 365:  Dims ::= [ ]
            //
            case 365: {
               //#line 833 "GJavaParser.g"
                my.SetResult(
                    //#line 833 GJavaParser.g
                    NewDims0(my.GetLeftIToken(), my.GetRightIToken(),
                             //#line 833 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(1)),
                             //#line 833 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(2))),
                //#line 833 GJavaParser.g
                )
                break
            }
            //
            // Rule 366:  Dims ::= Dims [ ]
            //
            case 366: {
               //#line 834 "GJavaParser.g"
                my.SetResult(
                    //#line 834 GJavaParser.g
                    NewDims1(my.GetLeftIToken(), my.GetRightIToken(),
                             //#line 834 GJavaParser.g
                             my.GetRhsSym(1).(IDims),
                             //#line 834 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(2)),
                             //#line 834 GJavaParser.g
                             NewAstToken(my.GetRhsIToken(3))),
                //#line 834 GJavaParser.g
                )
                break
            }
            //
            // Rule 367:  FieldAccess ::= Primary . identifier
            //
            case 367: {
               //#line 836 "GJavaParser.g"
                my.SetResult(
                    //#line 836 GJavaParser.g
                    NewFieldAccess0(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 836 GJavaParser.g
                                    my.GetRhsSym(1).(IPrimary),
                                    //#line 836 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 836 GJavaParser.g
                                    my.GetRhsSym(3).(*identifier)),
                //#line 836 GJavaParser.g
                )
                break
            }
            //
            // Rule 368:  FieldAccess ::= super . identifier
            //
            case 368: {
               //#line 837 "GJavaParser.g"
                my.SetResult(
                    //#line 837 GJavaParser.g
                    NewFieldAccess1(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 837 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(1)),
                                    //#line 837 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 837 GJavaParser.g
                                    my.GetRhsSym(3).(*identifier)),
                //#line 837 GJavaParser.g
                )
                break
            }
            //
            // Rule 369:  FieldAccess ::= ClassName . super . identifier
            //
            case 369: {
               //#line 838 "GJavaParser.g"
                my.SetResult(
                    //#line 838 GJavaParser.g
                    NewFieldAccess2(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 838 GJavaParser.g
                                    my.GetRhsSym(1).(IClassName),
                                    //#line 838 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 838 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(3)),
                                    //#line 838 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(4)),
                                    //#line 838 GJavaParser.g
                                    my.GetRhsSym(5).(*identifier)),
                //#line 838 GJavaParser.g
                )
                break
            }
            //
            // Rule 370:  MethodInvocation ::= MethodName ( ArgumentListopt )
            //
            case 370: {
               //#line 840 "GJavaParser.g"
                my.SetResult(
                    //#line 840 GJavaParser.g
                    NewMethodInvocation0(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 840 GJavaParser.g
                                         my.GetRhsSym(1).(IMethodName),
                                         //#line 840 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 840 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(3)),
                                         //#line 840 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(4))),
                //#line 840 GJavaParser.g
                )
                break
            }
            //
            // Rule 371:  MethodInvocation ::= Primary . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 371: {
               //#line 841 "GJavaParser.g"
                my.SetResult(
                    //#line 841 GJavaParser.g
                    NewMethodInvocation1(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 841 GJavaParser.g
                                         my.GetRhsSym(1).(IPrimary),
                                         //#line 841 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 841 GJavaParser.g
                                         AnyCastToTypeArguments(my.GetRhsSym(3)),
                                         //#line 841 GJavaParser.g
                                         my.GetRhsSym(4).(*identifier),
                                         //#line 841 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(5)),
                                         //#line 841 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                         //#line 841 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(7))),
                //#line 841 GJavaParser.g
                )
                break
            }
            //
            // Rule 372:  MethodInvocation ::= super . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 372: {
               //#line 842 "GJavaParser.g"
                my.SetResult(
                    //#line 842 GJavaParser.g
                    NewMethodInvocation2(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 842 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(1)),
                                         //#line 842 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 842 GJavaParser.g
                                         AnyCastToTypeArguments(my.GetRhsSym(3)),
                                         //#line 842 GJavaParser.g
                                         my.GetRhsSym(4).(*identifier),
                                         //#line 842 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(5)),
                                         //#line 842 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                         //#line 842 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(7))),
                //#line 842 GJavaParser.g
                )
                break
            }
            //
            // Rule 373:  MethodInvocation ::= ClassName . super . TypeArgumentsopt identifier ( ArgumentListopt )
            //
            case 373: {
               //#line 843 "GJavaParser.g"
                my.SetResult(
                    //#line 843 GJavaParser.g
                    NewMethodInvocation3(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 843 GJavaParser.g
                                         my.GetRhsSym(1).(IClassName),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(3)),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(4)),
                                         //#line 843 GJavaParser.g
                                         AnyCastToTypeArguments(my.GetRhsSym(5)),
                                         //#line 843 GJavaParser.g
                                         my.GetRhsSym(6).(*identifier),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(7)),
                                         //#line 843 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(8)),
                                         //#line 843 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(9))),
                //#line 843 GJavaParser.g
                )
                break
            }
            //
            // Rule 374:  MethodInvocation ::= TypeName . TypeArguments identifier ( ArgumentListopt )
            //
            case 374: {
               //#line 844 "GJavaParser.g"
                my.SetResult(
                    //#line 844 GJavaParser.g
                    NewMethodInvocation4(my.GetLeftIToken(), my.GetRightIToken(),
                                         //#line 844 GJavaParser.g
                                         my.GetRhsSym(1).(ITypeName),
                                         //#line 844 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(2)),
                                         //#line 844 GJavaParser.g
                                         my.GetRhsSym(3).(*TypeArguments),
                                         //#line 844 GJavaParser.g
                                         my.GetRhsSym(4).(*identifier),
                                         //#line 844 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(5)),
                                         //#line 844 GJavaParser.g
                                         AnyCastToIArgumentListopt(my.GetRhsSym(6)),
                                         //#line 844 GJavaParser.g
                                         NewAstToken(my.GetRhsIToken(7))),
                //#line 844 GJavaParser.g
                )
                break
            }
            //
            // Rule 375:  ArrayAccess ::= ExpressionName [ Expression ]
            //
            case 375: {
               //#line 852 "GJavaParser.g"
                my.SetResult(
                    //#line 852 GJavaParser.g
                    NewArrayAccess0(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 852 GJavaParser.g
                                    my.GetRhsSym(1).(IExpressionName),
                                    //#line 852 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 852 GJavaParser.g
                                    my.GetRhsSym(3).(IExpression),
                                    //#line 852 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(4))),
                //#line 852 GJavaParser.g
                )
                break
            }
            //
            // Rule 376:  ArrayAccess ::= PrimaryNoNewArray [ Expression ]
            //
            case 376: {
               //#line 853 "GJavaParser.g"
                my.SetResult(
                    //#line 853 GJavaParser.g
                    NewArrayAccess1(my.GetLeftIToken(), my.GetRightIToken(),
                                    //#line 853 GJavaParser.g
                                    my.GetRhsSym(1).(IPrimaryNoNewArray),
                                    //#line 853 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(2)),
                                    //#line 853 GJavaParser.g
                                    my.GetRhsSym(3).(IExpression),
                                    //#line 853 GJavaParser.g
                                    NewAstToken(my.GetRhsIToken(4))),
                //#line 853 GJavaParser.g
                )
                break
            }
            //
            // Rule 377:  PostfixExpression ::= Primary
            //
            case 377:
                break
            //
            // Rule 378:  PostfixExpression ::= ExpressionName
            //
            case 378:
                break
            //
            // Rule 379:  PostfixExpression ::= PostIncrementExpression
            //
            case 379:
                break
            //
            // Rule 380:  PostfixExpression ::= PostDecrementExpression
            //
            case 380:
                break
            //
            // Rule 381:  PostIncrementExpression ::= PostfixExpression ++
            //
            case 381: {
               //#line 860 "GJavaParser.g"
                my.SetResult(
                    //#line 860 GJavaParser.g
                    NewPostIncrementExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 860 GJavaParser.g
                                               my.GetRhsSym(1).(IPostfixExpression),
                                               //#line 860 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2))),
                //#line 860 GJavaParser.g
                )
                break
            }
            //
            // Rule 382:  PostDecrementExpression ::= PostfixExpression --
            //
            case 382: {
               //#line 862 "GJavaParser.g"
                my.SetResult(
                    //#line 862 GJavaParser.g
                    NewPostDecrementExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 862 GJavaParser.g
                                               my.GetRhsSym(1).(IPostfixExpression),
                                               //#line 862 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2))),
                //#line 862 GJavaParser.g
                )
                break
            }
            //
            // Rule 383:  UnaryExpression ::= PreIncrementExpression
            //
            case 383:
                break
            //
            // Rule 384:  UnaryExpression ::= PreDecrementExpression
            //
            case 384:
                break
            //
            // Rule 385:  UnaryExpression ::= + UnaryExpression
            //
            case 385: {
               //#line 866 "GJavaParser.g"
                my.SetResult(
                    //#line 866 GJavaParser.g
                    NewUnaryExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 866 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 866 GJavaParser.g
                                        my.GetRhsSym(2).(IUnaryExpression)),
                //#line 866 GJavaParser.g
                )
                break
            }
            //
            // Rule 386:  UnaryExpression ::= - UnaryExpression
            //
            case 386: {
               //#line 867 "GJavaParser.g"
                my.SetResult(
                    //#line 867 GJavaParser.g
                    NewUnaryExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 867 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(1)),
                                        //#line 867 GJavaParser.g
                                        my.GetRhsSym(2).(IUnaryExpression)),
                //#line 867 GJavaParser.g
                )
                break
            }
            //
            // Rule 387:  UnaryExpression ::= UnaryExpressionNotPlusMinus
            //
            case 387:
                break
            //
            // Rule 388:  PreIncrementExpression ::= ++ UnaryExpression
            //
            case 388: {
               //#line 870 "GJavaParser.g"
                my.SetResult(
                    //#line 870 GJavaParser.g
                    NewPreIncrementExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 870 GJavaParser.g
                                              NewAstToken(my.GetRhsIToken(1)),
                                              //#line 870 GJavaParser.g
                                              my.GetRhsSym(2).(IUnaryExpression)),
                //#line 870 GJavaParser.g
                )
                break
            }
            //
            // Rule 389:  PreDecrementExpression ::= -- UnaryExpression
            //
            case 389: {
               //#line 872 "GJavaParser.g"
                my.SetResult(
                    //#line 872 GJavaParser.g
                    NewPreDecrementExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                              //#line 872 GJavaParser.g
                                              NewAstToken(my.GetRhsIToken(1)),
                                              //#line 872 GJavaParser.g
                                              my.GetRhsSym(2).(IUnaryExpression)),
                //#line 872 GJavaParser.g
                )
                break
            }
            //
            // Rule 390:  UnaryExpressionNotPlusMinus ::= PostfixExpression
            //
            case 390:
                break
            //
            // Rule 391:  UnaryExpressionNotPlusMinus ::= ~ UnaryExpression
            //
            case 391: {
               //#line 875 "GJavaParser.g"
                my.SetResult(
                    //#line 875 GJavaParser.g
                    NewUnaryExpressionNotPlusMinus0(my.GetLeftIToken(), my.GetRightIToken(),
                                                    //#line 875 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(1)),
                                                    //#line 875 GJavaParser.g
                                                    my.GetRhsSym(2).(IUnaryExpression)),
                //#line 875 GJavaParser.g
                )
                break
            }
            //
            // Rule 392:  UnaryExpressionNotPlusMinus ::= ! UnaryExpression
            //
            case 392: {
               //#line 876 "GJavaParser.g"
                my.SetResult(
                    //#line 876 GJavaParser.g
                    NewUnaryExpressionNotPlusMinus1(my.GetLeftIToken(), my.GetRightIToken(),
                                                    //#line 876 GJavaParser.g
                                                    NewAstToken(my.GetRhsIToken(1)),
                                                    //#line 876 GJavaParser.g
                                                    my.GetRhsSym(2).(IUnaryExpression)),
                //#line 876 GJavaParser.g
                )
                break
            }
            //
            // Rule 393:  UnaryExpressionNotPlusMinus ::= CastExpression
            //
            case 393:
                break
            //
            // Rule 394:  CastExpression ::= ( PrimitiveType Dimsopt ) UnaryExpression
            //
            case 394: {
               //#line 879 "GJavaParser.g"
                my.SetResult(
                    //#line 879 GJavaParser.g
                    NewCastExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 879 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 879 GJavaParser.g
                                       my.GetRhsSym(2).(IPrimitiveType),
                                       //#line 879 GJavaParser.g
                                       AnyCastToIDimsopt(my.GetRhsSym(3)),
                                       //#line 879 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(4)),
                                       //#line 879 GJavaParser.g
                                       my.GetRhsSym(5).(IUnaryExpression)),
                //#line 879 GJavaParser.g
                )
                break
            }
            //
            // Rule 395:  CastExpression ::= ( ReferenceType ) UnaryExpressionNotPlusMinus
            //
            case 395: {
               //#line 880 "GJavaParser.g"
                my.SetResult(
                    //#line 880 GJavaParser.g
                    NewCastExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                       //#line 880 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(1)),
                                       //#line 880 GJavaParser.g
                                       my.GetRhsSym(2).(IReferenceType),
                                       //#line 880 GJavaParser.g
                                       NewAstToken(my.GetRhsIToken(3)),
                                       //#line 880 GJavaParser.g
                                       my.GetRhsSym(4).(IUnaryExpressionNotPlusMinus)),
                //#line 880 GJavaParser.g
                )
                break
            }
            //
            // Rule 396:  MultiplicativeExpression ::= UnaryExpression
            //
            case 396:
                break
            //
            // Rule 397:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
            //
            case 397: {
               //#line 883 "GJavaParser.g"
                my.SetResult(
                    //#line 883 GJavaParser.g
                    NewMultiplicativeExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 883 GJavaParser.g
                                                 my.GetRhsSym(1).(IMultiplicativeExpression),
                                                 //#line 883 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 883 GJavaParser.g
                                                 my.GetRhsSym(3).(IUnaryExpression)),
                //#line 883 GJavaParser.g
                )
                break
            }
            //
            // Rule 398:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
            //
            case 398: {
               //#line 884 "GJavaParser.g"
                my.SetResult(
                    //#line 884 GJavaParser.g
                    NewMultiplicativeExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 884 GJavaParser.g
                                                 my.GetRhsSym(1).(IMultiplicativeExpression),
                                                 //#line 884 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 884 GJavaParser.g
                                                 my.GetRhsSym(3).(IUnaryExpression)),
                //#line 884 GJavaParser.g
                )
                break
            }
            //
            // Rule 399:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
            //
            case 399: {
               //#line 885 "GJavaParser.g"
                my.SetResult(
                    //#line 885 GJavaParser.g
                    NewMultiplicativeExpression2(my.GetLeftIToken(), my.GetRightIToken(),
                                                 //#line 885 GJavaParser.g
                                                 my.GetRhsSym(1).(IMultiplicativeExpression),
                                                 //#line 885 GJavaParser.g
                                                 NewAstToken(my.GetRhsIToken(2)),
                                                 //#line 885 GJavaParser.g
                                                 my.GetRhsSym(3).(IUnaryExpression)),
                //#line 885 GJavaParser.g
                )
                break
            }
            //
            // Rule 400:  AdditiveExpression ::= MultiplicativeExpression
            //
            case 400:
                break
            //
            // Rule 401:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
            //
            case 401: {
               //#line 888 "GJavaParser.g"
                my.SetResult(
                    //#line 888 GJavaParser.g
                    NewAdditiveExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 888 GJavaParser.g
                                           my.GetRhsSym(1).(IAdditiveExpression),
                                           //#line 888 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 888 GJavaParser.g
                                           my.GetRhsSym(3).(IMultiplicativeExpression)),
                //#line 888 GJavaParser.g
                )
                break
            }
            //
            // Rule 402:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
            //
            case 402: {
               //#line 889 "GJavaParser.g"
                my.SetResult(
                    //#line 889 GJavaParser.g
                    NewAdditiveExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 889 GJavaParser.g
                                           my.GetRhsSym(1).(IAdditiveExpression),
                                           //#line 889 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 889 GJavaParser.g
                                           my.GetRhsSym(3).(IMultiplicativeExpression)),
                //#line 889 GJavaParser.g
                )
                break
            }
            //
            // Rule 403:  ShiftExpression ::= AdditiveExpression
            //
            case 403:
                break
            //
            // Rule 404:  ShiftExpression ::= ShiftExpression << AdditiveExpression
            //
            case 404: {
               //#line 892 "GJavaParser.g"
                my.SetResult(
                    //#line 892 GJavaParser.g
                    NewShiftExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 892 GJavaParser.g
                                        my.GetRhsSym(1).(IShiftExpression),
                                        //#line 892 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 892 GJavaParser.g
                                        my.GetRhsSym(3).(IAdditiveExpression)),
                //#line 892 GJavaParser.g
                )
                break
            }
            //
            // Rule 405:  ShiftExpression ::= ShiftExpression > > AdditiveExpression
            //
            case 405: {
               //#line 893 "GJavaParser.g"
                my.SetResult(
                    //#line 893 GJavaParser.g
                    NewShiftExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 893 GJavaParser.g
                                        my.GetRhsSym(1).(IShiftExpression),
                                        //#line 893 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 893 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3)),
                                        //#line 893 GJavaParser.g
                                        my.GetRhsSym(4).(IAdditiveExpression)),
                //#line 893 GJavaParser.g
                )
                break
            }
            //
            // Rule 406:  ShiftExpression ::= ShiftExpression > > > AdditiveExpression
            //
            case 406: {
               //#line 894 "GJavaParser.g"
                my.SetResult(
                    //#line 894 GJavaParser.g
                    NewShiftExpression2(my.GetLeftIToken(), my.GetRightIToken(),
                                        //#line 894 GJavaParser.g
                                        my.GetRhsSym(1).(IShiftExpression),
                                        //#line 894 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(2)),
                                        //#line 894 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(3)),
                                        //#line 894 GJavaParser.g
                                        NewAstToken(my.GetRhsIToken(4)),
                                        //#line 894 GJavaParser.g
                                        my.GetRhsSym(5).(IAdditiveExpression)),
                //#line 894 GJavaParser.g
                )
                break
            }
            //
            // Rule 407:  RelationalExpression ::= ShiftExpression
            //
            case 407:
                break
            //
            // Rule 408:  RelationalExpression ::= RelationalExpression < ShiftExpression
            //
            case 408: {
               //#line 897 "GJavaParser.g"
                my.SetResult(
                    //#line 897 GJavaParser.g
                    NewRelationalExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 897 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 897 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 897 GJavaParser.g
                                             my.GetRhsSym(3).(IShiftExpression)),
                //#line 897 GJavaParser.g
                )
                break
            }
            //
            // Rule 409:  RelationalExpression ::= RelationalExpression > ShiftExpression
            //
            case 409: {
               //#line 898 "GJavaParser.g"
                my.SetResult(
                    //#line 898 GJavaParser.g
                    NewRelationalExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 898 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 898 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 898 GJavaParser.g
                                             my.GetRhsSym(3).(IShiftExpression)),
                //#line 898 GJavaParser.g
                )
                break
            }
            //
            // Rule 410:  RelationalExpression ::= RelationalExpression <= ShiftExpression
            //
            case 410: {
               //#line 899 "GJavaParser.g"
                my.SetResult(
                    //#line 899 GJavaParser.g
                    NewRelationalExpression2(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 899 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 899 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 899 GJavaParser.g
                                             my.GetRhsSym(3).(IShiftExpression)),
                //#line 899 GJavaParser.g
                )
                break
            }
            //
            // Rule 411:  RelationalExpression ::= RelationalExpression > = ShiftExpression
            //
            case 411: {
               //#line 900 "GJavaParser.g"
                my.SetResult(
                    //#line 900 GJavaParser.g
                    NewRelationalExpression3(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 900 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 900 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 900 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(3)),
                                             //#line 900 GJavaParser.g
                                             my.GetRhsSym(4).(IShiftExpression)),
                //#line 900 GJavaParser.g
                )
                break
            }
            //
            // Rule 412:  RelationalExpression ::= RelationalExpression instanceof ReferenceType
            //
            case 412: {
               //#line 901 "GJavaParser.g"
                my.SetResult(
                    //#line 901 GJavaParser.g
                    NewRelationalExpression4(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 901 GJavaParser.g
                                             my.GetRhsSym(1).(IRelationalExpression),
                                             //#line 901 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 901 GJavaParser.g
                                             my.GetRhsSym(3).(IReferenceType)),
                //#line 901 GJavaParser.g
                )
                break
            }
            //
            // Rule 413:  EqualityExpression ::= RelationalExpression
            //
            case 413:
                break
            //
            // Rule 414:  EqualityExpression ::= EqualityExpression == RelationalExpression
            //
            case 414: {
               //#line 904 "GJavaParser.g"
                my.SetResult(
                    //#line 904 GJavaParser.g
                    NewEqualityExpression0(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 904 GJavaParser.g
                                           my.GetRhsSym(1).(IEqualityExpression),
                                           //#line 904 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 904 GJavaParser.g
                                           my.GetRhsSym(3).(IRelationalExpression)),
                //#line 904 GJavaParser.g
                )
                break
            }
            //
            // Rule 415:  EqualityExpression ::= EqualityExpression != RelationalExpression
            //
            case 415: {
               //#line 905 "GJavaParser.g"
                my.SetResult(
                    //#line 905 GJavaParser.g
                    NewEqualityExpression1(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 905 GJavaParser.g
                                           my.GetRhsSym(1).(IEqualityExpression),
                                           //#line 905 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 905 GJavaParser.g
                                           my.GetRhsSym(3).(IRelationalExpression)),
                //#line 905 GJavaParser.g
                )
                break
            }
            //
            // Rule 416:  AndExpression ::= EqualityExpression
            //
            case 416:
                break
            //
            // Rule 417:  AndExpression ::= AndExpression & EqualityExpression
            //
            case 417: {
               //#line 908 "GJavaParser.g"
                my.SetResult(
                    //#line 908 GJavaParser.g
                    NewAndExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                     //#line 908 GJavaParser.g
                                     my.GetRhsSym(1).(IAndExpression),
                                     //#line 908 GJavaParser.g
                                     NewAstToken(my.GetRhsIToken(2)),
                                     //#line 908 GJavaParser.g
                                     my.GetRhsSym(3).(IEqualityExpression)),
                //#line 908 GJavaParser.g
                )
                break
            }
            //
            // Rule 418:  ExclusiveOrExpression ::= AndExpression
            //
            case 418:
                break
            //
            // Rule 419:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
            //
            case 419: {
               //#line 911 "GJavaParser.g"
                my.SetResult(
                    //#line 911 GJavaParser.g
                    NewExclusiveOrExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 911 GJavaParser.g
                                             my.GetRhsSym(1).(IExclusiveOrExpression),
                                             //#line 911 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 911 GJavaParser.g
                                             my.GetRhsSym(3).(IAndExpression)),
                //#line 911 GJavaParser.g
                )
                break
            }
            //
            // Rule 420:  InclusiveOrExpression ::= ExclusiveOrExpression
            //
            case 420:
                break
            //
            // Rule 421:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
            //
            case 421: {
               //#line 914 "GJavaParser.g"
                my.SetResult(
                    //#line 914 GJavaParser.g
                    NewInclusiveOrExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 914 GJavaParser.g
                                             my.GetRhsSym(1).(IInclusiveOrExpression),
                                             //#line 914 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 914 GJavaParser.g
                                             my.GetRhsSym(3).(IExclusiveOrExpression)),
                //#line 914 GJavaParser.g
                )
                break
            }
            //
            // Rule 422:  ConditionalAndExpression ::= InclusiveOrExpression
            //
            case 422:
                break
            //
            // Rule 423:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
            //
            case 423: {
               //#line 917 "GJavaParser.g"
                my.SetResult(
                    //#line 917 GJavaParser.g
                    NewConditionalAndExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                                //#line 917 GJavaParser.g
                                                my.GetRhsSym(1).(IConditionalAndExpression),
                                                //#line 917 GJavaParser.g
                                                NewAstToken(my.GetRhsIToken(2)),
                                                //#line 917 GJavaParser.g
                                                my.GetRhsSym(3).(IInclusiveOrExpression)),
                //#line 917 GJavaParser.g
                )
                break
            }
            //
            // Rule 424:  ConditionalOrExpression ::= ConditionalAndExpression
            //
            case 424:
                break
            //
            // Rule 425:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
            //
            case 425: {
               //#line 920 "GJavaParser.g"
                my.SetResult(
                    //#line 920 GJavaParser.g
                    NewConditionalOrExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                               //#line 920 GJavaParser.g
                                               my.GetRhsSym(1).(IConditionalOrExpression),
                                               //#line 920 GJavaParser.g
                                               NewAstToken(my.GetRhsIToken(2)),
                                               //#line 920 GJavaParser.g
                                               my.GetRhsSym(3).(IConditionalAndExpression)),
                //#line 920 GJavaParser.g
                )
                break
            }
            //
            // Rule 426:  ConditionalExpression ::= ConditionalOrExpression
            //
            case 426:
                break
            //
            // Rule 427:  ConditionalExpression ::= ConditionalOrExpression ? Expression : ConditionalExpression
            //
            case 427: {
               //#line 923 "GJavaParser.g"
                my.SetResult(
                    //#line 923 GJavaParser.g
                    NewConditionalExpression(my.GetLeftIToken(), my.GetRightIToken(),
                                             //#line 923 GJavaParser.g
                                             my.GetRhsSym(1).(IConditionalOrExpression),
                                             //#line 923 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(2)),
                                             //#line 923 GJavaParser.g
                                             my.GetRhsSym(3).(IExpression),
                                             //#line 923 GJavaParser.g
                                             NewAstToken(my.GetRhsIToken(4)),
                                             //#line 923 GJavaParser.g
                                             my.GetRhsSym(5).(IConditionalExpression)),
                //#line 923 GJavaParser.g
                )
                break
            }
            //
            // Rule 428:  AssignmentExpression ::= ConditionalExpression
            //
            case 428:
                break
            //
            // Rule 429:  AssignmentExpression ::= Assignment
            //
            case 429:
                break
            //
            // Rule 430:  Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
            //
            case 430: {
               //#line 928 "GJavaParser.g"
                my.SetResult(
                    //#line 928 GJavaParser.g
                    NewAssignment(my.GetLeftIToken(), my.GetRightIToken(),
                                  //#line 928 GJavaParser.g
                                  my.GetRhsSym(1).(ILeftHandSide),
                                  //#line 928 GJavaParser.g
                                  my.GetRhsSym(2).(IAssignmentOperator),
                                  //#line 928 GJavaParser.g
                                  my.GetRhsSym(3).(IAssignmentExpression)),
                //#line 928 GJavaParser.g
                )
                break
            }
            //
            // Rule 431:  LeftHandSide ::= ExpressionName
            //
            case 431:
                break
            //
            // Rule 432:  LeftHandSide ::= FieldAccess
            //
            case 432:
                break
            //
            // Rule 433:  LeftHandSide ::= ArrayAccess
            //
            case 433:
                break
            //
            // Rule 434:  AssignmentOperator ::= =
            //
            case 434: {
               //#line 934 "GJavaParser.g"
                my.SetResult(
                    //#line 934 GJavaParser.g
                    NewAssignmentOperator0(my.GetRhsIToken(1)),
                //#line 934 GJavaParser.g
                )
                break
            }
            //
            // Rule 435:  AssignmentOperator ::= *=
            //
            case 435: {
               //#line 935 "GJavaParser.g"
                my.SetResult(
                    //#line 935 GJavaParser.g
                    NewAssignmentOperator1(my.GetRhsIToken(1)),
                //#line 935 GJavaParser.g
                )
                break
            }
            //
            // Rule 436:  AssignmentOperator ::= /=
            //
            case 436: {
               //#line 936 "GJavaParser.g"
                my.SetResult(
                    //#line 936 GJavaParser.g
                    NewAssignmentOperator2(my.GetRhsIToken(1)),
                //#line 936 GJavaParser.g
                )
                break
            }
            //
            // Rule 437:  AssignmentOperator ::= %=
            //
            case 437: {
               //#line 937 "GJavaParser.g"
                my.SetResult(
                    //#line 937 GJavaParser.g
                    NewAssignmentOperator3(my.GetRhsIToken(1)),
                //#line 937 GJavaParser.g
                )
                break
            }
            //
            // Rule 438:  AssignmentOperator ::= +=
            //
            case 438: {
               //#line 938 "GJavaParser.g"
                my.SetResult(
                    //#line 938 GJavaParser.g
                    NewAssignmentOperator4(my.GetRhsIToken(1)),
                //#line 938 GJavaParser.g
                )
                break
            }
            //
            // Rule 439:  AssignmentOperator ::= -=
            //
            case 439: {
               //#line 939 "GJavaParser.g"
                my.SetResult(
                    //#line 939 GJavaParser.g
                    NewAssignmentOperator5(my.GetRhsIToken(1)),
                //#line 939 GJavaParser.g
                )
                break
            }
            //
            // Rule 440:  AssignmentOperator ::= <<=
            //
            case 440: {
               //#line 940 "GJavaParser.g"
                my.SetResult(
                    //#line 940 GJavaParser.g
                    NewAssignmentOperator6(my.GetRhsIToken(1)),
                //#line 940 GJavaParser.g
                )
                break
            }
            //
            // Rule 441:  AssignmentOperator ::= > > =
            //
            case 441: {
               //#line 941 "GJavaParser.g"
                my.SetResult(
                    //#line 941 GJavaParser.g
                    NewAssignmentOperator7(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 941 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(1)),
                                           //#line 941 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 941 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(3))),
                //#line 941 GJavaParser.g
                )
                break
            }
            //
            // Rule 442:  AssignmentOperator ::= > > > =
            //
            case 442: {
               //#line 942 "GJavaParser.g"
                my.SetResult(
                    //#line 942 GJavaParser.g
                    NewAssignmentOperator8(my.GetLeftIToken(), my.GetRightIToken(),
                                           //#line 942 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(1)),
                                           //#line 942 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(2)),
                                           //#line 942 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(3)),
                                           //#line 942 GJavaParser.g
                                           NewAstToken(my.GetRhsIToken(4))),
                //#line 942 GJavaParser.g
                )
                break
            }
            //
            // Rule 443:  AssignmentOperator ::= &=
            //
            case 443: {
               //#line 943 "GJavaParser.g"
                my.SetResult(
                    //#line 943 GJavaParser.g
                    NewAssignmentOperator9(my.GetRhsIToken(1)),
                //#line 943 GJavaParser.g
                )
                break
            }
            //
            // Rule 444:  AssignmentOperator ::= ^=
            //
            case 444: {
               //#line 944 "GJavaParser.g"
                my.SetResult(
                    //#line 944 GJavaParser.g
                    NewAssignmentOperator10(my.GetRhsIToken(1)),
                //#line 944 GJavaParser.g
                )
                break
            }
            //
            // Rule 445:  AssignmentOperator ::= |=
            //
            case 445: {
               //#line 945 "GJavaParser.g"
                my.SetResult(
                    //#line 945 GJavaParser.g
                    NewAssignmentOperator11(my.GetRhsIToken(1)),
                //#line 945 GJavaParser.g
                )
                break
            }
            //
            // Rule 446:  Expression ::= AssignmentExpression
            //
            case 446:
                break
            //
            // Rule 447:  ConstantExpression ::= Expression
            //
            case 447:
                break
            //
            // Rule 448:  Dimsopt ::= $Empty
            //
            case 448: {
               //#line 954 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 449:  Dimsopt ::= Dims
            //
            case 449:
                break
            //
            // Rule 450:  Catchesopt ::= $Empty
            //
            case 450: {
               //#line 957 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 451:  Catchesopt ::= Catches
            //
            case 451:
                break
            //
            // Rule 452:  identifieropt ::= $Empty
            //
            case 452: {
               //#line 960 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 453:  identifieropt ::= identifier
            //
            case 453:
                break
            //
            // Rule 454:  ForUpdateopt ::= $Empty
            //
            case 454: {
               //#line 963 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 455:  ForUpdateopt ::= ForUpdate
            //
            case 455:
                break
            //
            // Rule 456:  Expressionopt ::= $Empty
            //
            case 456: {
               //#line 966 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 457:  Expressionopt ::= Expression
            //
            case 457:
                break
            //
            // Rule 458:  ForInitopt ::= $Empty
            //
            case 458: {
               //#line 969 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 459:  ForInitopt ::= ForInit
            //
            case 459:
                break
            //
            // Rule 460:  SwitchLabelsopt ::= $Empty
            //
            case 460: {
               //#line 972 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 461:  SwitchLabelsopt ::= SwitchLabels
            //
            case 461:
                break
            //
            // Rule 462:  SwitchBlockStatementGroupsopt ::= $Empty
            //
            case 462: {
               //#line 975 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 463:  SwitchBlockStatementGroupsopt ::= SwitchBlockStatementGroups
            //
            case 463:
                break
            //
            // Rule 464:  VariableModifiersopt ::= $Empty
            //
            case 464: {
               //#line 978 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 465:  VariableModifiersopt ::= VariableModifiers
            //
            case 465:
                break
            //
            // Rule 466:  VariableInitializersopt ::= $Empty
            //
            case 466: {
               //#line 981 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 467:  VariableInitializersopt ::= VariableInitializers
            //
            case 467:
                break
            //
            // Rule 468:  ElementValuesopt ::= $Empty
            //
            case 468: {
               //#line 984 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 469:  ElementValuesopt ::= ElementValues
            //
            case 469:
                break
            //
            // Rule 470:  ElementValuePairsopt ::= $Empty
            //
            case 470: {
               //#line 987 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 471:  ElementValuePairsopt ::= ElementValuePairs
            //
            case 471:
                break
            //
            // Rule 472:  DefaultValueopt ::= $Empty
            //
            case 472: {
               //#line 990 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 473:  DefaultValueopt ::= DefaultValue
            //
            case 473:
                break
            //
            // Rule 474:  AnnotationTypeElementDeclarationsopt ::= $Empty
            //
            case 474: {
               //#line 993 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 475:  AnnotationTypeElementDeclarationsopt ::= AnnotationTypeElementDeclarations
            //
            case 475:
                break
            //
            // Rule 476:  AbstractMethodModifiersopt ::= $Empty
            //
            case 476: {
               //#line 996 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 477:  AbstractMethodModifiersopt ::= AbstractMethodModifiers
            //
            case 477:
                break
            //
            // Rule 478:  ConstantModifiersopt ::= $Empty
            //
            case 478: {
               //#line 999 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 479:  ConstantModifiersopt ::= ConstantModifiers
            //
            case 479:
                break
            //
            // Rule 480:  InterfaceMemberDeclarationsopt ::= $Empty
            //
            case 480: {
               //#line 1002 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 481:  InterfaceMemberDeclarationsopt ::= InterfaceMemberDeclarations
            //
            case 481:
                break
            //
            // Rule 482:  ExtendsInterfacesopt ::= $Empty
            //
            case 482: {
               //#line 1005 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 483:  ExtendsInterfacesopt ::= ExtendsInterfaces
            //
            case 483:
                break
            //
            // Rule 484:  InterfaceModifiersopt ::= $Empty
            //
            case 484: {
               //#line 1008 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 485:  InterfaceModifiersopt ::= InterfaceModifiers
            //
            case 485:
                break
            //
            // Rule 486:  ClassBodyopt ::= $Empty
            //
            case 486: {
               //#line 1011 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 487:  ClassBodyopt ::= ClassBody
            //
            case 487:
                break
            //
            // Rule 488:  Argumentsopt ::= $Empty
            //
            case 488: {
               //#line 1014 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 489:  Argumentsopt ::= Arguments
            //
            case 489:
                break
            //
            // Rule 490:  EnumBodyDeclarationsopt ::= $Empty
            //
            case 490: {
               //#line 1017 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 491:  EnumBodyDeclarationsopt ::= EnumBodyDeclarations
            //
            case 491:
                break
            //
            // Rule 492:  ,opt ::= $Empty
            //
            case 492: {
               //#line 1020 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 493:  ,opt ::= ,
            //
            case 493: {
               //#line 1021 "GJavaParser.g"
                my.SetResult(
                    //#line 1021 GJavaParser.g
                    NewCommaopt(my.GetRhsIToken(1)),
                //#line 1021 GJavaParser.g
                )
                break
            }
            //
            // Rule 494:  EnumConstantsopt ::= $Empty
            //
            case 494: {
               //#line 1023 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 495:  EnumConstantsopt ::= EnumConstants
            //
            case 495:
                break
            //
            // Rule 496:  ArgumentListopt ::= $Empty
            //
            case 496: {
               //#line 1026 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 497:  ArgumentListopt ::= ArgumentList
            //
            case 497:
                break
            //
            // Rule 498:  BlockStatementsopt ::= $Empty
            //
            case 498: {
               //#line 1029 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 499:  BlockStatementsopt ::= BlockStatements
            //
            case 499:
                break
            //
            // Rule 500:  ExplicitConstructorInvocationopt ::= $Empty
            //
            case 500: {
               //#line 1032 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 501:  ExplicitConstructorInvocationopt ::= ExplicitConstructorInvocation
            //
            case 501:
                break
            //
            // Rule 502:  ConstructorModifiersopt ::= $Empty
            //
            case 502: {
               //#line 1035 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 503:  ConstructorModifiersopt ::= ConstructorModifiers
            //
            case 503:
                break
            //
            // Rule 504:  ...opt ::= $Empty
            //
            case 504: {
               //#line 1038 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 505:  ...opt ::= ...
            //
            case 505: {
               //#line 1039 "GJavaParser.g"
                my.SetResult(
                    //#line 1039 GJavaParser.g
                    NewEllipsisopt(my.GetRhsIToken(1)),
                //#line 1039 GJavaParser.g
                )
                break
            }
            //
            // Rule 506:  FormalParameterListopt ::= $Empty
            //
            case 506: {
               //#line 1041 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 507:  FormalParameterListopt ::= FormalParameterList
            //
            case 507:
                break
            //
            // Rule 508:  Throwsopt ::= $Empty
            //
            case 508: {
               //#line 1044 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 509:  Throwsopt ::= Throws
            //
            case 509:
                break
            //
            // Rule 510:  MethodModifiersopt ::= $Empty
            //
            case 510: {
               //#line 1047 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 511:  MethodModifiersopt ::= MethodModifiers
            //
            case 511:
                break
            //
            // Rule 512:  FieldModifiersopt ::= $Empty
            //
            case 512: {
               //#line 1050 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 513:  FieldModifiersopt ::= FieldModifiers
            //
            case 513:
                break
            //
            // Rule 514:  ClassBodyDeclarationsopt ::= $Empty
            //
            case 514: {
               //#line 1053 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 515:  ClassBodyDeclarationsopt ::= ClassBodyDeclarations
            //
            case 515:
                break
            //
            // Rule 516:  Interfacesopt ::= $Empty
            //
            case 516: {
               //#line 1056 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 517:  Interfacesopt ::= Interfaces
            //
            case 517:
                break
            //
            // Rule 518:  Superopt ::= $Empty
            //
            case 518: {
               //#line 1059 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 519:  Superopt ::= Super
            //
            case 519:
                break
            //
            // Rule 520:  TypeParametersopt ::= $Empty
            //
            case 520: {
               //#line 1062 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 521:  TypeParametersopt ::= TypeParameters
            //
            case 521:
                break
            //
            // Rule 522:  ClassModifiersopt ::= $Empty
            //
            case 522: {
               //#line 1065 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 523:  ClassModifiersopt ::= ClassModifiers
            //
            case 523:
                break
            //
            // Rule 524:  Annotationsopt ::= $Empty
            //
            case 524: {
               //#line 1068 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 525:  Annotationsopt ::= Annotations
            //
            case 525:
                break
            //
            // Rule 526:  TypeDeclarationsopt ::= $Empty
            //
            case 526: {
               //#line 1071 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 527:  TypeDeclarationsopt ::= TypeDeclarations
            //
            case 527:
                break
            //
            // Rule 528:  ImportDeclarationsopt ::= $Empty
            //
            case 528: {
               //#line 1074 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 529:  ImportDeclarationsopt ::= ImportDeclarations
            //
            case 529:
                break
            //
            // Rule 530:  PackageDeclarationopt ::= $Empty
            //
            case 530: {
               //#line 1077 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 531:  PackageDeclarationopt ::= PackageDeclaration
            //
            case 531:
                break
            //
            // Rule 532:  WildcardBoundsOpt ::= $Empty
            //
            case 532: {
               //#line 1080 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 533:  WildcardBoundsOpt ::= WildcardBounds
            //
            case 533:
                break
            //
            // Rule 534:  AdditionalBoundListopt ::= $Empty
            //
            case 534: {
               //#line 1083 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 535:  AdditionalBoundListopt ::= AdditionalBoundList
            //
            case 535:
                break
            //
            // Rule 536:  TypeBoundopt ::= $Empty
            //
            case 536: {
               //#line 1086 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 537:  TypeBoundopt ::= TypeBound
            //
            case 537:
                break
            //
            // Rule 538:  TypeArgumentsopt ::= $Empty
            //
            case 538: {
               //#line 1089 "GJavaParser.g"
                my.SetResult(nil);
                break
            }
            //
            // Rule 539:  TypeArgumentsopt ::= TypeArguments
            //
            case 539:
                break
    //#line 325 "btParserTemplateF.gi

    
            default:
                break
        }
        return
    }
type Ast struct{
     leftIToken  IToken 
     rightIToken IToken 
     parent IAst
}
func NewAst2(leftIToken  IToken , rightIToken  IToken ) *Ast{
        my := new(Ast)
        my.leftIToken = leftIToken
        my.rightIToken = rightIToken
        return my
}

func NewAst(token  IToken) *Ast{
        my := new(Ast)
        my.leftIToken = token
        my.rightIToken = token
        return my
}

func (my *Ast)     GetNextAst() IAst  { return nil }
func (my *Ast)      SetParent(parent IAst )  { my.parent = parent }
func (my *Ast)      GetParent() IAst { return my.parent }

func (my *Ast)     GetLeftIToken()  IToken { return my.leftIToken }
func (my *Ast)     GetRightIToken()  IToken { return my.rightIToken }
func (my *Ast)     GetPrecedingAdjuncts()  []IToken { return my.leftIToken.GetPrecedingAdjuncts() }
func (my *Ast)     GetFollowingAdjuncts()  []IToken { return my.rightIToken.GetFollowingAdjuncts() }

func (my *Ast)      ToString()string{
        return my.leftIToken.GetILexStream().ToString(my.leftIToken.GetStartOffset(), my.rightIToken.GetEndOffset())
}

func (my *Ast)     Initialize()  {}

    /**
     * A list of all children of my node, excluding the null ones.
     */
func (my *Ast)      GetChildren() *ArrayList{
        var list = my.GetAllChildren() 
        var k = -1
        var i = 0
        for ; i < list.Size(); i++{
            var element = list.Get(i)
            if element != nil{
                k += i
                if k != i{
                    list.Set(k, element)
                }
            }
        }
        i = list.Size() - 1
        for ; i > k; i--{ // remove extraneous elements
            list.RemoveAt(i)
        }
        return list
}

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Ast)    GetAllChildren() *ArrayList{return nil}

 func (my *Ast) AcceptWithVisitor(v Visitor){}
 func (my *Ast)  AcceptWithArg(v  ArgumentVisitor, o interface{}){}
 func (my *Ast) AcceptWithResult(v ResultVisitor) interface{}{return nil}
 func (my *Ast) AcceptWithResultArgument(v  ResultArgumentVisitor, o interface{}) interface{}{return nil}
func (my *Ast)      Accept(v IAstVisitor) {}


func AnyCastToAst(i interface{}) *Ast {
	if nil == i{
		return nil
	}else{
		return i.(*Ast)
	}
}
type AbstractAstList struct{
     *Ast
     leftRecursive bool 
     list *ArrayList 
}
func NewAbstractAstList(leftToken  IToken, rightToken  IToken, leftRecursive bool)*AbstractAstList{
      my := new(AbstractAstList)
      my.Ast = NewAst2(leftToken, rightToken)
      my.list = NewArrayList()
      my.leftRecursive = leftRecursive
      return my
}

func (my *AbstractAstList)      Size() int { return my.list.Size(); }
func (my *AbstractAstList)      GetList() *ArrayList{ return my.list }
func (my *AbstractAstList)      GetElementAt(i int ) IAst{
    var k int
    if my.leftRecursive {
       k =i
    }else{
       k =my.list.Size() - 1 - i
    }
    return my.list.Get(k).(IAst) 
    }
func (my *AbstractAstList)      GetArrayList() *ArrayList{
        if ! my.leftRecursive{ // reverse the list 
           var i = 0
           var n = my.list.Size() - 1
           for ; i < n;  n--{
                var ith = my.list.Get(i)
                var nth = my.list.Get(n)
                my.list.Set(i, nth)
                my.list.Set(n, ith)
               i++
           }
           my.leftRecursive = true
        }
        return my.list
    }
    /**
     * @deprecated replaced by {@link #AddElement()}
     *
     */
func (my *AbstractAstList)      Add(element IAst) bool {
        my.AddElement(element)
        return true
}

func (my *AbstractAstList)      AddElement(element IAst){
        my.list.Add(element)
        if my.leftRecursive{
             my.rightIToken = element.GetRightIToken()
        }else{
          my.leftIToken = element.GetLeftIToken()
        }
}

    /**
     * Make a copy of the list and return it. Note that we obtain the local list by
     * invoking GetArrayList so as to make sure that the list we return is in proper order.
     */
func (my *AbstractAstList)      GetAllChildren() *ArrayList{
        return my.GetArrayList().Clone()
}



func AnyCastToAbstractAstList(i interface{}) *AbstractAstList {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractAstList)
	}
}
type AstToken struct{
    *Ast
 }
func NewAstToken(token  IToken)*AstToken{
      my := new(AstToken)
      my.Ast = NewAst(token)
      return my
}

func (my *AstToken)      GetIToken()  IToken{ return my.leftIToken }
func (my *AstToken)      ToString()  string  { return my.leftIToken.ToString() }

    /**
     * A token class has no children. So, we return the empty list.
     */
func (my *AstToken)        GetAllChildren()  *ArrayList { return nil }


func (my *AstToken)      AcceptWithVisitor(v Visitor) { v.VisitAstToken(my)}
func (my *AstToken)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAstTokenWithArg(my, o) }
func (my *AstToken)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAstTokenWithResult(my) }
func (my *AstToken)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAstTokenWithResultArgument(my, o) }


func AnyCastToAstToken(i interface{}) *AstToken {
	if nil == i{
		return nil
	}else{
		return i.(*AstToken)
	}
}
type IRootForJavaParser interface{
     GetLeftIToken()  IToken
     GetRightIToken()  IToken
 AcceptWithVisitor(v Visitor)
  AcceptWithArg(v  ArgumentVisitor, o interface{})
 AcceptWithResult(v ResultVisitor) interface{}
 AcceptWithResultArgument(v  ResultArgumentVisitor, o interface{}) interface{}
}

func CastToAnyForJavaParser(i interface{}) interface{}{return i}

func AnyCastToIRootForJavaParser(i interface{}) IRootForJavaParser {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IRootForJavaParser)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PrimitiveType
 *<li>ClassType
 *<li>ArrayType
 *<li>TypeDeclaration
 *<li>NormalClassDeclaration
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>ResultType
 *<li>VariableModifier
 *<li>MethodBody
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>InterfaceMemberDeclaration
 *<li>ConstantDeclaration
 *<li>AbstractMethodDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>Block
 *<li>BlockStatements
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>Commaopt
 *<li>Ellipsisopt
 *<li>LPGUserAction0
 *<li>LPGUserAction1
 *<li>LPGUserAction2
 *<li>LPGUserAction3
 *<li>LPGUserAction4
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *<li>ClassModifier0
 *<li>ClassModifier1
 *<li>ClassModifier2
 *<li>ClassModifier3
 *<li>ClassModifier4
 *<li>ClassModifier5
 *<li>ClassModifier6
 *<li>FieldModifier0
 *<li>FieldModifier1
 *<li>FieldModifier2
 *<li>FieldModifier3
 *<li>FieldModifier4
 *<li>FieldModifier5
 *<li>FieldModifier6
 *<li>MethodModifier0
 *<li>MethodModifier1
 *<li>MethodModifier2
 *<li>MethodModifier3
 *<li>MethodModifier4
 *<li>MethodModifier5
 *<li>MethodModifier6
 *<li>MethodModifier7
 *<li>MethodModifier8
 *<li>ConstructorModifier0
 *<li>ConstructorModifier1
 *<li>ConstructorModifier2
 *<li>InterfaceModifier0
 *<li>InterfaceModifier1
 *<li>InterfaceModifier2
 *<li>InterfaceModifier3
 *<li>InterfaceModifier4
 *<li>InterfaceModifier5
 *<li>ConstantModifier0
 *<li>ConstantModifier1
 *<li>ConstantModifier2
 *<li>AbstractMethodModifier0
 *<li>AbstractMethodModifier1
 *<li>AnnotationTypeElementDeclaration0
 *<li>AnnotationTypeElementDeclaration1
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>AssignmentOperator0
 *<li>AssignmentOperator1
 *<li>AssignmentOperator2
 *<li>AssignmentOperator3
 *<li>AssignmentOperator4
 *<li>AssignmentOperator5
 *<li>AssignmentOperator6
 *<li>AssignmentOperator7
 *<li>AssignmentOperator8
 *<li>AssignmentOperator9
 *<li>AssignmentOperator10
 *<li>AssignmentOperator11
 *</ul>
 *</b>
 */
type IAstToken interface{
IRootForJavaParser
}

func AnyCastToIAstToken(i interface{}) IAstToken {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAstToken)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>Commaopt</b>
 */
type ICommaopt interface{
IAstToken
}

func AnyCastToICommaopt(i interface{}) ICommaopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICommaopt)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>Ellipsisopt</b>
 */
type IEllipsisopt interface{
IAstToken
}

func AnyCastToIEllipsisopt(i interface{}) IEllipsisopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEllipsisopt)
	  }
}
/**
 * is implemented by <b>CompilationUnit</b>
 */
type ICompilationUnit interface{
IRootForJavaParser
}

func AnyCastToICompilationUnit(i interface{}) ICompilationUnit {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICompilationUnit)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>ClassBodyDeclarations
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>StaticInitializer
 *<li>ConstructorDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>Block
 *</ul>
 *</b>
 */
type IClassBodyDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIClassBodyDeclarationsopt(i interface{}) IClassBodyDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBodyDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>Block
 *<li>BlockStatements
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>LPGUserAction0
 *<li>LPGUserAction1
 *<li>LPGUserAction2
 *<li>LPGUserAction3
 *<li>LPGUserAction4
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type ILPGUserAction interface{
IAstToken
}

func AnyCastToILPGUserAction(i interface{}) ILPGUserAction {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILPGUserAction)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type Iidentifier interface{
IAstToken
ITypeName
ITypeVariable
IPackageName
IExpressionName
IMethodName
IPackageOrTypeName
IAmbiguousName
IVariableDeclaratorId
ISimpleTypeName
ISimpleName
IEnumConstant
Iidentifieropt
}

func AnyCastToIidentifier(i interface{}) Iidentifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(Iidentifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>Block
 *<li>BlockStatements
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IBlockStatementsopt interface{
ILPGUserAction
}

func AnyCastToIBlockStatementsopt(i interface{}) IBlockStatementsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBlockStatementsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PrimitiveType
 *<li>ClassType
 *<li>ArrayType
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type IType interface{
IResultType
}

func AnyCastToIType(i interface{}) IType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>PrimitiveType
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type IPrimitiveType interface{
IType
IAstToken
}

func AnyCastToIPrimitiveType(i interface{}) IPrimitiveType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPrimitiveType)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *<li>ArrayType
 *</ul>
 *</b>
 */
type IReferenceType interface{
IType
IActualTypeArgument
}

func AnyCastToIReferenceType(i interface{}) IReferenceType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IReferenceType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type INumericType interface{
IPrimitiveType
}

func AnyCastToINumericType(i interface{}) INumericType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(INumericType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *</ul>
 *</b>
 */
type IIntegralType interface{
INumericType
IAstToken
}

func AnyCastToIIntegralType(i interface{}) IIntegralType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IIntegralType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type IFloatingPointType interface{
INumericType
IAstToken
}

func AnyCastToIFloatingPointType(i interface{}) IFloatingPointType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFloatingPointType)
	  }
}
/**
 * is implemented by <b>ClassType</b>
 */
type IClassOrInterfaceType interface{
IReferenceType
}

func AnyCastToIClassOrInterfaceType(i interface{}) IClassOrInterfaceType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassOrInterfaceType)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type ITypeVariable interface{
IReferenceType
IExceptionType
}

func AnyCastToITypeVariable(i interface{}) ITypeVariable {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeVariable)
	  }
}
/**
 * is implemented by <b>ArrayType</b>
 */
type IArrayType interface{
IReferenceType
}

func AnyCastToIArrayType(i interface{}) IArrayType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArrayType)
	  }
}
/**
 * is implemented by <b>ClassType</b>
 */
type IClassType interface{
IClassOrInterfaceType
IExceptionType
}

func AnyCastToIClassType(i interface{}) IClassType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassType)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>TypeName
 *</ul>
 *</b>
 */
type ITypeName interface{
IClassName
}

func AnyCastToITypeName(i interface{}) ITypeName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeName)
	  }
}
/**
 * is implemented by <b>TypeArguments</b>
 */
type ITypeArgumentsopt interface{
IRootForJavaParser
}

func AnyCastToITypeArgumentsopt(i interface{}) ITypeArgumentsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeArgumentsopt)
	  }
}
/**
 * is implemented by <b>InterfaceType</b>
 */
type IInterfaceType interface{
IInterfaceTypeList
}

func AnyCastToIInterfaceType(i interface{}) IInterfaceType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceType)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>TypeName
 *</ul>
 *</b>
 */
type IClassName interface{
IRootForJavaParser
}

func AnyCastToIClassName(i interface{}) IClassName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassName)
	  }
}
/**
 * is implemented by <b>TypeParameter</b>
 */
type ITypeParameter interface{
ITypeParameterList
}

func AnyCastToITypeParameter(i interface{}) ITypeParameter {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeParameter)
	  }
}
/**
 * is implemented by <b>TypeBound</b>
 */
type ITypeBoundopt interface{
IRootForJavaParser
}

func AnyCastToITypeBoundopt(i interface{}) ITypeBoundopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeBoundopt)
	  }
}
/**
 * is implemented by <b>TypeBound</b>
 */
type ITypeBound interface{
ITypeBoundopt
}

func AnyCastToITypeBound(i interface{}) ITypeBound {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeBound)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AdditionalBoundList
 *<li>AdditionalBound
 *</ul>
 *</b>
 */
type IAdditionalBoundListopt interface{
IRootForJavaParser
}

func AnyCastToIAdditionalBoundListopt(i interface{}) IAdditionalBoundListopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAdditionalBoundListopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AdditionalBoundList
 *<li>AdditionalBound
 *</ul>
 *</b>
 */
type IAdditionalBoundList interface{
IAdditionalBoundListopt
}

func AnyCastToIAdditionalBoundList(i interface{}) IAdditionalBoundList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAdditionalBoundList)
	  }
}
/**
 * is implemented by <b>AdditionalBound</b>
 */
type IAdditionalBound interface{
IAdditionalBoundList
}

func AnyCastToIAdditionalBound(i interface{}) IAdditionalBound {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAdditionalBound)
	  }
}
/**
 * is implemented by <b>TypeArguments</b>
 */
type ITypeArguments interface{
ITypeArgumentsopt
}

func AnyCastToITypeArguments(i interface{}) ITypeArguments {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeArguments)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *<li>ArrayType
 *<li>ActualTypeArgumentList
 *<li>Wildcard
 *</ul>
 *</b>
 */
type IActualTypeArgumentList interface{
IRootForJavaParser
}

func AnyCastToIActualTypeArgumentList(i interface{}) IActualTypeArgumentList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IActualTypeArgumentList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *<li>ArrayType
 *<li>Wildcard
 *</ul>
 *</b>
 */
type IActualTypeArgument interface{
IActualTypeArgumentList
}

func AnyCastToIActualTypeArgument(i interface{}) IActualTypeArgument {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IActualTypeArgument)
	  }
}
/**
 * is implemented by <b>Wildcard</b>
 */
type IWildcard interface{
IActualTypeArgument
}

func AnyCastToIWildcard(i interface{}) IWildcard {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWildcard)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>WildcardBounds0
 *<li>WildcardBounds1
 *</ul>
 *</b>
 */
type IWildcardBoundsOpt interface{
IRootForJavaParser
}

func AnyCastToIWildcardBoundsOpt(i interface{}) IWildcardBoundsOpt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWildcardBoundsOpt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>WildcardBounds0
 *<li>WildcardBounds1
 *</ul>
 *</b>
 */
type IWildcardBounds interface{
IWildcardBoundsOpt
}

func AnyCastToIWildcardBounds(i interface{}) IWildcardBounds {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWildcardBounds)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PackageName
 *</ul>
 *</b>
 */
type IPackageName interface{
IRootForJavaParser
}

func AnyCastToIPackageName(i interface{}) IPackageName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPackageName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *</ul>
 *</b>
 */
type IExpressionName interface{
IPostfixExpression
ILeftHandSide
}

func AnyCastToIExpressionName(i interface{}) IExpressionName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExpressionName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>AmbiguousName
 *</ul>
 *</b>
 */
type IAmbiguousName interface{
IRootForJavaParser
}

func AnyCastToIAmbiguousName(i interface{}) IAmbiguousName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAmbiguousName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>MethodName
 *</ul>
 *</b>
 */
type IMethodName interface{
IRootForJavaParser
}

func AnyCastToIMethodName(i interface{}) IMethodName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PackageOrTypeName
 *</ul>
 *</b>
 */
type IPackageOrTypeName interface{
IRootForJavaParser
}

func AnyCastToIPackageOrTypeName(i interface{}) IPackageOrTypeName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPackageOrTypeName)
	  }
}
/**
 * is implemented by <b>PackageDeclaration</b>
 */
type IPackageDeclarationopt interface{
IRootForJavaParser
}

func AnyCastToIPackageDeclarationopt(i interface{}) IPackageDeclarationopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPackageDeclarationopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ImportDeclarations
 *<li>SingleTypeImportDeclaration
 *<li>TypeImportOnDemandDeclaration
 *<li>SingleStaticImportDeclaration
 *<li>StaticImportOnDemandDeclaration
 *</ul>
 *</b>
 */
type IImportDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIImportDeclarationsopt(i interface{}) IImportDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IImportDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TypeDeclarations
 *<li>TypeDeclaration
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type ITypeDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToITypeDeclarationsopt(i interface{}) ITypeDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ImportDeclarations
 *<li>SingleTypeImportDeclaration
 *<li>TypeImportOnDemandDeclaration
 *<li>SingleStaticImportDeclaration
 *<li>StaticImportOnDemandDeclaration
 *</ul>
 *</b>
 */
type IImportDeclarations interface{
IImportDeclarationsopt
}

func AnyCastToIImportDeclarations(i interface{}) IImportDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IImportDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SingleTypeImportDeclaration
 *<li>TypeImportOnDemandDeclaration
 *<li>SingleStaticImportDeclaration
 *<li>StaticImportOnDemandDeclaration
 *</ul>
 *</b>
 */
type IImportDeclaration interface{
IImportDeclarations
}

func AnyCastToIImportDeclaration(i interface{}) IImportDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IImportDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TypeDeclarations
 *<li>TypeDeclaration
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type ITypeDeclarations interface{
ITypeDeclarationsopt
}

func AnyCastToITypeDeclarations(i interface{}) ITypeDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TypeDeclaration
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type ITypeDeclaration interface{
ITypeDeclarations
IAstToken
}

func AnyCastToITypeDeclaration(i interface{}) ITypeDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeDeclaration)
	  }
}
/**
 * is implemented by <b>PackageDeclaration</b>
 */
type IPackageDeclaration interface{
IPackageDeclarationopt
}

func AnyCastToIPackageDeclaration(i interface{}) IPackageDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPackageDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IAnnotationsopt interface{
IRootForJavaParser
}

func AnyCastToIAnnotationsopt(i interface{}) IAnnotationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationsopt)
	  }
}
/**
 * is implemented by <b>SingleTypeImportDeclaration</b>
 */
type ISingleTypeImportDeclaration interface{
IImportDeclaration
}

func AnyCastToISingleTypeImportDeclaration(i interface{}) ISingleTypeImportDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISingleTypeImportDeclaration)
	  }
}
/**
 * is implemented by <b>TypeImportOnDemandDeclaration</b>
 */
type ITypeImportOnDemandDeclaration interface{
IImportDeclaration
}

func AnyCastToITypeImportOnDemandDeclaration(i interface{}) ITypeImportOnDemandDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeImportOnDemandDeclaration)
	  }
}
/**
 * is implemented by <b>SingleStaticImportDeclaration</b>
 */
type ISingleStaticImportDeclaration interface{
IImportDeclaration
}

func AnyCastToISingleStaticImportDeclaration(i interface{}) ISingleStaticImportDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISingleStaticImportDeclaration)
	  }
}
/**
 * is implemented by <b>StaticImportOnDemandDeclaration</b>
 */
type IStaticImportOnDemandDeclaration interface{
IImportDeclaration
}

func AnyCastToIStaticImportOnDemandDeclaration(i interface{}) IStaticImportOnDemandDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStaticImportOnDemandDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *</ul>
 *</b>
 */
type IClassDeclaration interface{
ITypeDeclaration
IClassMemberDeclaration
IInterfaceMemberDeclaration
IAnnotationTypeElementDeclaration
IBlockStatement
}

func AnyCastToIClassDeclaration(i interface{}) IClassDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IInterfaceDeclaration interface{
ITypeDeclaration
IClassMemberDeclaration
IInterfaceMemberDeclaration
IAnnotationTypeElementDeclaration
}

func AnyCastToIInterfaceDeclaration(i interface{}) IInterfaceDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceDeclaration)
	  }
}
/**
 * is implemented by <b>NormalClassDeclaration</b>
 */
type INormalClassDeclaration interface{
IClassDeclaration
}

func AnyCastToINormalClassDeclaration(i interface{}) INormalClassDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(INormalClassDeclaration)
	  }
}
/**
 * is implemented by <b>EnumDeclaration</b>
 */
type IEnumDeclaration interface{
IClassDeclaration
IAnnotationTypeElementDeclaration
}

func AnyCastToIEnumDeclaration(i interface{}) IEnumDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ClassModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ClassModifier0
 *<li>ClassModifier1
 *<li>ClassModifier2
 *<li>ClassModifier3
 *<li>ClassModifier4
 *<li>ClassModifier5
 *<li>ClassModifier6
 *</ul>
 *</b>
 */
type IClassModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIClassModifiersopt(i interface{}) IClassModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassModifiersopt)
	  }
}
/**
 * is implemented by <b>TypeParameters</b>
 */
type ITypeParametersopt interface{
IRootForJavaParser
}

func AnyCastToITypeParametersopt(i interface{}) ITypeParametersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeParametersopt)
	  }
}
/**
 * is implemented by <b>Super</b>
 */
type ISuperopt interface{
IRootForJavaParser
}

func AnyCastToISuperopt(i interface{}) ISuperopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISuperopt)
	  }
}
/**
 * is implemented by <b>Interfaces</b>
 */
type IInterfacesopt interface{
IRootForJavaParser
}

func AnyCastToIInterfacesopt(i interface{}) IInterfacesopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfacesopt)
	  }
}
/**
 * is implemented by <b>ClassBody</b>
 */
type IClassBody interface{
IClassBodyopt
}

func AnyCastToIClassBody(i interface{}) IClassBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ClassModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ClassModifier0
 *<li>ClassModifier1
 *<li>ClassModifier2
 *<li>ClassModifier3
 *<li>ClassModifier4
 *<li>ClassModifier5
 *<li>ClassModifier6
 *</ul>
 *</b>
 */
type IClassModifiers interface{
IClassModifiersopt
}

func AnyCastToIClassModifiers(i interface{}) IClassModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ClassModifier0
 *<li>ClassModifier1
 *<li>ClassModifier2
 *<li>ClassModifier3
 *<li>ClassModifier4
 *<li>ClassModifier5
 *<li>ClassModifier6
 *</ul>
 *</b>
 */
type IClassModifier interface{
IClassModifiers
IAstToken
}

func AnyCastToIClassModifier(i interface{}) IClassModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IAnnotation interface{
IClassModifier
IFieldModifier
IInterfaceModifier
IConstantModifier
IAnnotations
IElementValue
}

func AnyCastToIAnnotation(i interface{}) IAnnotation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotation)
	  }
}
/**
 * is implemented by <b>TypeParameters</b>
 */
type ITypeParameters interface{
ITypeParametersopt
}

func AnyCastToITypeParameters(i interface{}) ITypeParameters {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeParameters)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TypeParameter
 *<li>TypeParameterList
 *</ul>
 *</b>
 */
type ITypeParameterList interface{
IRootForJavaParser
}

func AnyCastToITypeParameterList(i interface{}) ITypeParameterList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITypeParameterList)
	  }
}
/**
 * is implemented by <b>Super</b>
 */
type ISuper interface{
ISuperopt
}

func AnyCastToISuper(i interface{}) ISuper {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISuper)
	  }
}
/**
 * is implemented by <b>Interfaces</b>
 */
type IInterfaces interface{
IInterfacesopt
}

func AnyCastToIInterfaces(i interface{}) IInterfaces {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaces)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>InterfaceType
 *<li>InterfaceTypeList
 *</ul>
 *</b>
 */
type IInterfaceTypeList interface{
IRootForJavaParser
}

func AnyCastToIInterfaceTypeList(i interface{}) IInterfaceTypeList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceTypeList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>ClassBodyDeclarations
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>StaticInitializer
 *<li>ConstructorDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>Block
 *</ul>
 *</b>
 */
type IClassBodyDeclarations interface{
IClassBodyDeclarationsopt
}

func AnyCastToIClassBodyDeclarations(i interface{}) IClassBodyDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBodyDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>StaticInitializer
 *<li>ConstructorDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>Block
 *</ul>
 *</b>
 */
type IClassBodyDeclaration interface{
IClassBodyDeclarations
}

func AnyCastToIClassBodyDeclaration(i interface{}) IClassBodyDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBodyDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>ClassMemberDeclaration
 *<li>FieldDeclaration
 *<li>MethodDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IClassMemberDeclaration interface{
IClassBodyDeclaration
IAstToken
}

func AnyCastToIClassMemberDeclaration(i interface{}) IClassMemberDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassMemberDeclaration)
	  }
}
/**
 * is implemented by <b>Block</b>
 */
type IInstanceInitializer interface{
IClassBodyDeclaration
}

func AnyCastToIInstanceInitializer(i interface{}) IInstanceInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInstanceInitializer)
	  }
}
/**
 * is implemented by <b>StaticInitializer</b>
 */
type IStaticInitializer interface{
IClassBodyDeclaration
}

func AnyCastToIStaticInitializer(i interface{}) IStaticInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStaticInitializer)
	  }
}
/**
 * is implemented by <b>ConstructorDeclaration</b>
 */
type IConstructorDeclaration interface{
IClassBodyDeclaration
}

func AnyCastToIConstructorDeclaration(i interface{}) IConstructorDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorDeclaration)
	  }
}
/**
 * is implemented by <b>FieldDeclaration</b>
 */
type IFieldDeclaration interface{
IClassMemberDeclaration
}

func AnyCastToIFieldDeclaration(i interface{}) IFieldDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldDeclaration)
	  }
}
/**
 * is implemented by <b>MethodDeclaration</b>
 */
type IMethodDeclaration interface{
IClassMemberDeclaration
}

func AnyCastToIMethodDeclaration(i interface{}) IMethodDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FieldModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>FieldModifier0
 *<li>FieldModifier1
 *<li>FieldModifier2
 *<li>FieldModifier3
 *<li>FieldModifier4
 *<li>FieldModifier5
 *<li>FieldModifier6
 *</ul>
 *</b>
 */
type IFieldModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIFieldModifiersopt(i interface{}) IFieldModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>VariableDeclarators
 *<li>VariableDeclarator
 *<li>VariableDeclaratorId
 *</ul>
 *</b>
 */
type IVariableDeclarators interface{
IRootForJavaParser
}

func AnyCastToIVariableDeclarators(i interface{}) IVariableDeclarators {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableDeclarators)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>VariableDeclarator
 *<li>VariableDeclaratorId
 *</ul>
 *</b>
 */
type IVariableDeclarator interface{
IVariableDeclarators
}

func AnyCastToIVariableDeclarator(i interface{}) IVariableDeclarator {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableDeclarator)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>VariableDeclaratorId
 *</ul>
 *</b>
 */
type IVariableDeclaratorId interface{
IVariableDeclarator
}

func AnyCastToIVariableDeclaratorId(i interface{}) IVariableDeclaratorId {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableDeclaratorId)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArrayInitializer
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IVariableInitializer interface{
IVariableInitializers
}

func AnyCastToIVariableInitializer(i interface{}) IVariableInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableInitializer)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IExpression interface{
IVariableInitializer
IArgumentList
IConstantExpression
IExpressionopt
}

func AnyCastToIExpression(i interface{}) IExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExpression)
	  }
}
/**
 * is implemented by <b>ArrayInitializer</b>
 */
type IArrayInitializer interface{
IVariableInitializer
}

func AnyCastToIArrayInitializer(i interface{}) IArrayInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArrayInitializer)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FieldModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>FieldModifier0
 *<li>FieldModifier1
 *<li>FieldModifier2
 *<li>FieldModifier3
 *<li>FieldModifier4
 *<li>FieldModifier5
 *<li>FieldModifier6
 *</ul>
 *</b>
 */
type IFieldModifiers interface{
IFieldModifiersopt
}

func AnyCastToIFieldModifiers(i interface{}) IFieldModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>FieldModifier0
 *<li>FieldModifier1
 *<li>FieldModifier2
 *<li>FieldModifier3
 *<li>FieldModifier4
 *<li>FieldModifier5
 *<li>FieldModifier6
 *</ul>
 *</b>
 */
type IFieldModifier interface{
IFieldModifiers
IAstToken
}

func AnyCastToIFieldModifier(i interface{}) IFieldModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldModifier)
	  }
}
/**
 * is implemented by <b>MethodHeader</b>
 */
type IMethodHeader interface{
IRootForJavaParser
}

func AnyCastToIMethodHeader(i interface{}) IMethodHeader {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodHeader)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodBody
 *<li>Block
 *</ul>
 *</b>
 */
type IMethodBody interface{
IAstToken
}

func AnyCastToIMethodBody(i interface{}) IMethodBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>MethodModifier0
 *<li>MethodModifier1
 *<li>MethodModifier2
 *<li>MethodModifier3
 *<li>MethodModifier4
 *<li>MethodModifier5
 *<li>MethodModifier6
 *<li>MethodModifier7
 *<li>MethodModifier8
 *</ul>
 *</b>
 */
type IMethodModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIMethodModifiersopt(i interface{}) IMethodModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>PrimitiveType
 *<li>ClassType
 *<li>ArrayType
 *<li>ResultType
 *<li>IntegralType0
 *<li>IntegralType1
 *<li>IntegralType2
 *<li>IntegralType3
 *<li>IntegralType4
 *<li>FloatingPointType0
 *<li>FloatingPointType1
 *</ul>
 *</b>
 */
type IResultType interface{
IAstToken
}

func AnyCastToIResultType(i interface{}) IResultType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IResultType)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodDeclarator0
 *<li>MethodDeclarator1
 *</ul>
 *</b>
 */
type IMethodDeclarator interface{
IRootForJavaParser
}

func AnyCastToIMethodDeclarator(i interface{}) IMethodDeclarator {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodDeclarator)
	  }
}
/**
 * is implemented by <b>Throws</b>
 */
type IThrowsopt interface{
IRootForJavaParser
}

func AnyCastToIThrowsopt(i interface{}) IThrowsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IThrowsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FormalParameterList
 *<li>LastFormalParameter
 *</ul>
 *</b>
 */
type IFormalParameterListopt interface{
IRootForJavaParser
}

func AnyCastToIFormalParameterListopt(i interface{}) IFormalParameterListopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFormalParameterListopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FormalParameterList
 *<li>LastFormalParameter
 *</ul>
 *</b>
 */
type IFormalParameterList interface{
IFormalParameterListopt
}

func AnyCastToIFormalParameterList(i interface{}) IFormalParameterList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFormalParameterList)
	  }
}
/**
 * is implemented by <b>LastFormalParameter</b>
 */
type ILastFormalParameter interface{
IFormalParameterList
}

func AnyCastToILastFormalParameter(i interface{}) ILastFormalParameter {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILastFormalParameter)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FormalParameters
 *<li>FormalParameter
 *</ul>
 *</b>
 */
type IFormalParameters interface{
IRootForJavaParser
}

func AnyCastToIFormalParameters(i interface{}) IFormalParameters {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFormalParameters)
	  }
}
/**
 * is implemented by <b>FormalParameter</b>
 */
type IFormalParameter interface{
IFormalParameters
}

func AnyCastToIFormalParameter(i interface{}) IFormalParameter {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFormalParameter)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>VariableModifiers
 *<li>VariableModifier
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IVariableModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIVariableModifiersopt(i interface{}) IVariableModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>VariableModifiers
 *<li>VariableModifier
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IVariableModifiers interface{
IVariableModifiersopt
}

func AnyCastToIVariableModifiers(i interface{}) IVariableModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>VariableModifier
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IVariableModifier interface{
IVariableModifiers
IAstToken
}

func AnyCastToIVariableModifier(i interface{}) IVariableModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *</ul>
 *</b>
 */
type IAnnotations interface{
IVariableModifier
IMethodModifier
IConstructorModifier
IAbstractMethodModifier
IAnnotationsopt
}

func AnyCastToIAnnotations(i interface{}) IAnnotations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>MethodModifier0
 *<li>MethodModifier1
 *<li>MethodModifier2
 *<li>MethodModifier3
 *<li>MethodModifier4
 *<li>MethodModifier5
 *<li>MethodModifier6
 *<li>MethodModifier7
 *<li>MethodModifier8
 *</ul>
 *</b>
 */
type IMethodModifiers interface{
IMethodModifiersopt
}

func AnyCastToIMethodModifiers(i interface{}) IMethodModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>MethodModifier0
 *<li>MethodModifier1
 *<li>MethodModifier2
 *<li>MethodModifier3
 *<li>MethodModifier4
 *<li>MethodModifier5
 *<li>MethodModifier6
 *<li>MethodModifier7
 *<li>MethodModifier8
 *</ul>
 *</b>
 */
type IMethodModifier interface{
IMethodModifiers
IAstToken
}

func AnyCastToIMethodModifier(i interface{}) IMethodModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodModifier)
	  }
}
/**
 * is implemented by <b>Throws</b>
 */
type IThrows interface{
IThrowsopt
}

func AnyCastToIThrows(i interface{}) IThrows {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IThrows)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *<li>ExceptionTypeList
 *</ul>
 *</b>
 */
type IExceptionTypeList interface{
IRootForJavaParser
}

func AnyCastToIExceptionTypeList(i interface{}) IExceptionTypeList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExceptionTypeList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ClassType
 *</ul>
 *</b>
 */
type IExceptionType interface{
IExceptionTypeList
}

func AnyCastToIExceptionType(i interface{}) IExceptionType {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExceptionType)
	  }
}
/**
 * is implemented by <b>Block</b>
 */
type IBlock interface{
IMethodBody
IInstanceInitializer
IStatementWithoutTrailingSubstatement
}

func AnyCastToIBlock(i interface{}) IBlock {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBlock)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ConstructorModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstructorModifier0
 *<li>ConstructorModifier1
 *<li>ConstructorModifier2
 *</ul>
 *</b>
 */
type IConstructorModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIConstructorModifiersopt(i interface{}) IConstructorModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorModifiersopt)
	  }
}
/**
 * is implemented by <b>ConstructorDeclarator</b>
 */
type IConstructorDeclarator interface{
IRootForJavaParser
}

func AnyCastToIConstructorDeclarator(i interface{}) IConstructorDeclarator {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorDeclarator)
	  }
}
/**
 * is implemented by <b>ConstructorBody</b>
 */
type IConstructorBody interface{
IRootForJavaParser
}

func AnyCastToIConstructorBody(i interface{}) IConstructorBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorBody)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type ISimpleTypeName interface{
IRootForJavaParser
}

func AnyCastToISimpleTypeName(i interface{}) ISimpleTypeName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISimpleTypeName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ConstructorModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstructorModifier0
 *<li>ConstructorModifier1
 *<li>ConstructorModifier2
 *</ul>
 *</b>
 */
type IConstructorModifiers interface{
IConstructorModifiersopt
}

func AnyCastToIConstructorModifiers(i interface{}) IConstructorModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstructorModifier0
 *<li>ConstructorModifier1
 *<li>ConstructorModifier2
 *</ul>
 *</b>
 */
type IConstructorModifier interface{
IConstructorModifiers
IAstToken
}

func AnyCastToIConstructorModifier(i interface{}) IConstructorModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstructorModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ExplicitConstructorInvocation0
 *<li>ExplicitConstructorInvocation1
 *<li>ExplicitConstructorInvocation2
 *</ul>
 *</b>
 */
type IExplicitConstructorInvocationopt interface{
IRootForJavaParser
}

func AnyCastToIExplicitConstructorInvocationopt(i interface{}) IExplicitConstructorInvocationopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExplicitConstructorInvocationopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ExplicitConstructorInvocation0
 *<li>ExplicitConstructorInvocation1
 *<li>ExplicitConstructorInvocation2
 *</ul>
 *</b>
 */
type IExplicitConstructorInvocation interface{
IExplicitConstructorInvocationopt
}

func AnyCastToIExplicitConstructorInvocation(i interface{}) IExplicitConstructorInvocation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExplicitConstructorInvocation)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArgumentList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IArgumentListopt interface{
IRootForJavaParser
}

func AnyCastToIArgumentListopt(i interface{}) IArgumentListopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArgumentListopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type IPrimary interface{
IPostfixExpression
}

func AnyCastToIPrimary(i interface{}) IPrimary {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPrimary)
	  }
}
/**
 * is implemented by <b>EnumBody</b>
 */
type IEnumBody interface{
IRootForJavaParser
}

func AnyCastToIEnumBody(i interface{}) IEnumBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>EnumConstants
 *<li>EnumConstant
 *</ul>
 *</b>
 */
type IEnumConstantsopt interface{
IRootForJavaParser
}

func AnyCastToIEnumConstantsopt(i interface{}) IEnumConstantsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumConstantsopt)
	  }
}
/**
 * is implemented by <b>EnumBodyDeclarations</b>
 */
type IEnumBodyDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIEnumBodyDeclarationsopt(i interface{}) IEnumBodyDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumBodyDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>EnumConstants
 *<li>EnumConstant
 *</ul>
 *</b>
 */
type IEnumConstants interface{
IEnumConstantsopt
}

func AnyCastToIEnumConstants(i interface{}) IEnumConstants {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumConstants)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>EnumConstant
 *</ul>
 *</b>
 */
type IEnumConstant interface{
IEnumConstants
}

func AnyCastToIEnumConstant(i interface{}) IEnumConstant {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumConstant)
	  }
}
/**
 * is implemented by <b>Arguments</b>
 */
type IArgumentsopt interface{
IRootForJavaParser
}

func AnyCastToIArgumentsopt(i interface{}) IArgumentsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArgumentsopt)
	  }
}
/**
 * is implemented by <b>ClassBody</b>
 */
type IClassBodyopt interface{
IRootForJavaParser
}

func AnyCastToIClassBodyopt(i interface{}) IClassBodyopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassBodyopt)
	  }
}
/**
 * is implemented by <b>Arguments</b>
 */
type IArguments interface{
IArgumentsopt
}

func AnyCastToIArguments(i interface{}) IArguments {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArguments)
	  }
}
/**
 * is implemented by <b>EnumBodyDeclarations</b>
 */
type IEnumBodyDeclarations interface{
IEnumBodyDeclarationsopt
}

func AnyCastToIEnumBodyDeclarations(i interface{}) IEnumBodyDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnumBodyDeclarations)
	  }
}
/**
 * is implemented by <b>NormalInterfaceDeclaration</b>
 */
type INormalInterfaceDeclaration interface{
IInterfaceDeclaration
}

func AnyCastToINormalInterfaceDeclaration(i interface{}) INormalInterfaceDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(INormalInterfaceDeclaration)
	  }
}
/**
 * is implemented by <b>AnnotationTypeDeclaration</b>
 */
type IAnnotationTypeDeclaration interface{
IInterfaceDeclaration
IAnnotationTypeElementDeclaration
}

func AnyCastToIAnnotationTypeDeclaration(i interface{}) IAnnotationTypeDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>InterfaceModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>InterfaceModifier0
 *<li>InterfaceModifier1
 *<li>InterfaceModifier2
 *<li>InterfaceModifier3
 *<li>InterfaceModifier4
 *<li>InterfaceModifier5
 *</ul>
 *</b>
 */
type IInterfaceModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIInterfaceModifiersopt(i interface{}) IInterfaceModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ExtendsInterfaces0
 *<li>ExtendsInterfaces1
 *</ul>
 *</b>
 */
type IExtendsInterfacesopt interface{
IRootForJavaParser
}

func AnyCastToIExtendsInterfacesopt(i interface{}) IExtendsInterfacesopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExtendsInterfacesopt)
	  }
}
/**
 * is implemented by <b>InterfaceBody</b>
 */
type IInterfaceBody interface{
IRootForJavaParser
}

func AnyCastToIInterfaceBody(i interface{}) IInterfaceBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>InterfaceModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>InterfaceModifier0
 *<li>InterfaceModifier1
 *<li>InterfaceModifier2
 *<li>InterfaceModifier3
 *<li>InterfaceModifier4
 *<li>InterfaceModifier5
 *</ul>
 *</b>
 */
type IInterfaceModifiers interface{
IInterfaceModifiersopt
}

func AnyCastToIInterfaceModifiers(i interface{}) IInterfaceModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>InterfaceModifier0
 *<li>InterfaceModifier1
 *<li>InterfaceModifier2
 *<li>InterfaceModifier3
 *<li>InterfaceModifier4
 *<li>InterfaceModifier5
 *</ul>
 *</b>
 */
type IInterfaceModifier interface{
IInterfaceModifiers
IAstToken
}

func AnyCastToIInterfaceModifier(i interface{}) IInterfaceModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ExtendsInterfaces0
 *<li>ExtendsInterfaces1
 *</ul>
 *</b>
 */
type IExtendsInterfaces interface{
IExtendsInterfacesopt
}

func AnyCastToIExtendsInterfaces(i interface{}) IExtendsInterfaces {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExtendsInterfaces)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>InterfaceMemberDeclarations
 *<li>InterfaceMemberDeclaration
 *<li>ConstantDeclaration
 *<li>AbstractMethodDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IInterfaceMemberDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIInterfaceMemberDeclarationsopt(i interface{}) IInterfaceMemberDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceMemberDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>InterfaceMemberDeclarations
 *<li>InterfaceMemberDeclaration
 *<li>ConstantDeclaration
 *<li>AbstractMethodDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IInterfaceMemberDeclarations interface{
IInterfaceMemberDeclarationsopt
}

func AnyCastToIInterfaceMemberDeclarations(i interface{}) IInterfaceMemberDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceMemberDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>InterfaceMemberDeclaration
 *<li>ConstantDeclaration
 *<li>AbstractMethodDeclaration
 *<li>AnnotationTypeDeclaration
 *</ul>
 *</b>
 */
type IInterfaceMemberDeclaration interface{
IInterfaceMemberDeclarations
IAstToken
}

func AnyCastToIInterfaceMemberDeclaration(i interface{}) IInterfaceMemberDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInterfaceMemberDeclaration)
	  }
}
/**
 * is implemented by <b>ConstantDeclaration</b>
 */
type IConstantDeclaration interface{
IInterfaceMemberDeclaration
IAnnotationTypeElementDeclaration
}

func AnyCastToIConstantDeclaration(i interface{}) IConstantDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantDeclaration)
	  }
}
/**
 * is implemented by <b>AbstractMethodDeclaration</b>
 */
type IAbstractMethodDeclaration interface{
IInterfaceMemberDeclaration
}

func AnyCastToIAbstractMethodDeclaration(i interface{}) IAbstractMethodDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAbstractMethodDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ConstantModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstantModifier0
 *<li>ConstantModifier1
 *<li>ConstantModifier2
 *</ul>
 *</b>
 */
type IConstantModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIConstantModifiersopt(i interface{}) IConstantModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ConstantModifiers
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstantModifier0
 *<li>ConstantModifier1
 *<li>ConstantModifier2
 *</ul>
 *</b>
 */
type IConstantModifiers interface{
IConstantModifiersopt
}

func AnyCastToIConstantModifiers(i interface{}) IConstantModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>ConstantModifier0
 *<li>ConstantModifier1
 *<li>ConstantModifier2
 *</ul>
 *</b>
 */
type IConstantModifier interface{
IConstantModifiers
IAstToken
}

func AnyCastToIConstantModifier(i interface{}) IConstantModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantModifier)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AbstractMethodModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>AbstractMethodModifier0
 *<li>AbstractMethodModifier1
 *</ul>
 *</b>
 */
type IAbstractMethodModifiersopt interface{
IRootForJavaParser
}

func AnyCastToIAbstractMethodModifiersopt(i interface{}) IAbstractMethodModifiersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAbstractMethodModifiersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AbstractMethodModifiers
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>AbstractMethodModifier0
 *<li>AbstractMethodModifier1
 *</ul>
 *</b>
 */
type IAbstractMethodModifiers interface{
IAbstractMethodModifiersopt
}

func AnyCastToIAbstractMethodModifiers(i interface{}) IAbstractMethodModifiers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAbstractMethodModifiers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Annotations
 *<li>NormalAnnotation
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>AbstractMethodModifier0
 *<li>AbstractMethodModifier1
 *</ul>
 *</b>
 */
type IAbstractMethodModifier interface{
IAbstractMethodModifiers
IAstToken
}

func AnyCastToIAbstractMethodModifier(i interface{}) IAbstractMethodModifier {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAbstractMethodModifier)
	  }
}
/**
 * is implemented by <b>AnnotationTypeBody</b>
 */
type IAnnotationTypeBody interface{
IRootForJavaParser
}

func AnyCastToIAnnotationTypeBody(i interface{}) IAnnotationTypeBody {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeBody)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>ConstantDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>AnnotationTypeElementDeclarations
 *<li>AnnotationTypeElementDeclaration0
 *<li>AnnotationTypeElementDeclaration1
 *</ul>
 *</b>
 */
type IAnnotationTypeElementDeclarationsopt interface{
IRootForJavaParser
}

func AnyCastToIAnnotationTypeElementDeclarationsopt(i interface{}) IAnnotationTypeElementDeclarationsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeElementDeclarationsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>ConstantDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>AnnotationTypeElementDeclarations
 *<li>AnnotationTypeElementDeclaration0
 *<li>AnnotationTypeElementDeclaration1
 *</ul>
 *</b>
 */
type IAnnotationTypeElementDeclarations interface{
IAnnotationTypeElementDeclarationsopt
}

func AnyCastToIAnnotationTypeElementDeclarations(i interface{}) IAnnotationTypeElementDeclarations {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeElementDeclarations)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>NormalInterfaceDeclaration
 *<li>ConstantDeclaration
 *<li>AnnotationTypeDeclaration
 *<li>AnnotationTypeElementDeclaration0
 *<li>AnnotationTypeElementDeclaration1
 *</ul>
 *</b>
 */
type IAnnotationTypeElementDeclaration interface{
IAnnotationTypeElementDeclarations
IAstToken
}

func AnyCastToIAnnotationTypeElementDeclaration(i interface{}) IAnnotationTypeElementDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAnnotationTypeElementDeclaration)
	  }
}
/**
 * is implemented by <b>DefaultValue</b>
 */
type IDefaultValueopt interface{
IRootForJavaParser
}

func AnyCastToIDefaultValueopt(i interface{}) IDefaultValueopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDefaultValueopt)
	  }
}
/**
 * is implemented by <b>DefaultValue</b>
 */
type IDefaultValue interface{
IDefaultValueopt
}

func AnyCastToIDefaultValue(i interface{}) IDefaultValue {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDefaultValue)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>NormalAnnotation
 *<li>ElementValueArrayInitializer
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IElementValue interface{
IElementValues
}

func AnyCastToIElementValue(i interface{}) IElementValue {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValue)
	  }
}
/**
 * is implemented by <b>NormalAnnotation</b>
 */
type INormalAnnotation interface{
IAnnotation
}

func AnyCastToINormalAnnotation(i interface{}) INormalAnnotation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(INormalAnnotation)
	  }
}
/**
 * is implemented by <b>MarkerAnnotation</b>
 */
type IMarkerAnnotation interface{
IAnnotation
}

func AnyCastToIMarkerAnnotation(i interface{}) IMarkerAnnotation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMarkerAnnotation)
	  }
}
/**
 * is implemented by <b>SingleElementAnnotation</b>
 */
type ISingleElementAnnotation interface{
IAnnotation
}

func AnyCastToISingleElementAnnotation(i interface{}) ISingleElementAnnotation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISingleElementAnnotation)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ElementValuePairs
 *<li>ElementValuePair
 *</ul>
 *</b>
 */
type IElementValuePairsopt interface{
IRootForJavaParser
}

func AnyCastToIElementValuePairsopt(i interface{}) IElementValuePairsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValuePairsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ElementValuePairs
 *<li>ElementValuePair
 *</ul>
 *</b>
 */
type IElementValuePairs interface{
IElementValuePairsopt
}

func AnyCastToIElementValuePairs(i interface{}) IElementValuePairs {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValuePairs)
	  }
}
/**
 * is implemented by <b>ElementValuePair</b>
 */
type IElementValuePair interface{
IElementValuePairs
}

func AnyCastToIElementValuePair(i interface{}) IElementValuePair {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValuePair)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type ISimpleName interface{
IRootForJavaParser
}

func AnyCastToISimpleName(i interface{}) ISimpleName {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISimpleName)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IConditionalExpression interface{
IElementValue
IAssignmentExpression
}

func AnyCastToIConditionalExpression(i interface{}) IConditionalExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConditionalExpression)
	  }
}
/**
 * is implemented by <b>ElementValueArrayInitializer</b>
 */
type IElementValueArrayInitializer interface{
IElementValue
}

func AnyCastToIElementValueArrayInitializer(i interface{}) IElementValueArrayInitializer {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValueArrayInitializer)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>NormalAnnotation
 *<li>ElementValueArrayInitializer
 *<li>ElementValues
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IElementValuesopt interface{
IRootForJavaParser
}

func AnyCastToIElementValuesopt(i interface{}) IElementValuesopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValuesopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>NormalAnnotation
 *<li>ElementValueArrayInitializer
 *<li>ElementValues
 *<li>MarkerAnnotation
 *<li>SingleElementAnnotation
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IElementValues interface{
IElementValuesopt
}

func AnyCastToIElementValues(i interface{}) IElementValues {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IElementValues)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArrayInitializer
 *<li>VariableInitializers
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IVariableInitializersopt interface{
IRootForJavaParser
}

func AnyCastToIVariableInitializersopt(i interface{}) IVariableInitializersopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableInitializersopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArrayInitializer
 *<li>VariableInitializers
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IVariableInitializers interface{
IVariableInitializersopt
}

func AnyCastToIVariableInitializers(i interface{}) IVariableInitializers {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IVariableInitializers)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>Block
 *<li>BlockStatements
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IBlockStatements interface{
IBlockStatementsopt
}

func AnyCastToIBlockStatements(i interface{}) IBlockStatements {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBlockStatements)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>NormalClassDeclaration
 *<li>EnumDeclaration
 *<li>Block
 *<li>LocalVariableDeclarationStatement
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IBlockStatement interface{
IBlockStatements
}

func AnyCastToIBlockStatement(i interface{}) IBlockStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBlockStatement)
	  }
}
/**
 * is implemented by <b>LocalVariableDeclarationStatement</b>
 */
type ILocalVariableDeclarationStatement interface{
IBlockStatement
}

func AnyCastToILocalVariableDeclarationStatement(i interface{}) ILocalVariableDeclarationStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILocalVariableDeclarationStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Block
 *<li>IfThenStatement
 *<li>IfThenElseStatement
 *<li>EmptyStatement
 *<li>LabeledStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatement
 *<li>DoStatement
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IStatement interface{
IBlockStatement
}

func AnyCastToIStatement(i interface{}) IStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatement)
	  }
}
/**
 * is implemented by <b>LocalVariableDeclaration</b>
 */
type ILocalVariableDeclaration interface{
IForInit
}

func AnyCastToILocalVariableDeclaration(i interface{}) ILocalVariableDeclaration {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILocalVariableDeclaration)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Block
 *<li>EmptyStatement
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>DoStatement
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IStatementWithoutTrailingSubstatement interface{
IStatement
IStatementNoShortIf
}

func AnyCastToIStatementWithoutTrailingSubstatement(i interface{}) IStatementWithoutTrailingSubstatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatementWithoutTrailingSubstatement)
	  }
}
/**
 * is implemented by <b>LabeledStatement</b>
 */
type ILabeledStatement interface{
IStatement
}

func AnyCastToILabeledStatement(i interface{}) ILabeledStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILabeledStatement)
	  }
}
/**
 * is implemented by <b>IfThenStatement</b>
 */
type IIfThenStatement interface{
IStatement
}

func AnyCastToIIfThenStatement(i interface{}) IIfThenStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IIfThenStatement)
	  }
}
/**
 * is implemented by <b>IfThenElseStatement</b>
 */
type IIfThenElseStatement interface{
IStatement
}

func AnyCastToIIfThenElseStatement(i interface{}) IIfThenElseStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IIfThenElseStatement)
	  }
}
/**
 * is implemented by <b>WhileStatement</b>
 */
type IWhileStatement interface{
IStatement
}

func AnyCastToIWhileStatement(i interface{}) IWhileStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWhileStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>BasicForStatement
 *<li>EnhancedForStatement
 *</ul>
 *</b>
 */
type IForStatement interface{
IStatement
}

func AnyCastToIForStatement(i interface{}) IForStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForStatement)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>EmptyStatement</b>
 */
type IEmptyStatement interface{
IStatementWithoutTrailingSubstatement
IAstToken
}

func AnyCastToIEmptyStatement(i interface{}) IEmptyStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEmptyStatement)
	  }
}
/**
 * is implemented by <b>ExpressionStatement</b>
 */
type IExpressionStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIExpressionStatement(i interface{}) IExpressionStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExpressionStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AssertStatement0
 *<li>AssertStatement1
 *</ul>
 *</b>
 */
type IAssertStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIAssertStatement(i interface{}) IAssertStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAssertStatement)
	  }
}
/**
 * is implemented by <b>SwitchStatement</b>
 */
type ISwitchStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToISwitchStatement(i interface{}) ISwitchStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchStatement)
	  }
}
/**
 * is implemented by <b>DoStatement</b>
 */
type IDoStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIDoStatement(i interface{}) IDoStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDoStatement)
	  }
}
/**
 * is implemented by <b>BreakStatement</b>
 */
type IBreakStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIBreakStatement(i interface{}) IBreakStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBreakStatement)
	  }
}
/**
 * is implemented by <b>ContinueStatement</b>
 */
type IContinueStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIContinueStatement(i interface{}) IContinueStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IContinueStatement)
	  }
}
/**
 * is implemented by <b>ReturnStatement</b>
 */
type IReturnStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIReturnStatement(i interface{}) IReturnStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IReturnStatement)
	  }
}
/**
 * is implemented by <b>SynchronizedStatement</b>
 */
type ISynchronizedStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToISynchronizedStatement(i interface{}) ISynchronizedStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISynchronizedStatement)
	  }
}
/**
 * is implemented by <b>ThrowStatement</b>
 */
type IThrowStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToIThrowStatement(i interface{}) IThrowStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IThrowStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type ITryStatement interface{
IStatementWithoutTrailingSubstatement
}

func AnyCastToITryStatement(i interface{}) ITryStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ITryStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Block
 *<li>IfThenElseStatementNoShortIf
 *<li>EmptyStatement
 *<li>LabeledStatementNoShortIf
 *<li>ExpressionStatement
 *<li>SwitchStatement
 *<li>WhileStatementNoShortIf
 *<li>DoStatement
 *<li>ForStatementNoShortIf
 *<li>BreakStatement
 *<li>ContinueStatement
 *<li>ReturnStatement
 *<li>ThrowStatement
 *<li>SynchronizedStatement
 *<li>AssertStatement0
 *<li>AssertStatement1
 *<li>TryStatement0
 *<li>TryStatement1
 *</ul>
 *</b>
 */
type IStatementNoShortIf interface{
IRootForJavaParser
}

func AnyCastToIStatementNoShortIf(i interface{}) IStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatementNoShortIf)
	  }
}
/**
 * is implemented by <b>LabeledStatementNoShortIf</b>
 */
type ILabeledStatementNoShortIf interface{
IStatementNoShortIf
}

func AnyCastToILabeledStatementNoShortIf(i interface{}) ILabeledStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILabeledStatementNoShortIf)
	  }
}
/**
 * is implemented by <b>IfThenElseStatementNoShortIf</b>
 */
type IIfThenElseStatementNoShortIf interface{
IStatementNoShortIf
}

func AnyCastToIIfThenElseStatementNoShortIf(i interface{}) IIfThenElseStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IIfThenElseStatementNoShortIf)
	  }
}
/**
 * is implemented by <b>WhileStatementNoShortIf</b>
 */
type IWhileStatementNoShortIf interface{
IStatementNoShortIf
}

func AnyCastToIWhileStatementNoShortIf(i interface{}) IWhileStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IWhileStatementNoShortIf)
	  }
}
/**
 * is implemented by <b>ForStatementNoShortIf</b>
 */
type IForStatementNoShortIf interface{
IStatementNoShortIf
}

func AnyCastToIForStatementNoShortIf(i interface{}) IForStatementNoShortIf {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForStatementNoShortIf)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IStatementExpression interface{
IStatementExpressionList
}

func AnyCastToIStatementExpression(i interface{}) IStatementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatementExpression)
	  }
}
/**
 * is implemented by <b>Assignment</b>
 */
type IAssignment interface{
IStatementExpression
IAssignmentExpression
}

func AnyCastToIAssignment(i interface{}) IAssignment {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAssignment)
	  }
}
/**
 * is implemented by <b>PreIncrementExpression</b>
 */
type IPreIncrementExpression interface{
IStatementExpression
IUnaryExpression
}

func AnyCastToIPreIncrementExpression(i interface{}) IPreIncrementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPreIncrementExpression)
	  }
}
/**
 * is implemented by <b>PreDecrementExpression</b>
 */
type IPreDecrementExpression interface{
IStatementExpression
IUnaryExpression
}

func AnyCastToIPreDecrementExpression(i interface{}) IPreDecrementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPreDecrementExpression)
	  }
}
/**
 * is implemented by <b>PostIncrementExpression</b>
 */
type IPostIncrementExpression interface{
IStatementExpression
IPostfixExpression
}

func AnyCastToIPostIncrementExpression(i interface{}) IPostIncrementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPostIncrementExpression)
	  }
}
/**
 * is implemented by <b>PostDecrementExpression</b>
 */
type IPostDecrementExpression interface{
IStatementExpression
IPostfixExpression
}

func AnyCastToIPostDecrementExpression(i interface{}) IPostDecrementExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPostDecrementExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IMethodInvocation interface{
IStatementExpression
IPrimaryNoNewArray
}

func AnyCastToIMethodInvocation(i interface{}) IMethodInvocation {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMethodInvocation)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *</ul>
 *</b>
 */
type IClassInstanceCreationExpression interface{
IStatementExpression
IPrimaryNoNewArray
}

func AnyCastToIClassInstanceCreationExpression(i interface{}) IClassInstanceCreationExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IClassInstanceCreationExpression)
	  }
}
/**
 * is implemented by <b>SwitchBlock</b>
 */
type ISwitchBlock interface{
IRootForJavaParser
}

func AnyCastToISwitchBlock(i interface{}) ISwitchBlock {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchBlock)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchBlockStatementGroups
 *<li>SwitchBlockStatementGroup
 *</ul>
 *</b>
 */
type ISwitchBlockStatementGroupsopt interface{
IRootForJavaParser
}

func AnyCastToISwitchBlockStatementGroupsopt(i interface{}) ISwitchBlockStatementGroupsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchBlockStatementGroupsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchLabels
 *<li>SwitchLabel0
 *<li>SwitchLabel1
 *<li>SwitchLabel2
 *</ul>
 *</b>
 */
type ISwitchLabelsopt interface{
IRootForJavaParser
}

func AnyCastToISwitchLabelsopt(i interface{}) ISwitchLabelsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchLabelsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchBlockStatementGroups
 *<li>SwitchBlockStatementGroup
 *</ul>
 *</b>
 */
type ISwitchBlockStatementGroups interface{
ISwitchBlockStatementGroupsopt
}

func AnyCastToISwitchBlockStatementGroups(i interface{}) ISwitchBlockStatementGroups {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchBlockStatementGroups)
	  }
}
/**
 * is implemented by <b>SwitchBlockStatementGroup</b>
 */
type ISwitchBlockStatementGroup interface{
ISwitchBlockStatementGroups
}

func AnyCastToISwitchBlockStatementGroup(i interface{}) ISwitchBlockStatementGroup {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchBlockStatementGroup)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchLabels
 *<li>SwitchLabel0
 *<li>SwitchLabel1
 *<li>SwitchLabel2
 *</ul>
 *</b>
 */
type ISwitchLabels interface{
ISwitchLabelsopt
}

func AnyCastToISwitchLabels(i interface{}) ISwitchLabels {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchLabels)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>SwitchLabel0
 *<li>SwitchLabel1
 *<li>SwitchLabel2
 *</ul>
 *</b>
 */
type ISwitchLabel interface{
ISwitchLabels
}

func AnyCastToISwitchLabel(i interface{}) ISwitchLabel {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ISwitchLabel)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IConstantExpression interface{
IRootForJavaParser
}

func AnyCastToIConstantExpression(i interface{}) IConstantExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConstantExpression)
	  }
}
/**
 * is implemented by <b>BasicForStatement</b>
 */
type IBasicForStatement interface{
IForStatement
}

func AnyCastToIBasicForStatement(i interface{}) IBasicForStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBasicForStatement)
	  }
}
/**
 * is implemented by <b>EnhancedForStatement</b>
 */
type IEnhancedForStatement interface{
IForStatement
}

func AnyCastToIEnhancedForStatement(i interface{}) IEnhancedForStatement {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEnhancedForStatement)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>LocalVariableDeclaration
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IForInitopt interface{
IRootForJavaParser
}

func AnyCastToIForInitopt(i interface{}) IForInitopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForInitopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IExpressionopt interface{
IRootForJavaParser
}

func AnyCastToIExpressionopt(i interface{}) IExpressionopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExpressionopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IForUpdateopt interface{
IRootForJavaParser
}

func AnyCastToIForUpdateopt(i interface{}) IForUpdateopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForUpdateopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>LocalVariableDeclaration
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IForInit interface{
IForInitopt
}

func AnyCastToIForInit(i interface{}) IForInit {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForInit)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IStatementExpressionList interface{
IForInit
IForUpdate
}

func AnyCastToIStatementExpressionList(i interface{}) IStatementExpressionList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IStatementExpressionList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>StatementExpressionList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>Assignment
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *</ul>
 *</b>
 */
type IForUpdate interface{
IForUpdateopt
}

func AnyCastToIForUpdate(i interface{}) IForUpdate {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IForUpdate)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by <b>identifier</b>
 */
type Iidentifieropt interface{
IRootForJavaParser
}

func AnyCastToIidentifieropt(i interface{}) Iidentifieropt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(Iidentifieropt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Catches
 *<li>CatchClause
 *</ul>
 *</b>
 */
type ICatches interface{
ICatchesopt
}

func AnyCastToICatches(i interface{}) ICatches {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICatches)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Catches
 *<li>CatchClause
 *</ul>
 *</b>
 */
type ICatchesopt interface{
IRootForJavaParser
}

func AnyCastToICatchesopt(i interface{}) ICatchesopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICatchesopt)
	  }
}
/**
 * is implemented by <b>Finally</b>
 */
type IFinally interface{
IRootForJavaParser
}

func AnyCastToIFinally(i interface{}) IFinally {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFinally)
	  }
}
/**
 * is implemented by <b>CatchClause</b>
 */
type ICatchClause interface{
ICatches
}

func AnyCastToICatchClause(i interface{}) ICatchClause {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICatchClause)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type IPrimaryNoNewArray interface{
IPrimary
IAstToken
}

func AnyCastToIPrimaryNoNewArray(i interface{}) IPrimaryNoNewArray {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPrimaryNoNewArray)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *</ul>
 *</b>
 */
type IArrayCreationExpression interface{
IPrimary
}

func AnyCastToIArrayCreationExpression(i interface{}) IArrayCreationExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArrayCreationExpression)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *</ul>
 *</b>
 */
type ILiteral interface{
IPrimaryNoNewArray
IAstToken
}

func AnyCastToILiteral(i interface{}) ILiteral {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILiteral)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *</ul>
 *</b>
 */
type IFieldAccess interface{
IPrimaryNoNewArray
ILeftHandSide
}

func AnyCastToIFieldAccess(i interface{}) IFieldAccess {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IFieldAccess)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type IArrayAccess interface{
IPrimaryNoNewArray
ILeftHandSide
}

func AnyCastToIArrayAccess(i interface{}) IArrayAccess {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArrayAccess)
	  }
}
/**
 * is always implemented by <b>AstToken</b>. It is also implemented by:
 *<b>
 *<ul>
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *</ul>
 *</b>
 */
type IBooleanLiteral interface{
ILiteral
IAstToken
}

func AnyCastToIBooleanLiteral(i interface{}) IBooleanLiteral {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IBooleanLiteral)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>ArgumentList
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IArgumentList interface{
IArgumentListopt
}

func AnyCastToIArgumentList(i interface{}) IArgumentList {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IArgumentList)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>DimExprs
 *<li>DimExpr
 *</ul>
 *</b>
 */
type IDimExprs interface{
IRootForJavaParser
}

func AnyCastToIDimExprs(i interface{}) IDimExprs {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDimExprs)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Dims0
 *<li>Dims1
 *</ul>
 *</b>
 */
type IDimsopt interface{
IRootForJavaParser
}

func AnyCastToIDimsopt(i interface{}) IDimsopt {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDimsopt)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>Dims0
 *<li>Dims1
 *</ul>
 *</b>
 */
type IDims interface{
IDimsopt
}

func AnyCastToIDims(i interface{}) IDims {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDims)
	  }
}
/**
 * is implemented by <b>DimExpr</b>
 */
type IDimExpr interface{
IDimExprs
}

func AnyCastToIDimExpr(i interface{}) IDimExpr {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IDimExpr)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type IPostfixExpression interface{
IUnaryExpressionNotPlusMinus
}

func AnyCastToIPostfixExpression(i interface{}) IPostfixExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IPostfixExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *</ul>
 *</b>
 */
type IUnaryExpression interface{
IMultiplicativeExpression
}

func AnyCastToIUnaryExpression(i interface{}) IUnaryExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IUnaryExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *</ul>
 *</b>
 */
type IUnaryExpressionNotPlusMinus interface{
IUnaryExpression
}

func AnyCastToIUnaryExpressionNotPlusMinus(i interface{}) IUnaryExpressionNotPlusMinus {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IUnaryExpressionNotPlusMinus)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>CastExpression0
 *<li>CastExpression1
 *</ul>
 *</b>
 */
type ICastExpression interface{
IUnaryExpressionNotPlusMinus
}

func AnyCastToICastExpression(i interface{}) ICastExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ICastExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *</ul>
 *</b>
 */
type IMultiplicativeExpression interface{
IAdditiveExpression
}

func AnyCastToIMultiplicativeExpression(i interface{}) IMultiplicativeExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IMultiplicativeExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *</ul>
 *</b>
 */
type IAdditiveExpression interface{
IShiftExpression
}

func AnyCastToIAdditiveExpression(i interface{}) IAdditiveExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAdditiveExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *</ul>
 *</b>
 */
type IShiftExpression interface{
IRelationalExpression
}

func AnyCastToIShiftExpression(i interface{}) IShiftExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IShiftExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *</ul>
 *</b>
 */
type IRelationalExpression interface{
IEqualityExpression
}

func AnyCastToIRelationalExpression(i interface{}) IRelationalExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IRelationalExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IEqualityExpression interface{
IAndExpression
}

func AnyCastToIEqualityExpression(i interface{}) IEqualityExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IEqualityExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IAndExpression interface{
IExclusiveOrExpression
}

func AnyCastToIAndExpression(i interface{}) IAndExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAndExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IExclusiveOrExpression interface{
IInclusiveOrExpression
}

func AnyCastToIExclusiveOrExpression(i interface{}) IExclusiveOrExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IExclusiveOrExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IInclusiveOrExpression interface{
IConditionalAndExpression
}

func AnyCastToIInclusiveOrExpression(i interface{}) IInclusiveOrExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IInclusiveOrExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IConditionalAndExpression interface{
IConditionalOrExpression
}

func AnyCastToIConditionalAndExpression(i interface{}) IConditionalAndExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConditionalAndExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IConditionalOrExpression interface{
IConditionalExpression
}

func AnyCastToIConditionalOrExpression(i interface{}) IConditionalOrExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IConditionalOrExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>PostIncrementExpression
 *<li>PostDecrementExpression
 *<li>PreIncrementExpression
 *<li>PreDecrementExpression
 *<li>AndExpression
 *<li>ExclusiveOrExpression
 *<li>InclusiveOrExpression
 *<li>ConditionalAndExpression
 *<li>ConditionalOrExpression
 *<li>ConditionalExpression
 *<li>Assignment
 *<li>PrimaryNoNewArray0
 *<li>PrimaryNoNewArray1
 *<li>PrimaryNoNewArray2
 *<li>PrimaryNoNewArray3
 *<li>PrimaryNoNewArray4
 *<li>Literal0
 *<li>Literal1
 *<li>Literal2
 *<li>Literal3
 *<li>Literal4
 *<li>Literal5
 *<li>Literal6
 *<li>BooleanLiteral0
 *<li>BooleanLiteral1
 *<li>ClassInstanceCreationExpression0
 *<li>ClassInstanceCreationExpression1
 *<li>ArrayCreationExpression0
 *<li>ArrayCreationExpression1
 *<li>ArrayCreationExpression2
 *<li>ArrayCreationExpression3
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>MethodInvocation0
 *<li>MethodInvocation1
 *<li>MethodInvocation2
 *<li>MethodInvocation3
 *<li>MethodInvocation4
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *<li>UnaryExpression0
 *<li>UnaryExpression1
 *<li>UnaryExpressionNotPlusMinus0
 *<li>UnaryExpressionNotPlusMinus1
 *<li>CastExpression0
 *<li>CastExpression1
 *<li>MultiplicativeExpression0
 *<li>MultiplicativeExpression1
 *<li>MultiplicativeExpression2
 *<li>AdditiveExpression0
 *<li>AdditiveExpression1
 *<li>ShiftExpression0
 *<li>ShiftExpression1
 *<li>ShiftExpression2
 *<li>RelationalExpression0
 *<li>RelationalExpression1
 *<li>RelationalExpression2
 *<li>RelationalExpression3
 *<li>RelationalExpression4
 *<li>EqualityExpression0
 *<li>EqualityExpression1
 *</ul>
 *</b>
 */
type IAssignmentExpression interface{
IExpression
}

func AnyCastToIAssignmentExpression(i interface{}) IAssignmentExpression {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAssignmentExpression)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>identifier
 *<li>ExpressionName
 *<li>FieldAccess0
 *<li>FieldAccess1
 *<li>FieldAccess2
 *<li>ArrayAccess0
 *<li>ArrayAccess1
 *</ul>
 *</b>
 */
type ILeftHandSide interface{
IRootForJavaParser
}

func AnyCastToILeftHandSide(i interface{}) ILeftHandSide {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ILeftHandSide)
	  }
}
/**
 * is implemented by:
 *<b>
 *<ul>
 *<li>AssignmentOperator0
 *<li>AssignmentOperator1
 *<li>AssignmentOperator2
 *<li>AssignmentOperator3
 *<li>AssignmentOperator4
 *<li>AssignmentOperator5
 *<li>AssignmentOperator6
 *<li>AssignmentOperator7
 *<li>AssignmentOperator8
 *<li>AssignmentOperator9
 *<li>AssignmentOperator10
 *<li>AssignmentOperator11
 *</ul>
 *</b>
 */
type IAssignmentOperator interface{
IAstToken
}

func AnyCastToIAssignmentOperator(i interface{}) IAssignmentOperator {
	  if nil == i{
		 return nil
	  }else{
		 return i.(IAssignmentOperator)
	  }
}
/**
 *<b>
*<li>Rule 3:  identifier ::= IDENTIFIER
 *</b>
 */
type identifier struct{
    *AstToken
     environment *JavaParser
}
func (my *identifier)     GetEnvironment() *JavaParser{ return my.environment }

func (my *identifier)      GetIDENTIFIER()IToken{ return my.leftIToken; }

func Newidentifier(environment *JavaParser,token IToken )*identifier{
      my := new(identifier)
      my.environment = environment;
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *identifier)      AcceptWithVisitor(v Visitor) { v.Visitidentifier(my)}
func (my *identifier)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitidentifierWithArg(my, o) }
func (my *identifier)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitidentifierWithResult(my) }
func (my *identifier)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitidentifierWithResultArgument(my, o) }


func AnyCastToidentifier(i interface{}) *identifier {
	if nil == i{
		return nil
	}else{
		return i.(*identifier)
	}
}
/**
 *<em>
*<li>Rule 12:  PrimitiveType ::= NumericType
 *</em>
 *<p>
 *<b>
*<li>Rule 13:  PrimitiveType ::= boolean
 *</b>
 */
type PrimitiveType struct{
    *AstToken
}
func (my *PrimitiveType)      Getboolean()IToken{ return my.leftIToken; }

func NewPrimitiveType(token IToken )*PrimitiveType{
      my := new(PrimitiveType)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *PrimitiveType)      AcceptWithVisitor(v Visitor) { v.VisitPrimitiveType(my)}
func (my *PrimitiveType)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPrimitiveTypeWithArg(my, o) }
func (my *PrimitiveType)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPrimitiveTypeWithResult(my) }
func (my *PrimitiveType)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPrimitiveTypeWithResultArgument(my, o) }


func AnyCastToPrimitiveType(i interface{}) *PrimitiveType {
	if nil == i{
		return nil
	}else{
		return i.(*PrimitiveType)
	}
}
/**
 *<b>
*<li>Rule 27:  ClassType ::= TypeName TypeArgumentsopt
 *</b>
 */
type ClassType struct{
    *Ast
      _TypeName ITypeName
      _TypeArgumentsopt *TypeArguments
}
func (my *ClassType)      GetTypeName() ITypeName{ return my._TypeName}
func (my *ClassType)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ClassType)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ClassType)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }

func NewClassType(leftIToken IToken, rightIToken IToken ,
              _TypeName ITypeName,
              _TypeArgumentsopt *TypeArguments)*ClassType{
      my := new(ClassType)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassType)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        return list
    }

func (my *ClassType)      AcceptWithVisitor(v Visitor) { v.VisitClassType(my)}
func (my *ClassType)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassTypeWithArg(my, o) }
func (my *ClassType)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassTypeWithResult(my) }
func (my *ClassType)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassTypeWithResultArgument(my, o) }


func AnyCastToClassType(i interface{}) *ClassType {
	if nil == i{
		return nil
	}else{
		return i.(*ClassType)
	}
}
/**
 *<b>
*<li>Rule 28:  InterfaceType ::= TypeName TypeArgumentsopt
 *</b>
 */
type InterfaceType struct{
    *Ast
      _TypeName ITypeName
      _TypeArgumentsopt *TypeArguments
}
func (my *InterfaceType)      GetTypeName() ITypeName{ return my._TypeName}
func (my *InterfaceType)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *InterfaceType)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *InterfaceType)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }

func NewInterfaceType(leftIToken IToken, rightIToken IToken ,
              _TypeName ITypeName,
              _TypeArgumentsopt *TypeArguments)*InterfaceType{
      my := new(InterfaceType)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceType)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        return list
    }

func (my *InterfaceType)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceType(my)}
func (my *InterfaceType)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceTypeWithArg(my, o) }
func (my *InterfaceType)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceTypeWithResult(my) }
func (my *InterfaceType)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceTypeWithResultArgument(my, o) }


func AnyCastToInterfaceType(i interface{}) *InterfaceType {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceType)
	}
}
/**
 *<em>
*<li>Rule 29:  TypeName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 30:  TypeName ::= TypeName . identifier
 *</b>
 */
type TypeName struct{
    *Ast
      _TypeName ITypeName
      _DOT *AstToken
      _identifier *identifier
}
func (my *TypeName)      GetTypeName() ITypeName{ return my._TypeName}
func (my *TypeName)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *TypeName)      GetDOT() *AstToken{ return my._DOT}
func (my *TypeName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *TypeName)      Getidentifier() *identifier{ return my._identifier}
func (my *TypeName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewTypeName(leftIToken IToken, rightIToken IToken ,
              _TypeName ITypeName,
              _DOT *AstToken,
              _identifier *identifier)*TypeName{
      my := new(TypeName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *TypeName)      AcceptWithVisitor(v Visitor) { v.VisitTypeName(my)}
func (my *TypeName)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeNameWithArg(my, o) }
func (my *TypeName)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeNameWithResult(my) }
func (my *TypeName)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeNameWithResultArgument(my, o) }


func AnyCastToTypeName(i interface{}) *TypeName {
	if nil == i{
		return nil
	}else{
		return i.(*TypeName)
	}
}
/**
 *<b>
*<li>Rule 33:  ArrayType ::= Type [ ]
 *</b>
 */
type ArrayType struct{
    *Ast
      _Type IType
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *ArrayType)      GetType() IType{ return my._Type}
func (my *ArrayType)      SetType( _Type IType)  { my._Type = _Type }
func (my *ArrayType)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *ArrayType)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *ArrayType)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *ArrayType)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewArrayType(leftIToken IToken, rightIToken IToken ,
              _Type IType,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*ArrayType{
      my := new(ArrayType)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayType)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *ArrayType)      AcceptWithVisitor(v Visitor) { v.VisitArrayType(my)}
func (my *ArrayType)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArrayTypeWithArg(my, o) }
func (my *ArrayType)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArrayTypeWithResult(my) }
func (my *ArrayType)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArrayTypeWithResultArgument(my, o) }


func AnyCastToArrayType(i interface{}) *ArrayType {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayType)
	}
}
/**
 *<b>
*<li>Rule 34:  TypeParameter ::= TypeVariable TypeBoundopt
 *</b>
 */
type TypeParameter struct{
    *Ast
      _TypeVariable *identifier
      _TypeBoundopt *TypeBound
}
func (my *TypeParameter)      GetTypeVariable() *identifier{ return my._TypeVariable}
func (my *TypeParameter)      SetTypeVariable( _TypeVariable *identifier)  { my._TypeVariable = _TypeVariable }
    /**
     * The value returned by <b>GetTypeBoundopt</b> may be <b>null</b>
     */
func (my *TypeParameter)      GetTypeBoundopt() *TypeBound{ return my._TypeBoundopt}
func (my *TypeParameter)      SetTypeBoundopt( _TypeBoundopt *TypeBound)  { my._TypeBoundopt = _TypeBoundopt }

func NewTypeParameter(leftIToken IToken, rightIToken IToken ,
              _TypeVariable *identifier,
              _TypeBoundopt *TypeBound)*TypeParameter{
      my := new(TypeParameter)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeVariable = _TypeVariable;
        if nil != _TypeVariable{
        var trait_ interface{} = _TypeVariable
         trait_.(IAst).SetParent(my)
}
        my._TypeBoundopt = _TypeBoundopt;
        if nil != _TypeBoundopt{
        var trait_ interface{} = _TypeBoundopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeParameter)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeVariable{  list.Add(my._TypeVariable) }
        if nil != my._TypeBoundopt{  list.Add(my._TypeBoundopt) }
        return list
    }

func (my *TypeParameter)      AcceptWithVisitor(v Visitor) { v.VisitTypeParameter(my)}
func (my *TypeParameter)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeParameterWithArg(my, o) }
func (my *TypeParameter)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeParameterWithResult(my) }
func (my *TypeParameter)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeParameterWithResultArgument(my, o) }


func AnyCastToTypeParameter(i interface{}) *TypeParameter {
	if nil == i{
		return nil
	}else{
		return i.(*TypeParameter)
	}
}
/**
 *<b>
*<li>Rule 35:  TypeBound ::= extends ClassOrInterfaceType AdditionalBoundListopt
 *</b>
 */
type TypeBound struct{
    *Ast
      _extends *AstToken
      _ClassOrInterfaceType *ClassType
      _AdditionalBoundListopt IAdditionalBoundListopt
}
func (my *TypeBound)      Getextends() *AstToken{ return my._extends}
func (my *TypeBound)      Setextends( _extends *AstToken)  { my._extends = _extends }
func (my *TypeBound)      GetClassOrInterfaceType() *ClassType{ return my._ClassOrInterfaceType}
func (my *TypeBound)      SetClassOrInterfaceType( _ClassOrInterfaceType *ClassType)  { my._ClassOrInterfaceType = _ClassOrInterfaceType }
    /**
     * The value returned by <b>GetAdditionalBoundListopt</b> may be <b>null</b>
     */
func (my *TypeBound)      GetAdditionalBoundListopt() IAdditionalBoundListopt{ return my._AdditionalBoundListopt}
func (my *TypeBound)      SetAdditionalBoundListopt( _AdditionalBoundListopt IAdditionalBoundListopt)  { my._AdditionalBoundListopt = _AdditionalBoundListopt }

func NewTypeBound(leftIToken IToken, rightIToken IToken ,
              _extends *AstToken,
              _ClassOrInterfaceType *ClassType,
              _AdditionalBoundListopt IAdditionalBoundListopt)*TypeBound{
      my := new(TypeBound)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._extends = _extends;
        if nil != _extends{
        var trait_ interface{} = _extends
         trait_.(IAst).SetParent(my)
}
        my._ClassOrInterfaceType = _ClassOrInterfaceType;
        if nil != _ClassOrInterfaceType{
        var trait_ interface{} = _ClassOrInterfaceType
         trait_.(IAst).SetParent(my)
}
        my._AdditionalBoundListopt = _AdditionalBoundListopt;
        if nil != _AdditionalBoundListopt{
        var trait_ interface{} = _AdditionalBoundListopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeBound)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._extends{  list.Add(my._extends) }
        if nil != my._ClassOrInterfaceType{  list.Add(my._ClassOrInterfaceType) }
        if nil != my._AdditionalBoundListopt{  list.Add(my._AdditionalBoundListopt) }
        return list
    }

func (my *TypeBound)      AcceptWithVisitor(v Visitor) { v.VisitTypeBound(my)}
func (my *TypeBound)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeBoundWithArg(my, o) }
func (my *TypeBound)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeBoundWithResult(my) }
func (my *TypeBound)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeBoundWithResultArgument(my, o) }


func AnyCastToTypeBound(i interface{}) *TypeBound {
	if nil == i{
		return nil
	}else{
		return i.(*TypeBound)
	}
}
/**
 *<em>
*<li>Rule 36:  AdditionalBoundList ::= AdditionalBound
 *</em>
 *<p>
 *<b>
*<li>Rule 37:  AdditionalBoundList ::= AdditionalBoundList AdditionalBound
 *</b>
 */
type AdditionalBoundList struct{
    *Ast
      _AdditionalBoundList IAdditionalBoundList
      _AdditionalBound *AdditionalBound
}
func (my *AdditionalBoundList)      GetAdditionalBoundList() IAdditionalBoundList{ return my._AdditionalBoundList}
func (my *AdditionalBoundList)      SetAdditionalBoundList( _AdditionalBoundList IAdditionalBoundList)  { my._AdditionalBoundList = _AdditionalBoundList }
func (my *AdditionalBoundList)      GetAdditionalBound() *AdditionalBound{ return my._AdditionalBound}
func (my *AdditionalBoundList)      SetAdditionalBound( _AdditionalBound *AdditionalBound)  { my._AdditionalBound = _AdditionalBound }

func NewAdditionalBoundList(leftIToken IToken, rightIToken IToken ,
              _AdditionalBoundList IAdditionalBoundList,
              _AdditionalBound *AdditionalBound)*AdditionalBoundList{
      my := new(AdditionalBoundList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AdditionalBoundList = _AdditionalBoundList;
        if nil != _AdditionalBoundList{
        var trait_ interface{} = _AdditionalBoundList
         trait_.(IAst).SetParent(my)
}
        my._AdditionalBound = _AdditionalBound;
        if nil != _AdditionalBound{
        var trait_ interface{} = _AdditionalBound
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AdditionalBoundList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AdditionalBoundList{  list.Add(my._AdditionalBoundList) }
        if nil != my._AdditionalBound{  list.Add(my._AdditionalBound) }
        return list
    }

func (my *AdditionalBoundList)      AcceptWithVisitor(v Visitor) { v.VisitAdditionalBoundList(my)}
func (my *AdditionalBoundList)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAdditionalBoundListWithArg(my, o) }
func (my *AdditionalBoundList)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAdditionalBoundListWithResult(my) }
func (my *AdditionalBoundList)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAdditionalBoundListWithResultArgument(my, o) }


func AnyCastToAdditionalBoundList(i interface{}) *AdditionalBoundList {
	if nil == i{
		return nil
	}else{
		return i.(*AdditionalBoundList)
	}
}
/**
 *<b>
*<li>Rule 38:  AdditionalBound ::= & InterfaceType
 *</b>
 */
type AdditionalBound struct{
    *Ast
      _AND *AstToken
      _InterfaceType *InterfaceType
}
func (my *AdditionalBound)      GetAND() *AstToken{ return my._AND}
func (my *AdditionalBound)      SetAND( _AND *AstToken)  { my._AND = _AND }
func (my *AdditionalBound)      GetInterfaceType() *InterfaceType{ return my._InterfaceType}
func (my *AdditionalBound)      SetInterfaceType( _InterfaceType *InterfaceType)  { my._InterfaceType = _InterfaceType }

func NewAdditionalBound(leftIToken IToken, rightIToken IToken ,
              _AND *AstToken,
              _InterfaceType *InterfaceType)*AdditionalBound{
      my := new(AdditionalBound)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AND = _AND;
        if nil != _AND{
        var trait_ interface{} = _AND
         trait_.(IAst).SetParent(my)
}
        my._InterfaceType = _InterfaceType;
        if nil != _InterfaceType{
        var trait_ interface{} = _InterfaceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AdditionalBound)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AND{  list.Add(my._AND) }
        if nil != my._InterfaceType{  list.Add(my._InterfaceType) }
        return list
    }

func (my *AdditionalBound)      AcceptWithVisitor(v Visitor) { v.VisitAdditionalBound(my)}
func (my *AdditionalBound)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAdditionalBoundWithArg(my, o) }
func (my *AdditionalBound)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAdditionalBoundWithResult(my) }
func (my *AdditionalBound)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAdditionalBoundWithResultArgument(my, o) }


func AnyCastToAdditionalBound(i interface{}) *AdditionalBound {
	if nil == i{
		return nil
	}else{
		return i.(*AdditionalBound)
	}
}
/**
 *<b>
*<li>Rule 39:  TypeArguments ::= < ActualTypeArgumentList >
 *</b>
 */
type TypeArguments struct{
    *Ast
      _LESS *AstToken
      _ActualTypeArgumentList IActualTypeArgumentList
      _GREATER *AstToken
}
func (my *TypeArguments)      GetLESS() *AstToken{ return my._LESS}
func (my *TypeArguments)      SetLESS( _LESS *AstToken)  { my._LESS = _LESS }
func (my *TypeArguments)      GetActualTypeArgumentList() IActualTypeArgumentList{ return my._ActualTypeArgumentList}
func (my *TypeArguments)      SetActualTypeArgumentList( _ActualTypeArgumentList IActualTypeArgumentList)  { my._ActualTypeArgumentList = _ActualTypeArgumentList }
func (my *TypeArguments)      GetGREATER() *AstToken{ return my._GREATER}
func (my *TypeArguments)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }

func NewTypeArguments(leftIToken IToken, rightIToken IToken ,
              _LESS *AstToken,
              _ActualTypeArgumentList IActualTypeArgumentList,
              _GREATER *AstToken)*TypeArguments{
      my := new(TypeArguments)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LESS = _LESS;
        if nil != _LESS{
        var trait_ interface{} = _LESS
         trait_.(IAst).SetParent(my)
}
        my._ActualTypeArgumentList = _ActualTypeArgumentList;
        if nil != _ActualTypeArgumentList{
        var trait_ interface{} = _ActualTypeArgumentList
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeArguments)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LESS{  list.Add(my._LESS) }
        if nil != my._ActualTypeArgumentList{  list.Add(my._ActualTypeArgumentList) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        return list
    }

func (my *TypeArguments)      AcceptWithVisitor(v Visitor) { v.VisitTypeArguments(my)}
func (my *TypeArguments)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeArgumentsWithArg(my, o) }
func (my *TypeArguments)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeArgumentsWithResult(my) }
func (my *TypeArguments)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeArgumentsWithResultArgument(my, o) }


func AnyCastToTypeArguments(i interface{}) *TypeArguments {
	if nil == i{
		return nil
	}else{
		return i.(*TypeArguments)
	}
}
/**
 *<em>
*<li>Rule 40:  ActualTypeArgumentList ::= ActualTypeArgument
 *</em>
 *<p>
 *<b>
*<li>Rule 41:  ActualTypeArgumentList ::= ActualTypeArgumentList , ActualTypeArgument
 *</b>
 */
type ActualTypeArgumentList struct{
    *Ast
      _ActualTypeArgumentList IActualTypeArgumentList
      _COMMA *AstToken
      _ActualTypeArgument IActualTypeArgument
}
func (my *ActualTypeArgumentList)      GetActualTypeArgumentList() IActualTypeArgumentList{ return my._ActualTypeArgumentList}
func (my *ActualTypeArgumentList)      SetActualTypeArgumentList( _ActualTypeArgumentList IActualTypeArgumentList)  { my._ActualTypeArgumentList = _ActualTypeArgumentList }
func (my *ActualTypeArgumentList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ActualTypeArgumentList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ActualTypeArgumentList)      GetActualTypeArgument() IActualTypeArgument{ return my._ActualTypeArgument}
func (my *ActualTypeArgumentList)      SetActualTypeArgument( _ActualTypeArgument IActualTypeArgument)  { my._ActualTypeArgument = _ActualTypeArgument }

func NewActualTypeArgumentList(leftIToken IToken, rightIToken IToken ,
              _ActualTypeArgumentList IActualTypeArgumentList,
              _COMMA *AstToken,
              _ActualTypeArgument IActualTypeArgument)*ActualTypeArgumentList{
      my := new(ActualTypeArgumentList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ActualTypeArgumentList = _ActualTypeArgumentList;
        if nil != _ActualTypeArgumentList{
        var trait_ interface{} = _ActualTypeArgumentList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._ActualTypeArgument = _ActualTypeArgument;
        if nil != _ActualTypeArgument{
        var trait_ interface{} = _ActualTypeArgument
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ActualTypeArgumentList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ActualTypeArgumentList{  list.Add(my._ActualTypeArgumentList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._ActualTypeArgument{  list.Add(my._ActualTypeArgument) }
        return list
    }

func (my *ActualTypeArgumentList)      AcceptWithVisitor(v Visitor) { v.VisitActualTypeArgumentList(my)}
func (my *ActualTypeArgumentList)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitActualTypeArgumentListWithArg(my, o) }
func (my *ActualTypeArgumentList)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitActualTypeArgumentListWithResult(my) }
func (my *ActualTypeArgumentList)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitActualTypeArgumentListWithResultArgument(my, o) }


func AnyCastToActualTypeArgumentList(i interface{}) *ActualTypeArgumentList {
	if nil == i{
		return nil
	}else{
		return i.(*ActualTypeArgumentList)
	}
}
/**
 *<b>
*<li>Rule 44:  Wildcard ::= ? WildcardBoundsOpt
 *</b>
 */
type Wildcard struct{
    *Ast
      _QUESTION *AstToken
      _WildcardBoundsOpt IWildcardBoundsOpt
}
func (my *Wildcard)      GetQUESTION() *AstToken{ return my._QUESTION}
func (my *Wildcard)      SetQUESTION( _QUESTION *AstToken)  { my._QUESTION = _QUESTION }
    /**
     * The value returned by <b>GetWildcardBoundsOpt</b> may be <b>null</b>
     */
func (my *Wildcard)      GetWildcardBoundsOpt() IWildcardBoundsOpt{ return my._WildcardBoundsOpt}
func (my *Wildcard)      SetWildcardBoundsOpt( _WildcardBoundsOpt IWildcardBoundsOpt)  { my._WildcardBoundsOpt = _WildcardBoundsOpt }

func NewWildcard(leftIToken IToken, rightIToken IToken ,
              _QUESTION *AstToken,
              _WildcardBoundsOpt IWildcardBoundsOpt)*Wildcard{
      my := new(Wildcard)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._QUESTION = _QUESTION;
        if nil != _QUESTION{
        var trait_ interface{} = _QUESTION
         trait_.(IAst).SetParent(my)
}
        my._WildcardBoundsOpt = _WildcardBoundsOpt;
        if nil != _WildcardBoundsOpt{
        var trait_ interface{} = _WildcardBoundsOpt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Wildcard)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._QUESTION{  list.Add(my._QUESTION) }
        if nil != my._WildcardBoundsOpt{  list.Add(my._WildcardBoundsOpt) }
        return list
    }

func (my *Wildcard)      AcceptWithVisitor(v Visitor) { v.VisitWildcard(my)}
func (my *Wildcard)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitWildcardWithArg(my, o) }
func (my *Wildcard)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitWildcardWithResult(my) }
func (my *Wildcard)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitWildcardWithResultArgument(my, o) }


func AnyCastToWildcard(i interface{}) *Wildcard {
	if nil == i{
		return nil
	}else{
		return i.(*Wildcard)
	}
}
/**
 *<em>
*<li>Rule 47:  PackageName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 48:  PackageName ::= PackageName . identifier
 *</b>
 */
type PackageName struct{
    *Ast
      _PackageName IPackageName
      _DOT *AstToken
      _identifier *identifier
}
func (my *PackageName)      GetPackageName() IPackageName{ return my._PackageName}
func (my *PackageName)      SetPackageName( _PackageName IPackageName)  { my._PackageName = _PackageName }
func (my *PackageName)      GetDOT() *AstToken{ return my._DOT}
func (my *PackageName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PackageName)      Getidentifier() *identifier{ return my._identifier}
func (my *PackageName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewPackageName(leftIToken IToken, rightIToken IToken ,
              _PackageName IPackageName,
              _DOT *AstToken,
              _identifier *identifier)*PackageName{
      my := new(PackageName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PackageName = _PackageName;
        if nil != _PackageName{
        var trait_ interface{} = _PackageName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PackageName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PackageName{  list.Add(my._PackageName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *PackageName)      AcceptWithVisitor(v Visitor) { v.VisitPackageName(my)}
func (my *PackageName)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPackageNameWithArg(my, o) }
func (my *PackageName)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPackageNameWithResult(my) }
func (my *PackageName)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPackageNameWithResultArgument(my, o) }


func AnyCastToPackageName(i interface{}) *PackageName {
	if nil == i{
		return nil
	}else{
		return i.(*PackageName)
	}
}
/**
 *<em>
*<li>Rule 49:  ExpressionName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 50:  ExpressionName ::= AmbiguousName . identifier
 *</b>
 */
type ExpressionName struct{
    *Ast
      _AmbiguousName IAmbiguousName
      _DOT *AstToken
      _identifier *identifier
}
func (my *ExpressionName)      GetAmbiguousName() IAmbiguousName{ return my._AmbiguousName}
func (my *ExpressionName)      SetAmbiguousName( _AmbiguousName IAmbiguousName)  { my._AmbiguousName = _AmbiguousName }
func (my *ExpressionName)      GetDOT() *AstToken{ return my._DOT}
func (my *ExpressionName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *ExpressionName)      Getidentifier() *identifier{ return my._identifier}
func (my *ExpressionName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewExpressionName(leftIToken IToken, rightIToken IToken ,
              _AmbiguousName IAmbiguousName,
              _DOT *AstToken,
              _identifier *identifier)*ExpressionName{
      my := new(ExpressionName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AmbiguousName = _AmbiguousName;
        if nil != _AmbiguousName{
        var trait_ interface{} = _AmbiguousName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExpressionName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AmbiguousName{  list.Add(my._AmbiguousName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *ExpressionName)      AcceptWithVisitor(v Visitor) { v.VisitExpressionName(my)}
func (my *ExpressionName)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExpressionNameWithArg(my, o) }
func (my *ExpressionName)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExpressionNameWithResult(my) }
func (my *ExpressionName)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExpressionNameWithResultArgument(my, o) }


func AnyCastToExpressionName(i interface{}) *ExpressionName {
	if nil == i{
		return nil
	}else{
		return i.(*ExpressionName)
	}
}
/**
 *<em>
*<li>Rule 51:  MethodName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 52:  MethodName ::= AmbiguousName . identifier
 *</b>
 */
type MethodName struct{
    *Ast
      _AmbiguousName IAmbiguousName
      _DOT *AstToken
      _identifier *identifier
}
func (my *MethodName)      GetAmbiguousName() IAmbiguousName{ return my._AmbiguousName}
func (my *MethodName)      SetAmbiguousName( _AmbiguousName IAmbiguousName)  { my._AmbiguousName = _AmbiguousName }
func (my *MethodName)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *MethodName)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewMethodName(leftIToken IToken, rightIToken IToken ,
              _AmbiguousName IAmbiguousName,
              _DOT *AstToken,
              _identifier *identifier)*MethodName{
      my := new(MethodName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AmbiguousName = _AmbiguousName;
        if nil != _AmbiguousName{
        var trait_ interface{} = _AmbiguousName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AmbiguousName{  list.Add(my._AmbiguousName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *MethodName)      AcceptWithVisitor(v Visitor) { v.VisitMethodName(my)}
func (my *MethodName)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodNameWithArg(my, o) }
func (my *MethodName)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodNameWithResult(my) }
func (my *MethodName)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodNameWithResultArgument(my, o) }


func AnyCastToMethodName(i interface{}) *MethodName {
	if nil == i{
		return nil
	}else{
		return i.(*MethodName)
	}
}
/**
 *<em>
*<li>Rule 53:  PackageOrTypeName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 54:  PackageOrTypeName ::= PackageOrTypeName . identifier
 *</b>
 */
type PackageOrTypeName struct{
    *Ast
      _PackageOrTypeName IPackageOrTypeName
      _DOT *AstToken
      _identifier *identifier
}
func (my *PackageOrTypeName)      GetPackageOrTypeName() IPackageOrTypeName{ return my._PackageOrTypeName}
func (my *PackageOrTypeName)      SetPackageOrTypeName( _PackageOrTypeName IPackageOrTypeName)  { my._PackageOrTypeName = _PackageOrTypeName }
func (my *PackageOrTypeName)      GetDOT() *AstToken{ return my._DOT}
func (my *PackageOrTypeName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PackageOrTypeName)      Getidentifier() *identifier{ return my._identifier}
func (my *PackageOrTypeName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewPackageOrTypeName(leftIToken IToken, rightIToken IToken ,
              _PackageOrTypeName IPackageOrTypeName,
              _DOT *AstToken,
              _identifier *identifier)*PackageOrTypeName{
      my := new(PackageOrTypeName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PackageOrTypeName = _PackageOrTypeName;
        if nil != _PackageOrTypeName{
        var trait_ interface{} = _PackageOrTypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PackageOrTypeName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PackageOrTypeName{  list.Add(my._PackageOrTypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *PackageOrTypeName)      AcceptWithVisitor(v Visitor) { v.VisitPackageOrTypeName(my)}
func (my *PackageOrTypeName)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPackageOrTypeNameWithArg(my, o) }
func (my *PackageOrTypeName)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPackageOrTypeNameWithResult(my) }
func (my *PackageOrTypeName)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPackageOrTypeNameWithResultArgument(my, o) }


func AnyCastToPackageOrTypeName(i interface{}) *PackageOrTypeName {
	if nil == i{
		return nil
	}else{
		return i.(*PackageOrTypeName)
	}
}
/**
 *<em>
*<li>Rule 55:  AmbiguousName ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 56:  AmbiguousName ::= AmbiguousName . identifier
 *</b>
 */
type AmbiguousName struct{
    *Ast
      _AmbiguousName IAmbiguousName
      _DOT *AstToken
      _identifier *identifier
}
func (my *AmbiguousName)      GetAmbiguousName() IAmbiguousName{ return my._AmbiguousName}
func (my *AmbiguousName)      SetAmbiguousName( _AmbiguousName IAmbiguousName)  { my._AmbiguousName = _AmbiguousName }
func (my *AmbiguousName)      GetDOT() *AstToken{ return my._DOT}
func (my *AmbiguousName)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *AmbiguousName)      Getidentifier() *identifier{ return my._identifier}
func (my *AmbiguousName)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewAmbiguousName(leftIToken IToken, rightIToken IToken ,
              _AmbiguousName IAmbiguousName,
              _DOT *AstToken,
              _identifier *identifier)*AmbiguousName{
      my := new(AmbiguousName)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AmbiguousName = _AmbiguousName;
        if nil != _AmbiguousName{
        var trait_ interface{} = _AmbiguousName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AmbiguousName)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AmbiguousName{  list.Add(my._AmbiguousName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *AmbiguousName)      AcceptWithVisitor(v Visitor) { v.VisitAmbiguousName(my)}
func (my *AmbiguousName)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAmbiguousNameWithArg(my, o) }
func (my *AmbiguousName)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAmbiguousNameWithResult(my) }
func (my *AmbiguousName)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAmbiguousNameWithResultArgument(my, o) }


func AnyCastToAmbiguousName(i interface{}) *AmbiguousName {
	if nil == i{
		return nil
	}else{
		return i.(*AmbiguousName)
	}
}
/**
 *<b>
*<li>Rule 57:  CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt TypeDeclarationsopt
 *</b>
 */
type CompilationUnit struct{
    *Ast
      _PackageDeclarationopt *PackageDeclaration
      _ImportDeclarationsopt IImportDeclarationsopt
      _TypeDeclarationsopt ITypeDeclarationsopt
}
    /**
     * The value returned by <b>GetPackageDeclarationopt</b> may be <b>null</b>
     */
func (my *CompilationUnit)      GetPackageDeclarationopt() *PackageDeclaration{ return my._PackageDeclarationopt}
func (my *CompilationUnit)      SetPackageDeclarationopt( _PackageDeclarationopt *PackageDeclaration)  { my._PackageDeclarationopt = _PackageDeclarationopt }
    /**
     * The value returned by <b>GetImportDeclarationsopt</b> may be <b>null</b>
     */
func (my *CompilationUnit)      GetImportDeclarationsopt() IImportDeclarationsopt{ return my._ImportDeclarationsopt}
func (my *CompilationUnit)      SetImportDeclarationsopt( _ImportDeclarationsopt IImportDeclarationsopt)  { my._ImportDeclarationsopt = _ImportDeclarationsopt }
    /**
     * The value returned by <b>GetTypeDeclarationsopt</b> may be <b>null</b>
     */
func (my *CompilationUnit)      GetTypeDeclarationsopt() ITypeDeclarationsopt{ return my._TypeDeclarationsopt}
func (my *CompilationUnit)      SetTypeDeclarationsopt( _TypeDeclarationsopt ITypeDeclarationsopt)  { my._TypeDeclarationsopt = _TypeDeclarationsopt }

func NewCompilationUnit(leftIToken IToken, rightIToken IToken ,
              _PackageDeclarationopt *PackageDeclaration,
              _ImportDeclarationsopt IImportDeclarationsopt,
              _TypeDeclarationsopt ITypeDeclarationsopt)*CompilationUnit{
      my := new(CompilationUnit)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PackageDeclarationopt = _PackageDeclarationopt;
        if nil != _PackageDeclarationopt{
        var trait_ interface{} = _PackageDeclarationopt
         trait_.(IAst).SetParent(my)
}
        my._ImportDeclarationsopt = _ImportDeclarationsopt;
        if nil != _ImportDeclarationsopt{
        var trait_ interface{} = _ImportDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._TypeDeclarationsopt = _TypeDeclarationsopt;
        if nil != _TypeDeclarationsopt{
        var trait_ interface{} = _TypeDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *CompilationUnit)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PackageDeclarationopt{  list.Add(my._PackageDeclarationopt) }
        if nil != my._ImportDeclarationsopt{  list.Add(my._ImportDeclarationsopt) }
        if nil != my._TypeDeclarationsopt{  list.Add(my._TypeDeclarationsopt) }
        return list
    }

func (my *CompilationUnit)      AcceptWithVisitor(v Visitor) { v.VisitCompilationUnit(my)}
func (my *CompilationUnit)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitCompilationUnitWithArg(my, o) }
func (my *CompilationUnit)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitCompilationUnitWithResult(my) }
func (my *CompilationUnit)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitCompilationUnitWithResultArgument(my, o) }


func AnyCastToCompilationUnit(i interface{}) *CompilationUnit {
	if nil == i{
		return nil
	}else{
		return i.(*CompilationUnit)
	}
}
/**
 *<em>
*<li>Rule 58:  ImportDeclarations ::= ImportDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 59:  ImportDeclarations ::= ImportDeclarations ImportDeclaration
 *</b>
 */
type ImportDeclarations struct{
    *Ast
      _ImportDeclarations IImportDeclarations
      _ImportDeclaration IImportDeclaration
}
func (my *ImportDeclarations)      GetImportDeclarations() IImportDeclarations{ return my._ImportDeclarations}
func (my *ImportDeclarations)      SetImportDeclarations( _ImportDeclarations IImportDeclarations)  { my._ImportDeclarations = _ImportDeclarations }
func (my *ImportDeclarations)      GetImportDeclaration() IImportDeclaration{ return my._ImportDeclaration}
func (my *ImportDeclarations)      SetImportDeclaration( _ImportDeclaration IImportDeclaration)  { my._ImportDeclaration = _ImportDeclaration }

func NewImportDeclarations(leftIToken IToken, rightIToken IToken ,
              _ImportDeclarations IImportDeclarations,
              _ImportDeclaration IImportDeclaration)*ImportDeclarations{
      my := new(ImportDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ImportDeclarations = _ImportDeclarations;
        if nil != _ImportDeclarations{
        var trait_ interface{} = _ImportDeclarations
         trait_.(IAst).SetParent(my)
}
        my._ImportDeclaration = _ImportDeclaration;
        if nil != _ImportDeclaration{
        var trait_ interface{} = _ImportDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ImportDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ImportDeclarations{  list.Add(my._ImportDeclarations) }
        if nil != my._ImportDeclaration{  list.Add(my._ImportDeclaration) }
        return list
    }

func (my *ImportDeclarations)      AcceptWithVisitor(v Visitor) { v.VisitImportDeclarations(my)}
func (my *ImportDeclarations)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitImportDeclarationsWithArg(my, o) }
func (my *ImportDeclarations)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitImportDeclarationsWithResult(my) }
func (my *ImportDeclarations)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitImportDeclarationsWithResultArgument(my, o) }


func AnyCastToImportDeclarations(i interface{}) *ImportDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*ImportDeclarations)
	}
}
/**
 *<em>
*<li>Rule 60:  TypeDeclarations ::= TypeDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 61:  TypeDeclarations ::= TypeDeclarations TypeDeclaration
 *</b>
 */
type TypeDeclarations struct{
    *Ast
      _TypeDeclarations ITypeDeclarations
      _TypeDeclaration ITypeDeclaration
}
func (my *TypeDeclarations)      GetTypeDeclarations() ITypeDeclarations{ return my._TypeDeclarations}
func (my *TypeDeclarations)      SetTypeDeclarations( _TypeDeclarations ITypeDeclarations)  { my._TypeDeclarations = _TypeDeclarations }
func (my *TypeDeclarations)      GetTypeDeclaration() ITypeDeclaration{ return my._TypeDeclaration}
func (my *TypeDeclarations)      SetTypeDeclaration( _TypeDeclaration ITypeDeclaration)  { my._TypeDeclaration = _TypeDeclaration }

func NewTypeDeclarations(leftIToken IToken, rightIToken IToken ,
              _TypeDeclarations ITypeDeclarations,
              _TypeDeclaration ITypeDeclaration)*TypeDeclarations{
      my := new(TypeDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeDeclarations = _TypeDeclarations;
        if nil != _TypeDeclarations{
        var trait_ interface{} = _TypeDeclarations
         trait_.(IAst).SetParent(my)
}
        my._TypeDeclaration = _TypeDeclaration;
        if nil != _TypeDeclaration{
        var trait_ interface{} = _TypeDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeDeclarations{  list.Add(my._TypeDeclarations) }
        if nil != my._TypeDeclaration{  list.Add(my._TypeDeclaration) }
        return list
    }

func (my *TypeDeclarations)      AcceptWithVisitor(v Visitor) { v.VisitTypeDeclarations(my)}
func (my *TypeDeclarations)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeDeclarationsWithArg(my, o) }
func (my *TypeDeclarations)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeDeclarationsWithResult(my) }
func (my *TypeDeclarations)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeDeclarationsWithResultArgument(my, o) }


func AnyCastToTypeDeclarations(i interface{}) *TypeDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*TypeDeclarations)
	}
}
/**
 *<b>
*<li>Rule 62:  PackageDeclaration ::= Annotationsopt package PackageName ;
 *</b>
 */
type PackageDeclaration struct{
    *Ast
      _Annotationsopt IAnnotationsopt
      _package *AstToken
      _PackageName IPackageName
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetAnnotationsopt</b> may be <b>null</b>
     */
func (my *PackageDeclaration)      GetAnnotationsopt() IAnnotationsopt{ return my._Annotationsopt}
func (my *PackageDeclaration)      SetAnnotationsopt( _Annotationsopt IAnnotationsopt)  { my._Annotationsopt = _Annotationsopt }
func (my *PackageDeclaration)      Getpackage() *AstToken{ return my._package}
func (my *PackageDeclaration)      Setpackage( _package *AstToken)  { my._package = _package }
func (my *PackageDeclaration)      GetPackageName() IPackageName{ return my._PackageName}
func (my *PackageDeclaration)      SetPackageName( _PackageName IPackageName)  { my._PackageName = _PackageName }
func (my *PackageDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *PackageDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewPackageDeclaration(leftIToken IToken, rightIToken IToken ,
              _Annotationsopt IAnnotationsopt,
              _package *AstToken,
              _PackageName IPackageName,
              _SEMICOLON *AstToken)*PackageDeclaration{
      my := new(PackageDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Annotationsopt = _Annotationsopt;
        if nil != _Annotationsopt{
        var trait_ interface{} = _Annotationsopt
         trait_.(IAst).SetParent(my)
}
        my._package = _package;
        if nil != _package{
        var trait_ interface{} = _package
         trait_.(IAst).SetParent(my)
}
        my._PackageName = _PackageName;
        if nil != _PackageName{
        var trait_ interface{} = _PackageName
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PackageDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Annotationsopt{  list.Add(my._Annotationsopt) }
        if nil != my._package{  list.Add(my._package) }
        if nil != my._PackageName{  list.Add(my._PackageName) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *PackageDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitPackageDeclaration(my)}
func (my *PackageDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPackageDeclarationWithArg(my, o) }
func (my *PackageDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPackageDeclarationWithResult(my) }
func (my *PackageDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPackageDeclarationWithResultArgument(my, o) }


func AnyCastToPackageDeclaration(i interface{}) *PackageDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*PackageDeclaration)
	}
}
/**
 *<b>
*<li>Rule 67:  SingleTypeImportDeclaration ::= import TypeName ;
 *</b>
 */
type SingleTypeImportDeclaration struct{
    *Ast
      _import *AstToken
      _TypeName ITypeName
      _SEMICOLON *AstToken
}
func (my *SingleTypeImportDeclaration)      Getimport() *AstToken{ return my._import}
func (my *SingleTypeImportDeclaration)      Setimport( _import *AstToken)  { my._import = _import }
func (my *SingleTypeImportDeclaration)      GetTypeName() ITypeName{ return my._TypeName}
func (my *SingleTypeImportDeclaration)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *SingleTypeImportDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *SingleTypeImportDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewSingleTypeImportDeclaration(leftIToken IToken, rightIToken IToken ,
              _import *AstToken,
              _TypeName ITypeName,
              _SEMICOLON *AstToken)*SingleTypeImportDeclaration{
      my := new(SingleTypeImportDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._import = _import;
        if nil != _import{
        var trait_ interface{} = _import
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SingleTypeImportDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._import{  list.Add(my._import) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *SingleTypeImportDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitSingleTypeImportDeclaration(my)}
func (my *SingleTypeImportDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSingleTypeImportDeclarationWithArg(my, o) }
func (my *SingleTypeImportDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSingleTypeImportDeclarationWithResult(my) }
func (my *SingleTypeImportDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSingleTypeImportDeclarationWithResultArgument(my, o) }


func AnyCastToSingleTypeImportDeclaration(i interface{}) *SingleTypeImportDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*SingleTypeImportDeclaration)
	}
}
/**
 *<b>
*<li>Rule 68:  TypeImportOnDemandDeclaration ::= import PackageOrTypeName . * ;
 *</b>
 */
type TypeImportOnDemandDeclaration struct{
    *Ast
      _import *AstToken
      _PackageOrTypeName IPackageOrTypeName
      _DOT *AstToken
      _MULTIPLY *AstToken
      _SEMICOLON *AstToken
}
func (my *TypeImportOnDemandDeclaration)      Getimport() *AstToken{ return my._import}
func (my *TypeImportOnDemandDeclaration)      Setimport( _import *AstToken)  { my._import = _import }
func (my *TypeImportOnDemandDeclaration)      GetPackageOrTypeName() IPackageOrTypeName{ return my._PackageOrTypeName}
func (my *TypeImportOnDemandDeclaration)      SetPackageOrTypeName( _PackageOrTypeName IPackageOrTypeName)  { my._PackageOrTypeName = _PackageOrTypeName }
func (my *TypeImportOnDemandDeclaration)      GetDOT() *AstToken{ return my._DOT}
func (my *TypeImportOnDemandDeclaration)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *TypeImportOnDemandDeclaration)      GetMULTIPLY() *AstToken{ return my._MULTIPLY}
func (my *TypeImportOnDemandDeclaration)      SetMULTIPLY( _MULTIPLY *AstToken)  { my._MULTIPLY = _MULTIPLY }
func (my *TypeImportOnDemandDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *TypeImportOnDemandDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewTypeImportOnDemandDeclaration(leftIToken IToken, rightIToken IToken ,
              _import *AstToken,
              _PackageOrTypeName IPackageOrTypeName,
              _DOT *AstToken,
              _MULTIPLY *AstToken,
              _SEMICOLON *AstToken)*TypeImportOnDemandDeclaration{
      my := new(TypeImportOnDemandDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._import = _import;
        if nil != _import{
        var trait_ interface{} = _import
         trait_.(IAst).SetParent(my)
}
        my._PackageOrTypeName = _PackageOrTypeName;
        if nil != _PackageOrTypeName{
        var trait_ interface{} = _PackageOrTypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._MULTIPLY = _MULTIPLY;
        if nil != _MULTIPLY{
        var trait_ interface{} = _MULTIPLY
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeImportOnDemandDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._import{  list.Add(my._import) }
        if nil != my._PackageOrTypeName{  list.Add(my._PackageOrTypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._MULTIPLY{  list.Add(my._MULTIPLY) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *TypeImportOnDemandDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitTypeImportOnDemandDeclaration(my)}
func (my *TypeImportOnDemandDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeImportOnDemandDeclarationWithArg(my, o) }
func (my *TypeImportOnDemandDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeImportOnDemandDeclarationWithResult(my) }
func (my *TypeImportOnDemandDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeImportOnDemandDeclarationWithResultArgument(my, o) }


func AnyCastToTypeImportOnDemandDeclaration(i interface{}) *TypeImportOnDemandDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*TypeImportOnDemandDeclaration)
	}
}
/**
 *<b>
*<li>Rule 69:  SingleStaticImportDeclaration ::= import static TypeName . identifier ;
 *</b>
 */
type SingleStaticImportDeclaration struct{
    *Ast
      _import *AstToken
      _static *AstToken
      _TypeName ITypeName
      _DOT *AstToken
      _identifier *identifier
      _SEMICOLON *AstToken
}
func (my *SingleStaticImportDeclaration)      Getimport() *AstToken{ return my._import}
func (my *SingleStaticImportDeclaration)      Setimport( _import *AstToken)  { my._import = _import }
func (my *SingleStaticImportDeclaration)      Getstatic() *AstToken{ return my._static}
func (my *SingleStaticImportDeclaration)      Setstatic( _static *AstToken)  { my._static = _static }
func (my *SingleStaticImportDeclaration)      GetTypeName() ITypeName{ return my._TypeName}
func (my *SingleStaticImportDeclaration)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *SingleStaticImportDeclaration)      GetDOT() *AstToken{ return my._DOT}
func (my *SingleStaticImportDeclaration)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *SingleStaticImportDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *SingleStaticImportDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *SingleStaticImportDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *SingleStaticImportDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewSingleStaticImportDeclaration(leftIToken IToken, rightIToken IToken ,
              _import *AstToken,
              _static *AstToken,
              _TypeName ITypeName,
              _DOT *AstToken,
              _identifier *identifier,
              _SEMICOLON *AstToken)*SingleStaticImportDeclaration{
      my := new(SingleStaticImportDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._import = _import;
        if nil != _import{
        var trait_ interface{} = _import
         trait_.(IAst).SetParent(my)
}
        my._static = _static;
        if nil != _static{
        var trait_ interface{} = _static
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SingleStaticImportDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._import{  list.Add(my._import) }
        if nil != my._static{  list.Add(my._static) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *SingleStaticImportDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitSingleStaticImportDeclaration(my)}
func (my *SingleStaticImportDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSingleStaticImportDeclarationWithArg(my, o) }
func (my *SingleStaticImportDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSingleStaticImportDeclarationWithResult(my) }
func (my *SingleStaticImportDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSingleStaticImportDeclarationWithResultArgument(my, o) }


func AnyCastToSingleStaticImportDeclaration(i interface{}) *SingleStaticImportDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*SingleStaticImportDeclaration)
	}
}
/**
 *<b>
*<li>Rule 70:  StaticImportOnDemandDeclaration ::= import static TypeName . * ;
 *</b>
 */
type StaticImportOnDemandDeclaration struct{
    *Ast
      _import *AstToken
      _static *AstToken
      _TypeName ITypeName
      _DOT *AstToken
      _MULTIPLY *AstToken
      _SEMICOLON *AstToken
}
func (my *StaticImportOnDemandDeclaration)      Getimport() *AstToken{ return my._import}
func (my *StaticImportOnDemandDeclaration)      Setimport( _import *AstToken)  { my._import = _import }
func (my *StaticImportOnDemandDeclaration)      Getstatic() *AstToken{ return my._static}
func (my *StaticImportOnDemandDeclaration)      Setstatic( _static *AstToken)  { my._static = _static }
func (my *StaticImportOnDemandDeclaration)      GetTypeName() ITypeName{ return my._TypeName}
func (my *StaticImportOnDemandDeclaration)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *StaticImportOnDemandDeclaration)      GetDOT() *AstToken{ return my._DOT}
func (my *StaticImportOnDemandDeclaration)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *StaticImportOnDemandDeclaration)      GetMULTIPLY() *AstToken{ return my._MULTIPLY}
func (my *StaticImportOnDemandDeclaration)      SetMULTIPLY( _MULTIPLY *AstToken)  { my._MULTIPLY = _MULTIPLY }
func (my *StaticImportOnDemandDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *StaticImportOnDemandDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewStaticImportOnDemandDeclaration(leftIToken IToken, rightIToken IToken ,
              _import *AstToken,
              _static *AstToken,
              _TypeName ITypeName,
              _DOT *AstToken,
              _MULTIPLY *AstToken,
              _SEMICOLON *AstToken)*StaticImportOnDemandDeclaration{
      my := new(StaticImportOnDemandDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._import = _import;
        if nil != _import{
        var trait_ interface{} = _import
         trait_.(IAst).SetParent(my)
}
        my._static = _static;
        if nil != _static{
        var trait_ interface{} = _static
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._MULTIPLY = _MULTIPLY;
        if nil != _MULTIPLY{
        var trait_ interface{} = _MULTIPLY
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *StaticImportOnDemandDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._import{  list.Add(my._import) }
        if nil != my._static{  list.Add(my._static) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._MULTIPLY{  list.Add(my._MULTIPLY) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *StaticImportOnDemandDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitStaticImportOnDemandDeclaration(my)}
func (my *StaticImportOnDemandDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitStaticImportOnDemandDeclarationWithArg(my, o) }
func (my *StaticImportOnDemandDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitStaticImportOnDemandDeclarationWithResult(my) }
func (my *StaticImportOnDemandDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitStaticImportOnDemandDeclarationWithResultArgument(my, o) }


func AnyCastToStaticImportOnDemandDeclaration(i interface{}) *StaticImportOnDemandDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*StaticImportOnDemandDeclaration)
	}
}
/**
 *<em>
*<li>Rule 71:  TypeDeclaration ::= ClassDeclaration
*<li>Rule 72:  TypeDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 73:  TypeDeclaration ::= ;
 *</b>
 */
type TypeDeclaration struct{
    *AstToken
}
func (my *TypeDeclaration)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewTypeDeclaration(token IToken )*TypeDeclaration{
      my := new(TypeDeclaration)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *TypeDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitTypeDeclaration(my)}
func (my *TypeDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeDeclarationWithArg(my, o) }
func (my *TypeDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeDeclarationWithResult(my) }
func (my *TypeDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeDeclarationWithResultArgument(my, o) }


func AnyCastToTypeDeclaration(i interface{}) *TypeDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*TypeDeclaration)
	}
}
/**
 *<b>
*<li>Rule 76:  NormalClassDeclaration ::= ClassModifiersopt class identifier TypeParametersopt Superopt Interfacesopt ClassBody
 *</b>
 */
type NormalClassDeclaration struct{
    *Ast
      _ClassModifiersopt IClassModifiersopt
      _class *AstToken
      _identifier *identifier
      _TypeParametersopt *TypeParameters
      _Superopt *Super
      _Interfacesopt *Interfaces
      _ClassBody *ClassBody
}
    /**
     * The value returned by <b>GetClassModifiersopt</b> may be <b>null</b>
     */
func (my *NormalClassDeclaration)      GetClassModifiersopt() IClassModifiersopt{ return my._ClassModifiersopt}
func (my *NormalClassDeclaration)      SetClassModifiersopt( _ClassModifiersopt IClassModifiersopt)  { my._ClassModifiersopt = _ClassModifiersopt }
func (my *NormalClassDeclaration)      Getclass() *AstToken{ return my._class}
func (my *NormalClassDeclaration)      Setclass( _class *AstToken)  { my._class = _class }
func (my *NormalClassDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *NormalClassDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *NormalClassDeclaration)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *NormalClassDeclaration)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
    /**
     * The value returned by <b>GetSuperopt</b> may be <b>null</b>
     */
func (my *NormalClassDeclaration)      GetSuperopt() *Super{ return my._Superopt}
func (my *NormalClassDeclaration)      SetSuperopt( _Superopt *Super)  { my._Superopt = _Superopt }
    /**
     * The value returned by <b>GetInterfacesopt</b> may be <b>null</b>
     */
func (my *NormalClassDeclaration)      GetInterfacesopt() *Interfaces{ return my._Interfacesopt}
func (my *NormalClassDeclaration)      SetInterfacesopt( _Interfacesopt *Interfaces)  { my._Interfacesopt = _Interfacesopt }
func (my *NormalClassDeclaration)      GetClassBody() *ClassBody{ return my._ClassBody}
func (my *NormalClassDeclaration)      SetClassBody( _ClassBody *ClassBody)  { my._ClassBody = _ClassBody }

func NewNormalClassDeclaration(leftIToken IToken, rightIToken IToken ,
              _ClassModifiersopt IClassModifiersopt,
              _class *AstToken,
              _identifier *identifier,
              _TypeParametersopt *TypeParameters,
              _Superopt *Super,
              _Interfacesopt *Interfaces,
              _ClassBody *ClassBody)*NormalClassDeclaration{
      my := new(NormalClassDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassModifiersopt = _ClassModifiersopt;
        if nil != _ClassModifiersopt{
        var trait_ interface{} = _ClassModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._class = _class;
        if nil != _class{
        var trait_ interface{} = _class
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._Superopt = _Superopt;
        if nil != _Superopt{
        var trait_ interface{} = _Superopt
         trait_.(IAst).SetParent(my)
}
        my._Interfacesopt = _Interfacesopt;
        if nil != _Interfacesopt{
        var trait_ interface{} = _Interfacesopt
         trait_.(IAst).SetParent(my)
}
        my._ClassBody = _ClassBody;
        if nil != _ClassBody{
        var trait_ interface{} = _ClassBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *NormalClassDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassModifiersopt{  list.Add(my._ClassModifiersopt) }
        if nil != my._class{  list.Add(my._class) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._Superopt{  list.Add(my._Superopt) }
        if nil != my._Interfacesopt{  list.Add(my._Interfacesopt) }
        if nil != my._ClassBody{  list.Add(my._ClassBody) }
        return list
    }

func (my *NormalClassDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitNormalClassDeclaration(my)}
func (my *NormalClassDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitNormalClassDeclarationWithArg(my, o) }
func (my *NormalClassDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitNormalClassDeclarationWithResult(my) }
func (my *NormalClassDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitNormalClassDeclarationWithResultArgument(my, o) }


func AnyCastToNormalClassDeclaration(i interface{}) *NormalClassDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*NormalClassDeclaration)
	}
}
/**
 *<em>
*<li>Rule 77:  ClassModifiers ::= ClassModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 78:  ClassModifiers ::= ClassModifiers ClassModifier
 *</b>
 */
type ClassModifiers struct{
    *Ast
      _ClassModifiers IClassModifiers
      _ClassModifier IClassModifier
}
func (my *ClassModifiers)      GetClassModifiers() IClassModifiers{ return my._ClassModifiers}
func (my *ClassModifiers)      SetClassModifiers( _ClassModifiers IClassModifiers)  { my._ClassModifiers = _ClassModifiers }
func (my *ClassModifiers)      GetClassModifier() IClassModifier{ return my._ClassModifier}
func (my *ClassModifiers)      SetClassModifier( _ClassModifier IClassModifier)  { my._ClassModifier = _ClassModifier }

func NewClassModifiers(leftIToken IToken, rightIToken IToken ,
              _ClassModifiers IClassModifiers,
              _ClassModifier IClassModifier)*ClassModifiers{
      my := new(ClassModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassModifiers = _ClassModifiers;
        if nil != _ClassModifiers{
        var trait_ interface{} = _ClassModifiers
         trait_.(IAst).SetParent(my)
}
        my._ClassModifier = _ClassModifier;
        if nil != _ClassModifier{
        var trait_ interface{} = _ClassModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassModifiers{  list.Add(my._ClassModifiers) }
        if nil != my._ClassModifier{  list.Add(my._ClassModifier) }
        return list
    }

func (my *ClassModifiers)      AcceptWithVisitor(v Visitor) { v.VisitClassModifiers(my)}
func (my *ClassModifiers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassModifiersWithArg(my, o) }
func (my *ClassModifiers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassModifiersWithResult(my) }
func (my *ClassModifiers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassModifiersWithResultArgument(my, o) }


func AnyCastToClassModifiers(i interface{}) *ClassModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifiers)
	}
}
/**
 *<b>
*<li>Rule 87:  TypeParameters ::= < TypeParameterList >
 *</b>
 */
type TypeParameters struct{
    *Ast
      _LESS *AstToken
      _TypeParameterList ITypeParameterList
      _GREATER *AstToken
}
func (my *TypeParameters)      GetLESS() *AstToken{ return my._LESS}
func (my *TypeParameters)      SetLESS( _LESS *AstToken)  { my._LESS = _LESS }
func (my *TypeParameters)      GetTypeParameterList() ITypeParameterList{ return my._TypeParameterList}
func (my *TypeParameters)      SetTypeParameterList( _TypeParameterList ITypeParameterList)  { my._TypeParameterList = _TypeParameterList }
func (my *TypeParameters)      GetGREATER() *AstToken{ return my._GREATER}
func (my *TypeParameters)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }

func NewTypeParameters(leftIToken IToken, rightIToken IToken ,
              _LESS *AstToken,
              _TypeParameterList ITypeParameterList,
              _GREATER *AstToken)*TypeParameters{
      my := new(TypeParameters)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LESS = _LESS;
        if nil != _LESS{
        var trait_ interface{} = _LESS
         trait_.(IAst).SetParent(my)
}
        my._TypeParameterList = _TypeParameterList;
        if nil != _TypeParameterList{
        var trait_ interface{} = _TypeParameterList
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeParameters)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LESS{  list.Add(my._LESS) }
        if nil != my._TypeParameterList{  list.Add(my._TypeParameterList) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        return list
    }

func (my *TypeParameters)      AcceptWithVisitor(v Visitor) { v.VisitTypeParameters(my)}
func (my *TypeParameters)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeParametersWithArg(my, o) }
func (my *TypeParameters)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeParametersWithResult(my) }
func (my *TypeParameters)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeParametersWithResultArgument(my, o) }


func AnyCastToTypeParameters(i interface{}) *TypeParameters {
	if nil == i{
		return nil
	}else{
		return i.(*TypeParameters)
	}
}
/**
 *<em>
*<li>Rule 88:  TypeParameterList ::= TypeParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 89:  TypeParameterList ::= TypeParameterList , TypeParameter
 *</b>
 */
type TypeParameterList struct{
    *Ast
      _TypeParameterList ITypeParameterList
      _COMMA *AstToken
      _TypeParameter *TypeParameter
}
func (my *TypeParameterList)      GetTypeParameterList() ITypeParameterList{ return my._TypeParameterList}
func (my *TypeParameterList)      SetTypeParameterList( _TypeParameterList ITypeParameterList)  { my._TypeParameterList = _TypeParameterList }
func (my *TypeParameterList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *TypeParameterList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *TypeParameterList)      GetTypeParameter() *TypeParameter{ return my._TypeParameter}
func (my *TypeParameterList)      SetTypeParameter( _TypeParameter *TypeParameter)  { my._TypeParameter = _TypeParameter }

func NewTypeParameterList(leftIToken IToken, rightIToken IToken ,
              _TypeParameterList ITypeParameterList,
              _COMMA *AstToken,
              _TypeParameter *TypeParameter)*TypeParameterList{
      my := new(TypeParameterList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeParameterList = _TypeParameterList;
        if nil != _TypeParameterList{
        var trait_ interface{} = _TypeParameterList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._TypeParameter = _TypeParameter;
        if nil != _TypeParameter{
        var trait_ interface{} = _TypeParameter
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TypeParameterList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeParameterList{  list.Add(my._TypeParameterList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._TypeParameter{  list.Add(my._TypeParameter) }
        return list
    }

func (my *TypeParameterList)      AcceptWithVisitor(v Visitor) { v.VisitTypeParameterList(my)}
func (my *TypeParameterList)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTypeParameterListWithArg(my, o) }
func (my *TypeParameterList)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTypeParameterListWithResult(my) }
func (my *TypeParameterList)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTypeParameterListWithResultArgument(my, o) }


func AnyCastToTypeParameterList(i interface{}) *TypeParameterList {
	if nil == i{
		return nil
	}else{
		return i.(*TypeParameterList)
	}
}
/**
 *<b>
*<li>Rule 90:  Super ::= extends ClassType
 *</b>
 */
type Super struct{
    *Ast
      _extends *AstToken
      _ClassType *ClassType
}
func (my *Super)      Getextends() *AstToken{ return my._extends}
func (my *Super)      Setextends( _extends *AstToken)  { my._extends = _extends }
func (my *Super)      GetClassType() *ClassType{ return my._ClassType}
func (my *Super)      SetClassType( _ClassType *ClassType)  { my._ClassType = _ClassType }

func NewSuper(leftIToken IToken, rightIToken IToken ,
              _extends *AstToken,
              _ClassType *ClassType)*Super{
      my := new(Super)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._extends = _extends;
        if nil != _extends{
        var trait_ interface{} = _extends
         trait_.(IAst).SetParent(my)
}
        my._ClassType = _ClassType;
        if nil != _ClassType{
        var trait_ interface{} = _ClassType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Super)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._extends{  list.Add(my._extends) }
        if nil != my._ClassType{  list.Add(my._ClassType) }
        return list
    }

func (my *Super)      AcceptWithVisitor(v Visitor) { v.VisitSuper(my)}
func (my *Super)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSuperWithArg(my, o) }
func (my *Super)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSuperWithResult(my) }
func (my *Super)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSuperWithResultArgument(my, o) }


func AnyCastToSuper(i interface{}) *Super {
	if nil == i{
		return nil
	}else{
		return i.(*Super)
	}
}
/**
 *<b>
*<li>Rule 91:  Interfaces ::= implements InterfaceTypeList
 *</b>
 */
type Interfaces struct{
    *Ast
      _implements *AstToken
      _InterfaceTypeList IInterfaceTypeList
}
func (my *Interfaces)      Getimplements() *AstToken{ return my._implements}
func (my *Interfaces)      Setimplements( _implements *AstToken)  { my._implements = _implements }
func (my *Interfaces)      GetInterfaceTypeList() IInterfaceTypeList{ return my._InterfaceTypeList}
func (my *Interfaces)      SetInterfaceTypeList( _InterfaceTypeList IInterfaceTypeList)  { my._InterfaceTypeList = _InterfaceTypeList }

func NewInterfaces(leftIToken IToken, rightIToken IToken ,
              _implements *AstToken,
              _InterfaceTypeList IInterfaceTypeList)*Interfaces{
      my := new(Interfaces)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._implements = _implements;
        if nil != _implements{
        var trait_ interface{} = _implements
         trait_.(IAst).SetParent(my)
}
        my._InterfaceTypeList = _InterfaceTypeList;
        if nil != _InterfaceTypeList{
        var trait_ interface{} = _InterfaceTypeList
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Interfaces)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._implements{  list.Add(my._implements) }
        if nil != my._InterfaceTypeList{  list.Add(my._InterfaceTypeList) }
        return list
    }

func (my *Interfaces)      AcceptWithVisitor(v Visitor) { v.VisitInterfaces(my)}
func (my *Interfaces)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfacesWithArg(my, o) }
func (my *Interfaces)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfacesWithResult(my) }
func (my *Interfaces)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfacesWithResultArgument(my, o) }


func AnyCastToInterfaces(i interface{}) *Interfaces {
	if nil == i{
		return nil
	}else{
		return i.(*Interfaces)
	}
}
/**
 *<em>
*<li>Rule 92:  InterfaceTypeList ::= InterfaceType
 *</em>
 *<p>
 *<b>
*<li>Rule 93:  InterfaceTypeList ::= InterfaceTypeList , InterfaceType
 *</b>
 */
type InterfaceTypeList struct{
    *Ast
      _InterfaceTypeList IInterfaceTypeList
      _COMMA *AstToken
      _InterfaceType *InterfaceType
}
func (my *InterfaceTypeList)      GetInterfaceTypeList() IInterfaceTypeList{ return my._InterfaceTypeList}
func (my *InterfaceTypeList)      SetInterfaceTypeList( _InterfaceTypeList IInterfaceTypeList)  { my._InterfaceTypeList = _InterfaceTypeList }
func (my *InterfaceTypeList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *InterfaceTypeList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *InterfaceTypeList)      GetInterfaceType() *InterfaceType{ return my._InterfaceType}
func (my *InterfaceTypeList)      SetInterfaceType( _InterfaceType *InterfaceType)  { my._InterfaceType = _InterfaceType }

func NewInterfaceTypeList(leftIToken IToken, rightIToken IToken ,
              _InterfaceTypeList IInterfaceTypeList,
              _COMMA *AstToken,
              _InterfaceType *InterfaceType)*InterfaceTypeList{
      my := new(InterfaceTypeList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceTypeList = _InterfaceTypeList;
        if nil != _InterfaceTypeList{
        var trait_ interface{} = _InterfaceTypeList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._InterfaceType = _InterfaceType;
        if nil != _InterfaceType{
        var trait_ interface{} = _InterfaceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceTypeList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceTypeList{  list.Add(my._InterfaceTypeList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._InterfaceType{  list.Add(my._InterfaceType) }
        return list
    }

func (my *InterfaceTypeList)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceTypeList(my)}
func (my *InterfaceTypeList)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceTypeListWithArg(my, o) }
func (my *InterfaceTypeList)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceTypeListWithResult(my) }
func (my *InterfaceTypeList)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceTypeListWithResultArgument(my, o) }


func AnyCastToInterfaceTypeList(i interface{}) *InterfaceTypeList {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceTypeList)
	}
}
/**
 *<b>
*<li>Rule 94:  ClassBody ::= { ClassBodyDeclarationsopt }
 *</b>
 */
type ClassBody struct{
    *Ast
      _LBRACE *AstToken
      _ClassBodyDeclarationsopt IClassBodyDeclarationsopt
      _RBRACE *AstToken
}
func (my *ClassBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *ClassBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetClassBodyDeclarationsopt</b> may be <b>null</b>
     */
func (my *ClassBody)      GetClassBodyDeclarationsopt() IClassBodyDeclarationsopt{ return my._ClassBodyDeclarationsopt}
func (my *ClassBody)      SetClassBodyDeclarationsopt( _ClassBodyDeclarationsopt IClassBodyDeclarationsopt)  { my._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt }
func (my *ClassBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *ClassBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewClassBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _ClassBodyDeclarationsopt IClassBodyDeclarationsopt,
              _RBRACE *AstToken)*ClassBody{
      my := new(ClassBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt;
        if nil != _ClassBodyDeclarationsopt{
        var trait_ interface{} = _ClassBodyDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._ClassBodyDeclarationsopt{  list.Add(my._ClassBodyDeclarationsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *ClassBody)      AcceptWithVisitor(v Visitor) { v.VisitClassBody(my)}
func (my *ClassBody)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassBodyWithArg(my, o) }
func (my *ClassBody)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassBodyWithResult(my) }
func (my *ClassBody)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassBodyWithResultArgument(my, o) }


func AnyCastToClassBody(i interface{}) *ClassBody {
	if nil == i{
		return nil
	}else{
		return i.(*ClassBody)
	}
}
/**
 *<em>
*<li>Rule 95:  ClassBodyDeclarations ::= ClassBodyDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 96:  ClassBodyDeclarations ::= ClassBodyDeclarations ClassBodyDeclaration
 *</b>
 */
type ClassBodyDeclarations struct{
    *Ast
      _ClassBodyDeclarations IClassBodyDeclarations
      _ClassBodyDeclaration IClassBodyDeclaration
}
func (my *ClassBodyDeclarations)      GetClassBodyDeclarations() IClassBodyDeclarations{ return my._ClassBodyDeclarations}
func (my *ClassBodyDeclarations)      SetClassBodyDeclarations( _ClassBodyDeclarations IClassBodyDeclarations)  { my._ClassBodyDeclarations = _ClassBodyDeclarations }
func (my *ClassBodyDeclarations)      GetClassBodyDeclaration() IClassBodyDeclaration{ return my._ClassBodyDeclaration}
func (my *ClassBodyDeclarations)      SetClassBodyDeclaration( _ClassBodyDeclaration IClassBodyDeclaration)  { my._ClassBodyDeclaration = _ClassBodyDeclaration }

func NewClassBodyDeclarations(leftIToken IToken, rightIToken IToken ,
              _ClassBodyDeclarations IClassBodyDeclarations,
              _ClassBodyDeclaration IClassBodyDeclaration)*ClassBodyDeclarations{
      my := new(ClassBodyDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassBodyDeclarations = _ClassBodyDeclarations;
        if nil != _ClassBodyDeclarations{
        var trait_ interface{} = _ClassBodyDeclarations
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyDeclaration = _ClassBodyDeclaration;
        if nil != _ClassBodyDeclaration{
        var trait_ interface{} = _ClassBodyDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassBodyDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassBodyDeclarations{  list.Add(my._ClassBodyDeclarations) }
        if nil != my._ClassBodyDeclaration{  list.Add(my._ClassBodyDeclaration) }
        return list
    }

func (my *ClassBodyDeclarations)      AcceptWithVisitor(v Visitor) { v.VisitClassBodyDeclarations(my)}
func (my *ClassBodyDeclarations)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassBodyDeclarationsWithArg(my, o) }
func (my *ClassBodyDeclarations)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassBodyDeclarationsWithResult(my) }
func (my *ClassBodyDeclarations)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassBodyDeclarationsWithResultArgument(my, o) }


func AnyCastToClassBodyDeclarations(i interface{}) *ClassBodyDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*ClassBodyDeclarations)
	}
}
/**
 *<em>
*<li>Rule 101:  ClassMemberDeclaration ::= FieldDeclaration
*<li>Rule 102:  ClassMemberDeclaration ::= MethodDeclaration
*<li>Rule 103:  ClassMemberDeclaration ::= ClassDeclaration
*<li>Rule 104:  ClassMemberDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 105:  ClassMemberDeclaration ::= ;
 *</b>
 */
type ClassMemberDeclaration struct{
    *AstToken
}
func (my *ClassMemberDeclaration)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewClassMemberDeclaration(token IToken )*ClassMemberDeclaration{
      my := new(ClassMemberDeclaration)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassMemberDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitClassMemberDeclaration(my)}
func (my *ClassMemberDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassMemberDeclarationWithArg(my, o) }
func (my *ClassMemberDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassMemberDeclarationWithResult(my) }
func (my *ClassMemberDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassMemberDeclarationWithResultArgument(my, o) }


func AnyCastToClassMemberDeclaration(i interface{}) *ClassMemberDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*ClassMemberDeclaration)
	}
}
/**
 *<b>
*<li>Rule 106:  FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ;
 *</b>
 */
type FieldDeclaration struct{
    *Ast
      _FieldModifiersopt IFieldModifiersopt
      _Type IType
      _VariableDeclarators IVariableDeclarators
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetFieldModifiersopt</b> may be <b>null</b>
     */
func (my *FieldDeclaration)      GetFieldModifiersopt() IFieldModifiersopt{ return my._FieldModifiersopt}
func (my *FieldDeclaration)      SetFieldModifiersopt( _FieldModifiersopt IFieldModifiersopt)  { my._FieldModifiersopt = _FieldModifiersopt }
func (my *FieldDeclaration)      GetType() IType{ return my._Type}
func (my *FieldDeclaration)      SetType( _Type IType)  { my._Type = _Type }
func (my *FieldDeclaration)      GetVariableDeclarators() IVariableDeclarators{ return my._VariableDeclarators}
func (my *FieldDeclaration)      SetVariableDeclarators( _VariableDeclarators IVariableDeclarators)  { my._VariableDeclarators = _VariableDeclarators }
func (my *FieldDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *FieldDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewFieldDeclaration(leftIToken IToken, rightIToken IToken ,
              _FieldModifiersopt IFieldModifiersopt,
              _Type IType,
              _VariableDeclarators IVariableDeclarators,
              _SEMICOLON *AstToken)*FieldDeclaration{
      my := new(FieldDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._FieldModifiersopt = _FieldModifiersopt;
        if nil != _FieldModifiersopt{
        var trait_ interface{} = _FieldModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclarators = _VariableDeclarators;
        if nil != _VariableDeclarators{
        var trait_ interface{} = _VariableDeclarators
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._FieldModifiersopt{  list.Add(my._FieldModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._VariableDeclarators{  list.Add(my._VariableDeclarators) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *FieldDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitFieldDeclaration(my)}
func (my *FieldDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldDeclarationWithArg(my, o) }
func (my *FieldDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldDeclarationWithResult(my) }
func (my *FieldDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldDeclarationWithResultArgument(my, o) }


func AnyCastToFieldDeclaration(i interface{}) *FieldDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*FieldDeclaration)
	}
}
/**
 *<em>
*<li>Rule 107:  VariableDeclarators ::= VariableDeclarator
 *</em>
 *<p>
 *<b>
*<li>Rule 108:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
 *</b>
 */
type VariableDeclarators struct{
    *Ast
      _VariableDeclarators IVariableDeclarators
      _COMMA *AstToken
      _VariableDeclarator IVariableDeclarator
}
func (my *VariableDeclarators)      GetVariableDeclarators() IVariableDeclarators{ return my._VariableDeclarators}
func (my *VariableDeclarators)      SetVariableDeclarators( _VariableDeclarators IVariableDeclarators)  { my._VariableDeclarators = _VariableDeclarators }
func (my *VariableDeclarators)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *VariableDeclarators)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *VariableDeclarators)      GetVariableDeclarator() IVariableDeclarator{ return my._VariableDeclarator}
func (my *VariableDeclarators)      SetVariableDeclarator( _VariableDeclarator IVariableDeclarator)  { my._VariableDeclarator = _VariableDeclarator }

func NewVariableDeclarators(leftIToken IToken, rightIToken IToken ,
              _VariableDeclarators IVariableDeclarators,
              _COMMA *AstToken,
              _VariableDeclarator IVariableDeclarator)*VariableDeclarators{
      my := new(VariableDeclarators)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableDeclarators = _VariableDeclarators;
        if nil != _VariableDeclarators{
        var trait_ interface{} = _VariableDeclarators
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclarator = _VariableDeclarator;
        if nil != _VariableDeclarator{
        var trait_ interface{} = _VariableDeclarator
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableDeclarators)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableDeclarators{  list.Add(my._VariableDeclarators) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._VariableDeclarator{  list.Add(my._VariableDeclarator) }
        return list
    }

func (my *VariableDeclarators)      AcceptWithVisitor(v Visitor) { v.VisitVariableDeclarators(my)}
func (my *VariableDeclarators)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitVariableDeclaratorsWithArg(my, o) }
func (my *VariableDeclarators)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitVariableDeclaratorsWithResult(my) }
func (my *VariableDeclarators)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitVariableDeclaratorsWithResultArgument(my, o) }


func AnyCastToVariableDeclarators(i interface{}) *VariableDeclarators {
	if nil == i{
		return nil
	}else{
		return i.(*VariableDeclarators)
	}
}
/**
 *<em>
*<li>Rule 109:  VariableDeclarator ::= VariableDeclaratorId
 *</em>
 *<p>
 *<b>
*<li>Rule 110:  VariableDeclarator ::= VariableDeclaratorId = VariableInitializer
 *</b>
 */
type VariableDeclarator struct{
    *Ast
      _VariableDeclaratorId IVariableDeclaratorId
      _EQUAL *AstToken
      _VariableInitializer IVariableInitializer
}
func (my *VariableDeclarator)      GetVariableDeclaratorId() IVariableDeclaratorId{ return my._VariableDeclaratorId}
func (my *VariableDeclarator)      SetVariableDeclaratorId( _VariableDeclaratorId IVariableDeclaratorId)  { my._VariableDeclaratorId = _VariableDeclaratorId }
func (my *VariableDeclarator)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *VariableDeclarator)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }
func (my *VariableDeclarator)      GetVariableInitializer() IVariableInitializer{ return my._VariableInitializer}
func (my *VariableDeclarator)      SetVariableInitializer( _VariableInitializer IVariableInitializer)  { my._VariableInitializer = _VariableInitializer }

func NewVariableDeclarator(leftIToken IToken, rightIToken IToken ,
              _VariableDeclaratorId IVariableDeclaratorId,
              _EQUAL *AstToken,
              _VariableInitializer IVariableInitializer)*VariableDeclarator{
      my := new(VariableDeclarator)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableDeclaratorId = _VariableDeclaratorId;
        if nil != _VariableDeclaratorId{
        var trait_ interface{} = _VariableDeclaratorId
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my._VariableInitializer = _VariableInitializer;
        if nil != _VariableInitializer{
        var trait_ interface{} = _VariableInitializer
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableDeclarator)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableDeclaratorId{  list.Add(my._VariableDeclaratorId) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        if nil != my._VariableInitializer{  list.Add(my._VariableInitializer) }
        return list
    }

func (my *VariableDeclarator)      AcceptWithVisitor(v Visitor) { v.VisitVariableDeclarator(my)}
func (my *VariableDeclarator)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitVariableDeclaratorWithArg(my, o) }
func (my *VariableDeclarator)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitVariableDeclaratorWithResult(my) }
func (my *VariableDeclarator)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitVariableDeclaratorWithResultArgument(my, o) }


func AnyCastToVariableDeclarator(i interface{}) *VariableDeclarator {
	if nil == i{
		return nil
	}else{
		return i.(*VariableDeclarator)
	}
}
/**
 *<em>
*<li>Rule 111:  VariableDeclaratorId ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 112:  VariableDeclaratorId ::= VariableDeclaratorId [ ]
 *</b>
 */
type VariableDeclaratorId struct{
    *Ast
      _VariableDeclaratorId IVariableDeclaratorId
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *VariableDeclaratorId)      GetVariableDeclaratorId() IVariableDeclaratorId{ return my._VariableDeclaratorId}
func (my *VariableDeclaratorId)      SetVariableDeclaratorId( _VariableDeclaratorId IVariableDeclaratorId)  { my._VariableDeclaratorId = _VariableDeclaratorId }
func (my *VariableDeclaratorId)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *VariableDeclaratorId)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *VariableDeclaratorId)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *VariableDeclaratorId)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewVariableDeclaratorId(leftIToken IToken, rightIToken IToken ,
              _VariableDeclaratorId IVariableDeclaratorId,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*VariableDeclaratorId{
      my := new(VariableDeclaratorId)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableDeclaratorId = _VariableDeclaratorId;
        if nil != _VariableDeclaratorId{
        var trait_ interface{} = _VariableDeclaratorId
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableDeclaratorId)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableDeclaratorId{  list.Add(my._VariableDeclaratorId) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *VariableDeclaratorId)      AcceptWithVisitor(v Visitor) { v.VisitVariableDeclaratorId(my)}
func (my *VariableDeclaratorId)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitVariableDeclaratorIdWithArg(my, o) }
func (my *VariableDeclaratorId)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitVariableDeclaratorIdWithResult(my) }
func (my *VariableDeclaratorId)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitVariableDeclaratorIdWithResultArgument(my, o) }


func AnyCastToVariableDeclaratorId(i interface{}) *VariableDeclaratorId {
	if nil == i{
		return nil
	}else{
		return i.(*VariableDeclaratorId)
	}
}
/**
 *<em>
*<li>Rule 115:  FieldModifiers ::= FieldModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 116:  FieldModifiers ::= FieldModifiers FieldModifier
 *</b>
 */
type FieldModifiers struct{
    *Ast
      _FieldModifiers IFieldModifiers
      _FieldModifier IFieldModifier
}
func (my *FieldModifiers)      GetFieldModifiers() IFieldModifiers{ return my._FieldModifiers}
func (my *FieldModifiers)      SetFieldModifiers( _FieldModifiers IFieldModifiers)  { my._FieldModifiers = _FieldModifiers }
func (my *FieldModifiers)      GetFieldModifier() IFieldModifier{ return my._FieldModifier}
func (my *FieldModifiers)      SetFieldModifier( _FieldModifier IFieldModifier)  { my._FieldModifier = _FieldModifier }

func NewFieldModifiers(leftIToken IToken, rightIToken IToken ,
              _FieldModifiers IFieldModifiers,
              _FieldModifier IFieldModifier)*FieldModifiers{
      my := new(FieldModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._FieldModifiers = _FieldModifiers;
        if nil != _FieldModifiers{
        var trait_ interface{} = _FieldModifiers
         trait_.(IAst).SetParent(my)
}
        my._FieldModifier = _FieldModifier;
        if nil != _FieldModifier{
        var trait_ interface{} = _FieldModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._FieldModifiers{  list.Add(my._FieldModifiers) }
        if nil != my._FieldModifier{  list.Add(my._FieldModifier) }
        return list
    }

func (my *FieldModifiers)      AcceptWithVisitor(v Visitor) { v.VisitFieldModifiers(my)}
func (my *FieldModifiers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldModifiersWithArg(my, o) }
func (my *FieldModifiers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldModifiersWithResult(my) }
func (my *FieldModifiers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldModifiersWithResultArgument(my, o) }


func AnyCastToFieldModifiers(i interface{}) *FieldModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifiers)
	}
}
/**
 *<b>
*<li>Rule 125:  MethodDeclaration ::= MethodHeader MethodBody
 *</b>
 */
type MethodDeclaration struct{
    *Ast
      _MethodHeader *MethodHeader
      _MethodBody IMethodBody
}
func (my *MethodDeclaration)      GetMethodHeader() *MethodHeader{ return my._MethodHeader}
func (my *MethodDeclaration)      SetMethodHeader( _MethodHeader *MethodHeader)  { my._MethodHeader = _MethodHeader }
func (my *MethodDeclaration)      GetMethodBody() IMethodBody{ return my._MethodBody}
func (my *MethodDeclaration)      SetMethodBody( _MethodBody IMethodBody)  { my._MethodBody = _MethodBody }

func NewMethodDeclaration(leftIToken IToken, rightIToken IToken ,
              _MethodHeader *MethodHeader,
              _MethodBody IMethodBody)*MethodDeclaration{
      my := new(MethodDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodHeader = _MethodHeader;
        if nil != _MethodHeader{
        var trait_ interface{} = _MethodHeader
         trait_.(IAst).SetParent(my)
}
        my._MethodBody = _MethodBody;
        if nil != _MethodBody{
        var trait_ interface{} = _MethodBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodHeader{  list.Add(my._MethodHeader) }
        if nil != my._MethodBody{  list.Add(my._MethodBody) }
        return list
    }

func (my *MethodDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitMethodDeclaration(my)}
func (my *MethodDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodDeclarationWithArg(my, o) }
func (my *MethodDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodDeclarationWithResult(my) }
func (my *MethodDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodDeclarationWithResultArgument(my, o) }


func AnyCastToMethodDeclaration(i interface{}) *MethodDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*MethodDeclaration)
	}
}
/**
 *<b>
*<li>Rule 126:  MethodHeader ::= MethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt
 *</b>
 */
type MethodHeader struct{
    *Ast
      _MethodModifiersopt IMethodModifiersopt
      _TypeParametersopt *TypeParameters
      _ResultType IResultType
      _MethodDeclarator IMethodDeclarator
      _Throwsopt *Throws
}
    /**
     * The value returned by <b>GetMethodModifiersopt</b> may be <b>null</b>
     */
func (my *MethodHeader)      GetMethodModifiersopt() IMethodModifiersopt{ return my._MethodModifiersopt}
func (my *MethodHeader)      SetMethodModifiersopt( _MethodModifiersopt IMethodModifiersopt)  { my._MethodModifiersopt = _MethodModifiersopt }
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *MethodHeader)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *MethodHeader)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
func (my *MethodHeader)      GetResultType() IResultType{ return my._ResultType}
func (my *MethodHeader)      SetResultType( _ResultType IResultType)  { my._ResultType = _ResultType }
func (my *MethodHeader)      GetMethodDeclarator() IMethodDeclarator{ return my._MethodDeclarator}
func (my *MethodHeader)      SetMethodDeclarator( _MethodDeclarator IMethodDeclarator)  { my._MethodDeclarator = _MethodDeclarator }
    /**
     * The value returned by <b>GetThrowsopt</b> may be <b>null</b>
     */
func (my *MethodHeader)      GetThrowsopt() *Throws{ return my._Throwsopt}
func (my *MethodHeader)      SetThrowsopt( _Throwsopt *Throws)  { my._Throwsopt = _Throwsopt }

func NewMethodHeader(leftIToken IToken, rightIToken IToken ,
              _MethodModifiersopt IMethodModifiersopt,
              _TypeParametersopt *TypeParameters,
              _ResultType IResultType,
              _MethodDeclarator IMethodDeclarator,
              _Throwsopt *Throws)*MethodHeader{
      my := new(MethodHeader)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodModifiersopt = _MethodModifiersopt;
        if nil != _MethodModifiersopt{
        var trait_ interface{} = _MethodModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._ResultType = _ResultType;
        if nil != _ResultType{
        var trait_ interface{} = _ResultType
         trait_.(IAst).SetParent(my)
}
        my._MethodDeclarator = _MethodDeclarator;
        if nil != _MethodDeclarator{
        var trait_ interface{} = _MethodDeclarator
         trait_.(IAst).SetParent(my)
}
        my._Throwsopt = _Throwsopt;
        if nil != _Throwsopt{
        var trait_ interface{} = _Throwsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodHeader)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodModifiersopt{  list.Add(my._MethodModifiersopt) }
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._ResultType{  list.Add(my._ResultType) }
        if nil != my._MethodDeclarator{  list.Add(my._MethodDeclarator) }
        if nil != my._Throwsopt{  list.Add(my._Throwsopt) }
        return list
    }

func (my *MethodHeader)      AcceptWithVisitor(v Visitor) { v.VisitMethodHeader(my)}
func (my *MethodHeader)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodHeaderWithArg(my, o) }
func (my *MethodHeader)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodHeaderWithResult(my) }
func (my *MethodHeader)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodHeaderWithResultArgument(my, o) }


func AnyCastToMethodHeader(i interface{}) *MethodHeader {
	if nil == i{
		return nil
	}else{
		return i.(*MethodHeader)
	}
}
/**
 *<em>
*<li>Rule 127:  ResultType ::= Type
 *</em>
 *<p>
 *<b>
*<li>Rule 128:  ResultType ::= void
 *</b>
 */
type ResultType struct{
    *AstToken
}
func (my *ResultType)      Getvoid()IToken{ return my.leftIToken; }

func NewResultType(token IToken )*ResultType{
      my := new(ResultType)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ResultType)      AcceptWithVisitor(v Visitor) { v.VisitResultType(my)}
func (my *ResultType)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitResultTypeWithArg(my, o) }
func (my *ResultType)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitResultTypeWithResult(my) }
func (my *ResultType)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitResultTypeWithResultArgument(my, o) }


func AnyCastToResultType(i interface{}) *ResultType {
	if nil == i{
		return nil
	}else{
		return i.(*ResultType)
	}
}
/**
 *<em>
*<li>Rule 131:  FormalParameterList ::= LastFormalParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 132:  FormalParameterList ::= FormalParameters , LastFormalParameter
 *</b>
 */
type FormalParameterList struct{
    *Ast
      _FormalParameters IFormalParameters
      _COMMA *AstToken
      _LastFormalParameter *LastFormalParameter
}
func (my *FormalParameterList)      GetFormalParameters() IFormalParameters{ return my._FormalParameters}
func (my *FormalParameterList)      SetFormalParameters( _FormalParameters IFormalParameters)  { my._FormalParameters = _FormalParameters }
func (my *FormalParameterList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *FormalParameterList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *FormalParameterList)      GetLastFormalParameter() *LastFormalParameter{ return my._LastFormalParameter}
func (my *FormalParameterList)      SetLastFormalParameter( _LastFormalParameter *LastFormalParameter)  { my._LastFormalParameter = _LastFormalParameter }

func NewFormalParameterList(leftIToken IToken, rightIToken IToken ,
              _FormalParameters IFormalParameters,
              _COMMA *AstToken,
              _LastFormalParameter *LastFormalParameter)*FormalParameterList{
      my := new(FormalParameterList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._FormalParameters = _FormalParameters;
        if nil != _FormalParameters{
        var trait_ interface{} = _FormalParameters
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._LastFormalParameter = _LastFormalParameter;
        if nil != _LastFormalParameter{
        var trait_ interface{} = _LastFormalParameter
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FormalParameterList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._FormalParameters{  list.Add(my._FormalParameters) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._LastFormalParameter{  list.Add(my._LastFormalParameter) }
        return list
    }

func (my *FormalParameterList)      AcceptWithVisitor(v Visitor) { v.VisitFormalParameterList(my)}
func (my *FormalParameterList)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFormalParameterListWithArg(my, o) }
func (my *FormalParameterList)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFormalParameterListWithResult(my) }
func (my *FormalParameterList)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFormalParameterListWithResultArgument(my, o) }


func AnyCastToFormalParameterList(i interface{}) *FormalParameterList {
	if nil == i{
		return nil
	}else{
		return i.(*FormalParameterList)
	}
}
/**
 *<em>
*<li>Rule 133:  FormalParameters ::= FormalParameter
 *</em>
 *<p>
 *<b>
*<li>Rule 134:  FormalParameters ::= FormalParameters , FormalParameter
 *</b>
 */
type FormalParameters struct{
    *Ast
      _FormalParameters IFormalParameters
      _COMMA *AstToken
      _FormalParameter *FormalParameter
}
func (my *FormalParameters)      GetFormalParameters() IFormalParameters{ return my._FormalParameters}
func (my *FormalParameters)      SetFormalParameters( _FormalParameters IFormalParameters)  { my._FormalParameters = _FormalParameters }
func (my *FormalParameters)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *FormalParameters)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *FormalParameters)      GetFormalParameter() *FormalParameter{ return my._FormalParameter}
func (my *FormalParameters)      SetFormalParameter( _FormalParameter *FormalParameter)  { my._FormalParameter = _FormalParameter }

func NewFormalParameters(leftIToken IToken, rightIToken IToken ,
              _FormalParameters IFormalParameters,
              _COMMA *AstToken,
              _FormalParameter *FormalParameter)*FormalParameters{
      my := new(FormalParameters)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._FormalParameters = _FormalParameters;
        if nil != _FormalParameters{
        var trait_ interface{} = _FormalParameters
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._FormalParameter = _FormalParameter;
        if nil != _FormalParameter{
        var trait_ interface{} = _FormalParameter
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FormalParameters)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._FormalParameters{  list.Add(my._FormalParameters) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._FormalParameter{  list.Add(my._FormalParameter) }
        return list
    }

func (my *FormalParameters)      AcceptWithVisitor(v Visitor) { v.VisitFormalParameters(my)}
func (my *FormalParameters)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFormalParametersWithArg(my, o) }
func (my *FormalParameters)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFormalParametersWithResult(my) }
func (my *FormalParameters)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFormalParametersWithResultArgument(my, o) }


func AnyCastToFormalParameters(i interface{}) *FormalParameters {
	if nil == i{
		return nil
	}else{
		return i.(*FormalParameters)
	}
}
/**
 *<b>
*<li>Rule 135:  FormalParameter ::= VariableModifiersopt Type VariableDeclaratorId
 *</b>
 */
type FormalParameter struct{
    *Ast
      _VariableModifiersopt IVariableModifiersopt
      _Type IType
      _VariableDeclaratorId IVariableDeclaratorId
}
    /**
     * The value returned by <b>GetVariableModifiersopt</b> may be <b>null</b>
     */
func (my *FormalParameter)      GetVariableModifiersopt() IVariableModifiersopt{ return my._VariableModifiersopt}
func (my *FormalParameter)      SetVariableModifiersopt( _VariableModifiersopt IVariableModifiersopt)  { my._VariableModifiersopt = _VariableModifiersopt }
func (my *FormalParameter)      GetType() IType{ return my._Type}
func (my *FormalParameter)      SetType( _Type IType)  { my._Type = _Type }
func (my *FormalParameter)      GetVariableDeclaratorId() IVariableDeclaratorId{ return my._VariableDeclaratorId}
func (my *FormalParameter)      SetVariableDeclaratorId( _VariableDeclaratorId IVariableDeclaratorId)  { my._VariableDeclaratorId = _VariableDeclaratorId }

func NewFormalParameter(leftIToken IToken, rightIToken IToken ,
              _VariableModifiersopt IVariableModifiersopt,
              _Type IType,
              _VariableDeclaratorId IVariableDeclaratorId)*FormalParameter{
      my := new(FormalParameter)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableModifiersopt = _VariableModifiersopt;
        if nil != _VariableModifiersopt{
        var trait_ interface{} = _VariableModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclaratorId = _VariableDeclaratorId;
        if nil != _VariableDeclaratorId{
        var trait_ interface{} = _VariableDeclaratorId
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FormalParameter)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableModifiersopt{  list.Add(my._VariableModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._VariableDeclaratorId{  list.Add(my._VariableDeclaratorId) }
        return list
    }

func (my *FormalParameter)      AcceptWithVisitor(v Visitor) { v.VisitFormalParameter(my)}
func (my *FormalParameter)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFormalParameterWithArg(my, o) }
func (my *FormalParameter)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFormalParameterWithResult(my) }
func (my *FormalParameter)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFormalParameterWithResultArgument(my, o) }


func AnyCastToFormalParameter(i interface{}) *FormalParameter {
	if nil == i{
		return nil
	}else{
		return i.(*FormalParameter)
	}
}
/**
 *<em>
*<li>Rule 136:  VariableModifiers ::= VariableModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 137:  VariableModifiers ::= VariableModifiers VariableModifier
 *</b>
 */
type VariableModifiers struct{
    *Ast
      _VariableModifiers IVariableModifiers
      _VariableModifier IVariableModifier
}
func (my *VariableModifiers)      GetVariableModifiers() IVariableModifiers{ return my._VariableModifiers}
func (my *VariableModifiers)      SetVariableModifiers( _VariableModifiers IVariableModifiers)  { my._VariableModifiers = _VariableModifiers }
func (my *VariableModifiers)      GetVariableModifier() IVariableModifier{ return my._VariableModifier}
func (my *VariableModifiers)      SetVariableModifier( _VariableModifier IVariableModifier)  { my._VariableModifier = _VariableModifier }

func NewVariableModifiers(leftIToken IToken, rightIToken IToken ,
              _VariableModifiers IVariableModifiers,
              _VariableModifier IVariableModifier)*VariableModifiers{
      my := new(VariableModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableModifiers = _VariableModifiers;
        if nil != _VariableModifiers{
        var trait_ interface{} = _VariableModifiers
         trait_.(IAst).SetParent(my)
}
        my._VariableModifier = _VariableModifier;
        if nil != _VariableModifier{
        var trait_ interface{} = _VariableModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableModifiers{  list.Add(my._VariableModifiers) }
        if nil != my._VariableModifier{  list.Add(my._VariableModifier) }
        return list
    }

func (my *VariableModifiers)      AcceptWithVisitor(v Visitor) { v.VisitVariableModifiers(my)}
func (my *VariableModifiers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitVariableModifiersWithArg(my, o) }
func (my *VariableModifiers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitVariableModifiersWithResult(my) }
func (my *VariableModifiers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitVariableModifiersWithResultArgument(my, o) }


func AnyCastToVariableModifiers(i interface{}) *VariableModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*VariableModifiers)
	}
}
/**
 *<em>
*<li>Rule 139:  VariableModifier ::= Annotations
 *</em>
 *<p>
 *<b>
*<li>Rule 138:  VariableModifier ::= final
 *</b>
 */
type VariableModifier struct{
    *AstToken
}
func (my *VariableModifier)      Getfinal()IToken{ return my.leftIToken; }

func NewVariableModifier(token IToken )*VariableModifier{
      my := new(VariableModifier)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *VariableModifier)      AcceptWithVisitor(v Visitor) { v.VisitVariableModifier(my)}
func (my *VariableModifier)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitVariableModifierWithArg(my, o) }
func (my *VariableModifier)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitVariableModifierWithResult(my) }
func (my *VariableModifier)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitVariableModifierWithResultArgument(my, o) }


func AnyCastToVariableModifier(i interface{}) *VariableModifier {
	if nil == i{
		return nil
	}else{
		return i.(*VariableModifier)
	}
}
/**
 *<b>
*<li>Rule 140:  LastFormalParameter ::= VariableModifiersopt Type ...opt VariableDeclaratorId
 *</b>
 */
type LastFormalParameter struct{
    *Ast
      _VariableModifiersopt IVariableModifiersopt
      _Type IType
      _Ellipsisopt *Ellipsisopt
      _VariableDeclaratorId IVariableDeclaratorId
}
    /**
     * The value returned by <b>GetVariableModifiersopt</b> may be <b>null</b>
     */
func (my *LastFormalParameter)      GetVariableModifiersopt() IVariableModifiersopt{ return my._VariableModifiersopt}
func (my *LastFormalParameter)      SetVariableModifiersopt( _VariableModifiersopt IVariableModifiersopt)  { my._VariableModifiersopt = _VariableModifiersopt }
func (my *LastFormalParameter)      GetType() IType{ return my._Type}
func (my *LastFormalParameter)      SetType( _Type IType)  { my._Type = _Type }
    /**
     * The value returned by <b>GetEllipsisopt</b> may be <b>null</b>
     */
func (my *LastFormalParameter)      GetEllipsisopt() *Ellipsisopt{ return my._Ellipsisopt}
func (my *LastFormalParameter)      SetEllipsisopt( _Ellipsisopt *Ellipsisopt)  { my._Ellipsisopt = _Ellipsisopt }
func (my *LastFormalParameter)      GetVariableDeclaratorId() IVariableDeclaratorId{ return my._VariableDeclaratorId}
func (my *LastFormalParameter)      SetVariableDeclaratorId( _VariableDeclaratorId IVariableDeclaratorId)  { my._VariableDeclaratorId = _VariableDeclaratorId }

func NewLastFormalParameter(leftIToken IToken, rightIToken IToken ,
              _VariableModifiersopt IVariableModifiersopt,
              _Type IType,
              _Ellipsisopt *Ellipsisopt,
              _VariableDeclaratorId IVariableDeclaratorId)*LastFormalParameter{
      my := new(LastFormalParameter)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableModifiersopt = _VariableModifiersopt;
        if nil != _VariableModifiersopt{
        var trait_ interface{} = _VariableModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._Ellipsisopt = _Ellipsisopt;
        if nil != _Ellipsisopt{
        var trait_ interface{} = _Ellipsisopt
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclaratorId = _VariableDeclaratorId;
        if nil != _VariableDeclaratorId{
        var trait_ interface{} = _VariableDeclaratorId
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LastFormalParameter)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableModifiersopt{  list.Add(my._VariableModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._Ellipsisopt{  list.Add(my._Ellipsisopt) }
        if nil != my._VariableDeclaratorId{  list.Add(my._VariableDeclaratorId) }
        return list
    }

func (my *LastFormalParameter)      AcceptWithVisitor(v Visitor) { v.VisitLastFormalParameter(my)}
func (my *LastFormalParameter)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLastFormalParameterWithArg(my, o) }
func (my *LastFormalParameter)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLastFormalParameterWithResult(my) }
func (my *LastFormalParameter)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLastFormalParameterWithResultArgument(my, o) }


func AnyCastToLastFormalParameter(i interface{}) *LastFormalParameter {
	if nil == i{
		return nil
	}else{
		return i.(*LastFormalParameter)
	}
}
/**
 *<em>
*<li>Rule 141:  MethodModifiers ::= MethodModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 142:  MethodModifiers ::= MethodModifiers MethodModifier
 *</b>
 */
type MethodModifiers struct{
    *Ast
      _MethodModifiers IMethodModifiers
      _MethodModifier IMethodModifier
}
func (my *MethodModifiers)      GetMethodModifiers() IMethodModifiers{ return my._MethodModifiers}
func (my *MethodModifiers)      SetMethodModifiers( _MethodModifiers IMethodModifiers)  { my._MethodModifiers = _MethodModifiers }
func (my *MethodModifiers)      GetMethodModifier() IMethodModifier{ return my._MethodModifier}
func (my *MethodModifiers)      SetMethodModifier( _MethodModifier IMethodModifier)  { my._MethodModifier = _MethodModifier }

func NewMethodModifiers(leftIToken IToken, rightIToken IToken ,
              _MethodModifiers IMethodModifiers,
              _MethodModifier IMethodModifier)*MethodModifiers{
      my := new(MethodModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodModifiers = _MethodModifiers;
        if nil != _MethodModifiers{
        var trait_ interface{} = _MethodModifiers
         trait_.(IAst).SetParent(my)
}
        my._MethodModifier = _MethodModifier;
        if nil != _MethodModifier{
        var trait_ interface{} = _MethodModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodModifiers{  list.Add(my._MethodModifiers) }
        if nil != my._MethodModifier{  list.Add(my._MethodModifier) }
        return list
    }

func (my *MethodModifiers)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifiers(my)}
func (my *MethodModifiers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifiersWithArg(my, o) }
func (my *MethodModifiers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifiersWithResult(my) }
func (my *MethodModifiers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifiersWithResultArgument(my, o) }


func AnyCastToMethodModifiers(i interface{}) *MethodModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifiers)
	}
}
/**
 *<b>
*<li>Rule 153:  Throws ::= throws ExceptionTypeList
 *</b>
 */
type Throws struct{
    *Ast
      _throws *AstToken
      _ExceptionTypeList IExceptionTypeList
}
func (my *Throws)      Getthrows() *AstToken{ return my._throws}
func (my *Throws)      Setthrows( _throws *AstToken)  { my._throws = _throws }
func (my *Throws)      GetExceptionTypeList() IExceptionTypeList{ return my._ExceptionTypeList}
func (my *Throws)      SetExceptionTypeList( _ExceptionTypeList IExceptionTypeList)  { my._ExceptionTypeList = _ExceptionTypeList }

func NewThrows(leftIToken IToken, rightIToken IToken ,
              _throws *AstToken,
              _ExceptionTypeList IExceptionTypeList)*Throws{
      my := new(Throws)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._throws = _throws;
        if nil != _throws{
        var trait_ interface{} = _throws
         trait_.(IAst).SetParent(my)
}
        my._ExceptionTypeList = _ExceptionTypeList;
        if nil != _ExceptionTypeList{
        var trait_ interface{} = _ExceptionTypeList
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Throws)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._throws{  list.Add(my._throws) }
        if nil != my._ExceptionTypeList{  list.Add(my._ExceptionTypeList) }
        return list
    }

func (my *Throws)      AcceptWithVisitor(v Visitor) { v.VisitThrows(my)}
func (my *Throws)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitThrowsWithArg(my, o) }
func (my *Throws)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitThrowsWithResult(my) }
func (my *Throws)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitThrowsWithResultArgument(my, o) }


func AnyCastToThrows(i interface{}) *Throws {
	if nil == i{
		return nil
	}else{
		return i.(*Throws)
	}
}
/**
 *<em>
*<li>Rule 154:  ExceptionTypeList ::= ExceptionType
 *</em>
 *<p>
 *<b>
*<li>Rule 155:  ExceptionTypeList ::= ExceptionTypeList , ExceptionType
 *</b>
 */
type ExceptionTypeList struct{
    *Ast
      _ExceptionTypeList IExceptionTypeList
      _COMMA *AstToken
      _ExceptionType IExceptionType
}
func (my *ExceptionTypeList)      GetExceptionTypeList() IExceptionTypeList{ return my._ExceptionTypeList}
func (my *ExceptionTypeList)      SetExceptionTypeList( _ExceptionTypeList IExceptionTypeList)  { my._ExceptionTypeList = _ExceptionTypeList }
func (my *ExceptionTypeList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ExceptionTypeList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ExceptionTypeList)      GetExceptionType() IExceptionType{ return my._ExceptionType}
func (my *ExceptionTypeList)      SetExceptionType( _ExceptionType IExceptionType)  { my._ExceptionType = _ExceptionType }

func NewExceptionTypeList(leftIToken IToken, rightIToken IToken ,
              _ExceptionTypeList IExceptionTypeList,
              _COMMA *AstToken,
              _ExceptionType IExceptionType)*ExceptionTypeList{
      my := new(ExceptionTypeList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ExceptionTypeList = _ExceptionTypeList;
        if nil != _ExceptionTypeList{
        var trait_ interface{} = _ExceptionTypeList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._ExceptionType = _ExceptionType;
        if nil != _ExceptionType{
        var trait_ interface{} = _ExceptionType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExceptionTypeList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ExceptionTypeList{  list.Add(my._ExceptionTypeList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._ExceptionType{  list.Add(my._ExceptionType) }
        return list
    }

func (my *ExceptionTypeList)      AcceptWithVisitor(v Visitor) { v.VisitExceptionTypeList(my)}
func (my *ExceptionTypeList)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExceptionTypeListWithArg(my, o) }
func (my *ExceptionTypeList)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExceptionTypeListWithResult(my) }
func (my *ExceptionTypeList)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExceptionTypeListWithResultArgument(my, o) }


func AnyCastToExceptionTypeList(i interface{}) *ExceptionTypeList {
	if nil == i{
		return nil
	}else{
		return i.(*ExceptionTypeList)
	}
}
/**
 *<em>
*<li>Rule 158:  MethodBody ::= Block
 *</em>
 *<p>
 *<b>
*<li>Rule 159:  MethodBody ::= ;
 *</b>
 */
type MethodBody struct{
    *AstToken
}
func (my *MethodBody)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewMethodBody(token IToken )*MethodBody{
      my := new(MethodBody)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodBody)      AcceptWithVisitor(v Visitor) { v.VisitMethodBody(my)}
func (my *MethodBody)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodBodyWithArg(my, o) }
func (my *MethodBody)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodBodyWithResult(my) }
func (my *MethodBody)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodBodyWithResultArgument(my, o) }


func AnyCastToMethodBody(i interface{}) *MethodBody {
	if nil == i{
		return nil
	}else{
		return i.(*MethodBody)
	}
}
/**
 *<b>
*<li>Rule 161:  StaticInitializer ::= static Block
 *</b>
 */
type StaticInitializer struct{
    *Ast
      _static *AstToken
      _Block *Block
}
func (my *StaticInitializer)      Getstatic() *AstToken{ return my._static}
func (my *StaticInitializer)      Setstatic( _static *AstToken)  { my._static = _static }
func (my *StaticInitializer)      GetBlock() *Block{ return my._Block}
func (my *StaticInitializer)      SetBlock( _Block *Block)  { my._Block = _Block }

func NewStaticInitializer(leftIToken IToken, rightIToken IToken ,
              _static *AstToken,
              _Block *Block)*StaticInitializer{
      my := new(StaticInitializer)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._static = _static;
        if nil != _static{
        var trait_ interface{} = _static
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *StaticInitializer)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._static{  list.Add(my._static) }
        if nil != my._Block{  list.Add(my._Block) }
        return list
    }

func (my *StaticInitializer)      AcceptWithVisitor(v Visitor) { v.VisitStaticInitializer(my)}
func (my *StaticInitializer)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitStaticInitializerWithArg(my, o) }
func (my *StaticInitializer)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitStaticInitializerWithResult(my) }
func (my *StaticInitializer)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitStaticInitializerWithResultArgument(my, o) }


func AnyCastToStaticInitializer(i interface{}) *StaticInitializer {
	if nil == i{
		return nil
	}else{
		return i.(*StaticInitializer)
	}
}
/**
 *<b>
*<li>Rule 162:  ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator Throwsopt ConstructorBody
 *</b>
 */
type ConstructorDeclaration struct{
    *Ast
      _ConstructorModifiersopt IConstructorModifiersopt
      _ConstructorDeclarator *ConstructorDeclarator
      _Throwsopt *Throws
      _ConstructorBody *ConstructorBody
}
    /**
     * The value returned by <b>GetConstructorModifiersopt</b> may be <b>null</b>
     */
func (my *ConstructorDeclaration)      GetConstructorModifiersopt() IConstructorModifiersopt{ return my._ConstructorModifiersopt}
func (my *ConstructorDeclaration)      SetConstructorModifiersopt( _ConstructorModifiersopt IConstructorModifiersopt)  { my._ConstructorModifiersopt = _ConstructorModifiersopt }
func (my *ConstructorDeclaration)      GetConstructorDeclarator() *ConstructorDeclarator{ return my._ConstructorDeclarator}
func (my *ConstructorDeclaration)      SetConstructorDeclarator( _ConstructorDeclarator *ConstructorDeclarator)  { my._ConstructorDeclarator = _ConstructorDeclarator }
    /**
     * The value returned by <b>GetThrowsopt</b> may be <b>null</b>
     */
func (my *ConstructorDeclaration)      GetThrowsopt() *Throws{ return my._Throwsopt}
func (my *ConstructorDeclaration)      SetThrowsopt( _Throwsopt *Throws)  { my._Throwsopt = _Throwsopt }
func (my *ConstructorDeclaration)      GetConstructorBody() *ConstructorBody{ return my._ConstructorBody}
func (my *ConstructorDeclaration)      SetConstructorBody( _ConstructorBody *ConstructorBody)  { my._ConstructorBody = _ConstructorBody }

func NewConstructorDeclaration(leftIToken IToken, rightIToken IToken ,
              _ConstructorModifiersopt IConstructorModifiersopt,
              _ConstructorDeclarator *ConstructorDeclarator,
              _Throwsopt *Throws,
              _ConstructorBody *ConstructorBody)*ConstructorDeclaration{
      my := new(ConstructorDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConstructorModifiersopt = _ConstructorModifiersopt;
        if nil != _ConstructorModifiersopt{
        var trait_ interface{} = _ConstructorModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._ConstructorDeclarator = _ConstructorDeclarator;
        if nil != _ConstructorDeclarator{
        var trait_ interface{} = _ConstructorDeclarator
         trait_.(IAst).SetParent(my)
}
        my._Throwsopt = _Throwsopt;
        if nil != _Throwsopt{
        var trait_ interface{} = _Throwsopt
         trait_.(IAst).SetParent(my)
}
        my._ConstructorBody = _ConstructorBody;
        if nil != _ConstructorBody{
        var trait_ interface{} = _ConstructorBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstructorDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConstructorModifiersopt{  list.Add(my._ConstructorModifiersopt) }
        if nil != my._ConstructorDeclarator{  list.Add(my._ConstructorDeclarator) }
        if nil != my._Throwsopt{  list.Add(my._Throwsopt) }
        if nil != my._ConstructorBody{  list.Add(my._ConstructorBody) }
        return list
    }

func (my *ConstructorDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitConstructorDeclaration(my)}
func (my *ConstructorDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstructorDeclarationWithArg(my, o) }
func (my *ConstructorDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstructorDeclarationWithResult(my) }
func (my *ConstructorDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstructorDeclarationWithResultArgument(my, o) }


func AnyCastToConstructorDeclaration(i interface{}) *ConstructorDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorDeclaration)
	}
}
/**
 *<b>
*<li>Rule 163:  ConstructorDeclarator ::= TypeParametersopt SimpleTypeName ( FormalParameterListopt )
 *</b>
 */
type ConstructorDeclarator struct{
    *Ast
      _TypeParametersopt *TypeParameters
      _SimpleTypeName *identifier
      _LPAREN *AstToken
      _FormalParameterListopt IFormalParameterListopt
      _RPAREN *AstToken
}
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *ConstructorDeclarator)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *ConstructorDeclarator)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
func (my *ConstructorDeclarator)      GetSimpleTypeName() *identifier{ return my._SimpleTypeName}
func (my *ConstructorDeclarator)      SetSimpleTypeName( _SimpleTypeName *identifier)  { my._SimpleTypeName = _SimpleTypeName }
func (my *ConstructorDeclarator)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ConstructorDeclarator)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetFormalParameterListopt</b> may be <b>null</b>
     */
func (my *ConstructorDeclarator)      GetFormalParameterListopt() IFormalParameterListopt{ return my._FormalParameterListopt}
func (my *ConstructorDeclarator)      SetFormalParameterListopt( _FormalParameterListopt IFormalParameterListopt)  { my._FormalParameterListopt = _FormalParameterListopt }
func (my *ConstructorDeclarator)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ConstructorDeclarator)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewConstructorDeclarator(leftIToken IToken, rightIToken IToken ,
              _TypeParametersopt *TypeParameters,
              _SimpleTypeName *identifier,
              _LPAREN *AstToken,
              _FormalParameterListopt IFormalParameterListopt,
              _RPAREN *AstToken)*ConstructorDeclarator{
      my := new(ConstructorDeclarator)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._SimpleTypeName = _SimpleTypeName;
        if nil != _SimpleTypeName{
        var trait_ interface{} = _SimpleTypeName
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._FormalParameterListopt = _FormalParameterListopt;
        if nil != _FormalParameterListopt{
        var trait_ interface{} = _FormalParameterListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstructorDeclarator)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._SimpleTypeName{  list.Add(my._SimpleTypeName) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._FormalParameterListopt{  list.Add(my._FormalParameterListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *ConstructorDeclarator)      AcceptWithVisitor(v Visitor) { v.VisitConstructorDeclarator(my)}
func (my *ConstructorDeclarator)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstructorDeclaratorWithArg(my, o) }
func (my *ConstructorDeclarator)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstructorDeclaratorWithResult(my) }
func (my *ConstructorDeclarator)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstructorDeclaratorWithResultArgument(my, o) }


func AnyCastToConstructorDeclarator(i interface{}) *ConstructorDeclarator {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorDeclarator)
	}
}
/**
 *<em>
*<li>Rule 165:  ConstructorModifiers ::= ConstructorModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 166:  ConstructorModifiers ::= ConstructorModifiers ConstructorModifier
 *</b>
 */
type ConstructorModifiers struct{
    *Ast
      _ConstructorModifiers IConstructorModifiers
      _ConstructorModifier IConstructorModifier
}
func (my *ConstructorModifiers)      GetConstructorModifiers() IConstructorModifiers{ return my._ConstructorModifiers}
func (my *ConstructorModifiers)      SetConstructorModifiers( _ConstructorModifiers IConstructorModifiers)  { my._ConstructorModifiers = _ConstructorModifiers }
func (my *ConstructorModifiers)      GetConstructorModifier() IConstructorModifier{ return my._ConstructorModifier}
func (my *ConstructorModifiers)      SetConstructorModifier( _ConstructorModifier IConstructorModifier)  { my._ConstructorModifier = _ConstructorModifier }

func NewConstructorModifiers(leftIToken IToken, rightIToken IToken ,
              _ConstructorModifiers IConstructorModifiers,
              _ConstructorModifier IConstructorModifier)*ConstructorModifiers{
      my := new(ConstructorModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConstructorModifiers = _ConstructorModifiers;
        if nil != _ConstructorModifiers{
        var trait_ interface{} = _ConstructorModifiers
         trait_.(IAst).SetParent(my)
}
        my._ConstructorModifier = _ConstructorModifier;
        if nil != _ConstructorModifier{
        var trait_ interface{} = _ConstructorModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstructorModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConstructorModifiers{  list.Add(my._ConstructorModifiers) }
        if nil != my._ConstructorModifier{  list.Add(my._ConstructorModifier) }
        return list
    }

func (my *ConstructorModifiers)      AcceptWithVisitor(v Visitor) { v.VisitConstructorModifiers(my)}
func (my *ConstructorModifiers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstructorModifiersWithArg(my, o) }
func (my *ConstructorModifiers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstructorModifiersWithResult(my) }
func (my *ConstructorModifiers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstructorModifiersWithResultArgument(my, o) }


func AnyCastToConstructorModifiers(i interface{}) *ConstructorModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorModifiers)
	}
}
/**
 *<b>
*<li>Rule 171:  ConstructorBody ::= { ExplicitConstructorInvocationopt BlockStatementsopt }
 *</b>
 */
type ConstructorBody struct{
    *Ast
      _LBRACE *AstToken
      _ExplicitConstructorInvocationopt IExplicitConstructorInvocationopt
      _BlockStatementsopt IBlockStatementsopt
      _RBRACE *AstToken
}
func (my *ConstructorBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *ConstructorBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetExplicitConstructorInvocationopt</b> may be <b>null</b>
     */
func (my *ConstructorBody)      GetExplicitConstructorInvocationopt() IExplicitConstructorInvocationopt{ return my._ExplicitConstructorInvocationopt}
func (my *ConstructorBody)      SetExplicitConstructorInvocationopt( _ExplicitConstructorInvocationopt IExplicitConstructorInvocationopt)  { my._ExplicitConstructorInvocationopt = _ExplicitConstructorInvocationopt }
    /**
     * The value returned by <b>GetBlockStatementsopt</b> may be <b>null</b>
     */
func (my *ConstructorBody)      GetBlockStatementsopt() IBlockStatementsopt{ return my._BlockStatementsopt}
func (my *ConstructorBody)      SetBlockStatementsopt( _BlockStatementsopt IBlockStatementsopt)  { my._BlockStatementsopt = _BlockStatementsopt }
func (my *ConstructorBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *ConstructorBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewConstructorBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _ExplicitConstructorInvocationopt IExplicitConstructorInvocationopt,
              _BlockStatementsopt IBlockStatementsopt,
              _RBRACE *AstToken)*ConstructorBody{
      my := new(ConstructorBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._ExplicitConstructorInvocationopt = _ExplicitConstructorInvocationopt;
        if nil != _ExplicitConstructorInvocationopt{
        var trait_ interface{} = _ExplicitConstructorInvocationopt
         trait_.(IAst).SetParent(my)
}
        my._BlockStatementsopt = _BlockStatementsopt;
        if nil != _BlockStatementsopt{
        var trait_ interface{} = _BlockStatementsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstructorBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._ExplicitConstructorInvocationopt{  list.Add(my._ExplicitConstructorInvocationopt) }
        if nil != my._BlockStatementsopt{  list.Add(my._BlockStatementsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *ConstructorBody)      AcceptWithVisitor(v Visitor) { v.VisitConstructorBody(my)}
func (my *ConstructorBody)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstructorBodyWithArg(my, o) }
func (my *ConstructorBody)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstructorBodyWithResult(my) }
func (my *ConstructorBody)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstructorBodyWithResultArgument(my, o) }


func AnyCastToConstructorBody(i interface{}) *ConstructorBody {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorBody)
	}
}
/**
 *<b>
*<li>Rule 175:  EnumDeclaration ::= ClassModifiersopt enum identifier Interfacesopt EnumBody
 *</b>
 */
type EnumDeclaration struct{
    *Ast
      _ClassModifiersopt IClassModifiersopt
      _enum *AstToken
      _identifier *identifier
      _Interfacesopt *Interfaces
      _EnumBody *EnumBody
}
    /**
     * The value returned by <b>GetClassModifiersopt</b> may be <b>null</b>
     */
func (my *EnumDeclaration)      GetClassModifiersopt() IClassModifiersopt{ return my._ClassModifiersopt}
func (my *EnumDeclaration)      SetClassModifiersopt( _ClassModifiersopt IClassModifiersopt)  { my._ClassModifiersopt = _ClassModifiersopt }
func (my *EnumDeclaration)      Getenum() *AstToken{ return my._enum}
func (my *EnumDeclaration)      Setenum( _enum *AstToken)  { my._enum = _enum }
func (my *EnumDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *EnumDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetInterfacesopt</b> may be <b>null</b>
     */
func (my *EnumDeclaration)      GetInterfacesopt() *Interfaces{ return my._Interfacesopt}
func (my *EnumDeclaration)      SetInterfacesopt( _Interfacesopt *Interfaces)  { my._Interfacesopt = _Interfacesopt }
func (my *EnumDeclaration)      GetEnumBody() *EnumBody{ return my._EnumBody}
func (my *EnumDeclaration)      SetEnumBody( _EnumBody *EnumBody)  { my._EnumBody = _EnumBody }

func NewEnumDeclaration(leftIToken IToken, rightIToken IToken ,
              _ClassModifiersopt IClassModifiersopt,
              _enum *AstToken,
              _identifier *identifier,
              _Interfacesopt *Interfaces,
              _EnumBody *EnumBody)*EnumDeclaration{
      my := new(EnumDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassModifiersopt = _ClassModifiersopt;
        if nil != _ClassModifiersopt{
        var trait_ interface{} = _ClassModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._enum = _enum;
        if nil != _enum{
        var trait_ interface{} = _enum
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._Interfacesopt = _Interfacesopt;
        if nil != _Interfacesopt{
        var trait_ interface{} = _Interfacesopt
         trait_.(IAst).SetParent(my)
}
        my._EnumBody = _EnumBody;
        if nil != _EnumBody{
        var trait_ interface{} = _EnumBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassModifiersopt{  list.Add(my._ClassModifiersopt) }
        if nil != my._enum{  list.Add(my._enum) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._Interfacesopt{  list.Add(my._Interfacesopt) }
        if nil != my._EnumBody{  list.Add(my._EnumBody) }
        return list
    }

func (my *EnumDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitEnumDeclaration(my)}
func (my *EnumDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEnumDeclarationWithArg(my, o) }
func (my *EnumDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEnumDeclarationWithResult(my) }
func (my *EnumDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEnumDeclarationWithResultArgument(my, o) }


func AnyCastToEnumDeclaration(i interface{}) *EnumDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*EnumDeclaration)
	}
}
/**
 *<b>
*<li>Rule 176:  EnumBody ::= { EnumConstantsopt ,opt EnumBodyDeclarationsopt }
 *</b>
 */
type EnumBody struct{
    *Ast
      _LBRACE *AstToken
      _EnumConstantsopt IEnumConstantsopt
      _Commaopt *Commaopt
      _EnumBodyDeclarationsopt *EnumBodyDeclarations
      _RBRACE *AstToken
}
func (my *EnumBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *EnumBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetEnumConstantsopt</b> may be <b>null</b>
     */
func (my *EnumBody)      GetEnumConstantsopt() IEnumConstantsopt{ return my._EnumConstantsopt}
func (my *EnumBody)      SetEnumConstantsopt( _EnumConstantsopt IEnumConstantsopt)  { my._EnumConstantsopt = _EnumConstantsopt }
    /**
     * The value returned by <b>GetCommaopt</b> may be <b>null</b>
     */
func (my *EnumBody)      GetCommaopt() *Commaopt{ return my._Commaopt}
func (my *EnumBody)      SetCommaopt( _Commaopt *Commaopt)  { my._Commaopt = _Commaopt }
    /**
     * The value returned by <b>GetEnumBodyDeclarationsopt</b> may be <b>null</b>
     */
func (my *EnumBody)      GetEnumBodyDeclarationsopt() *EnumBodyDeclarations{ return my._EnumBodyDeclarationsopt}
func (my *EnumBody)      SetEnumBodyDeclarationsopt( _EnumBodyDeclarationsopt *EnumBodyDeclarations)  { my._EnumBodyDeclarationsopt = _EnumBodyDeclarationsopt }
func (my *EnumBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *EnumBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewEnumBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _EnumConstantsopt IEnumConstantsopt,
              _Commaopt *Commaopt,
              _EnumBodyDeclarationsopt *EnumBodyDeclarations,
              _RBRACE *AstToken)*EnumBody{
      my := new(EnumBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._EnumConstantsopt = _EnumConstantsopt;
        if nil != _EnumConstantsopt{
        var trait_ interface{} = _EnumConstantsopt
         trait_.(IAst).SetParent(my)
}
        my._Commaopt = _Commaopt;
        if nil != _Commaopt{
        var trait_ interface{} = _Commaopt
         trait_.(IAst).SetParent(my)
}
        my._EnumBodyDeclarationsopt = _EnumBodyDeclarationsopt;
        if nil != _EnumBodyDeclarationsopt{
        var trait_ interface{} = _EnumBodyDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._EnumConstantsopt{  list.Add(my._EnumConstantsopt) }
        if nil != my._Commaopt{  list.Add(my._Commaopt) }
        if nil != my._EnumBodyDeclarationsopt{  list.Add(my._EnumBodyDeclarationsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *EnumBody)      AcceptWithVisitor(v Visitor) { v.VisitEnumBody(my)}
func (my *EnumBody)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEnumBodyWithArg(my, o) }
func (my *EnumBody)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEnumBodyWithResult(my) }
func (my *EnumBody)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEnumBodyWithResultArgument(my, o) }


func AnyCastToEnumBody(i interface{}) *EnumBody {
	if nil == i{
		return nil
	}else{
		return i.(*EnumBody)
	}
}
/**
 *<em>
*<li>Rule 177:  EnumConstants ::= EnumConstant
 *</em>
 *<p>
 *<b>
*<li>Rule 178:  EnumConstants ::= EnumConstants , EnumConstant
 *</b>
 */
type EnumConstants struct{
    *Ast
      _EnumConstants IEnumConstants
      _COMMA *AstToken
      _EnumConstant IEnumConstant
}
func (my *EnumConstants)      GetEnumConstants() IEnumConstants{ return my._EnumConstants}
func (my *EnumConstants)      SetEnumConstants( _EnumConstants IEnumConstants)  { my._EnumConstants = _EnumConstants }
func (my *EnumConstants)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *EnumConstants)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *EnumConstants)      GetEnumConstant() IEnumConstant{ return my._EnumConstant}
func (my *EnumConstants)      SetEnumConstant( _EnumConstant IEnumConstant)  { my._EnumConstant = _EnumConstant }

func NewEnumConstants(leftIToken IToken, rightIToken IToken ,
              _EnumConstants IEnumConstants,
              _COMMA *AstToken,
              _EnumConstant IEnumConstant)*EnumConstants{
      my := new(EnumConstants)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._EnumConstants = _EnumConstants;
        if nil != _EnumConstants{
        var trait_ interface{} = _EnumConstants
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._EnumConstant = _EnumConstant;
        if nil != _EnumConstant{
        var trait_ interface{} = _EnumConstant
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumConstants)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._EnumConstants{  list.Add(my._EnumConstants) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._EnumConstant{  list.Add(my._EnumConstant) }
        return list
    }

func (my *EnumConstants)      AcceptWithVisitor(v Visitor) { v.VisitEnumConstants(my)}
func (my *EnumConstants)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEnumConstantsWithArg(my, o) }
func (my *EnumConstants)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEnumConstantsWithResult(my) }
func (my *EnumConstants)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEnumConstantsWithResultArgument(my, o) }


func AnyCastToEnumConstants(i interface{}) *EnumConstants {
	if nil == i{
		return nil
	}else{
		return i.(*EnumConstants)
	}
}
/**
 *<em>
*<li>Rule 307:  EnumConstant ::= identifier
 *</em>
 *<p>
 *<b>
*<li>Rule 179:  EnumConstant ::= Annotationsopt identifier Argumentsopt ClassBodyopt
 *</b>
 */
type EnumConstant struct{
    *Ast
      _Annotationsopt IAnnotationsopt
      _identifier *identifier
      _Argumentsopt *Arguments
      _ClassBodyopt *ClassBody
}
    /**
     * The value returned by <b>GetAnnotationsopt</b> may be <b>null</b>
     */
func (my *EnumConstant)      GetAnnotationsopt() IAnnotationsopt{ return my._Annotationsopt}
func (my *EnumConstant)      SetAnnotationsopt( _Annotationsopt IAnnotationsopt)  { my._Annotationsopt = _Annotationsopt }
func (my *EnumConstant)      Getidentifier() *identifier{ return my._identifier}
func (my *EnumConstant)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetArgumentsopt</b> may be <b>null</b>
     */
func (my *EnumConstant)      GetArgumentsopt() *Arguments{ return my._Argumentsopt}
func (my *EnumConstant)      SetArgumentsopt( _Argumentsopt *Arguments)  { my._Argumentsopt = _Argumentsopt }
    /**
     * The value returned by <b>GetClassBodyopt</b> may be <b>null</b>
     */
func (my *EnumConstant)      GetClassBodyopt() *ClassBody{ return my._ClassBodyopt}
func (my *EnumConstant)      SetClassBodyopt( _ClassBodyopt *ClassBody)  { my._ClassBodyopt = _ClassBodyopt }

func NewEnumConstant(leftIToken IToken, rightIToken IToken ,
              _Annotationsopt IAnnotationsopt,
              _identifier *identifier,
              _Argumentsopt *Arguments,
              _ClassBodyopt *ClassBody)*EnumConstant{
      my := new(EnumConstant)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Annotationsopt = _Annotationsopt;
        if nil != _Annotationsopt{
        var trait_ interface{} = _Annotationsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._Argumentsopt = _Argumentsopt;
        if nil != _Argumentsopt{
        var trait_ interface{} = _Argumentsopt
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyopt = _ClassBodyopt;
        if nil != _ClassBodyopt{
        var trait_ interface{} = _ClassBodyopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumConstant)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Annotationsopt{  list.Add(my._Annotationsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._Argumentsopt{  list.Add(my._Argumentsopt) }
        if nil != my._ClassBodyopt{  list.Add(my._ClassBodyopt) }
        return list
    }

func (my *EnumConstant)      AcceptWithVisitor(v Visitor) { v.VisitEnumConstant(my)}
func (my *EnumConstant)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEnumConstantWithArg(my, o) }
func (my *EnumConstant)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEnumConstantWithResult(my) }
func (my *EnumConstant)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEnumConstantWithResultArgument(my, o) }


func AnyCastToEnumConstant(i interface{}) *EnumConstant {
	if nil == i{
		return nil
	}else{
		return i.(*EnumConstant)
	}
}
/**
 *<b>
*<li>Rule 180:  Arguments ::= ( ArgumentListopt )
 *</b>
 */
type Arguments struct{
    *Ast
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *Arguments)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *Arguments)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *Arguments)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *Arguments)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *Arguments)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *Arguments)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewArguments(leftIToken IToken, rightIToken IToken ,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*Arguments{
      my := new(Arguments)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Arguments)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *Arguments)      AcceptWithVisitor(v Visitor) { v.VisitArguments(my)}
func (my *Arguments)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArgumentsWithArg(my, o) }
func (my *Arguments)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArgumentsWithResult(my) }
func (my *Arguments)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArgumentsWithResultArgument(my, o) }


func AnyCastToArguments(i interface{}) *Arguments {
	if nil == i{
		return nil
	}else{
		return i.(*Arguments)
	}
}
/**
 *<b>
*<li>Rule 181:  EnumBodyDeclarations ::= ; ClassBodyDeclarationsopt
 *</b>
 */
type EnumBodyDeclarations struct{
    *Ast
      _SEMICOLON *AstToken
      _ClassBodyDeclarationsopt IClassBodyDeclarationsopt
}
func (my *EnumBodyDeclarations)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *EnumBodyDeclarations)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }
    /**
     * The value returned by <b>GetClassBodyDeclarationsopt</b> may be <b>null</b>
     */
func (my *EnumBodyDeclarations)      GetClassBodyDeclarationsopt() IClassBodyDeclarationsopt{ return my._ClassBodyDeclarationsopt}
func (my *EnumBodyDeclarations)      SetClassBodyDeclarationsopt( _ClassBodyDeclarationsopt IClassBodyDeclarationsopt)  { my._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt }

func NewEnumBodyDeclarations(leftIToken IToken, rightIToken IToken ,
              _SEMICOLON *AstToken,
              _ClassBodyDeclarationsopt IClassBodyDeclarationsopt)*EnumBodyDeclarations{
      my := new(EnumBodyDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyDeclarationsopt = _ClassBodyDeclarationsopt;
        if nil != _ClassBodyDeclarationsopt{
        var trait_ interface{} = _ClassBodyDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnumBodyDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        if nil != my._ClassBodyDeclarationsopt{  list.Add(my._ClassBodyDeclarationsopt) }
        return list
    }

func (my *EnumBodyDeclarations)      AcceptWithVisitor(v Visitor) { v.VisitEnumBodyDeclarations(my)}
func (my *EnumBodyDeclarations)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEnumBodyDeclarationsWithArg(my, o) }
func (my *EnumBodyDeclarations)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEnumBodyDeclarationsWithResult(my) }
func (my *EnumBodyDeclarations)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEnumBodyDeclarationsWithResultArgument(my, o) }


func AnyCastToEnumBodyDeclarations(i interface{}) *EnumBodyDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*EnumBodyDeclarations)
	}
}
/**
 *<b>
*<li>Rule 184:  NormalInterfaceDeclaration ::= InterfaceModifiersopt interface identifier TypeParametersopt ExtendsInterfacesopt InterfaceBody
 *</b>
 */
type NormalInterfaceDeclaration struct{
    *Ast
      _InterfaceModifiersopt IInterfaceModifiersopt
      _interface *AstToken
      _identifier *identifier
      _TypeParametersopt *TypeParameters
      _ExtendsInterfacesopt IExtendsInterfacesopt
      _InterfaceBody *InterfaceBody
}
    /**
     * The value returned by <b>GetInterfaceModifiersopt</b> may be <b>null</b>
     */
func (my *NormalInterfaceDeclaration)      GetInterfaceModifiersopt() IInterfaceModifiersopt{ return my._InterfaceModifiersopt}
func (my *NormalInterfaceDeclaration)      SetInterfaceModifiersopt( _InterfaceModifiersopt IInterfaceModifiersopt)  { my._InterfaceModifiersopt = _InterfaceModifiersopt }
func (my *NormalInterfaceDeclaration)      Getinterface() *AstToken{ return my._interface}
func (my *NormalInterfaceDeclaration)      Setinterface( _interface *AstToken)  { my._interface = _interface }
func (my *NormalInterfaceDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *NormalInterfaceDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *NormalInterfaceDeclaration)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *NormalInterfaceDeclaration)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
    /**
     * The value returned by <b>GetExtendsInterfacesopt</b> may be <b>null</b>
     */
func (my *NormalInterfaceDeclaration)      GetExtendsInterfacesopt() IExtendsInterfacesopt{ return my._ExtendsInterfacesopt}
func (my *NormalInterfaceDeclaration)      SetExtendsInterfacesopt( _ExtendsInterfacesopt IExtendsInterfacesopt)  { my._ExtendsInterfacesopt = _ExtendsInterfacesopt }
func (my *NormalInterfaceDeclaration)      GetInterfaceBody() *InterfaceBody{ return my._InterfaceBody}
func (my *NormalInterfaceDeclaration)      SetInterfaceBody( _InterfaceBody *InterfaceBody)  { my._InterfaceBody = _InterfaceBody }

func NewNormalInterfaceDeclaration(leftIToken IToken, rightIToken IToken ,
              _InterfaceModifiersopt IInterfaceModifiersopt,
              _interface *AstToken,
              _identifier *identifier,
              _TypeParametersopt *TypeParameters,
              _ExtendsInterfacesopt IExtendsInterfacesopt,
              _InterfaceBody *InterfaceBody)*NormalInterfaceDeclaration{
      my := new(NormalInterfaceDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceModifiersopt = _InterfaceModifiersopt;
        if nil != _InterfaceModifiersopt{
        var trait_ interface{} = _InterfaceModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._interface = _interface;
        if nil != _interface{
        var trait_ interface{} = _interface
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._ExtendsInterfacesopt = _ExtendsInterfacesopt;
        if nil != _ExtendsInterfacesopt{
        var trait_ interface{} = _ExtendsInterfacesopt
         trait_.(IAst).SetParent(my)
}
        my._InterfaceBody = _InterfaceBody;
        if nil != _InterfaceBody{
        var trait_ interface{} = _InterfaceBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *NormalInterfaceDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceModifiersopt{  list.Add(my._InterfaceModifiersopt) }
        if nil != my._interface{  list.Add(my._interface) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._ExtendsInterfacesopt{  list.Add(my._ExtendsInterfacesopt) }
        if nil != my._InterfaceBody{  list.Add(my._InterfaceBody) }
        return list
    }

func (my *NormalInterfaceDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitNormalInterfaceDeclaration(my)}
func (my *NormalInterfaceDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitNormalInterfaceDeclarationWithArg(my, o) }
func (my *NormalInterfaceDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitNormalInterfaceDeclarationWithResult(my) }
func (my *NormalInterfaceDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitNormalInterfaceDeclarationWithResultArgument(my, o) }


func AnyCastToNormalInterfaceDeclaration(i interface{}) *NormalInterfaceDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*NormalInterfaceDeclaration)
	}
}
/**
 *<em>
*<li>Rule 185:  InterfaceModifiers ::= InterfaceModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 186:  InterfaceModifiers ::= InterfaceModifiers InterfaceModifier
 *</b>
 */
type InterfaceModifiers struct{
    *Ast
      _InterfaceModifiers IInterfaceModifiers
      _InterfaceModifier IInterfaceModifier
}
func (my *InterfaceModifiers)      GetInterfaceModifiers() IInterfaceModifiers{ return my._InterfaceModifiers}
func (my *InterfaceModifiers)      SetInterfaceModifiers( _InterfaceModifiers IInterfaceModifiers)  { my._InterfaceModifiers = _InterfaceModifiers }
func (my *InterfaceModifiers)      GetInterfaceModifier() IInterfaceModifier{ return my._InterfaceModifier}
func (my *InterfaceModifiers)      SetInterfaceModifier( _InterfaceModifier IInterfaceModifier)  { my._InterfaceModifier = _InterfaceModifier }

func NewInterfaceModifiers(leftIToken IToken, rightIToken IToken ,
              _InterfaceModifiers IInterfaceModifiers,
              _InterfaceModifier IInterfaceModifier)*InterfaceModifiers{
      my := new(InterfaceModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceModifiers = _InterfaceModifiers;
        if nil != _InterfaceModifiers{
        var trait_ interface{} = _InterfaceModifiers
         trait_.(IAst).SetParent(my)
}
        my._InterfaceModifier = _InterfaceModifier;
        if nil != _InterfaceModifier{
        var trait_ interface{} = _InterfaceModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceModifiers{  list.Add(my._InterfaceModifiers) }
        if nil != my._InterfaceModifier{  list.Add(my._InterfaceModifier) }
        return list
    }

func (my *InterfaceModifiers)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceModifiers(my)}
func (my *InterfaceModifiers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceModifiersWithArg(my, o) }
func (my *InterfaceModifiers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceModifiersWithResult(my) }
func (my *InterfaceModifiers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceModifiersWithResultArgument(my, o) }


func AnyCastToInterfaceModifiers(i interface{}) *InterfaceModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifiers)
	}
}
/**
 *<b>
*<li>Rule 196:  InterfaceBody ::= { InterfaceMemberDeclarationsopt }
 *</b>
 */
type InterfaceBody struct{
    *Ast
      _LBRACE *AstToken
      _InterfaceMemberDeclarationsopt IInterfaceMemberDeclarationsopt
      _RBRACE *AstToken
}
func (my *InterfaceBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *InterfaceBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetInterfaceMemberDeclarationsopt</b> may be <b>null</b>
     */
func (my *InterfaceBody)      GetInterfaceMemberDeclarationsopt() IInterfaceMemberDeclarationsopt{ return my._InterfaceMemberDeclarationsopt}
func (my *InterfaceBody)      SetInterfaceMemberDeclarationsopt( _InterfaceMemberDeclarationsopt IInterfaceMemberDeclarationsopt)  { my._InterfaceMemberDeclarationsopt = _InterfaceMemberDeclarationsopt }
func (my *InterfaceBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *InterfaceBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewInterfaceBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _InterfaceMemberDeclarationsopt IInterfaceMemberDeclarationsopt,
              _RBRACE *AstToken)*InterfaceBody{
      my := new(InterfaceBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._InterfaceMemberDeclarationsopt = _InterfaceMemberDeclarationsopt;
        if nil != _InterfaceMemberDeclarationsopt{
        var trait_ interface{} = _InterfaceMemberDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._InterfaceMemberDeclarationsopt{  list.Add(my._InterfaceMemberDeclarationsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *InterfaceBody)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceBody(my)}
func (my *InterfaceBody)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceBodyWithArg(my, o) }
func (my *InterfaceBody)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceBodyWithResult(my) }
func (my *InterfaceBody)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceBodyWithResultArgument(my, o) }


func AnyCastToInterfaceBody(i interface{}) *InterfaceBody {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceBody)
	}
}
/**
 *<em>
*<li>Rule 197:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 198:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
 *</b>
 */
type InterfaceMemberDeclarations struct{
    *Ast
      _InterfaceMemberDeclarations IInterfaceMemberDeclarations
      _InterfaceMemberDeclaration IInterfaceMemberDeclaration
}
func (my *InterfaceMemberDeclarations)      GetInterfaceMemberDeclarations() IInterfaceMemberDeclarations{ return my._InterfaceMemberDeclarations}
func (my *InterfaceMemberDeclarations)      SetInterfaceMemberDeclarations( _InterfaceMemberDeclarations IInterfaceMemberDeclarations)  { my._InterfaceMemberDeclarations = _InterfaceMemberDeclarations }
func (my *InterfaceMemberDeclarations)      GetInterfaceMemberDeclaration() IInterfaceMemberDeclaration{ return my._InterfaceMemberDeclaration}
func (my *InterfaceMemberDeclarations)      SetInterfaceMemberDeclaration( _InterfaceMemberDeclaration IInterfaceMemberDeclaration)  { my._InterfaceMemberDeclaration = _InterfaceMemberDeclaration }

func NewInterfaceMemberDeclarations(leftIToken IToken, rightIToken IToken ,
              _InterfaceMemberDeclarations IInterfaceMemberDeclarations,
              _InterfaceMemberDeclaration IInterfaceMemberDeclaration)*InterfaceMemberDeclarations{
      my := new(InterfaceMemberDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceMemberDeclarations = _InterfaceMemberDeclarations;
        if nil != _InterfaceMemberDeclarations{
        var trait_ interface{} = _InterfaceMemberDeclarations
         trait_.(IAst).SetParent(my)
}
        my._InterfaceMemberDeclaration = _InterfaceMemberDeclaration;
        if nil != _InterfaceMemberDeclaration{
        var trait_ interface{} = _InterfaceMemberDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InterfaceMemberDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceMemberDeclarations{  list.Add(my._InterfaceMemberDeclarations) }
        if nil != my._InterfaceMemberDeclaration{  list.Add(my._InterfaceMemberDeclaration) }
        return list
    }

func (my *InterfaceMemberDeclarations)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceMemberDeclarations(my)}
func (my *InterfaceMemberDeclarations)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceMemberDeclarationsWithArg(my, o) }
func (my *InterfaceMemberDeclarations)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceMemberDeclarationsWithResult(my) }
func (my *InterfaceMemberDeclarations)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceMemberDeclarationsWithResultArgument(my, o) }


func AnyCastToInterfaceMemberDeclarations(i interface{}) *InterfaceMemberDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceMemberDeclarations)
	}
}
/**
 *<em>
*<li>Rule 199:  InterfaceMemberDeclaration ::= ConstantDeclaration
*<li>Rule 200:  InterfaceMemberDeclaration ::= AbstractMethodDeclaration
*<li>Rule 201:  InterfaceMemberDeclaration ::= ClassDeclaration
*<li>Rule 202:  InterfaceMemberDeclaration ::= InterfaceDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 203:  InterfaceMemberDeclaration ::= ;
 *</b>
 */
type InterfaceMemberDeclaration struct{
    *AstToken
}
func (my *InterfaceMemberDeclaration)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewInterfaceMemberDeclaration(token IToken )*InterfaceMemberDeclaration{
      my := new(InterfaceMemberDeclaration)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceMemberDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceMemberDeclaration(my)}
func (my *InterfaceMemberDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceMemberDeclarationWithArg(my, o) }
func (my *InterfaceMemberDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceMemberDeclarationWithResult(my) }
func (my *InterfaceMemberDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceMemberDeclarationWithResultArgument(my, o) }


func AnyCastToInterfaceMemberDeclaration(i interface{}) *InterfaceMemberDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceMemberDeclaration)
	}
}
/**
 *<b>
*<li>Rule 204:  ConstantDeclaration ::= ConstantModifiersopt Type VariableDeclarators
 *</b>
 */
type ConstantDeclaration struct{
    *Ast
      _ConstantModifiersopt IConstantModifiersopt
      _Type IType
      _VariableDeclarators IVariableDeclarators
}
    /**
     * The value returned by <b>GetConstantModifiersopt</b> may be <b>null</b>
     */
func (my *ConstantDeclaration)      GetConstantModifiersopt() IConstantModifiersopt{ return my._ConstantModifiersopt}
func (my *ConstantDeclaration)      SetConstantModifiersopt( _ConstantModifiersopt IConstantModifiersopt)  { my._ConstantModifiersopt = _ConstantModifiersopt }
func (my *ConstantDeclaration)      GetType() IType{ return my._Type}
func (my *ConstantDeclaration)      SetType( _Type IType)  { my._Type = _Type }
func (my *ConstantDeclaration)      GetVariableDeclarators() IVariableDeclarators{ return my._VariableDeclarators}
func (my *ConstantDeclaration)      SetVariableDeclarators( _VariableDeclarators IVariableDeclarators)  { my._VariableDeclarators = _VariableDeclarators }

func NewConstantDeclaration(leftIToken IToken, rightIToken IToken ,
              _ConstantModifiersopt IConstantModifiersopt,
              _Type IType,
              _VariableDeclarators IVariableDeclarators)*ConstantDeclaration{
      my := new(ConstantDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConstantModifiersopt = _ConstantModifiersopt;
        if nil != _ConstantModifiersopt{
        var trait_ interface{} = _ConstantModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclarators = _VariableDeclarators;
        if nil != _VariableDeclarators{
        var trait_ interface{} = _VariableDeclarators
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstantDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConstantModifiersopt{  list.Add(my._ConstantModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._VariableDeclarators{  list.Add(my._VariableDeclarators) }
        return list
    }

func (my *ConstantDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitConstantDeclaration(my)}
func (my *ConstantDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstantDeclarationWithArg(my, o) }
func (my *ConstantDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstantDeclarationWithResult(my) }
func (my *ConstantDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstantDeclarationWithResultArgument(my, o) }


func AnyCastToConstantDeclaration(i interface{}) *ConstantDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantDeclaration)
	}
}
/**
 *<em>
*<li>Rule 205:  ConstantModifiers ::= ConstantModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 206:  ConstantModifiers ::= ConstantModifiers ConstantModifier
 *</b>
 */
type ConstantModifiers struct{
    *Ast
      _ConstantModifiers IConstantModifiers
      _ConstantModifier IConstantModifier
}
func (my *ConstantModifiers)      GetConstantModifiers() IConstantModifiers{ return my._ConstantModifiers}
func (my *ConstantModifiers)      SetConstantModifiers( _ConstantModifiers IConstantModifiers)  { my._ConstantModifiers = _ConstantModifiers }
func (my *ConstantModifiers)      GetConstantModifier() IConstantModifier{ return my._ConstantModifier}
func (my *ConstantModifiers)      SetConstantModifier( _ConstantModifier IConstantModifier)  { my._ConstantModifier = _ConstantModifier }

func NewConstantModifiers(leftIToken IToken, rightIToken IToken ,
              _ConstantModifiers IConstantModifiers,
              _ConstantModifier IConstantModifier)*ConstantModifiers{
      my := new(ConstantModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConstantModifiers = _ConstantModifiers;
        if nil != _ConstantModifiers{
        var trait_ interface{} = _ConstantModifiers
         trait_.(IAst).SetParent(my)
}
        my._ConstantModifier = _ConstantModifier;
        if nil != _ConstantModifier{
        var trait_ interface{} = _ConstantModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConstantModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConstantModifiers{  list.Add(my._ConstantModifiers) }
        if nil != my._ConstantModifier{  list.Add(my._ConstantModifier) }
        return list
    }

func (my *ConstantModifiers)      AcceptWithVisitor(v Visitor) { v.VisitConstantModifiers(my)}
func (my *ConstantModifiers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstantModifiersWithArg(my, o) }
func (my *ConstantModifiers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstantModifiersWithResult(my) }
func (my *ConstantModifiers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstantModifiersWithResultArgument(my, o) }


func AnyCastToConstantModifiers(i interface{}) *ConstantModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantModifiers)
	}
}
/**
 *<b>
*<li>Rule 211:  AbstractMethodDeclaration ::= AbstractMethodModifiersopt TypeParametersopt ResultType MethodDeclarator Throwsopt ;
 *</b>
 */
type AbstractMethodDeclaration struct{
    *Ast
      _AbstractMethodModifiersopt IAbstractMethodModifiersopt
      _TypeParametersopt *TypeParameters
      _ResultType IResultType
      _MethodDeclarator IMethodDeclarator
      _Throwsopt *Throws
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetAbstractMethodModifiersopt</b> may be <b>null</b>
     */
func (my *AbstractMethodDeclaration)      GetAbstractMethodModifiersopt() IAbstractMethodModifiersopt{ return my._AbstractMethodModifiersopt}
func (my *AbstractMethodDeclaration)      SetAbstractMethodModifiersopt( _AbstractMethodModifiersopt IAbstractMethodModifiersopt)  { my._AbstractMethodModifiersopt = _AbstractMethodModifiersopt }
    /**
     * The value returned by <b>GetTypeParametersopt</b> may be <b>null</b>
     */
func (my *AbstractMethodDeclaration)      GetTypeParametersopt() *TypeParameters{ return my._TypeParametersopt}
func (my *AbstractMethodDeclaration)      SetTypeParametersopt( _TypeParametersopt *TypeParameters)  { my._TypeParametersopt = _TypeParametersopt }
func (my *AbstractMethodDeclaration)      GetResultType() IResultType{ return my._ResultType}
func (my *AbstractMethodDeclaration)      SetResultType( _ResultType IResultType)  { my._ResultType = _ResultType }
func (my *AbstractMethodDeclaration)      GetMethodDeclarator() IMethodDeclarator{ return my._MethodDeclarator}
func (my *AbstractMethodDeclaration)      SetMethodDeclarator( _MethodDeclarator IMethodDeclarator)  { my._MethodDeclarator = _MethodDeclarator }
    /**
     * The value returned by <b>GetThrowsopt</b> may be <b>null</b>
     */
func (my *AbstractMethodDeclaration)      GetThrowsopt() *Throws{ return my._Throwsopt}
func (my *AbstractMethodDeclaration)      SetThrowsopt( _Throwsopt *Throws)  { my._Throwsopt = _Throwsopt }
func (my *AbstractMethodDeclaration)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *AbstractMethodDeclaration)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewAbstractMethodDeclaration(leftIToken IToken, rightIToken IToken ,
              _AbstractMethodModifiersopt IAbstractMethodModifiersopt,
              _TypeParametersopt *TypeParameters,
              _ResultType IResultType,
              _MethodDeclarator IMethodDeclarator,
              _Throwsopt *Throws,
              _SEMICOLON *AstToken)*AbstractMethodDeclaration{
      my := new(AbstractMethodDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AbstractMethodModifiersopt = _AbstractMethodModifiersopt;
        if nil != _AbstractMethodModifiersopt{
        var trait_ interface{} = _AbstractMethodModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._TypeParametersopt = _TypeParametersopt;
        if nil != _TypeParametersopt{
        var trait_ interface{} = _TypeParametersopt
         trait_.(IAst).SetParent(my)
}
        my._ResultType = _ResultType;
        if nil != _ResultType{
        var trait_ interface{} = _ResultType
         trait_.(IAst).SetParent(my)
}
        my._MethodDeclarator = _MethodDeclarator;
        if nil != _MethodDeclarator{
        var trait_ interface{} = _MethodDeclarator
         trait_.(IAst).SetParent(my)
}
        my._Throwsopt = _Throwsopt;
        if nil != _Throwsopt{
        var trait_ interface{} = _Throwsopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AbstractMethodDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AbstractMethodModifiersopt{  list.Add(my._AbstractMethodModifiersopt) }
        if nil != my._TypeParametersopt{  list.Add(my._TypeParametersopt) }
        if nil != my._ResultType{  list.Add(my._ResultType) }
        if nil != my._MethodDeclarator{  list.Add(my._MethodDeclarator) }
        if nil != my._Throwsopt{  list.Add(my._Throwsopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *AbstractMethodDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitAbstractMethodDeclaration(my)}
func (my *AbstractMethodDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAbstractMethodDeclarationWithArg(my, o) }
func (my *AbstractMethodDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAbstractMethodDeclarationWithResult(my) }
func (my *AbstractMethodDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAbstractMethodDeclarationWithResultArgument(my, o) }


func AnyCastToAbstractMethodDeclaration(i interface{}) *AbstractMethodDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractMethodDeclaration)
	}
}
/**
 *<em>
*<li>Rule 212:  AbstractMethodModifiers ::= AbstractMethodModifier
 *</em>
 *<p>
 *<b>
*<li>Rule 213:  AbstractMethodModifiers ::= AbstractMethodModifiers AbstractMethodModifier
 *</b>
 */
type AbstractMethodModifiers struct{
    *Ast
      _AbstractMethodModifiers IAbstractMethodModifiers
      _AbstractMethodModifier IAbstractMethodModifier
}
func (my *AbstractMethodModifiers)      GetAbstractMethodModifiers() IAbstractMethodModifiers{ return my._AbstractMethodModifiers}
func (my *AbstractMethodModifiers)      SetAbstractMethodModifiers( _AbstractMethodModifiers IAbstractMethodModifiers)  { my._AbstractMethodModifiers = _AbstractMethodModifiers }
func (my *AbstractMethodModifiers)      GetAbstractMethodModifier() IAbstractMethodModifier{ return my._AbstractMethodModifier}
func (my *AbstractMethodModifiers)      SetAbstractMethodModifier( _AbstractMethodModifier IAbstractMethodModifier)  { my._AbstractMethodModifier = _AbstractMethodModifier }

func NewAbstractMethodModifiers(leftIToken IToken, rightIToken IToken ,
              _AbstractMethodModifiers IAbstractMethodModifiers,
              _AbstractMethodModifier IAbstractMethodModifier)*AbstractMethodModifiers{
      my := new(AbstractMethodModifiers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AbstractMethodModifiers = _AbstractMethodModifiers;
        if nil != _AbstractMethodModifiers{
        var trait_ interface{} = _AbstractMethodModifiers
         trait_.(IAst).SetParent(my)
}
        my._AbstractMethodModifier = _AbstractMethodModifier;
        if nil != _AbstractMethodModifier{
        var trait_ interface{} = _AbstractMethodModifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AbstractMethodModifiers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AbstractMethodModifiers{  list.Add(my._AbstractMethodModifiers) }
        if nil != my._AbstractMethodModifier{  list.Add(my._AbstractMethodModifier) }
        return list
    }

func (my *AbstractMethodModifiers)      AcceptWithVisitor(v Visitor) { v.VisitAbstractMethodModifiers(my)}
func (my *AbstractMethodModifiers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAbstractMethodModifiersWithArg(my, o) }
func (my *AbstractMethodModifiers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAbstractMethodModifiersWithResult(my) }
func (my *AbstractMethodModifiers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAbstractMethodModifiersWithResultArgument(my, o) }


func AnyCastToAbstractMethodModifiers(i interface{}) *AbstractMethodModifiers {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractMethodModifiers)
	}
}
/**
 *<b>
*<li>Rule 217:  AnnotationTypeDeclaration ::= InterfaceModifiersopt @ interface identifier AnnotationTypeBody
 *</b>
 */
type AnnotationTypeDeclaration struct{
    *Ast
      _InterfaceModifiersopt IInterfaceModifiersopt
      _AT *AstToken
      _interface *AstToken
      _identifier *identifier
      _AnnotationTypeBody *AnnotationTypeBody
}
    /**
     * The value returned by <b>GetInterfaceModifiersopt</b> may be <b>null</b>
     */
func (my *AnnotationTypeDeclaration)      GetInterfaceModifiersopt() IInterfaceModifiersopt{ return my._InterfaceModifiersopt}
func (my *AnnotationTypeDeclaration)      SetInterfaceModifiersopt( _InterfaceModifiersopt IInterfaceModifiersopt)  { my._InterfaceModifiersopt = _InterfaceModifiersopt }
func (my *AnnotationTypeDeclaration)      GetAT() *AstToken{ return my._AT}
func (my *AnnotationTypeDeclaration)      SetAT( _AT *AstToken)  { my._AT = _AT }
func (my *AnnotationTypeDeclaration)      Getinterface() *AstToken{ return my._interface}
func (my *AnnotationTypeDeclaration)      Setinterface( _interface *AstToken)  { my._interface = _interface }
func (my *AnnotationTypeDeclaration)      Getidentifier() *identifier{ return my._identifier}
func (my *AnnotationTypeDeclaration)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *AnnotationTypeDeclaration)      GetAnnotationTypeBody() *AnnotationTypeBody{ return my._AnnotationTypeBody}
func (my *AnnotationTypeDeclaration)      SetAnnotationTypeBody( _AnnotationTypeBody *AnnotationTypeBody)  { my._AnnotationTypeBody = _AnnotationTypeBody }

func NewAnnotationTypeDeclaration(leftIToken IToken, rightIToken IToken ,
              _InterfaceModifiersopt IInterfaceModifiersopt,
              _AT *AstToken,
              _interface *AstToken,
              _identifier *identifier,
              _AnnotationTypeBody *AnnotationTypeBody)*AnnotationTypeDeclaration{
      my := new(AnnotationTypeDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InterfaceModifiersopt = _InterfaceModifiersopt;
        if nil != _InterfaceModifiersopt{
        var trait_ interface{} = _InterfaceModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._AT = _AT;
        if nil != _AT{
        var trait_ interface{} = _AT
         trait_.(IAst).SetParent(my)
}
        my._interface = _interface;
        if nil != _interface{
        var trait_ interface{} = _interface
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._AnnotationTypeBody = _AnnotationTypeBody;
        if nil != _AnnotationTypeBody{
        var trait_ interface{} = _AnnotationTypeBody
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AnnotationTypeDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InterfaceModifiersopt{  list.Add(my._InterfaceModifiersopt) }
        if nil != my._AT{  list.Add(my._AT) }
        if nil != my._interface{  list.Add(my._interface) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._AnnotationTypeBody{  list.Add(my._AnnotationTypeBody) }
        return list
    }

func (my *AnnotationTypeDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitAnnotationTypeDeclaration(my)}
func (my *AnnotationTypeDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAnnotationTypeDeclarationWithArg(my, o) }
func (my *AnnotationTypeDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAnnotationTypeDeclarationWithResult(my) }
func (my *AnnotationTypeDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAnnotationTypeDeclarationWithResultArgument(my, o) }


func AnyCastToAnnotationTypeDeclaration(i interface{}) *AnnotationTypeDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeDeclaration)
	}
}
/**
 *<b>
*<li>Rule 218:  AnnotationTypeBody ::= { AnnotationTypeElementDeclarationsopt }
 *</b>
 */
type AnnotationTypeBody struct{
    *Ast
      _LBRACE *AstToken
      _AnnotationTypeElementDeclarationsopt IAnnotationTypeElementDeclarationsopt
      _RBRACE *AstToken
}
func (my *AnnotationTypeBody)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *AnnotationTypeBody)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetAnnotationTypeElementDeclarationsopt</b> may be <b>null</b>
     */
func (my *AnnotationTypeBody)      GetAnnotationTypeElementDeclarationsopt() IAnnotationTypeElementDeclarationsopt{ return my._AnnotationTypeElementDeclarationsopt}
func (my *AnnotationTypeBody)      SetAnnotationTypeElementDeclarationsopt( _AnnotationTypeElementDeclarationsopt IAnnotationTypeElementDeclarationsopt)  { my._AnnotationTypeElementDeclarationsopt = _AnnotationTypeElementDeclarationsopt }
func (my *AnnotationTypeBody)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *AnnotationTypeBody)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewAnnotationTypeBody(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _AnnotationTypeElementDeclarationsopt IAnnotationTypeElementDeclarationsopt,
              _RBRACE *AstToken)*AnnotationTypeBody{
      my := new(AnnotationTypeBody)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._AnnotationTypeElementDeclarationsopt = _AnnotationTypeElementDeclarationsopt;
        if nil != _AnnotationTypeElementDeclarationsopt{
        var trait_ interface{} = _AnnotationTypeElementDeclarationsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AnnotationTypeBody)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._AnnotationTypeElementDeclarationsopt{  list.Add(my._AnnotationTypeElementDeclarationsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *AnnotationTypeBody)      AcceptWithVisitor(v Visitor) { v.VisitAnnotationTypeBody(my)}
func (my *AnnotationTypeBody)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAnnotationTypeBodyWithArg(my, o) }
func (my *AnnotationTypeBody)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAnnotationTypeBodyWithResult(my) }
func (my *AnnotationTypeBody)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAnnotationTypeBodyWithResultArgument(my, o) }


func AnyCastToAnnotationTypeBody(i interface{}) *AnnotationTypeBody {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeBody)
	}
}
/**
 *<em>
*<li>Rule 219:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclaration
 *</em>
 *<p>
 *<b>
*<li>Rule 220:  AnnotationTypeElementDeclarations ::= AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
 *</b>
 */
type AnnotationTypeElementDeclarations struct{
    *Ast
      _AnnotationTypeElementDeclarations IAnnotationTypeElementDeclarations
      _AnnotationTypeElementDeclaration IAnnotationTypeElementDeclaration
}
func (my *AnnotationTypeElementDeclarations)      GetAnnotationTypeElementDeclarations() IAnnotationTypeElementDeclarations{ return my._AnnotationTypeElementDeclarations}
func (my *AnnotationTypeElementDeclarations)      SetAnnotationTypeElementDeclarations( _AnnotationTypeElementDeclarations IAnnotationTypeElementDeclarations)  { my._AnnotationTypeElementDeclarations = _AnnotationTypeElementDeclarations }
func (my *AnnotationTypeElementDeclarations)      GetAnnotationTypeElementDeclaration() IAnnotationTypeElementDeclaration{ return my._AnnotationTypeElementDeclaration}
func (my *AnnotationTypeElementDeclarations)      SetAnnotationTypeElementDeclaration( _AnnotationTypeElementDeclaration IAnnotationTypeElementDeclaration)  { my._AnnotationTypeElementDeclaration = _AnnotationTypeElementDeclaration }

func NewAnnotationTypeElementDeclarations(leftIToken IToken, rightIToken IToken ,
              _AnnotationTypeElementDeclarations IAnnotationTypeElementDeclarations,
              _AnnotationTypeElementDeclaration IAnnotationTypeElementDeclaration)*AnnotationTypeElementDeclarations{
      my := new(AnnotationTypeElementDeclarations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AnnotationTypeElementDeclarations = _AnnotationTypeElementDeclarations;
        if nil != _AnnotationTypeElementDeclarations{
        var trait_ interface{} = _AnnotationTypeElementDeclarations
         trait_.(IAst).SetParent(my)
}
        my._AnnotationTypeElementDeclaration = _AnnotationTypeElementDeclaration;
        if nil != _AnnotationTypeElementDeclaration{
        var trait_ interface{} = _AnnotationTypeElementDeclaration
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AnnotationTypeElementDeclarations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AnnotationTypeElementDeclarations{  list.Add(my._AnnotationTypeElementDeclarations) }
        if nil != my._AnnotationTypeElementDeclaration{  list.Add(my._AnnotationTypeElementDeclaration) }
        return list
    }

func (my *AnnotationTypeElementDeclarations)      AcceptWithVisitor(v Visitor) { v.VisitAnnotationTypeElementDeclarations(my)}
func (my *AnnotationTypeElementDeclarations)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAnnotationTypeElementDeclarationsWithArg(my, o) }
func (my *AnnotationTypeElementDeclarations)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAnnotationTypeElementDeclarationsWithResult(my) }
func (my *AnnotationTypeElementDeclarations)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAnnotationTypeElementDeclarationsWithResultArgument(my, o) }


func AnyCastToAnnotationTypeElementDeclarations(i interface{}) *AnnotationTypeElementDeclarations {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeElementDeclarations)
	}
}
/**
 *<b>
*<li>Rule 228:  DefaultValue ::= default ElementValue
 *</b>
 */
type DefaultValue struct{
    *Ast
      _default *AstToken
      _ElementValue IElementValue
}
func (my *DefaultValue)      Getdefault() *AstToken{ return my._default}
func (my *DefaultValue)      Setdefault( _default *AstToken)  { my._default = _default }
func (my *DefaultValue)      GetElementValue() IElementValue{ return my._ElementValue}
func (my *DefaultValue)      SetElementValue( _ElementValue IElementValue)  { my._ElementValue = _ElementValue }

func NewDefaultValue(leftIToken IToken, rightIToken IToken ,
              _default *AstToken,
              _ElementValue IElementValue)*DefaultValue{
      my := new(DefaultValue)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._default = _default;
        if nil != _default{
        var trait_ interface{} = _default
         trait_.(IAst).SetParent(my)
}
        my._ElementValue = _ElementValue;
        if nil != _ElementValue{
        var trait_ interface{} = _ElementValue
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *DefaultValue)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._default{  list.Add(my._default) }
        if nil != my._ElementValue{  list.Add(my._ElementValue) }
        return list
    }

func (my *DefaultValue)      AcceptWithVisitor(v Visitor) { v.VisitDefaultValue(my)}
func (my *DefaultValue)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitDefaultValueWithArg(my, o) }
func (my *DefaultValue)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitDefaultValueWithResult(my) }
func (my *DefaultValue)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitDefaultValueWithResultArgument(my, o) }


func AnyCastToDefaultValue(i interface{}) *DefaultValue {
	if nil == i{
		return nil
	}else{
		return i.(*DefaultValue)
	}
}
/**
 *<em>
*<li>Rule 229:  Annotations ::= Annotation
 *</em>
 *<p>
 *<b>
*<li>Rule 230:  Annotations ::= Annotations Annotation
 *</b>
 */
type Annotations struct{
    *Ast
      _Annotations IAnnotations
      _Annotation IAnnotation
}
func (my *Annotations)      GetAnnotations() IAnnotations{ return my._Annotations}
func (my *Annotations)      SetAnnotations( _Annotations IAnnotations)  { my._Annotations = _Annotations }
func (my *Annotations)      GetAnnotation() IAnnotation{ return my._Annotation}
func (my *Annotations)      SetAnnotation( _Annotation IAnnotation)  { my._Annotation = _Annotation }

func NewAnnotations(leftIToken IToken, rightIToken IToken ,
              _Annotations IAnnotations,
              _Annotation IAnnotation)*Annotations{
      my := new(Annotations)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Annotations = _Annotations;
        if nil != _Annotations{
        var trait_ interface{} = _Annotations
         trait_.(IAst).SetParent(my)
}
        my._Annotation = _Annotation;
        if nil != _Annotation{
        var trait_ interface{} = _Annotation
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Annotations)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Annotations{  list.Add(my._Annotations) }
        if nil != my._Annotation{  list.Add(my._Annotation) }
        return list
    }

func (my *Annotations)      AcceptWithVisitor(v Visitor) { v.VisitAnnotations(my)}
func (my *Annotations)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAnnotationsWithArg(my, o) }
func (my *Annotations)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAnnotationsWithResult(my) }
func (my *Annotations)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAnnotationsWithResultArgument(my, o) }


func AnyCastToAnnotations(i interface{}) *Annotations {
	if nil == i{
		return nil
	}else{
		return i.(*Annotations)
	}
}
/**
 *<b>
*<li>Rule 234:  NormalAnnotation ::= @ TypeName ( ElementValuePairsopt )
 *</b>
 */
type NormalAnnotation struct{
    *Ast
      _AT *AstToken
      _TypeName ITypeName
      _LPAREN *AstToken
      _ElementValuePairsopt IElementValuePairsopt
      _RPAREN *AstToken
}
func (my *NormalAnnotation)      GetAT() *AstToken{ return my._AT}
func (my *NormalAnnotation)      SetAT( _AT *AstToken)  { my._AT = _AT }
func (my *NormalAnnotation)      GetTypeName() ITypeName{ return my._TypeName}
func (my *NormalAnnotation)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *NormalAnnotation)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *NormalAnnotation)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetElementValuePairsopt</b> may be <b>null</b>
     */
func (my *NormalAnnotation)      GetElementValuePairsopt() IElementValuePairsopt{ return my._ElementValuePairsopt}
func (my *NormalAnnotation)      SetElementValuePairsopt( _ElementValuePairsopt IElementValuePairsopt)  { my._ElementValuePairsopt = _ElementValuePairsopt }
func (my *NormalAnnotation)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *NormalAnnotation)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewNormalAnnotation(leftIToken IToken, rightIToken IToken ,
              _AT *AstToken,
              _TypeName ITypeName,
              _LPAREN *AstToken,
              _ElementValuePairsopt IElementValuePairsopt,
              _RPAREN *AstToken)*NormalAnnotation{
      my := new(NormalAnnotation)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AT = _AT;
        if nil != _AT{
        var trait_ interface{} = _AT
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ElementValuePairsopt = _ElementValuePairsopt;
        if nil != _ElementValuePairsopt{
        var trait_ interface{} = _ElementValuePairsopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *NormalAnnotation)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AT{  list.Add(my._AT) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ElementValuePairsopt{  list.Add(my._ElementValuePairsopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *NormalAnnotation)      AcceptWithVisitor(v Visitor) { v.VisitNormalAnnotation(my)}
func (my *NormalAnnotation)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitNormalAnnotationWithArg(my, o) }
func (my *NormalAnnotation)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitNormalAnnotationWithResult(my) }
func (my *NormalAnnotation)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitNormalAnnotationWithResultArgument(my, o) }


func AnyCastToNormalAnnotation(i interface{}) *NormalAnnotation {
	if nil == i{
		return nil
	}else{
		return i.(*NormalAnnotation)
	}
}
/**
 *<em>
*<li>Rule 235:  ElementValuePairs ::= ElementValuePair
 *</em>
 *<p>
 *<b>
*<li>Rule 236:  ElementValuePairs ::= ElementValuePairs , ElementValuePair
 *</b>
 */
type ElementValuePairs struct{
    *Ast
      _ElementValuePairs IElementValuePairs
      _COMMA *AstToken
      _ElementValuePair *ElementValuePair
}
func (my *ElementValuePairs)      GetElementValuePairs() IElementValuePairs{ return my._ElementValuePairs}
func (my *ElementValuePairs)      SetElementValuePairs( _ElementValuePairs IElementValuePairs)  { my._ElementValuePairs = _ElementValuePairs }
func (my *ElementValuePairs)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ElementValuePairs)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ElementValuePairs)      GetElementValuePair() *ElementValuePair{ return my._ElementValuePair}
func (my *ElementValuePairs)      SetElementValuePair( _ElementValuePair *ElementValuePair)  { my._ElementValuePair = _ElementValuePair }

func NewElementValuePairs(leftIToken IToken, rightIToken IToken ,
              _ElementValuePairs IElementValuePairs,
              _COMMA *AstToken,
              _ElementValuePair *ElementValuePair)*ElementValuePairs{
      my := new(ElementValuePairs)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ElementValuePairs = _ElementValuePairs;
        if nil != _ElementValuePairs{
        var trait_ interface{} = _ElementValuePairs
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._ElementValuePair = _ElementValuePair;
        if nil != _ElementValuePair{
        var trait_ interface{} = _ElementValuePair
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ElementValuePairs)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ElementValuePairs{  list.Add(my._ElementValuePairs) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._ElementValuePair{  list.Add(my._ElementValuePair) }
        return list
    }

func (my *ElementValuePairs)      AcceptWithVisitor(v Visitor) { v.VisitElementValuePairs(my)}
func (my *ElementValuePairs)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitElementValuePairsWithArg(my, o) }
func (my *ElementValuePairs)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitElementValuePairsWithResult(my) }
func (my *ElementValuePairs)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitElementValuePairsWithResultArgument(my, o) }


func AnyCastToElementValuePairs(i interface{}) *ElementValuePairs {
	if nil == i{
		return nil
	}else{
		return i.(*ElementValuePairs)
	}
}
/**
 *<b>
*<li>Rule 237:  ElementValuePair ::= SimpleName = ElementValue
 *</b>
 */
type ElementValuePair struct{
    *Ast
      _SimpleName *identifier
      _EQUAL *AstToken
      _ElementValue IElementValue
}
func (my *ElementValuePair)      GetSimpleName() *identifier{ return my._SimpleName}
func (my *ElementValuePair)      SetSimpleName( _SimpleName *identifier)  { my._SimpleName = _SimpleName }
func (my *ElementValuePair)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *ElementValuePair)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }
func (my *ElementValuePair)      GetElementValue() IElementValue{ return my._ElementValue}
func (my *ElementValuePair)      SetElementValue( _ElementValue IElementValue)  { my._ElementValue = _ElementValue }

func NewElementValuePair(leftIToken IToken, rightIToken IToken ,
              _SimpleName *identifier,
              _EQUAL *AstToken,
              _ElementValue IElementValue)*ElementValuePair{
      my := new(ElementValuePair)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SimpleName = _SimpleName;
        if nil != _SimpleName{
        var trait_ interface{} = _SimpleName
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my._ElementValue = _ElementValue;
        if nil != _ElementValue{
        var trait_ interface{} = _ElementValue
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ElementValuePair)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SimpleName{  list.Add(my._SimpleName) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        if nil != my._ElementValue{  list.Add(my._ElementValue) }
        return list
    }

func (my *ElementValuePair)      AcceptWithVisitor(v Visitor) { v.VisitElementValuePair(my)}
func (my *ElementValuePair)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitElementValuePairWithArg(my, o) }
func (my *ElementValuePair)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitElementValuePairWithResult(my) }
func (my *ElementValuePair)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitElementValuePairWithResultArgument(my, o) }


func AnyCastToElementValuePair(i interface{}) *ElementValuePair {
	if nil == i{
		return nil
	}else{
		return i.(*ElementValuePair)
	}
}
/**
 *<b>
*<li>Rule 242:  ElementValueArrayInitializer ::= { ElementValuesopt ,opt }
 *</b>
 */
type ElementValueArrayInitializer struct{
    *Ast
      _LBRACE *AstToken
      _ElementValuesopt IElementValuesopt
      _Commaopt *Commaopt
      _RBRACE *AstToken
}
func (my *ElementValueArrayInitializer)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *ElementValueArrayInitializer)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetElementValuesopt</b> may be <b>null</b>
     */
func (my *ElementValueArrayInitializer)      GetElementValuesopt() IElementValuesopt{ return my._ElementValuesopt}
func (my *ElementValueArrayInitializer)      SetElementValuesopt( _ElementValuesopt IElementValuesopt)  { my._ElementValuesopt = _ElementValuesopt }
    /**
     * The value returned by <b>GetCommaopt</b> may be <b>null</b>
     */
func (my *ElementValueArrayInitializer)      GetCommaopt() *Commaopt{ return my._Commaopt}
func (my *ElementValueArrayInitializer)      SetCommaopt( _Commaopt *Commaopt)  { my._Commaopt = _Commaopt }
func (my *ElementValueArrayInitializer)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *ElementValueArrayInitializer)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewElementValueArrayInitializer(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _ElementValuesopt IElementValuesopt,
              _Commaopt *Commaopt,
              _RBRACE *AstToken)*ElementValueArrayInitializer{
      my := new(ElementValueArrayInitializer)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._ElementValuesopt = _ElementValuesopt;
        if nil != _ElementValuesopt{
        var trait_ interface{} = _ElementValuesopt
         trait_.(IAst).SetParent(my)
}
        my._Commaopt = _Commaopt;
        if nil != _Commaopt{
        var trait_ interface{} = _Commaopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ElementValueArrayInitializer)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._ElementValuesopt{  list.Add(my._ElementValuesopt) }
        if nil != my._Commaopt{  list.Add(my._Commaopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *ElementValueArrayInitializer)      AcceptWithVisitor(v Visitor) { v.VisitElementValueArrayInitializer(my)}
func (my *ElementValueArrayInitializer)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitElementValueArrayInitializerWithArg(my, o) }
func (my *ElementValueArrayInitializer)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitElementValueArrayInitializerWithResult(my) }
func (my *ElementValueArrayInitializer)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitElementValueArrayInitializerWithResultArgument(my, o) }


func AnyCastToElementValueArrayInitializer(i interface{}) *ElementValueArrayInitializer {
	if nil == i{
		return nil
	}else{
		return i.(*ElementValueArrayInitializer)
	}
}
/**
 *<em>
*<li>Rule 243:  ElementValues ::= ElementValue
 *</em>
 *<p>
 *<b>
*<li>Rule 244:  ElementValues ::= ElementValues , ElementValue
 *</b>
 */
type ElementValues struct{
    *Ast
      _ElementValues IElementValues
      _COMMA *AstToken
      _ElementValue IElementValue
}
func (my *ElementValues)      GetElementValues() IElementValues{ return my._ElementValues}
func (my *ElementValues)      SetElementValues( _ElementValues IElementValues)  { my._ElementValues = _ElementValues }
func (my *ElementValues)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ElementValues)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ElementValues)      GetElementValue() IElementValue{ return my._ElementValue}
func (my *ElementValues)      SetElementValue( _ElementValue IElementValue)  { my._ElementValue = _ElementValue }

func NewElementValues(leftIToken IToken, rightIToken IToken ,
              _ElementValues IElementValues,
              _COMMA *AstToken,
              _ElementValue IElementValue)*ElementValues{
      my := new(ElementValues)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ElementValues = _ElementValues;
        if nil != _ElementValues{
        var trait_ interface{} = _ElementValues
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._ElementValue = _ElementValue;
        if nil != _ElementValue{
        var trait_ interface{} = _ElementValue
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ElementValues)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ElementValues{  list.Add(my._ElementValues) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._ElementValue{  list.Add(my._ElementValue) }
        return list
    }

func (my *ElementValues)      AcceptWithVisitor(v Visitor) { v.VisitElementValues(my)}
func (my *ElementValues)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitElementValuesWithArg(my, o) }
func (my *ElementValues)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitElementValuesWithResult(my) }
func (my *ElementValues)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitElementValuesWithResultArgument(my, o) }


func AnyCastToElementValues(i interface{}) *ElementValues {
	if nil == i{
		return nil
	}else{
		return i.(*ElementValues)
	}
}
/**
 *<b>
*<li>Rule 245:  MarkerAnnotation ::= @ TypeName
 *</b>
 */
type MarkerAnnotation struct{
    *Ast
      _AT *AstToken
      _TypeName ITypeName
}
func (my *MarkerAnnotation)      GetAT() *AstToken{ return my._AT}
func (my *MarkerAnnotation)      SetAT( _AT *AstToken)  { my._AT = _AT }
func (my *MarkerAnnotation)      GetTypeName() ITypeName{ return my._TypeName}
func (my *MarkerAnnotation)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }

func NewMarkerAnnotation(leftIToken IToken, rightIToken IToken ,
              _AT *AstToken,
              _TypeName ITypeName)*MarkerAnnotation{
      my := new(MarkerAnnotation)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AT = _AT;
        if nil != _AT{
        var trait_ interface{} = _AT
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MarkerAnnotation)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AT{  list.Add(my._AT) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        return list
    }

func (my *MarkerAnnotation)      AcceptWithVisitor(v Visitor) { v.VisitMarkerAnnotation(my)}
func (my *MarkerAnnotation)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMarkerAnnotationWithArg(my, o) }
func (my *MarkerAnnotation)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMarkerAnnotationWithResult(my) }
func (my *MarkerAnnotation)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMarkerAnnotationWithResultArgument(my, o) }


func AnyCastToMarkerAnnotation(i interface{}) *MarkerAnnotation {
	if nil == i{
		return nil
	}else{
		return i.(*MarkerAnnotation)
	}
}
/**
 *<b>
*<li>Rule 246:  SingleElementAnnotation ::= @ TypeName ( ElementValue )
 *</b>
 */
type SingleElementAnnotation struct{
    *Ast
      _AT *AstToken
      _TypeName ITypeName
      _LPAREN *AstToken
      _ElementValue IElementValue
      _RPAREN *AstToken
}
func (my *SingleElementAnnotation)      GetAT() *AstToken{ return my._AT}
func (my *SingleElementAnnotation)      SetAT( _AT *AstToken)  { my._AT = _AT }
func (my *SingleElementAnnotation)      GetTypeName() ITypeName{ return my._TypeName}
func (my *SingleElementAnnotation)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *SingleElementAnnotation)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *SingleElementAnnotation)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *SingleElementAnnotation)      GetElementValue() IElementValue{ return my._ElementValue}
func (my *SingleElementAnnotation)      SetElementValue( _ElementValue IElementValue)  { my._ElementValue = _ElementValue }
func (my *SingleElementAnnotation)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *SingleElementAnnotation)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewSingleElementAnnotation(leftIToken IToken, rightIToken IToken ,
              _AT *AstToken,
              _TypeName ITypeName,
              _LPAREN *AstToken,
              _ElementValue IElementValue,
              _RPAREN *AstToken)*SingleElementAnnotation{
      my := new(SingleElementAnnotation)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AT = _AT;
        if nil != _AT{
        var trait_ interface{} = _AT
         trait_.(IAst).SetParent(my)
}
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ElementValue = _ElementValue;
        if nil != _ElementValue{
        var trait_ interface{} = _ElementValue
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SingleElementAnnotation)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AT{  list.Add(my._AT) }
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ElementValue{  list.Add(my._ElementValue) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *SingleElementAnnotation)      AcceptWithVisitor(v Visitor) { v.VisitSingleElementAnnotation(my)}
func (my *SingleElementAnnotation)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSingleElementAnnotationWithArg(my, o) }
func (my *SingleElementAnnotation)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSingleElementAnnotationWithResult(my) }
func (my *SingleElementAnnotation)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSingleElementAnnotationWithResultArgument(my, o) }


func AnyCastToSingleElementAnnotation(i interface{}) *SingleElementAnnotation {
	if nil == i{
		return nil
	}else{
		return i.(*SingleElementAnnotation)
	}
}
/**
 *<b>
*<li>Rule 247:  ArrayInitializer ::= { VariableInitializersopt ,opt }
 *</b>
 */
type ArrayInitializer struct{
    *Ast
      _LBRACE *AstToken
      _VariableInitializersopt IVariableInitializersopt
      _Commaopt *Commaopt
      _RBRACE *AstToken
}
func (my *ArrayInitializer)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *ArrayInitializer)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetVariableInitializersopt</b> may be <b>null</b>
     */
func (my *ArrayInitializer)      GetVariableInitializersopt() IVariableInitializersopt{ return my._VariableInitializersopt}
func (my *ArrayInitializer)      SetVariableInitializersopt( _VariableInitializersopt IVariableInitializersopt)  { my._VariableInitializersopt = _VariableInitializersopt }
    /**
     * The value returned by <b>GetCommaopt</b> may be <b>null</b>
     */
func (my *ArrayInitializer)      GetCommaopt() *Commaopt{ return my._Commaopt}
func (my *ArrayInitializer)      SetCommaopt( _Commaopt *Commaopt)  { my._Commaopt = _Commaopt }
func (my *ArrayInitializer)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *ArrayInitializer)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewArrayInitializer(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _VariableInitializersopt IVariableInitializersopt,
              _Commaopt *Commaopt,
              _RBRACE *AstToken)*ArrayInitializer{
      my := new(ArrayInitializer)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._VariableInitializersopt = _VariableInitializersopt;
        if nil != _VariableInitializersopt{
        var trait_ interface{} = _VariableInitializersopt
         trait_.(IAst).SetParent(my)
}
        my._Commaopt = _Commaopt;
        if nil != _Commaopt{
        var trait_ interface{} = _Commaopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayInitializer)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._VariableInitializersopt{  list.Add(my._VariableInitializersopt) }
        if nil != my._Commaopt{  list.Add(my._Commaopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *ArrayInitializer)      AcceptWithVisitor(v Visitor) { v.VisitArrayInitializer(my)}
func (my *ArrayInitializer)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArrayInitializerWithArg(my, o) }
func (my *ArrayInitializer)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArrayInitializerWithResult(my) }
func (my *ArrayInitializer)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArrayInitializerWithResultArgument(my, o) }


func AnyCastToArrayInitializer(i interface{}) *ArrayInitializer {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayInitializer)
	}
}
/**
 *<em>
*<li>Rule 248:  VariableInitializers ::= VariableInitializer
 *</em>
 *<p>
 *<b>
*<li>Rule 249:  VariableInitializers ::= VariableInitializers , VariableInitializer
 *</b>
 */
type VariableInitializers struct{
    *Ast
      _VariableInitializers IVariableInitializers
      _COMMA *AstToken
      _VariableInitializer IVariableInitializer
}
func (my *VariableInitializers)      GetVariableInitializers() IVariableInitializers{ return my._VariableInitializers}
func (my *VariableInitializers)      SetVariableInitializers( _VariableInitializers IVariableInitializers)  { my._VariableInitializers = _VariableInitializers }
func (my *VariableInitializers)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *VariableInitializers)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *VariableInitializers)      GetVariableInitializer() IVariableInitializer{ return my._VariableInitializer}
func (my *VariableInitializers)      SetVariableInitializer( _VariableInitializer IVariableInitializer)  { my._VariableInitializer = _VariableInitializer }

func NewVariableInitializers(leftIToken IToken, rightIToken IToken ,
              _VariableInitializers IVariableInitializers,
              _COMMA *AstToken,
              _VariableInitializer IVariableInitializer)*VariableInitializers{
      my := new(VariableInitializers)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableInitializers = _VariableInitializers;
        if nil != _VariableInitializers{
        var trait_ interface{} = _VariableInitializers
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._VariableInitializer = _VariableInitializer;
        if nil != _VariableInitializer{
        var trait_ interface{} = _VariableInitializer
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *VariableInitializers)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableInitializers{  list.Add(my._VariableInitializers) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._VariableInitializer{  list.Add(my._VariableInitializer) }
        return list
    }

func (my *VariableInitializers)      AcceptWithVisitor(v Visitor) { v.VisitVariableInitializers(my)}
func (my *VariableInitializers)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitVariableInitializersWithArg(my, o) }
func (my *VariableInitializers)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitVariableInitializersWithResult(my) }
func (my *VariableInitializers)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitVariableInitializersWithResultArgument(my, o) }


func AnyCastToVariableInitializers(i interface{}) *VariableInitializers {
	if nil == i{
		return nil
	}else{
		return i.(*VariableInitializers)
	}
}
/**
 *<b>
*<li>Rule 250:  Block ::= { BlockStatementsopt }
 *</b>
 */
type Block struct{
    *Ast
      _LBRACE *AstToken
      _BlockStatementsopt IBlockStatementsopt
      _RBRACE *AstToken
}
func (my *Block)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *Block)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetBlockStatementsopt</b> may be <b>null</b>
     */
func (my *Block)      GetBlockStatementsopt() IBlockStatementsopt{ return my._BlockStatementsopt}
func (my *Block)      SetBlockStatementsopt( _BlockStatementsopt IBlockStatementsopt)  { my._BlockStatementsopt = _BlockStatementsopt }
func (my *Block)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *Block)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewBlock(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _BlockStatementsopt IBlockStatementsopt,
              _RBRACE *AstToken)*Block{
      my := new(Block)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._BlockStatementsopt = _BlockStatementsopt;
        if nil != _BlockStatementsopt{
        var trait_ interface{} = _BlockStatementsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Block)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._BlockStatementsopt{  list.Add(my._BlockStatementsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *Block)      AcceptWithVisitor(v Visitor) { v.VisitBlock(my)}
func (my *Block)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitBlockWithArg(my, o) }
func (my *Block)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitBlockWithResult(my) }
func (my *Block)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitBlockWithResultArgument(my, o) }


func AnyCastToBlock(i interface{}) *Block {
	if nil == i{
		return nil
	}else{
		return i.(*Block)
	}
}
/**
 *<em>
*<li>Rule 251:  BlockStatements ::= BlockStatement
 *</em>
 *<p>
 *<b>
*<li>Rule 252:  BlockStatements ::= BlockStatements BlockStatement
 *</b>
 */
type BlockStatements struct{
    *Ast
      _BlockStatements IBlockStatements
      _BlockStatement IBlockStatement
}
func (my *BlockStatements)      GetBlockStatements() IBlockStatements{ return my._BlockStatements}
func (my *BlockStatements)      SetBlockStatements( _BlockStatements IBlockStatements)  { my._BlockStatements = _BlockStatements }
func (my *BlockStatements)      GetBlockStatement() IBlockStatement{ return my._BlockStatement}
func (my *BlockStatements)      SetBlockStatement( _BlockStatement IBlockStatement)  { my._BlockStatement = _BlockStatement }

func NewBlockStatements(leftIToken IToken, rightIToken IToken ,
              _BlockStatements IBlockStatements,
              _BlockStatement IBlockStatement)*BlockStatements{
      my := new(BlockStatements)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._BlockStatements = _BlockStatements;
        if nil != _BlockStatements{
        var trait_ interface{} = _BlockStatements
         trait_.(IAst).SetParent(my)
}
        my._BlockStatement = _BlockStatement;
        if nil != _BlockStatement{
        var trait_ interface{} = _BlockStatement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *BlockStatements)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._BlockStatements{  list.Add(my._BlockStatements) }
        if nil != my._BlockStatement{  list.Add(my._BlockStatement) }
        return list
    }

func (my *BlockStatements)      AcceptWithVisitor(v Visitor) { v.VisitBlockStatements(my)}
func (my *BlockStatements)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitBlockStatementsWithArg(my, o) }
func (my *BlockStatements)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitBlockStatementsWithResult(my) }
func (my *BlockStatements)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitBlockStatementsWithResultArgument(my, o) }


func AnyCastToBlockStatements(i interface{}) *BlockStatements {
	if nil == i{
		return nil
	}else{
		return i.(*BlockStatements)
	}
}
/**
 *<b>
*<li>Rule 256:  LocalVariableDeclarationStatement ::= LocalVariableDeclaration ;
 *</b>
 */
type LocalVariableDeclarationStatement struct{
    *Ast
      _LocalVariableDeclaration *LocalVariableDeclaration
      _SEMICOLON *AstToken
}
func (my *LocalVariableDeclarationStatement)      GetLocalVariableDeclaration() *LocalVariableDeclaration{ return my._LocalVariableDeclaration}
func (my *LocalVariableDeclarationStatement)      SetLocalVariableDeclaration( _LocalVariableDeclaration *LocalVariableDeclaration)  { my._LocalVariableDeclaration = _LocalVariableDeclaration }
func (my *LocalVariableDeclarationStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *LocalVariableDeclarationStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewLocalVariableDeclarationStatement(leftIToken IToken, rightIToken IToken ,
              _LocalVariableDeclaration *LocalVariableDeclaration,
              _SEMICOLON *AstToken)*LocalVariableDeclarationStatement{
      my := new(LocalVariableDeclarationStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LocalVariableDeclaration = _LocalVariableDeclaration;
        if nil != _LocalVariableDeclaration{
        var trait_ interface{} = _LocalVariableDeclaration
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LocalVariableDeclarationStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LocalVariableDeclaration{  list.Add(my._LocalVariableDeclaration) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *LocalVariableDeclarationStatement)      AcceptWithVisitor(v Visitor) { v.VisitLocalVariableDeclarationStatement(my)}
func (my *LocalVariableDeclarationStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLocalVariableDeclarationStatementWithArg(my, o) }
func (my *LocalVariableDeclarationStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLocalVariableDeclarationStatementWithResult(my) }
func (my *LocalVariableDeclarationStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLocalVariableDeclarationStatementWithResultArgument(my, o) }


func AnyCastToLocalVariableDeclarationStatement(i interface{}) *LocalVariableDeclarationStatement {
	if nil == i{
		return nil
	}else{
		return i.(*LocalVariableDeclarationStatement)
	}
}
/**
 *<b>
*<li>Rule 257:  LocalVariableDeclaration ::= VariableModifiersopt Type VariableDeclarators
 *</b>
 */
type LocalVariableDeclaration struct{
    *Ast
      _VariableModifiersopt IVariableModifiersopt
      _Type IType
      _VariableDeclarators IVariableDeclarators
}
    /**
     * The value returned by <b>GetVariableModifiersopt</b> may be <b>null</b>
     */
func (my *LocalVariableDeclaration)      GetVariableModifiersopt() IVariableModifiersopt{ return my._VariableModifiersopt}
func (my *LocalVariableDeclaration)      SetVariableModifiersopt( _VariableModifiersopt IVariableModifiersopt)  { my._VariableModifiersopt = _VariableModifiersopt }
func (my *LocalVariableDeclaration)      GetType() IType{ return my._Type}
func (my *LocalVariableDeclaration)      SetType( _Type IType)  { my._Type = _Type }
func (my *LocalVariableDeclaration)      GetVariableDeclarators() IVariableDeclarators{ return my._VariableDeclarators}
func (my *LocalVariableDeclaration)      SetVariableDeclarators( _VariableDeclarators IVariableDeclarators)  { my._VariableDeclarators = _VariableDeclarators }

func NewLocalVariableDeclaration(leftIToken IToken, rightIToken IToken ,
              _VariableModifiersopt IVariableModifiersopt,
              _Type IType,
              _VariableDeclarators IVariableDeclarators)*LocalVariableDeclaration{
      my := new(LocalVariableDeclaration)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._VariableModifiersopt = _VariableModifiersopt;
        if nil != _VariableModifiersopt{
        var trait_ interface{} = _VariableModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._VariableDeclarators = _VariableDeclarators;
        if nil != _VariableDeclarators{
        var trait_ interface{} = _VariableDeclarators
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LocalVariableDeclaration)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._VariableModifiersopt{  list.Add(my._VariableModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._VariableDeclarators{  list.Add(my._VariableDeclarators) }
        return list
    }

func (my *LocalVariableDeclaration)      AcceptWithVisitor(v Visitor) { v.VisitLocalVariableDeclaration(my)}
func (my *LocalVariableDeclaration)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLocalVariableDeclarationWithArg(my, o) }
func (my *LocalVariableDeclaration)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLocalVariableDeclarationWithResult(my) }
func (my *LocalVariableDeclaration)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLocalVariableDeclarationWithResultArgument(my, o) }


func AnyCastToLocalVariableDeclaration(i interface{}) *LocalVariableDeclaration {
	if nil == i{
		return nil
	}else{
		return i.(*LocalVariableDeclaration)
	}
}
/**
 *<b>
*<li>Rule 281:  IfThenStatement ::= if ( Expression ) Statement
 *</b>
 */
type IfThenStatement struct{
    *Ast
      _if *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _Statement IStatement
}
func (my *IfThenStatement)      Getif() *AstToken{ return my._if}
func (my *IfThenStatement)      Setif( _if *AstToken)  { my._if = _if }
func (my *IfThenStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *IfThenStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *IfThenStatement)      GetExpression() IExpression{ return my._Expression}
func (my *IfThenStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *IfThenStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *IfThenStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *IfThenStatement)      GetStatement() IStatement{ return my._Statement}
func (my *IfThenStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewIfThenStatement(leftIToken IToken, rightIToken IToken ,
              _if *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _Statement IStatement)*IfThenStatement{
      my := new(IfThenStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._if = _if;
        if nil != _if{
        var trait_ interface{} = _if
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *IfThenStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._if{  list.Add(my._if) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *IfThenStatement)      AcceptWithVisitor(v Visitor) { v.VisitIfThenStatement(my)}
func (my *IfThenStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitIfThenStatementWithArg(my, o) }
func (my *IfThenStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitIfThenStatementWithResult(my) }
func (my *IfThenStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitIfThenStatementWithResultArgument(my, o) }


func AnyCastToIfThenStatement(i interface{}) *IfThenStatement {
	if nil == i{
		return nil
	}else{
		return i.(*IfThenStatement)
	}
}
/**
 *<b>
*<li>Rule 282:  IfThenElseStatement ::= if ( Expression ) StatementNoShortIf else Statement
 *</b>
 */
type IfThenElseStatement struct{
    *Ast
      _if *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _StatementNoShortIf IStatementNoShortIf
      _else *AstToken
      _Statement IStatement
}
func (my *IfThenElseStatement)      Getif() *AstToken{ return my._if}
func (my *IfThenElseStatement)      Setif( _if *AstToken)  { my._if = _if }
func (my *IfThenElseStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *IfThenElseStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *IfThenElseStatement)      GetExpression() IExpression{ return my._Expression}
func (my *IfThenElseStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *IfThenElseStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *IfThenElseStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *IfThenElseStatement)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *IfThenElseStatement)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }
func (my *IfThenElseStatement)      Getelse() *AstToken{ return my._else}
func (my *IfThenElseStatement)      Setelse( _else *AstToken)  { my._else = _else }
func (my *IfThenElseStatement)      GetStatement() IStatement{ return my._Statement}
func (my *IfThenElseStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewIfThenElseStatement(leftIToken IToken, rightIToken IToken ,
              _if *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _StatementNoShortIf IStatementNoShortIf,
              _else *AstToken,
              _Statement IStatement)*IfThenElseStatement{
      my := new(IfThenElseStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._if = _if;
        if nil != _if{
        var trait_ interface{} = _if
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my._else = _else;
        if nil != _else{
        var trait_ interface{} = _else
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *IfThenElseStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._if{  list.Add(my._if) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        if nil != my._else{  list.Add(my._else) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *IfThenElseStatement)      AcceptWithVisitor(v Visitor) { v.VisitIfThenElseStatement(my)}
func (my *IfThenElseStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitIfThenElseStatementWithArg(my, o) }
func (my *IfThenElseStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitIfThenElseStatementWithResult(my) }
func (my *IfThenElseStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitIfThenElseStatementWithResultArgument(my, o) }


func AnyCastToIfThenElseStatement(i interface{}) *IfThenElseStatement {
	if nil == i{
		return nil
	}else{
		return i.(*IfThenElseStatement)
	}
}
/**
 *<b>
*<li>Rule 283:  IfThenElseStatementNoShortIf ::= if ( Expression ) StatementNoShortIf else StatementNoShortIf
 *</b>
 */
type IfThenElseStatementNoShortIf struct{
    *Ast
      _if *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _StatementNoShortIf IStatementNoShortIf
      _else *AstToken
      _StatementNoShortIf7 IStatementNoShortIf
}
func (my *IfThenElseStatementNoShortIf)      Getif() *AstToken{ return my._if}
func (my *IfThenElseStatementNoShortIf)      Setif( _if *AstToken)  { my._if = _if }
func (my *IfThenElseStatementNoShortIf)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *IfThenElseStatementNoShortIf)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *IfThenElseStatementNoShortIf)      GetExpression() IExpression{ return my._Expression}
func (my *IfThenElseStatementNoShortIf)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *IfThenElseStatementNoShortIf)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *IfThenElseStatementNoShortIf)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *IfThenElseStatementNoShortIf)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *IfThenElseStatementNoShortIf)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }
func (my *IfThenElseStatementNoShortIf)      Getelse() *AstToken{ return my._else}
func (my *IfThenElseStatementNoShortIf)      Setelse( _else *AstToken)  { my._else = _else }
func (my *IfThenElseStatementNoShortIf)      GetStatementNoShortIf7() IStatementNoShortIf{ return my._StatementNoShortIf7}
func (my *IfThenElseStatementNoShortIf)      SetStatementNoShortIf7( _StatementNoShortIf7 IStatementNoShortIf)  { my._StatementNoShortIf7 = _StatementNoShortIf7 }

func NewIfThenElseStatementNoShortIf(leftIToken IToken, rightIToken IToken ,
              _if *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _StatementNoShortIf IStatementNoShortIf,
              _else *AstToken,
              _StatementNoShortIf7 IStatementNoShortIf)*IfThenElseStatementNoShortIf{
      my := new(IfThenElseStatementNoShortIf)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._if = _if;
        if nil != _if{
        var trait_ interface{} = _if
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my._else = _else;
        if nil != _else{
        var trait_ interface{} = _else
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf7 = _StatementNoShortIf7;
        if nil != _StatementNoShortIf7{
        var trait_ interface{} = _StatementNoShortIf7
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *IfThenElseStatementNoShortIf)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._if{  list.Add(my._if) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        if nil != my._else{  list.Add(my._else) }
        if nil != my._StatementNoShortIf7{  list.Add(my._StatementNoShortIf7) }
        return list
    }

func (my *IfThenElseStatementNoShortIf)      AcceptWithVisitor(v Visitor) { v.VisitIfThenElseStatementNoShortIf(my)}
func (my *IfThenElseStatementNoShortIf)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitIfThenElseStatementNoShortIfWithArg(my, o) }
func (my *IfThenElseStatementNoShortIf)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitIfThenElseStatementNoShortIfWithResult(my) }
func (my *IfThenElseStatementNoShortIf)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitIfThenElseStatementNoShortIfWithResultArgument(my, o) }


func AnyCastToIfThenElseStatementNoShortIf(i interface{}) *IfThenElseStatementNoShortIf {
	if nil == i{
		return nil
	}else{
		return i.(*IfThenElseStatementNoShortIf)
	}
}
/**
 *<b>
*<li>Rule 284:  EmptyStatement ::= ;
 *</b>
 */
type EmptyStatement struct{
    *AstToken
}
func (my *EmptyStatement)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewEmptyStatement(token IToken )*EmptyStatement{
      my := new(EmptyStatement)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *EmptyStatement)      AcceptWithVisitor(v Visitor) { v.VisitEmptyStatement(my)}
func (my *EmptyStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEmptyStatementWithArg(my, o) }
func (my *EmptyStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEmptyStatementWithResult(my) }
func (my *EmptyStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEmptyStatementWithResultArgument(my, o) }


func AnyCastToEmptyStatement(i interface{}) *EmptyStatement {
	if nil == i{
		return nil
	}else{
		return i.(*EmptyStatement)
	}
}
/**
 *<b>
*<li>Rule 285:  LabeledStatement ::= identifier : Statement
 *</b>
 */
type LabeledStatement struct{
    *Ast
      _identifier *identifier
      _COLON *AstToken
      _Statement IStatement
}
func (my *LabeledStatement)      Getidentifier() *identifier{ return my._identifier}
func (my *LabeledStatement)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *LabeledStatement)      GetCOLON() *AstToken{ return my._COLON}
func (my *LabeledStatement)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *LabeledStatement)      GetStatement() IStatement{ return my._Statement}
func (my *LabeledStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewLabeledStatement(leftIToken IToken, rightIToken IToken ,
              _identifier *identifier,
              _COLON *AstToken,
              _Statement IStatement)*LabeledStatement{
      my := new(LabeledStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LabeledStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *LabeledStatement)      AcceptWithVisitor(v Visitor) { v.VisitLabeledStatement(my)}
func (my *LabeledStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLabeledStatementWithArg(my, o) }
func (my *LabeledStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLabeledStatementWithResult(my) }
func (my *LabeledStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLabeledStatementWithResultArgument(my, o) }


func AnyCastToLabeledStatement(i interface{}) *LabeledStatement {
	if nil == i{
		return nil
	}else{
		return i.(*LabeledStatement)
	}
}
/**
 *<b>
*<li>Rule 286:  LabeledStatementNoShortIf ::= identifier : StatementNoShortIf
 *</b>
 */
type LabeledStatementNoShortIf struct{
    *Ast
      _identifier *identifier
      _COLON *AstToken
      _StatementNoShortIf IStatementNoShortIf
}
func (my *LabeledStatementNoShortIf)      Getidentifier() *identifier{ return my._identifier}
func (my *LabeledStatementNoShortIf)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *LabeledStatementNoShortIf)      GetCOLON() *AstToken{ return my._COLON}
func (my *LabeledStatementNoShortIf)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *LabeledStatementNoShortIf)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *LabeledStatementNoShortIf)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }

func NewLabeledStatementNoShortIf(leftIToken IToken, rightIToken IToken ,
              _identifier *identifier,
              _COLON *AstToken,
              _StatementNoShortIf IStatementNoShortIf)*LabeledStatementNoShortIf{
      my := new(LabeledStatementNoShortIf)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LabeledStatementNoShortIf)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        return list
    }

func (my *LabeledStatementNoShortIf)      AcceptWithVisitor(v Visitor) { v.VisitLabeledStatementNoShortIf(my)}
func (my *LabeledStatementNoShortIf)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLabeledStatementNoShortIfWithArg(my, o) }
func (my *LabeledStatementNoShortIf)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLabeledStatementNoShortIfWithResult(my) }
func (my *LabeledStatementNoShortIf)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLabeledStatementNoShortIfWithResultArgument(my, o) }


func AnyCastToLabeledStatementNoShortIf(i interface{}) *LabeledStatementNoShortIf {
	if nil == i{
		return nil
	}else{
		return i.(*LabeledStatementNoShortIf)
	}
}
/**
 *<b>
*<li>Rule 287:  ExpressionStatement ::= StatementExpression ;
 *</b>
 */
type ExpressionStatement struct{
    *Ast
      _StatementExpression IStatementExpression
      _SEMICOLON *AstToken
}
func (my *ExpressionStatement)      GetStatementExpression() IStatementExpression{ return my._StatementExpression}
func (my *ExpressionStatement)      SetStatementExpression( _StatementExpression IStatementExpression)  { my._StatementExpression = _StatementExpression }
func (my *ExpressionStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ExpressionStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewExpressionStatement(leftIToken IToken, rightIToken IToken ,
              _StatementExpression IStatementExpression,
              _SEMICOLON *AstToken)*ExpressionStatement{
      my := new(ExpressionStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._StatementExpression = _StatementExpression;
        if nil != _StatementExpression{
        var trait_ interface{} = _StatementExpression
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExpressionStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._StatementExpression{  list.Add(my._StatementExpression) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ExpressionStatement)      AcceptWithVisitor(v Visitor) { v.VisitExpressionStatement(my)}
func (my *ExpressionStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExpressionStatementWithArg(my, o) }
func (my *ExpressionStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExpressionStatementWithResult(my) }
func (my *ExpressionStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExpressionStatementWithResultArgument(my, o) }


func AnyCastToExpressionStatement(i interface{}) *ExpressionStatement {
	if nil == i{
		return nil
	}else{
		return i.(*ExpressionStatement)
	}
}
/**
 *<b>
*<li>Rule 297:  SwitchStatement ::= switch ( Expression ) SwitchBlock
 *</b>
 */
type SwitchStatement struct{
    *Ast
      _switch *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _SwitchBlock *SwitchBlock
}
func (my *SwitchStatement)      Getswitch() *AstToken{ return my._switch}
func (my *SwitchStatement)      Setswitch( _switch *AstToken)  { my._switch = _switch }
func (my *SwitchStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *SwitchStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *SwitchStatement)      GetExpression() IExpression{ return my._Expression}
func (my *SwitchStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *SwitchStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *SwitchStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *SwitchStatement)      GetSwitchBlock() *SwitchBlock{ return my._SwitchBlock}
func (my *SwitchStatement)      SetSwitchBlock( _SwitchBlock *SwitchBlock)  { my._SwitchBlock = _SwitchBlock }

func NewSwitchStatement(leftIToken IToken, rightIToken IToken ,
              _switch *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _SwitchBlock *SwitchBlock)*SwitchStatement{
      my := new(SwitchStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._switch = _switch;
        if nil != _switch{
        var trait_ interface{} = _switch
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SwitchBlock = _SwitchBlock;
        if nil != _SwitchBlock{
        var trait_ interface{} = _SwitchBlock
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._switch{  list.Add(my._switch) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SwitchBlock{  list.Add(my._SwitchBlock) }
        return list
    }

func (my *SwitchStatement)      AcceptWithVisitor(v Visitor) { v.VisitSwitchStatement(my)}
func (my *SwitchStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSwitchStatementWithArg(my, o) }
func (my *SwitchStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSwitchStatementWithResult(my) }
func (my *SwitchStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSwitchStatementWithResultArgument(my, o) }


func AnyCastToSwitchStatement(i interface{}) *SwitchStatement {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchStatement)
	}
}
/**
 *<b>
*<li>Rule 298:  SwitchBlock ::= { SwitchBlockStatementGroupsopt SwitchLabelsopt }
 *</b>
 */
type SwitchBlock struct{
    *Ast
      _LBRACE *AstToken
      _SwitchBlockStatementGroupsopt ISwitchBlockStatementGroupsopt
      _SwitchLabelsopt ISwitchLabelsopt
      _RBRACE *AstToken
}
func (my *SwitchBlock)      GetLBRACE() *AstToken{ return my._LBRACE}
func (my *SwitchBlock)      SetLBRACE( _LBRACE *AstToken)  { my._LBRACE = _LBRACE }
    /**
     * The value returned by <b>GetSwitchBlockStatementGroupsopt</b> may be <b>null</b>
     */
func (my *SwitchBlock)      GetSwitchBlockStatementGroupsopt() ISwitchBlockStatementGroupsopt{ return my._SwitchBlockStatementGroupsopt}
func (my *SwitchBlock)      SetSwitchBlockStatementGroupsopt( _SwitchBlockStatementGroupsopt ISwitchBlockStatementGroupsopt)  { my._SwitchBlockStatementGroupsopt = _SwitchBlockStatementGroupsopt }
    /**
     * The value returned by <b>GetSwitchLabelsopt</b> may be <b>null</b>
     */
func (my *SwitchBlock)      GetSwitchLabelsopt() ISwitchLabelsopt{ return my._SwitchLabelsopt}
func (my *SwitchBlock)      SetSwitchLabelsopt( _SwitchLabelsopt ISwitchLabelsopt)  { my._SwitchLabelsopt = _SwitchLabelsopt }
func (my *SwitchBlock)      GetRBRACE() *AstToken{ return my._RBRACE}
func (my *SwitchBlock)      SetRBRACE( _RBRACE *AstToken)  { my._RBRACE = _RBRACE }

func NewSwitchBlock(leftIToken IToken, rightIToken IToken ,
              _LBRACE *AstToken,
              _SwitchBlockStatementGroupsopt ISwitchBlockStatementGroupsopt,
              _SwitchLabelsopt ISwitchLabelsopt,
              _RBRACE *AstToken)*SwitchBlock{
      my := new(SwitchBlock)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACE = _LBRACE;
        if nil != _LBRACE{
        var trait_ interface{} = _LBRACE
         trait_.(IAst).SetParent(my)
}
        my._SwitchBlockStatementGroupsopt = _SwitchBlockStatementGroupsopt;
        if nil != _SwitchBlockStatementGroupsopt{
        var trait_ interface{} = _SwitchBlockStatementGroupsopt
         trait_.(IAst).SetParent(my)
}
        my._SwitchLabelsopt = _SwitchLabelsopt;
        if nil != _SwitchLabelsopt{
        var trait_ interface{} = _SwitchLabelsopt
         trait_.(IAst).SetParent(my)
}
        my._RBRACE = _RBRACE;
        if nil != _RBRACE{
        var trait_ interface{} = _RBRACE
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchBlock)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACE{  list.Add(my._LBRACE) }
        if nil != my._SwitchBlockStatementGroupsopt{  list.Add(my._SwitchBlockStatementGroupsopt) }
        if nil != my._SwitchLabelsopt{  list.Add(my._SwitchLabelsopt) }
        if nil != my._RBRACE{  list.Add(my._RBRACE) }
        return list
    }

func (my *SwitchBlock)      AcceptWithVisitor(v Visitor) { v.VisitSwitchBlock(my)}
func (my *SwitchBlock)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSwitchBlockWithArg(my, o) }
func (my *SwitchBlock)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSwitchBlockWithResult(my) }
func (my *SwitchBlock)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSwitchBlockWithResultArgument(my, o) }


func AnyCastToSwitchBlock(i interface{}) *SwitchBlock {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchBlock)
	}
}
/**
 *<em>
*<li>Rule 299:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroup
 *</em>
 *<p>
 *<b>
*<li>Rule 300:  SwitchBlockStatementGroups ::= SwitchBlockStatementGroups SwitchBlockStatementGroup
 *</b>
 */
type SwitchBlockStatementGroups struct{
    *Ast
      _SwitchBlockStatementGroups ISwitchBlockStatementGroups
      _SwitchBlockStatementGroup *SwitchBlockStatementGroup
}
func (my *SwitchBlockStatementGroups)      GetSwitchBlockStatementGroups() ISwitchBlockStatementGroups{ return my._SwitchBlockStatementGroups}
func (my *SwitchBlockStatementGroups)      SetSwitchBlockStatementGroups( _SwitchBlockStatementGroups ISwitchBlockStatementGroups)  { my._SwitchBlockStatementGroups = _SwitchBlockStatementGroups }
func (my *SwitchBlockStatementGroups)      GetSwitchBlockStatementGroup() *SwitchBlockStatementGroup{ return my._SwitchBlockStatementGroup}
func (my *SwitchBlockStatementGroups)      SetSwitchBlockStatementGroup( _SwitchBlockStatementGroup *SwitchBlockStatementGroup)  { my._SwitchBlockStatementGroup = _SwitchBlockStatementGroup }

func NewSwitchBlockStatementGroups(leftIToken IToken, rightIToken IToken ,
              _SwitchBlockStatementGroups ISwitchBlockStatementGroups,
              _SwitchBlockStatementGroup *SwitchBlockStatementGroup)*SwitchBlockStatementGroups{
      my := new(SwitchBlockStatementGroups)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SwitchBlockStatementGroups = _SwitchBlockStatementGroups;
        if nil != _SwitchBlockStatementGroups{
        var trait_ interface{} = _SwitchBlockStatementGroups
         trait_.(IAst).SetParent(my)
}
        my._SwitchBlockStatementGroup = _SwitchBlockStatementGroup;
        if nil != _SwitchBlockStatementGroup{
        var trait_ interface{} = _SwitchBlockStatementGroup
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchBlockStatementGroups)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SwitchBlockStatementGroups{  list.Add(my._SwitchBlockStatementGroups) }
        if nil != my._SwitchBlockStatementGroup{  list.Add(my._SwitchBlockStatementGroup) }
        return list
    }

func (my *SwitchBlockStatementGroups)      AcceptWithVisitor(v Visitor) { v.VisitSwitchBlockStatementGroups(my)}
func (my *SwitchBlockStatementGroups)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSwitchBlockStatementGroupsWithArg(my, o) }
func (my *SwitchBlockStatementGroups)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSwitchBlockStatementGroupsWithResult(my) }
func (my *SwitchBlockStatementGroups)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSwitchBlockStatementGroupsWithResultArgument(my, o) }


func AnyCastToSwitchBlockStatementGroups(i interface{}) *SwitchBlockStatementGroups {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchBlockStatementGroups)
	}
}
/**
 *<b>
*<li>Rule 301:  SwitchBlockStatementGroup ::= SwitchLabels BlockStatements
 *</b>
 */
type SwitchBlockStatementGroup struct{
    *Ast
      _SwitchLabels ISwitchLabels
      _BlockStatements IBlockStatements
}
func (my *SwitchBlockStatementGroup)      GetSwitchLabels() ISwitchLabels{ return my._SwitchLabels}
func (my *SwitchBlockStatementGroup)      SetSwitchLabels( _SwitchLabels ISwitchLabels)  { my._SwitchLabels = _SwitchLabels }
func (my *SwitchBlockStatementGroup)      GetBlockStatements() IBlockStatements{ return my._BlockStatements}
func (my *SwitchBlockStatementGroup)      SetBlockStatements( _BlockStatements IBlockStatements)  { my._BlockStatements = _BlockStatements }

func NewSwitchBlockStatementGroup(leftIToken IToken, rightIToken IToken ,
              _SwitchLabels ISwitchLabels,
              _BlockStatements IBlockStatements)*SwitchBlockStatementGroup{
      my := new(SwitchBlockStatementGroup)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SwitchLabels = _SwitchLabels;
        if nil != _SwitchLabels{
        var trait_ interface{} = _SwitchLabels
         trait_.(IAst).SetParent(my)
}
        my._BlockStatements = _BlockStatements;
        if nil != _BlockStatements{
        var trait_ interface{} = _BlockStatements
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchBlockStatementGroup)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SwitchLabels{  list.Add(my._SwitchLabels) }
        if nil != my._BlockStatements{  list.Add(my._BlockStatements) }
        return list
    }

func (my *SwitchBlockStatementGroup)      AcceptWithVisitor(v Visitor) { v.VisitSwitchBlockStatementGroup(my)}
func (my *SwitchBlockStatementGroup)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSwitchBlockStatementGroupWithArg(my, o) }
func (my *SwitchBlockStatementGroup)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSwitchBlockStatementGroupWithResult(my) }
func (my *SwitchBlockStatementGroup)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSwitchBlockStatementGroupWithResultArgument(my, o) }


func AnyCastToSwitchBlockStatementGroup(i interface{}) *SwitchBlockStatementGroup {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchBlockStatementGroup)
	}
}
/**
 *<em>
*<li>Rule 302:  SwitchLabels ::= SwitchLabel
 *</em>
 *<p>
 *<b>
*<li>Rule 303:  SwitchLabels ::= SwitchLabels SwitchLabel
 *</b>
 */
type SwitchLabels struct{
    *Ast
      _SwitchLabels ISwitchLabels
      _SwitchLabel ISwitchLabel
}
func (my *SwitchLabels)      GetSwitchLabels() ISwitchLabels{ return my._SwitchLabels}
func (my *SwitchLabels)      SetSwitchLabels( _SwitchLabels ISwitchLabels)  { my._SwitchLabels = _SwitchLabels }
func (my *SwitchLabels)      GetSwitchLabel() ISwitchLabel{ return my._SwitchLabel}
func (my *SwitchLabels)      SetSwitchLabel( _SwitchLabel ISwitchLabel)  { my._SwitchLabel = _SwitchLabel }

func NewSwitchLabels(leftIToken IToken, rightIToken IToken ,
              _SwitchLabels ISwitchLabels,
              _SwitchLabel ISwitchLabel)*SwitchLabels{
      my := new(SwitchLabels)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._SwitchLabels = _SwitchLabels;
        if nil != _SwitchLabels{
        var trait_ interface{} = _SwitchLabels
         trait_.(IAst).SetParent(my)
}
        my._SwitchLabel = _SwitchLabel;
        if nil != _SwitchLabel{
        var trait_ interface{} = _SwitchLabel
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchLabels)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._SwitchLabels{  list.Add(my._SwitchLabels) }
        if nil != my._SwitchLabel{  list.Add(my._SwitchLabel) }
        return list
    }

func (my *SwitchLabels)      AcceptWithVisitor(v Visitor) { v.VisitSwitchLabels(my)}
func (my *SwitchLabels)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSwitchLabelsWithArg(my, o) }
func (my *SwitchLabels)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSwitchLabelsWithResult(my) }
func (my *SwitchLabels)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSwitchLabelsWithResultArgument(my, o) }


func AnyCastToSwitchLabels(i interface{}) *SwitchLabels {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchLabels)
	}
}
/**
 *<b>
*<li>Rule 308:  WhileStatement ::= while ( Expression ) Statement
 *</b>
 */
type WhileStatement struct{
    *Ast
      _while *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _Statement IStatement
}
func (my *WhileStatement)      Getwhile() *AstToken{ return my._while}
func (my *WhileStatement)      Setwhile( _while *AstToken)  { my._while = _while }
func (my *WhileStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *WhileStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *WhileStatement)      GetExpression() IExpression{ return my._Expression}
func (my *WhileStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *WhileStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *WhileStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *WhileStatement)      GetStatement() IStatement{ return my._Statement}
func (my *WhileStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewWhileStatement(leftIToken IToken, rightIToken IToken ,
              _while *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _Statement IStatement)*WhileStatement{
      my := new(WhileStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._while = _while;
        if nil != _while{
        var trait_ interface{} = _while
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *WhileStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._while{  list.Add(my._while) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *WhileStatement)      AcceptWithVisitor(v Visitor) { v.VisitWhileStatement(my)}
func (my *WhileStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitWhileStatementWithArg(my, o) }
func (my *WhileStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitWhileStatementWithResult(my) }
func (my *WhileStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitWhileStatementWithResultArgument(my, o) }


func AnyCastToWhileStatement(i interface{}) *WhileStatement {
	if nil == i{
		return nil
	}else{
		return i.(*WhileStatement)
	}
}
/**
 *<b>
*<li>Rule 309:  WhileStatementNoShortIf ::= while ( Expression ) StatementNoShortIf
 *</b>
 */
type WhileStatementNoShortIf struct{
    *Ast
      _while *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _StatementNoShortIf IStatementNoShortIf
}
func (my *WhileStatementNoShortIf)      Getwhile() *AstToken{ return my._while}
func (my *WhileStatementNoShortIf)      Setwhile( _while *AstToken)  { my._while = _while }
func (my *WhileStatementNoShortIf)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *WhileStatementNoShortIf)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *WhileStatementNoShortIf)      GetExpression() IExpression{ return my._Expression}
func (my *WhileStatementNoShortIf)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *WhileStatementNoShortIf)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *WhileStatementNoShortIf)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *WhileStatementNoShortIf)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *WhileStatementNoShortIf)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }

func NewWhileStatementNoShortIf(leftIToken IToken, rightIToken IToken ,
              _while *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _StatementNoShortIf IStatementNoShortIf)*WhileStatementNoShortIf{
      my := new(WhileStatementNoShortIf)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._while = _while;
        if nil != _while{
        var trait_ interface{} = _while
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *WhileStatementNoShortIf)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._while{  list.Add(my._while) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        return list
    }

func (my *WhileStatementNoShortIf)      AcceptWithVisitor(v Visitor) { v.VisitWhileStatementNoShortIf(my)}
func (my *WhileStatementNoShortIf)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitWhileStatementNoShortIfWithArg(my, o) }
func (my *WhileStatementNoShortIf)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitWhileStatementNoShortIfWithResult(my) }
func (my *WhileStatementNoShortIf)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitWhileStatementNoShortIfWithResultArgument(my, o) }


func AnyCastToWhileStatementNoShortIf(i interface{}) *WhileStatementNoShortIf {
	if nil == i{
		return nil
	}else{
		return i.(*WhileStatementNoShortIf)
	}
}
/**
 *<b>
*<li>Rule 310:  DoStatement ::= do Statement while ( Expression ) ;
 *</b>
 */
type DoStatement struct{
    *Ast
      _do *AstToken
      _Statement IStatement
      _while *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _SEMICOLON *AstToken
}
func (my *DoStatement)      Getdo() *AstToken{ return my._do}
func (my *DoStatement)      Setdo( _do *AstToken)  { my._do = _do }
func (my *DoStatement)      GetStatement() IStatement{ return my._Statement}
func (my *DoStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }
func (my *DoStatement)      Getwhile() *AstToken{ return my._while}
func (my *DoStatement)      Setwhile( _while *AstToken)  { my._while = _while }
func (my *DoStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *DoStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *DoStatement)      GetExpression() IExpression{ return my._Expression}
func (my *DoStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *DoStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *DoStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *DoStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *DoStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewDoStatement(leftIToken IToken, rightIToken IToken ,
              _do *AstToken,
              _Statement IStatement,
              _while *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _SEMICOLON *AstToken)*DoStatement{
      my := new(DoStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._do = _do;
        if nil != _do{
        var trait_ interface{} = _do
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my._while = _while;
        if nil != _while{
        var trait_ interface{} = _while
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *DoStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._do{  list.Add(my._do) }
        if nil != my._Statement{  list.Add(my._Statement) }
        if nil != my._while{  list.Add(my._while) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *DoStatement)      AcceptWithVisitor(v Visitor) { v.VisitDoStatement(my)}
func (my *DoStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitDoStatementWithArg(my, o) }
func (my *DoStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitDoStatementWithResult(my) }
func (my *DoStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitDoStatementWithResultArgument(my, o) }


func AnyCastToDoStatement(i interface{}) *DoStatement {
	if nil == i{
		return nil
	}else{
		return i.(*DoStatement)
	}
}
/**
 *<b>
*<li>Rule 313:  BasicForStatement ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) Statement
 *</b>
 */
type BasicForStatement struct{
    *Ast
      _for *AstToken
      _LPAREN *AstToken
      _ForInitopt IForInitopt
      _SEMICOLON *AstToken
      _Expressionopt IExpressionopt
      _SEMICOLON6 *AstToken
      _ForUpdateopt IForUpdateopt
      _RPAREN *AstToken
      _Statement IStatement
}
func (my *BasicForStatement)      Getfor() *AstToken{ return my._for}
func (my *BasicForStatement)      Setfor( _for *AstToken)  { my._for = _for }
func (my *BasicForStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *BasicForStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetForInitopt</b> may be <b>null</b>
     */
func (my *BasicForStatement)      GetForInitopt() IForInitopt{ return my._ForInitopt}
func (my *BasicForStatement)      SetForInitopt( _ForInitopt IForInitopt)  { my._ForInitopt = _ForInitopt }
func (my *BasicForStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *BasicForStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }
    /**
     * The value returned by <b>GetExpressionopt</b> may be <b>null</b>
     */
func (my *BasicForStatement)      GetExpressionopt() IExpressionopt{ return my._Expressionopt}
func (my *BasicForStatement)      SetExpressionopt( _Expressionopt IExpressionopt)  { my._Expressionopt = _Expressionopt }
func (my *BasicForStatement)      GetSEMICOLON6() *AstToken{ return my._SEMICOLON6}
func (my *BasicForStatement)      SetSEMICOLON6( _SEMICOLON6 *AstToken)  { my._SEMICOLON6 = _SEMICOLON6 }
    /**
     * The value returned by <b>GetForUpdateopt</b> may be <b>null</b>
     */
func (my *BasicForStatement)      GetForUpdateopt() IForUpdateopt{ return my._ForUpdateopt}
func (my *BasicForStatement)      SetForUpdateopt( _ForUpdateopt IForUpdateopt)  { my._ForUpdateopt = _ForUpdateopt }
func (my *BasicForStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *BasicForStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *BasicForStatement)      GetStatement() IStatement{ return my._Statement}
func (my *BasicForStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewBasicForStatement(leftIToken IToken, rightIToken IToken ,
              _for *AstToken,
              _LPAREN *AstToken,
              _ForInitopt IForInitopt,
              _SEMICOLON *AstToken,
              _Expressionopt IExpressionopt,
              _SEMICOLON6 *AstToken,
              _ForUpdateopt IForUpdateopt,
              _RPAREN *AstToken,
              _Statement IStatement)*BasicForStatement{
      my := new(BasicForStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._for = _for;
        if nil != _for{
        var trait_ interface{} = _for
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ForInitopt = _ForInitopt;
        if nil != _ForInitopt{
        var trait_ interface{} = _ForInitopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my._Expressionopt = _Expressionopt;
        if nil != _Expressionopt{
        var trait_ interface{} = _Expressionopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON6 = _SEMICOLON6;
        if nil != _SEMICOLON6{
        var trait_ interface{} = _SEMICOLON6
         trait_.(IAst).SetParent(my)
}
        my._ForUpdateopt = _ForUpdateopt;
        if nil != _ForUpdateopt{
        var trait_ interface{} = _ForUpdateopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *BasicForStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._for{  list.Add(my._for) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ForInitopt{  list.Add(my._ForInitopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        if nil != my._Expressionopt{  list.Add(my._Expressionopt) }
        if nil != my._SEMICOLON6{  list.Add(my._SEMICOLON6) }
        if nil != my._ForUpdateopt{  list.Add(my._ForUpdateopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *BasicForStatement)      AcceptWithVisitor(v Visitor) { v.VisitBasicForStatement(my)}
func (my *BasicForStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitBasicForStatementWithArg(my, o) }
func (my *BasicForStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitBasicForStatementWithResult(my) }
func (my *BasicForStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitBasicForStatementWithResultArgument(my, o) }


func AnyCastToBasicForStatement(i interface{}) *BasicForStatement {
	if nil == i{
		return nil
	}else{
		return i.(*BasicForStatement)
	}
}
/**
 *<b>
*<li>Rule 314:  ForStatementNoShortIf ::= for ( ForInitopt ; Expressionopt ; ForUpdateopt ) StatementNoShortIf
 *</b>
 */
type ForStatementNoShortIf struct{
    *Ast
      _for *AstToken
      _LPAREN *AstToken
      _ForInitopt IForInitopt
      _SEMICOLON *AstToken
      _Expressionopt IExpressionopt
      _SEMICOLON6 *AstToken
      _ForUpdateopt IForUpdateopt
      _RPAREN *AstToken
      _StatementNoShortIf IStatementNoShortIf
}
func (my *ForStatementNoShortIf)      Getfor() *AstToken{ return my._for}
func (my *ForStatementNoShortIf)      Setfor( _for *AstToken)  { my._for = _for }
func (my *ForStatementNoShortIf)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ForStatementNoShortIf)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetForInitopt</b> may be <b>null</b>
     */
func (my *ForStatementNoShortIf)      GetForInitopt() IForInitopt{ return my._ForInitopt}
func (my *ForStatementNoShortIf)      SetForInitopt( _ForInitopt IForInitopt)  { my._ForInitopt = _ForInitopt }
func (my *ForStatementNoShortIf)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ForStatementNoShortIf)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }
    /**
     * The value returned by <b>GetExpressionopt</b> may be <b>null</b>
     */
func (my *ForStatementNoShortIf)      GetExpressionopt() IExpressionopt{ return my._Expressionopt}
func (my *ForStatementNoShortIf)      SetExpressionopt( _Expressionopt IExpressionopt)  { my._Expressionopt = _Expressionopt }
func (my *ForStatementNoShortIf)      GetSEMICOLON6() *AstToken{ return my._SEMICOLON6}
func (my *ForStatementNoShortIf)      SetSEMICOLON6( _SEMICOLON6 *AstToken)  { my._SEMICOLON6 = _SEMICOLON6 }
    /**
     * The value returned by <b>GetForUpdateopt</b> may be <b>null</b>
     */
func (my *ForStatementNoShortIf)      GetForUpdateopt() IForUpdateopt{ return my._ForUpdateopt}
func (my *ForStatementNoShortIf)      SetForUpdateopt( _ForUpdateopt IForUpdateopt)  { my._ForUpdateopt = _ForUpdateopt }
func (my *ForStatementNoShortIf)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ForStatementNoShortIf)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *ForStatementNoShortIf)      GetStatementNoShortIf() IStatementNoShortIf{ return my._StatementNoShortIf}
func (my *ForStatementNoShortIf)      SetStatementNoShortIf( _StatementNoShortIf IStatementNoShortIf)  { my._StatementNoShortIf = _StatementNoShortIf }

func NewForStatementNoShortIf(leftIToken IToken, rightIToken IToken ,
              _for *AstToken,
              _LPAREN *AstToken,
              _ForInitopt IForInitopt,
              _SEMICOLON *AstToken,
              _Expressionopt IExpressionopt,
              _SEMICOLON6 *AstToken,
              _ForUpdateopt IForUpdateopt,
              _RPAREN *AstToken,
              _StatementNoShortIf IStatementNoShortIf)*ForStatementNoShortIf{
      my := new(ForStatementNoShortIf)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._for = _for;
        if nil != _for{
        var trait_ interface{} = _for
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ForInitopt = _ForInitopt;
        if nil != _ForInitopt{
        var trait_ interface{} = _ForInitopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my._Expressionopt = _Expressionopt;
        if nil != _Expressionopt{
        var trait_ interface{} = _Expressionopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON6 = _SEMICOLON6;
        if nil != _SEMICOLON6{
        var trait_ interface{} = _SEMICOLON6
         trait_.(IAst).SetParent(my)
}
        my._ForUpdateopt = _ForUpdateopt;
        if nil != _ForUpdateopt{
        var trait_ interface{} = _ForUpdateopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._StatementNoShortIf = _StatementNoShortIf;
        if nil != _StatementNoShortIf{
        var trait_ interface{} = _StatementNoShortIf
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ForStatementNoShortIf)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._for{  list.Add(my._for) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ForInitopt{  list.Add(my._ForInitopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        if nil != my._Expressionopt{  list.Add(my._Expressionopt) }
        if nil != my._SEMICOLON6{  list.Add(my._SEMICOLON6) }
        if nil != my._ForUpdateopt{  list.Add(my._ForUpdateopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._StatementNoShortIf{  list.Add(my._StatementNoShortIf) }
        return list
    }

func (my *ForStatementNoShortIf)      AcceptWithVisitor(v Visitor) { v.VisitForStatementNoShortIf(my)}
func (my *ForStatementNoShortIf)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitForStatementNoShortIfWithArg(my, o) }
func (my *ForStatementNoShortIf)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitForStatementNoShortIfWithResult(my) }
func (my *ForStatementNoShortIf)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitForStatementNoShortIfWithResultArgument(my, o) }


func AnyCastToForStatementNoShortIf(i interface{}) *ForStatementNoShortIf {
	if nil == i{
		return nil
	}else{
		return i.(*ForStatementNoShortIf)
	}
}
/**
 *<em>
*<li>Rule 318:  StatementExpressionList ::= StatementExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 319:  StatementExpressionList ::= StatementExpressionList , StatementExpression
 *</b>
 */
type StatementExpressionList struct{
    *Ast
      _StatementExpressionList IStatementExpressionList
      _COMMA *AstToken
      _StatementExpression IStatementExpression
}
func (my *StatementExpressionList)      GetStatementExpressionList() IStatementExpressionList{ return my._StatementExpressionList}
func (my *StatementExpressionList)      SetStatementExpressionList( _StatementExpressionList IStatementExpressionList)  { my._StatementExpressionList = _StatementExpressionList }
func (my *StatementExpressionList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *StatementExpressionList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *StatementExpressionList)      GetStatementExpression() IStatementExpression{ return my._StatementExpression}
func (my *StatementExpressionList)      SetStatementExpression( _StatementExpression IStatementExpression)  { my._StatementExpression = _StatementExpression }

func NewStatementExpressionList(leftIToken IToken, rightIToken IToken ,
              _StatementExpressionList IStatementExpressionList,
              _COMMA *AstToken,
              _StatementExpression IStatementExpression)*StatementExpressionList{
      my := new(StatementExpressionList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._StatementExpressionList = _StatementExpressionList;
        if nil != _StatementExpressionList{
        var trait_ interface{} = _StatementExpressionList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._StatementExpression = _StatementExpression;
        if nil != _StatementExpression{
        var trait_ interface{} = _StatementExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *StatementExpressionList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._StatementExpressionList{  list.Add(my._StatementExpressionList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._StatementExpression{  list.Add(my._StatementExpression) }
        return list
    }

func (my *StatementExpressionList)      AcceptWithVisitor(v Visitor) { v.VisitStatementExpressionList(my)}
func (my *StatementExpressionList)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitStatementExpressionListWithArg(my, o) }
func (my *StatementExpressionList)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitStatementExpressionListWithResult(my) }
func (my *StatementExpressionList)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitStatementExpressionListWithResultArgument(my, o) }


func AnyCastToStatementExpressionList(i interface{}) *StatementExpressionList {
	if nil == i{
		return nil
	}else{
		return i.(*StatementExpressionList)
	}
}
/**
 *<b>
*<li>Rule 320:  EnhancedForStatement ::= for ( FormalParameter : Expression ) Statement
 *</b>
 */
type EnhancedForStatement struct{
    *Ast
      _for *AstToken
      _LPAREN *AstToken
      _FormalParameter *FormalParameter
      _COLON *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _Statement IStatement
}
func (my *EnhancedForStatement)      Getfor() *AstToken{ return my._for}
func (my *EnhancedForStatement)      Setfor( _for *AstToken)  { my._for = _for }
func (my *EnhancedForStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *EnhancedForStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *EnhancedForStatement)      GetFormalParameter() *FormalParameter{ return my._FormalParameter}
func (my *EnhancedForStatement)      SetFormalParameter( _FormalParameter *FormalParameter)  { my._FormalParameter = _FormalParameter }
func (my *EnhancedForStatement)      GetCOLON() *AstToken{ return my._COLON}
func (my *EnhancedForStatement)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *EnhancedForStatement)      GetExpression() IExpression{ return my._Expression}
func (my *EnhancedForStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *EnhancedForStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *EnhancedForStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *EnhancedForStatement)      GetStatement() IStatement{ return my._Statement}
func (my *EnhancedForStatement)      SetStatement( _Statement IStatement)  { my._Statement = _Statement }

func NewEnhancedForStatement(leftIToken IToken, rightIToken IToken ,
              _for *AstToken,
              _LPAREN *AstToken,
              _FormalParameter *FormalParameter,
              _COLON *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _Statement IStatement)*EnhancedForStatement{
      my := new(EnhancedForStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._for = _for;
        if nil != _for{
        var trait_ interface{} = _for
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._FormalParameter = _FormalParameter;
        if nil != _FormalParameter{
        var trait_ interface{} = _FormalParameter
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Statement = _Statement;
        if nil != _Statement{
        var trait_ interface{} = _Statement
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EnhancedForStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._for{  list.Add(my._for) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._FormalParameter{  list.Add(my._FormalParameter) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Statement{  list.Add(my._Statement) }
        return list
    }

func (my *EnhancedForStatement)      AcceptWithVisitor(v Visitor) { v.VisitEnhancedForStatement(my)}
func (my *EnhancedForStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEnhancedForStatementWithArg(my, o) }
func (my *EnhancedForStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEnhancedForStatementWithResult(my) }
func (my *EnhancedForStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEnhancedForStatementWithResultArgument(my, o) }


func AnyCastToEnhancedForStatement(i interface{}) *EnhancedForStatement {
	if nil == i{
		return nil
	}else{
		return i.(*EnhancedForStatement)
	}
}
/**
 *<b>
*<li>Rule 321:  BreakStatement ::= break identifieropt ;
 *</b>
 */
type BreakStatement struct{
    *Ast
      _break *AstToken
      _identifieropt *identifier
      _SEMICOLON *AstToken
}
func (my *BreakStatement)      Getbreak() *AstToken{ return my._break}
func (my *BreakStatement)      Setbreak( _break *AstToken)  { my._break = _break }
    /**
     * The value returned by <b>Getidentifieropt</b> may be <b>null</b>
     */
func (my *BreakStatement)      Getidentifieropt() *identifier{ return my._identifieropt}
func (my *BreakStatement)      Setidentifieropt( _identifieropt *identifier)  { my._identifieropt = _identifieropt }
func (my *BreakStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *BreakStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewBreakStatement(leftIToken IToken, rightIToken IToken ,
              _break *AstToken,
              _identifieropt *identifier,
              _SEMICOLON *AstToken)*BreakStatement{
      my := new(BreakStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._break = _break;
        if nil != _break{
        var trait_ interface{} = _break
         trait_.(IAst).SetParent(my)
}
        my._identifieropt = _identifieropt;
        if nil != _identifieropt{
        var trait_ interface{} = _identifieropt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *BreakStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._break{  list.Add(my._break) }
        if nil != my._identifieropt{  list.Add(my._identifieropt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *BreakStatement)      AcceptWithVisitor(v Visitor) { v.VisitBreakStatement(my)}
func (my *BreakStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitBreakStatementWithArg(my, o) }
func (my *BreakStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitBreakStatementWithResult(my) }
func (my *BreakStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitBreakStatementWithResultArgument(my, o) }


func AnyCastToBreakStatement(i interface{}) *BreakStatement {
	if nil == i{
		return nil
	}else{
		return i.(*BreakStatement)
	}
}
/**
 *<b>
*<li>Rule 322:  ContinueStatement ::= continue identifieropt ;
 *</b>
 */
type ContinueStatement struct{
    *Ast
      _continue *AstToken
      _identifieropt *identifier
      _SEMICOLON *AstToken
}
func (my *ContinueStatement)      Getcontinue() *AstToken{ return my._continue}
func (my *ContinueStatement)      Setcontinue( _continue *AstToken)  { my._continue = _continue }
    /**
     * The value returned by <b>Getidentifieropt</b> may be <b>null</b>
     */
func (my *ContinueStatement)      Getidentifieropt() *identifier{ return my._identifieropt}
func (my *ContinueStatement)      Setidentifieropt( _identifieropt *identifier)  { my._identifieropt = _identifieropt }
func (my *ContinueStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ContinueStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewContinueStatement(leftIToken IToken, rightIToken IToken ,
              _continue *AstToken,
              _identifieropt *identifier,
              _SEMICOLON *AstToken)*ContinueStatement{
      my := new(ContinueStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._continue = _continue;
        if nil != _continue{
        var trait_ interface{} = _continue
         trait_.(IAst).SetParent(my)
}
        my._identifieropt = _identifieropt;
        if nil != _identifieropt{
        var trait_ interface{} = _identifieropt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ContinueStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._continue{  list.Add(my._continue) }
        if nil != my._identifieropt{  list.Add(my._identifieropt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ContinueStatement)      AcceptWithVisitor(v Visitor) { v.VisitContinueStatement(my)}
func (my *ContinueStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitContinueStatementWithArg(my, o) }
func (my *ContinueStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitContinueStatementWithResult(my) }
func (my *ContinueStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitContinueStatementWithResultArgument(my, o) }


func AnyCastToContinueStatement(i interface{}) *ContinueStatement {
	if nil == i{
		return nil
	}else{
		return i.(*ContinueStatement)
	}
}
/**
 *<b>
*<li>Rule 323:  ReturnStatement ::= return Expressionopt ;
 *</b>
 */
type ReturnStatement struct{
    *Ast
      _return *AstToken
      _Expressionopt IExpressionopt
      _SEMICOLON *AstToken
}
func (my *ReturnStatement)      Getreturn() *AstToken{ return my._return}
func (my *ReturnStatement)      Setreturn( _return *AstToken)  { my._return = _return }
    /**
     * The value returned by <b>GetExpressionopt</b> may be <b>null</b>
     */
func (my *ReturnStatement)      GetExpressionopt() IExpressionopt{ return my._Expressionopt}
func (my *ReturnStatement)      SetExpressionopt( _Expressionopt IExpressionopt)  { my._Expressionopt = _Expressionopt }
func (my *ReturnStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ReturnStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewReturnStatement(leftIToken IToken, rightIToken IToken ,
              _return *AstToken,
              _Expressionopt IExpressionopt,
              _SEMICOLON *AstToken)*ReturnStatement{
      my := new(ReturnStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._return = _return;
        if nil != _return{
        var trait_ interface{} = _return
         trait_.(IAst).SetParent(my)
}
        my._Expressionopt = _Expressionopt;
        if nil != _Expressionopt{
        var trait_ interface{} = _Expressionopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ReturnStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._return{  list.Add(my._return) }
        if nil != my._Expressionopt{  list.Add(my._Expressionopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ReturnStatement)      AcceptWithVisitor(v Visitor) { v.VisitReturnStatement(my)}
func (my *ReturnStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitReturnStatementWithArg(my, o) }
func (my *ReturnStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitReturnStatementWithResult(my) }
func (my *ReturnStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitReturnStatementWithResultArgument(my, o) }


func AnyCastToReturnStatement(i interface{}) *ReturnStatement {
	if nil == i{
		return nil
	}else{
		return i.(*ReturnStatement)
	}
}
/**
 *<b>
*<li>Rule 324:  ThrowStatement ::= throw Expression ;
 *</b>
 */
type ThrowStatement struct{
    *Ast
      _throw *AstToken
      _Expression IExpression
      _SEMICOLON *AstToken
}
func (my *ThrowStatement)      Getthrow() *AstToken{ return my._throw}
func (my *ThrowStatement)      Setthrow( _throw *AstToken)  { my._throw = _throw }
func (my *ThrowStatement)      GetExpression() IExpression{ return my._Expression}
func (my *ThrowStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *ThrowStatement)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ThrowStatement)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewThrowStatement(leftIToken IToken, rightIToken IToken ,
              _throw *AstToken,
              _Expression IExpression,
              _SEMICOLON *AstToken)*ThrowStatement{
      my := new(ThrowStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._throw = _throw;
        if nil != _throw{
        var trait_ interface{} = _throw
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ThrowStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._throw{  list.Add(my._throw) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ThrowStatement)      AcceptWithVisitor(v Visitor) { v.VisitThrowStatement(my)}
func (my *ThrowStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitThrowStatementWithArg(my, o) }
func (my *ThrowStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitThrowStatementWithResult(my) }
func (my *ThrowStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitThrowStatementWithResultArgument(my, o) }


func AnyCastToThrowStatement(i interface{}) *ThrowStatement {
	if nil == i{
		return nil
	}else{
		return i.(*ThrowStatement)
	}
}
/**
 *<b>
*<li>Rule 325:  SynchronizedStatement ::= synchronized ( Expression ) Block
 *</b>
 */
type SynchronizedStatement struct{
    *Ast
      _synchronized *AstToken
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
      _Block *Block
}
func (my *SynchronizedStatement)      Getsynchronized() *AstToken{ return my._synchronized}
func (my *SynchronizedStatement)      Setsynchronized( _synchronized *AstToken)  { my._synchronized = _synchronized }
func (my *SynchronizedStatement)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *SynchronizedStatement)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *SynchronizedStatement)      GetExpression() IExpression{ return my._Expression}
func (my *SynchronizedStatement)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *SynchronizedStatement)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *SynchronizedStatement)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *SynchronizedStatement)      GetBlock() *Block{ return my._Block}
func (my *SynchronizedStatement)      SetBlock( _Block *Block)  { my._Block = _Block }

func NewSynchronizedStatement(leftIToken IToken, rightIToken IToken ,
              _synchronized *AstToken,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken,
              _Block *Block)*SynchronizedStatement{
      my := new(SynchronizedStatement)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._synchronized = _synchronized;
        if nil != _synchronized{
        var trait_ interface{} = _synchronized
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SynchronizedStatement)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._synchronized{  list.Add(my._synchronized) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Block{  list.Add(my._Block) }
        return list
    }

func (my *SynchronizedStatement)      AcceptWithVisitor(v Visitor) { v.VisitSynchronizedStatement(my)}
func (my *SynchronizedStatement)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSynchronizedStatementWithArg(my, o) }
func (my *SynchronizedStatement)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSynchronizedStatementWithResult(my) }
func (my *SynchronizedStatement)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSynchronizedStatementWithResultArgument(my, o) }


func AnyCastToSynchronizedStatement(i interface{}) *SynchronizedStatement {
	if nil == i{
		return nil
	}else{
		return i.(*SynchronizedStatement)
	}
}
/**
 *<em>
*<li>Rule 328:  Catches ::= CatchClause
 *</em>
 *<p>
 *<b>
*<li>Rule 329:  Catches ::= Catches CatchClause
 *</b>
 */
type Catches struct{
    *Ast
      _Catches ICatches
      _CatchClause *CatchClause
}
func (my *Catches)      GetCatches() ICatches{ return my._Catches}
func (my *Catches)      SetCatches( _Catches ICatches)  { my._Catches = _Catches }
func (my *Catches)      GetCatchClause() *CatchClause{ return my._CatchClause}
func (my *Catches)      SetCatchClause( _CatchClause *CatchClause)  { my._CatchClause = _CatchClause }

func NewCatches(leftIToken IToken, rightIToken IToken ,
              _Catches ICatches,
              _CatchClause *CatchClause)*Catches{
      my := new(Catches)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Catches = _Catches;
        if nil != _Catches{
        var trait_ interface{} = _Catches
         trait_.(IAst).SetParent(my)
}
        my._CatchClause = _CatchClause;
        if nil != _CatchClause{
        var trait_ interface{} = _CatchClause
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Catches)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Catches{  list.Add(my._Catches) }
        if nil != my._CatchClause{  list.Add(my._CatchClause) }
        return list
    }

func (my *Catches)      AcceptWithVisitor(v Visitor) { v.VisitCatches(my)}
func (my *Catches)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitCatchesWithArg(my, o) }
func (my *Catches)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitCatchesWithResult(my) }
func (my *Catches)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitCatchesWithResultArgument(my, o) }


func AnyCastToCatches(i interface{}) *Catches {
	if nil == i{
		return nil
	}else{
		return i.(*Catches)
	}
}
/**
 *<b>
*<li>Rule 330:  CatchClause ::= catch ( FormalParameter ) Block
 *</b>
 */
type CatchClause struct{
    *Ast
      _catch *AstToken
      _LPAREN *AstToken
      _FormalParameter *FormalParameter
      _RPAREN *AstToken
      _Block *Block
}
func (my *CatchClause)      Getcatch() *AstToken{ return my._catch}
func (my *CatchClause)      Setcatch( _catch *AstToken)  { my._catch = _catch }
func (my *CatchClause)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *CatchClause)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *CatchClause)      GetFormalParameter() *FormalParameter{ return my._FormalParameter}
func (my *CatchClause)      SetFormalParameter( _FormalParameter *FormalParameter)  { my._FormalParameter = _FormalParameter }
func (my *CatchClause)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *CatchClause)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *CatchClause)      GetBlock() *Block{ return my._Block}
func (my *CatchClause)      SetBlock( _Block *Block)  { my._Block = _Block }

func NewCatchClause(leftIToken IToken, rightIToken IToken ,
              _catch *AstToken,
              _LPAREN *AstToken,
              _FormalParameter *FormalParameter,
              _RPAREN *AstToken,
              _Block *Block)*CatchClause{
      my := new(CatchClause)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._catch = _catch;
        if nil != _catch{
        var trait_ interface{} = _catch
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._FormalParameter = _FormalParameter;
        if nil != _FormalParameter{
        var trait_ interface{} = _FormalParameter
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *CatchClause)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._catch{  list.Add(my._catch) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._FormalParameter{  list.Add(my._FormalParameter) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._Block{  list.Add(my._Block) }
        return list
    }

func (my *CatchClause)      AcceptWithVisitor(v Visitor) { v.VisitCatchClause(my)}
func (my *CatchClause)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitCatchClauseWithArg(my, o) }
func (my *CatchClause)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitCatchClauseWithResult(my) }
func (my *CatchClause)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitCatchClauseWithResultArgument(my, o) }


func AnyCastToCatchClause(i interface{}) *CatchClause {
	if nil == i{
		return nil
	}else{
		return i.(*CatchClause)
	}
}
/**
 *<b>
*<li>Rule 331:  Finally ::= finally Block
 *</b>
 */
type Finally struct{
    *Ast
      _finally *AstToken
      _Block *Block
}
func (my *Finally)      Getfinally() *AstToken{ return my._finally}
func (my *Finally)      Setfinally( _finally *AstToken)  { my._finally = _finally }
func (my *Finally)      GetBlock() *Block{ return my._Block}
func (my *Finally)      SetBlock( _Block *Block)  { my._Block = _Block }

func NewFinally(leftIToken IToken, rightIToken IToken ,
              _finally *AstToken,
              _Block *Block)*Finally{
      my := new(Finally)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._finally = _finally;
        if nil != _finally{
        var trait_ interface{} = _finally
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Finally)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._finally{  list.Add(my._finally) }
        if nil != my._Block{  list.Add(my._Block) }
        return list
    }

func (my *Finally)      AcceptWithVisitor(v Visitor) { v.VisitFinally(my)}
func (my *Finally)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFinallyWithArg(my, o) }
func (my *Finally)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFinallyWithResult(my) }
func (my *Finally)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFinallyWithResultArgument(my, o) }


func AnyCastToFinally(i interface{}) *Finally {
	if nil == i{
		return nil
	}else{
		return i.(*Finally)
	}
}
/**
 *<em>
*<li>Rule 356:  ArgumentList ::= Expression
 *</em>
 *<p>
 *<b>
*<li>Rule 357:  ArgumentList ::= ArgumentList , Expression
 *</b>
 */
type ArgumentList struct{
    *Ast
      _ArgumentList IArgumentList
      _COMMA *AstToken
      _Expression IExpression
}
func (my *ArgumentList)      GetArgumentList() IArgumentList{ return my._ArgumentList}
func (my *ArgumentList)      SetArgumentList( _ArgumentList IArgumentList)  { my._ArgumentList = _ArgumentList }
func (my *ArgumentList)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ArgumentList)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ArgumentList)      GetExpression() IExpression{ return my._Expression}
func (my *ArgumentList)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }

func NewArgumentList(leftIToken IToken, rightIToken IToken ,
              _ArgumentList IArgumentList,
              _COMMA *AstToken,
              _Expression IExpression)*ArgumentList{
      my := new(ArgumentList)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ArgumentList = _ArgumentList;
        if nil != _ArgumentList{
        var trait_ interface{} = _ArgumentList
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArgumentList)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ArgumentList{  list.Add(my._ArgumentList) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._Expression{  list.Add(my._Expression) }
        return list
    }

func (my *ArgumentList)      AcceptWithVisitor(v Visitor) { v.VisitArgumentList(my)}
func (my *ArgumentList)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArgumentListWithArg(my, o) }
func (my *ArgumentList)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArgumentListWithResult(my) }
func (my *ArgumentList)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArgumentListWithResultArgument(my, o) }


func AnyCastToArgumentList(i interface{}) *ArgumentList {
	if nil == i{
		return nil
	}else{
		return i.(*ArgumentList)
	}
}
/**
 *<em>
*<li>Rule 362:  DimExprs ::= DimExpr
 *</em>
 *<p>
 *<b>
*<li>Rule 363:  DimExprs ::= DimExprs DimExpr
 *</b>
 */
type DimExprs struct{
    *Ast
      _DimExprs IDimExprs
      _DimExpr *DimExpr
}
func (my *DimExprs)      GetDimExprs() IDimExprs{ return my._DimExprs}
func (my *DimExprs)      SetDimExprs( _DimExprs IDimExprs)  { my._DimExprs = _DimExprs }
func (my *DimExprs)      GetDimExpr() *DimExpr{ return my._DimExpr}
func (my *DimExprs)      SetDimExpr( _DimExpr *DimExpr)  { my._DimExpr = _DimExpr }

func NewDimExprs(leftIToken IToken, rightIToken IToken ,
              _DimExprs IDimExprs,
              _DimExpr *DimExpr)*DimExprs{
      my := new(DimExprs)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._DimExprs = _DimExprs;
        if nil != _DimExprs{
        var trait_ interface{} = _DimExprs
         trait_.(IAst).SetParent(my)
}
        my._DimExpr = _DimExpr;
        if nil != _DimExpr{
        var trait_ interface{} = _DimExpr
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *DimExprs)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._DimExprs{  list.Add(my._DimExprs) }
        if nil != my._DimExpr{  list.Add(my._DimExpr) }
        return list
    }

func (my *DimExprs)      AcceptWithVisitor(v Visitor) { v.VisitDimExprs(my)}
func (my *DimExprs)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitDimExprsWithArg(my, o) }
func (my *DimExprs)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitDimExprsWithResult(my) }
func (my *DimExprs)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitDimExprsWithResultArgument(my, o) }


func AnyCastToDimExprs(i interface{}) *DimExprs {
	if nil == i{
		return nil
	}else{
		return i.(*DimExprs)
	}
}
/**
 *<b>
*<li>Rule 364:  DimExpr ::= [ Expression ]
 *</b>
 */
type DimExpr struct{
    *Ast
      _LBRACKET *AstToken
      _Expression IExpression
      _RBRACKET *AstToken
}
func (my *DimExpr)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *DimExpr)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *DimExpr)      GetExpression() IExpression{ return my._Expression}
func (my *DimExpr)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *DimExpr)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *DimExpr)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewDimExpr(leftIToken IToken, rightIToken IToken ,
              _LBRACKET *AstToken,
              _Expression IExpression,
              _RBRACKET *AstToken)*DimExpr{
      my := new(DimExpr)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *DimExpr)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *DimExpr)      AcceptWithVisitor(v Visitor) { v.VisitDimExpr(my)}
func (my *DimExpr)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitDimExprWithArg(my, o) }
func (my *DimExpr)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitDimExprWithResult(my) }
func (my *DimExpr)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitDimExprWithResultArgument(my, o) }


func AnyCastToDimExpr(i interface{}) *DimExpr {
	if nil == i{
		return nil
	}else{
		return i.(*DimExpr)
	}
}
/**
 *<b>
*<li>Rule 381:  PostIncrementExpression ::= PostfixExpression ++
 *</b>
 */
type PostIncrementExpression struct{
    *Ast
      _PostfixExpression IPostfixExpression
      _PLUS_PLUS *AstToken
}
func (my *PostIncrementExpression)      GetPostfixExpression() IPostfixExpression{ return my._PostfixExpression}
func (my *PostIncrementExpression)      SetPostfixExpression( _PostfixExpression IPostfixExpression)  { my._PostfixExpression = _PostfixExpression }
func (my *PostIncrementExpression)      GetPLUS_PLUS() *AstToken{ return my._PLUS_PLUS}
func (my *PostIncrementExpression)      SetPLUS_PLUS( _PLUS_PLUS *AstToken)  { my._PLUS_PLUS = _PLUS_PLUS }

func NewPostIncrementExpression(leftIToken IToken, rightIToken IToken ,
              _PostfixExpression IPostfixExpression,
              _PLUS_PLUS *AstToken)*PostIncrementExpression{
      my := new(PostIncrementExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PostfixExpression = _PostfixExpression;
        if nil != _PostfixExpression{
        var trait_ interface{} = _PostfixExpression
         trait_.(IAst).SetParent(my)
}
        my._PLUS_PLUS = _PLUS_PLUS;
        if nil != _PLUS_PLUS{
        var trait_ interface{} = _PLUS_PLUS
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PostIncrementExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PostfixExpression{  list.Add(my._PostfixExpression) }
        if nil != my._PLUS_PLUS{  list.Add(my._PLUS_PLUS) }
        return list
    }

func (my *PostIncrementExpression)      AcceptWithVisitor(v Visitor) { v.VisitPostIncrementExpression(my)}
func (my *PostIncrementExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPostIncrementExpressionWithArg(my, o) }
func (my *PostIncrementExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPostIncrementExpressionWithResult(my) }
func (my *PostIncrementExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPostIncrementExpressionWithResultArgument(my, o) }


func AnyCastToPostIncrementExpression(i interface{}) *PostIncrementExpression {
	if nil == i{
		return nil
	}else{
		return i.(*PostIncrementExpression)
	}
}
/**
 *<b>
*<li>Rule 382:  PostDecrementExpression ::= PostfixExpression --
 *</b>
 */
type PostDecrementExpression struct{
    *Ast
      _PostfixExpression IPostfixExpression
      _MINUS_MINUS *AstToken
}
func (my *PostDecrementExpression)      GetPostfixExpression() IPostfixExpression{ return my._PostfixExpression}
func (my *PostDecrementExpression)      SetPostfixExpression( _PostfixExpression IPostfixExpression)  { my._PostfixExpression = _PostfixExpression }
func (my *PostDecrementExpression)      GetMINUS_MINUS() *AstToken{ return my._MINUS_MINUS}
func (my *PostDecrementExpression)      SetMINUS_MINUS( _MINUS_MINUS *AstToken)  { my._MINUS_MINUS = _MINUS_MINUS }

func NewPostDecrementExpression(leftIToken IToken, rightIToken IToken ,
              _PostfixExpression IPostfixExpression,
              _MINUS_MINUS *AstToken)*PostDecrementExpression{
      my := new(PostDecrementExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PostfixExpression = _PostfixExpression;
        if nil != _PostfixExpression{
        var trait_ interface{} = _PostfixExpression
         trait_.(IAst).SetParent(my)
}
        my._MINUS_MINUS = _MINUS_MINUS;
        if nil != _MINUS_MINUS{
        var trait_ interface{} = _MINUS_MINUS
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PostDecrementExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PostfixExpression{  list.Add(my._PostfixExpression) }
        if nil != my._MINUS_MINUS{  list.Add(my._MINUS_MINUS) }
        return list
    }

func (my *PostDecrementExpression)      AcceptWithVisitor(v Visitor) { v.VisitPostDecrementExpression(my)}
func (my *PostDecrementExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPostDecrementExpressionWithArg(my, o) }
func (my *PostDecrementExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPostDecrementExpressionWithResult(my) }
func (my *PostDecrementExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPostDecrementExpressionWithResultArgument(my, o) }


func AnyCastToPostDecrementExpression(i interface{}) *PostDecrementExpression {
	if nil == i{
		return nil
	}else{
		return i.(*PostDecrementExpression)
	}
}
/**
 *<b>
*<li>Rule 388:  PreIncrementExpression ::= ++ UnaryExpression
 *</b>
 */
type PreIncrementExpression struct{
    *Ast
      _PLUS_PLUS *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *PreIncrementExpression)      GetPLUS_PLUS() *AstToken{ return my._PLUS_PLUS}
func (my *PreIncrementExpression)      SetPLUS_PLUS( _PLUS_PLUS *AstToken)  { my._PLUS_PLUS = _PLUS_PLUS }
func (my *PreIncrementExpression)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *PreIncrementExpression)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewPreIncrementExpression(leftIToken IToken, rightIToken IToken ,
              _PLUS_PLUS *AstToken,
              _UnaryExpression IUnaryExpression)*PreIncrementExpression{
      my := new(PreIncrementExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PLUS_PLUS = _PLUS_PLUS;
        if nil != _PLUS_PLUS{
        var trait_ interface{} = _PLUS_PLUS
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PreIncrementExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PLUS_PLUS{  list.Add(my._PLUS_PLUS) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *PreIncrementExpression)      AcceptWithVisitor(v Visitor) { v.VisitPreIncrementExpression(my)}
func (my *PreIncrementExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPreIncrementExpressionWithArg(my, o) }
func (my *PreIncrementExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPreIncrementExpressionWithResult(my) }
func (my *PreIncrementExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPreIncrementExpressionWithResultArgument(my, o) }


func AnyCastToPreIncrementExpression(i interface{}) *PreIncrementExpression {
	if nil == i{
		return nil
	}else{
		return i.(*PreIncrementExpression)
	}
}
/**
 *<b>
*<li>Rule 389:  PreDecrementExpression ::= -- UnaryExpression
 *</b>
 */
type PreDecrementExpression struct{
    *Ast
      _MINUS_MINUS *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *PreDecrementExpression)      GetMINUS_MINUS() *AstToken{ return my._MINUS_MINUS}
func (my *PreDecrementExpression)      SetMINUS_MINUS( _MINUS_MINUS *AstToken)  { my._MINUS_MINUS = _MINUS_MINUS }
func (my *PreDecrementExpression)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *PreDecrementExpression)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewPreDecrementExpression(leftIToken IToken, rightIToken IToken ,
              _MINUS_MINUS *AstToken,
              _UnaryExpression IUnaryExpression)*PreDecrementExpression{
      my := new(PreDecrementExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MINUS_MINUS = _MINUS_MINUS;
        if nil != _MINUS_MINUS{
        var trait_ interface{} = _MINUS_MINUS
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PreDecrementExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MINUS_MINUS{  list.Add(my._MINUS_MINUS) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *PreDecrementExpression)      AcceptWithVisitor(v Visitor) { v.VisitPreDecrementExpression(my)}
func (my *PreDecrementExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPreDecrementExpressionWithArg(my, o) }
func (my *PreDecrementExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPreDecrementExpressionWithResult(my) }
func (my *PreDecrementExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPreDecrementExpressionWithResultArgument(my, o) }


func AnyCastToPreDecrementExpression(i interface{}) *PreDecrementExpression {
	if nil == i{
		return nil
	}else{
		return i.(*PreDecrementExpression)
	}
}
/**
 *<em>
*<li>Rule 416:  AndExpression ::= EqualityExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 417:  AndExpression ::= AndExpression & EqualityExpression
 *</b>
 */
type AndExpression struct{
    *Ast
      _AndExpression IAndExpression
      _AND *AstToken
      _EqualityExpression IEqualityExpression
}
func (my *AndExpression)      GetAndExpression() IAndExpression{ return my._AndExpression}
func (my *AndExpression)      SetAndExpression( _AndExpression IAndExpression)  { my._AndExpression = _AndExpression }
func (my *AndExpression)      GetAND() *AstToken{ return my._AND}
func (my *AndExpression)      SetAND( _AND *AstToken)  { my._AND = _AND }
func (my *AndExpression)      GetEqualityExpression() IEqualityExpression{ return my._EqualityExpression}
func (my *AndExpression)      SetEqualityExpression( _EqualityExpression IEqualityExpression)  { my._EqualityExpression = _EqualityExpression }

func NewAndExpression(leftIToken IToken, rightIToken IToken ,
              _AndExpression IAndExpression,
              _AND *AstToken,
              _EqualityExpression IEqualityExpression)*AndExpression{
      my := new(AndExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AndExpression = _AndExpression;
        if nil != _AndExpression{
        var trait_ interface{} = _AndExpression
         trait_.(IAst).SetParent(my)
}
        my._AND = _AND;
        if nil != _AND{
        var trait_ interface{} = _AND
         trait_.(IAst).SetParent(my)
}
        my._EqualityExpression = _EqualityExpression;
        if nil != _EqualityExpression{
        var trait_ interface{} = _EqualityExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AndExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AndExpression{  list.Add(my._AndExpression) }
        if nil != my._AND{  list.Add(my._AND) }
        if nil != my._EqualityExpression{  list.Add(my._EqualityExpression) }
        return list
    }

func (my *AndExpression)      AcceptWithVisitor(v Visitor) { v.VisitAndExpression(my)}
func (my *AndExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAndExpressionWithArg(my, o) }
func (my *AndExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAndExpressionWithResult(my) }
func (my *AndExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAndExpressionWithResultArgument(my, o) }


func AnyCastToAndExpression(i interface{}) *AndExpression {
	if nil == i{
		return nil
	}else{
		return i.(*AndExpression)
	}
}
/**
 *<em>
*<li>Rule 418:  ExclusiveOrExpression ::= AndExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 419:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
 *</b>
 */
type ExclusiveOrExpression struct{
    *Ast
      _ExclusiveOrExpression IExclusiveOrExpression
      _XOR *AstToken
      _AndExpression IAndExpression
}
func (my *ExclusiveOrExpression)      GetExclusiveOrExpression() IExclusiveOrExpression{ return my._ExclusiveOrExpression}
func (my *ExclusiveOrExpression)      SetExclusiveOrExpression( _ExclusiveOrExpression IExclusiveOrExpression)  { my._ExclusiveOrExpression = _ExclusiveOrExpression }
func (my *ExclusiveOrExpression)      GetXOR() *AstToken{ return my._XOR}
func (my *ExclusiveOrExpression)      SetXOR( _XOR *AstToken)  { my._XOR = _XOR }
func (my *ExclusiveOrExpression)      GetAndExpression() IAndExpression{ return my._AndExpression}
func (my *ExclusiveOrExpression)      SetAndExpression( _AndExpression IAndExpression)  { my._AndExpression = _AndExpression }

func NewExclusiveOrExpression(leftIToken IToken, rightIToken IToken ,
              _ExclusiveOrExpression IExclusiveOrExpression,
              _XOR *AstToken,
              _AndExpression IAndExpression)*ExclusiveOrExpression{
      my := new(ExclusiveOrExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ExclusiveOrExpression = _ExclusiveOrExpression;
        if nil != _ExclusiveOrExpression{
        var trait_ interface{} = _ExclusiveOrExpression
         trait_.(IAst).SetParent(my)
}
        my._XOR = _XOR;
        if nil != _XOR{
        var trait_ interface{} = _XOR
         trait_.(IAst).SetParent(my)
}
        my._AndExpression = _AndExpression;
        if nil != _AndExpression{
        var trait_ interface{} = _AndExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExclusiveOrExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ExclusiveOrExpression{  list.Add(my._ExclusiveOrExpression) }
        if nil != my._XOR{  list.Add(my._XOR) }
        if nil != my._AndExpression{  list.Add(my._AndExpression) }
        return list
    }

func (my *ExclusiveOrExpression)      AcceptWithVisitor(v Visitor) { v.VisitExclusiveOrExpression(my)}
func (my *ExclusiveOrExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExclusiveOrExpressionWithArg(my, o) }
func (my *ExclusiveOrExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExclusiveOrExpressionWithResult(my) }
func (my *ExclusiveOrExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExclusiveOrExpressionWithResultArgument(my, o) }


func AnyCastToExclusiveOrExpression(i interface{}) *ExclusiveOrExpression {
	if nil == i{
		return nil
	}else{
		return i.(*ExclusiveOrExpression)
	}
}
/**
 *<em>
*<li>Rule 420:  InclusiveOrExpression ::= ExclusiveOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 421:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
 *</b>
 */
type InclusiveOrExpression struct{
    *Ast
      _InclusiveOrExpression IInclusiveOrExpression
      _OR *AstToken
      _ExclusiveOrExpression IExclusiveOrExpression
}
func (my *InclusiveOrExpression)      GetInclusiveOrExpression() IInclusiveOrExpression{ return my._InclusiveOrExpression}
func (my *InclusiveOrExpression)      SetInclusiveOrExpression( _InclusiveOrExpression IInclusiveOrExpression)  { my._InclusiveOrExpression = _InclusiveOrExpression }
func (my *InclusiveOrExpression)      GetOR() *AstToken{ return my._OR}
func (my *InclusiveOrExpression)      SetOR( _OR *AstToken)  { my._OR = _OR }
func (my *InclusiveOrExpression)      GetExclusiveOrExpression() IExclusiveOrExpression{ return my._ExclusiveOrExpression}
func (my *InclusiveOrExpression)      SetExclusiveOrExpression( _ExclusiveOrExpression IExclusiveOrExpression)  { my._ExclusiveOrExpression = _ExclusiveOrExpression }

func NewInclusiveOrExpression(leftIToken IToken, rightIToken IToken ,
              _InclusiveOrExpression IInclusiveOrExpression,
              _OR *AstToken,
              _ExclusiveOrExpression IExclusiveOrExpression)*InclusiveOrExpression{
      my := new(InclusiveOrExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._InclusiveOrExpression = _InclusiveOrExpression;
        if nil != _InclusiveOrExpression{
        var trait_ interface{} = _InclusiveOrExpression
         trait_.(IAst).SetParent(my)
}
        my._OR = _OR;
        if nil != _OR{
        var trait_ interface{} = _OR
         trait_.(IAst).SetParent(my)
}
        my._ExclusiveOrExpression = _ExclusiveOrExpression;
        if nil != _ExclusiveOrExpression{
        var trait_ interface{} = _ExclusiveOrExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *InclusiveOrExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._InclusiveOrExpression{  list.Add(my._InclusiveOrExpression) }
        if nil != my._OR{  list.Add(my._OR) }
        if nil != my._ExclusiveOrExpression{  list.Add(my._ExclusiveOrExpression) }
        return list
    }

func (my *InclusiveOrExpression)      AcceptWithVisitor(v Visitor) { v.VisitInclusiveOrExpression(my)}
func (my *InclusiveOrExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInclusiveOrExpressionWithArg(my, o) }
func (my *InclusiveOrExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInclusiveOrExpressionWithResult(my) }
func (my *InclusiveOrExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInclusiveOrExpressionWithResultArgument(my, o) }


func AnyCastToInclusiveOrExpression(i interface{}) *InclusiveOrExpression {
	if nil == i{
		return nil
	}else{
		return i.(*InclusiveOrExpression)
	}
}
/**
 *<em>
*<li>Rule 422:  ConditionalAndExpression ::= InclusiveOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 423:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
 *</b>
 */
type ConditionalAndExpression struct{
    *Ast
      _ConditionalAndExpression IConditionalAndExpression
      _AND_AND *AstToken
      _InclusiveOrExpression IInclusiveOrExpression
}
func (my *ConditionalAndExpression)      GetConditionalAndExpression() IConditionalAndExpression{ return my._ConditionalAndExpression}
func (my *ConditionalAndExpression)      SetConditionalAndExpression( _ConditionalAndExpression IConditionalAndExpression)  { my._ConditionalAndExpression = _ConditionalAndExpression }
func (my *ConditionalAndExpression)      GetAND_AND() *AstToken{ return my._AND_AND}
func (my *ConditionalAndExpression)      SetAND_AND( _AND_AND *AstToken)  { my._AND_AND = _AND_AND }
func (my *ConditionalAndExpression)      GetInclusiveOrExpression() IInclusiveOrExpression{ return my._InclusiveOrExpression}
func (my *ConditionalAndExpression)      SetInclusiveOrExpression( _InclusiveOrExpression IInclusiveOrExpression)  { my._InclusiveOrExpression = _InclusiveOrExpression }

func NewConditionalAndExpression(leftIToken IToken, rightIToken IToken ,
              _ConditionalAndExpression IConditionalAndExpression,
              _AND_AND *AstToken,
              _InclusiveOrExpression IInclusiveOrExpression)*ConditionalAndExpression{
      my := new(ConditionalAndExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConditionalAndExpression = _ConditionalAndExpression;
        if nil != _ConditionalAndExpression{
        var trait_ interface{} = _ConditionalAndExpression
         trait_.(IAst).SetParent(my)
}
        my._AND_AND = _AND_AND;
        if nil != _AND_AND{
        var trait_ interface{} = _AND_AND
         trait_.(IAst).SetParent(my)
}
        my._InclusiveOrExpression = _InclusiveOrExpression;
        if nil != _InclusiveOrExpression{
        var trait_ interface{} = _InclusiveOrExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConditionalAndExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConditionalAndExpression{  list.Add(my._ConditionalAndExpression) }
        if nil != my._AND_AND{  list.Add(my._AND_AND) }
        if nil != my._InclusiveOrExpression{  list.Add(my._InclusiveOrExpression) }
        return list
    }

func (my *ConditionalAndExpression)      AcceptWithVisitor(v Visitor) { v.VisitConditionalAndExpression(my)}
func (my *ConditionalAndExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConditionalAndExpressionWithArg(my, o) }
func (my *ConditionalAndExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConditionalAndExpressionWithResult(my) }
func (my *ConditionalAndExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConditionalAndExpressionWithResultArgument(my, o) }


func AnyCastToConditionalAndExpression(i interface{}) *ConditionalAndExpression {
	if nil == i{
		return nil
	}else{
		return i.(*ConditionalAndExpression)
	}
}
/**
 *<em>
*<li>Rule 424:  ConditionalOrExpression ::= ConditionalAndExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 425:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
 *</b>
 */
type ConditionalOrExpression struct{
    *Ast
      _ConditionalOrExpression IConditionalOrExpression
      _OR_OR *AstToken
      _ConditionalAndExpression IConditionalAndExpression
}
func (my *ConditionalOrExpression)      GetConditionalOrExpression() IConditionalOrExpression{ return my._ConditionalOrExpression}
func (my *ConditionalOrExpression)      SetConditionalOrExpression( _ConditionalOrExpression IConditionalOrExpression)  { my._ConditionalOrExpression = _ConditionalOrExpression }
func (my *ConditionalOrExpression)      GetOR_OR() *AstToken{ return my._OR_OR}
func (my *ConditionalOrExpression)      SetOR_OR( _OR_OR *AstToken)  { my._OR_OR = _OR_OR }
func (my *ConditionalOrExpression)      GetConditionalAndExpression() IConditionalAndExpression{ return my._ConditionalAndExpression}
func (my *ConditionalOrExpression)      SetConditionalAndExpression( _ConditionalAndExpression IConditionalAndExpression)  { my._ConditionalAndExpression = _ConditionalAndExpression }

func NewConditionalOrExpression(leftIToken IToken, rightIToken IToken ,
              _ConditionalOrExpression IConditionalOrExpression,
              _OR_OR *AstToken,
              _ConditionalAndExpression IConditionalAndExpression)*ConditionalOrExpression{
      my := new(ConditionalOrExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConditionalOrExpression = _ConditionalOrExpression;
        if nil != _ConditionalOrExpression{
        var trait_ interface{} = _ConditionalOrExpression
         trait_.(IAst).SetParent(my)
}
        my._OR_OR = _OR_OR;
        if nil != _OR_OR{
        var trait_ interface{} = _OR_OR
         trait_.(IAst).SetParent(my)
}
        my._ConditionalAndExpression = _ConditionalAndExpression;
        if nil != _ConditionalAndExpression{
        var trait_ interface{} = _ConditionalAndExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConditionalOrExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConditionalOrExpression{  list.Add(my._ConditionalOrExpression) }
        if nil != my._OR_OR{  list.Add(my._OR_OR) }
        if nil != my._ConditionalAndExpression{  list.Add(my._ConditionalAndExpression) }
        return list
    }

func (my *ConditionalOrExpression)      AcceptWithVisitor(v Visitor) { v.VisitConditionalOrExpression(my)}
func (my *ConditionalOrExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConditionalOrExpressionWithArg(my, o) }
func (my *ConditionalOrExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConditionalOrExpressionWithResult(my) }
func (my *ConditionalOrExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConditionalOrExpressionWithResultArgument(my, o) }


func AnyCastToConditionalOrExpression(i interface{}) *ConditionalOrExpression {
	if nil == i{
		return nil
	}else{
		return i.(*ConditionalOrExpression)
	}
}
/**
 *<em>
*<li>Rule 426:  ConditionalExpression ::= ConditionalOrExpression
 *</em>
 *<p>
 *<b>
*<li>Rule 427:  ConditionalExpression ::= ConditionalOrExpression ? Expression : ConditionalExpression
 *</b>
 */
type ConditionalExpression struct{
    *Ast
      _ConditionalOrExpression IConditionalOrExpression
      _QUESTION *AstToken
      _Expression IExpression
      _COLON *AstToken
      _ConditionalExpression IConditionalExpression
}
func (my *ConditionalExpression)      GetConditionalOrExpression() IConditionalOrExpression{ return my._ConditionalOrExpression}
func (my *ConditionalExpression)      SetConditionalOrExpression( _ConditionalOrExpression IConditionalOrExpression)  { my._ConditionalOrExpression = _ConditionalOrExpression }
func (my *ConditionalExpression)      GetQUESTION() *AstToken{ return my._QUESTION}
func (my *ConditionalExpression)      SetQUESTION( _QUESTION *AstToken)  { my._QUESTION = _QUESTION }
func (my *ConditionalExpression)      GetExpression() IExpression{ return my._Expression}
func (my *ConditionalExpression)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *ConditionalExpression)      GetCOLON() *AstToken{ return my._COLON}
func (my *ConditionalExpression)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *ConditionalExpression)      GetConditionalExpression() IConditionalExpression{ return my._ConditionalExpression}
func (my *ConditionalExpression)      SetConditionalExpression( _ConditionalExpression IConditionalExpression)  { my._ConditionalExpression = _ConditionalExpression }

func NewConditionalExpression(leftIToken IToken, rightIToken IToken ,
              _ConditionalOrExpression IConditionalOrExpression,
              _QUESTION *AstToken,
              _Expression IExpression,
              _COLON *AstToken,
              _ConditionalExpression IConditionalExpression)*ConditionalExpression{
      my := new(ConditionalExpression)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ConditionalOrExpression = _ConditionalOrExpression;
        if nil != _ConditionalOrExpression{
        var trait_ interface{} = _ConditionalOrExpression
         trait_.(IAst).SetParent(my)
}
        my._QUESTION = _QUESTION;
        if nil != _QUESTION{
        var trait_ interface{} = _QUESTION
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._ConditionalExpression = _ConditionalExpression;
        if nil != _ConditionalExpression{
        var trait_ interface{} = _ConditionalExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ConditionalExpression)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ConditionalOrExpression{  list.Add(my._ConditionalOrExpression) }
        if nil != my._QUESTION{  list.Add(my._QUESTION) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._ConditionalExpression{  list.Add(my._ConditionalExpression) }
        return list
    }

func (my *ConditionalExpression)      AcceptWithVisitor(v Visitor) { v.VisitConditionalExpression(my)}
func (my *ConditionalExpression)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConditionalExpressionWithArg(my, o) }
func (my *ConditionalExpression)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConditionalExpressionWithResult(my) }
func (my *ConditionalExpression)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConditionalExpressionWithResultArgument(my, o) }


func AnyCastToConditionalExpression(i interface{}) *ConditionalExpression {
	if nil == i{
		return nil
	}else{
		return i.(*ConditionalExpression)
	}
}
/**
 *<b>
*<li>Rule 430:  Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
 *</b>
 */
type Assignment struct{
    *Ast
      _LeftHandSide ILeftHandSide
      _AssignmentOperator IAssignmentOperator
      _AssignmentExpression IAssignmentExpression
}
func (my *Assignment)      GetLeftHandSide() ILeftHandSide{ return my._LeftHandSide}
func (my *Assignment)      SetLeftHandSide( _LeftHandSide ILeftHandSide)  { my._LeftHandSide = _LeftHandSide }
func (my *Assignment)      GetAssignmentOperator() IAssignmentOperator{ return my._AssignmentOperator}
func (my *Assignment)      SetAssignmentOperator( _AssignmentOperator IAssignmentOperator)  { my._AssignmentOperator = _AssignmentOperator }
func (my *Assignment)      GetAssignmentExpression() IAssignmentExpression{ return my._AssignmentExpression}
func (my *Assignment)      SetAssignmentExpression( _AssignmentExpression IAssignmentExpression)  { my._AssignmentExpression = _AssignmentExpression }

func NewAssignment(leftIToken IToken, rightIToken IToken ,
              _LeftHandSide ILeftHandSide,
              _AssignmentOperator IAssignmentOperator,
              _AssignmentExpression IAssignmentExpression)*Assignment{
      my := new(Assignment)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LeftHandSide = _LeftHandSide;
        if nil != _LeftHandSide{
        var trait_ interface{} = _LeftHandSide
         trait_.(IAst).SetParent(my)
}
        my._AssignmentOperator = _AssignmentOperator;
        if nil != _AssignmentOperator{
        var trait_ interface{} = _AssignmentOperator
         trait_.(IAst).SetParent(my)
}
        my._AssignmentExpression = _AssignmentExpression;
        if nil != _AssignmentExpression{
        var trait_ interface{} = _AssignmentExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Assignment)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LeftHandSide{  list.Add(my._LeftHandSide) }
        if nil != my._AssignmentOperator{  list.Add(my._AssignmentOperator) }
        if nil != my._AssignmentExpression{  list.Add(my._AssignmentExpression) }
        return list
    }

func (my *Assignment)      AcceptWithVisitor(v Visitor) { v.VisitAssignment(my)}
func (my *Assignment)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentWithArg(my, o) }
func (my *Assignment)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentWithResult(my) }
func (my *Assignment)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentWithResultArgument(my, o) }


func AnyCastToAssignment(i interface{}) *Assignment {
	if nil == i{
		return nil
	}else{
		return i.(*Assignment)
	}
}
/**
 *<em>
*<li>Rule 492:  ,opt ::= $Empty
 *</em>
 *<p>
 *<b>
*<li>Rule 493:  ,opt ::= ,
 *</b>
 */
type Commaopt struct{
    *AstToken
}
func (my *Commaopt)      GetCOMMA()IToken{ return my.leftIToken; }

func NewCommaopt(token IToken )*Commaopt{
      my := new(Commaopt)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Commaopt)      AcceptWithVisitor(v Visitor) { v.VisitCommaopt(my)}
func (my *Commaopt)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitCommaoptWithArg(my, o) }
func (my *Commaopt)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitCommaoptWithResult(my) }
func (my *Commaopt)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitCommaoptWithResultArgument(my, o) }


func AnyCastToCommaopt(i interface{}) *Commaopt {
	if nil == i{
		return nil
	}else{
		return i.(*Commaopt)
	}
}
/**
 *<em>
*<li>Rule 504:  ...opt ::= $Empty
 *</em>
 *<p>
 *<b>
*<li>Rule 505:  ...opt ::= ...
 *</b>
 */
type Ellipsisopt struct{
    *AstToken
}
func (my *Ellipsisopt)      GetELLIPSIS()IToken{ return my.leftIToken; }

func NewEllipsisopt(token IToken )*Ellipsisopt{
      my := new(Ellipsisopt)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Ellipsisopt)      AcceptWithVisitor(v Visitor) { v.VisitEllipsisopt(my)}
func (my *Ellipsisopt)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEllipsisoptWithArg(my, o) }
func (my *Ellipsisopt)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEllipsisoptWithResult(my) }
func (my *Ellipsisopt)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEllipsisoptWithResultArgument(my, o) }


func AnyCastToEllipsisopt(i interface{}) *Ellipsisopt {
	if nil == i{
		return nil
	}else{
		return i.(*Ellipsisopt)
	}
}
/**
 *<b>
*<li>Rule 5:  LPGUserAction ::= $BeginAction BlockStatementsopt $EndAction
 *</b>
 */
type LPGUserAction0 struct{
    *Ast
      _BeginAction *AstToken
      _BlockStatementsopt IBlockStatementsopt
      _EndAction *AstToken
}
func (my *LPGUserAction0)      GetBeginAction() *AstToken{ return my._BeginAction}
func (my *LPGUserAction0)      SetBeginAction( _BeginAction *AstToken)  { my._BeginAction = _BeginAction }
    /**
     * The value returned by <b>GetBlockStatementsopt</b> may be <b>null</b>
     */
func (my *LPGUserAction0)      GetBlockStatementsopt() IBlockStatementsopt{ return my._BlockStatementsopt}
func (my *LPGUserAction0)      SetBlockStatementsopt( _BlockStatementsopt IBlockStatementsopt)  { my._BlockStatementsopt = _BlockStatementsopt }
func (my *LPGUserAction0)      GetEndAction() *AstToken{ return my._EndAction}
func (my *LPGUserAction0)      SetEndAction( _EndAction *AstToken)  { my._EndAction = _EndAction }

func NewLPGUserAction0(leftIToken IToken, rightIToken IToken ,
              _BeginAction *AstToken,
              _BlockStatementsopt IBlockStatementsopt,
              _EndAction *AstToken)*LPGUserAction0{
      my := new(LPGUserAction0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._BeginAction = _BeginAction;
        if nil != _BeginAction{
        var trait_ interface{} = _BeginAction
         trait_.(IAst).SetParent(my)
}
        my._BlockStatementsopt = _BlockStatementsopt;
        if nil != _BlockStatementsopt{
        var trait_ interface{} = _BlockStatementsopt
         trait_.(IAst).SetParent(my)
}
        my._EndAction = _EndAction;
        if nil != _EndAction{
        var trait_ interface{} = _EndAction
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LPGUserAction0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._BeginAction{  list.Add(my._BeginAction) }
        if nil != my._BlockStatementsopt{  list.Add(my._BlockStatementsopt) }
        if nil != my._EndAction{  list.Add(my._EndAction) }
        return list
    }

func (my *LPGUserAction0)      AcceptWithVisitor(v Visitor) { v.VisitLPGUserAction0(my)}
func (my *LPGUserAction0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLPGUserAction0WithArg(my, o) }
func (my *LPGUserAction0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLPGUserAction0WithResult(my) }
func (my *LPGUserAction0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLPGUserAction0WithResultArgument(my, o) }


func AnyCastToLPGUserAction0(i interface{}) *LPGUserAction0 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction0)
	}
}
/**
 *<b>
*<li>Rule 6:  LPGUserAction ::= $BeginJava BlockStatementsopt $EndJava
 *</b>
 */
type LPGUserAction1 struct{
    *Ast
      _BeginJava *AstToken
      _BlockStatementsopt IBlockStatementsopt
      _EndJava *AstToken
}
func (my *LPGUserAction1)      GetBeginJava() *AstToken{ return my._BeginJava}
func (my *LPGUserAction1)      SetBeginJava( _BeginJava *AstToken)  { my._BeginJava = _BeginJava }
    /**
     * The value returned by <b>GetBlockStatementsopt</b> may be <b>null</b>
     */
func (my *LPGUserAction1)      GetBlockStatementsopt() IBlockStatementsopt{ return my._BlockStatementsopt}
func (my *LPGUserAction1)      SetBlockStatementsopt( _BlockStatementsopt IBlockStatementsopt)  { my._BlockStatementsopt = _BlockStatementsopt }
func (my *LPGUserAction1)      GetEndJava() *AstToken{ return my._EndJava}
func (my *LPGUserAction1)      SetEndJava( _EndJava *AstToken)  { my._EndJava = _EndJava }

func NewLPGUserAction1(leftIToken IToken, rightIToken IToken ,
              _BeginJava *AstToken,
              _BlockStatementsopt IBlockStatementsopt,
              _EndJava *AstToken)*LPGUserAction1{
      my := new(LPGUserAction1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._BeginJava = _BeginJava;
        if nil != _BeginJava{
        var trait_ interface{} = _BeginJava
         trait_.(IAst).SetParent(my)
}
        my._BlockStatementsopt = _BlockStatementsopt;
        if nil != _BlockStatementsopt{
        var trait_ interface{} = _BlockStatementsopt
         trait_.(IAst).SetParent(my)
}
        my._EndJava = _EndJava;
        if nil != _EndJava{
        var trait_ interface{} = _EndJava
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *LPGUserAction1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._BeginJava{  list.Add(my._BeginJava) }
        if nil != my._BlockStatementsopt{  list.Add(my._BlockStatementsopt) }
        if nil != my._EndJava{  list.Add(my._EndJava) }
        return list
    }

func (my *LPGUserAction1)      AcceptWithVisitor(v Visitor) { v.VisitLPGUserAction1(my)}
func (my *LPGUserAction1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLPGUserAction1WithArg(my, o) }
func (my *LPGUserAction1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLPGUserAction1WithResult(my) }
func (my *LPGUserAction1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLPGUserAction1WithResultArgument(my, o) }


func AnyCastToLPGUserAction1(i interface{}) *LPGUserAction1 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction1)
	}
}
/**
 *<b>
*<li>Rule 7:  LPGUserAction ::= $NoAction
 *</b>
 */
type LPGUserAction2 struct{
    *AstToken
}
func (my *LPGUserAction2)      GetNoAction()IToken{ return my.leftIToken; }

func NewLPGUserAction2(token IToken )*LPGUserAction2{
      my := new(LPGUserAction2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *LPGUserAction2)      AcceptWithVisitor(v Visitor) { v.VisitLPGUserAction2(my)}
func (my *LPGUserAction2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLPGUserAction2WithArg(my, o) }
func (my *LPGUserAction2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLPGUserAction2WithResult(my) }
func (my *LPGUserAction2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLPGUserAction2WithResultArgument(my, o) }


func AnyCastToLPGUserAction2(i interface{}) *LPGUserAction2 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction2)
	}
}
/**
 *<b>
*<li>Rule 8:  LPGUserAction ::= $NullAction
 *</b>
 */
type LPGUserAction3 struct{
    *AstToken
}
func (my *LPGUserAction3)      GetNullAction()IToken{ return my.leftIToken; }

func NewLPGUserAction3(token IToken )*LPGUserAction3{
      my := new(LPGUserAction3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *LPGUserAction3)      AcceptWithVisitor(v Visitor) { v.VisitLPGUserAction3(my)}
func (my *LPGUserAction3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLPGUserAction3WithArg(my, o) }
func (my *LPGUserAction3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLPGUserAction3WithResult(my) }
func (my *LPGUserAction3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLPGUserAction3WithResultArgument(my, o) }


func AnyCastToLPGUserAction3(i interface{}) *LPGUserAction3 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction3)
	}
}
/**
 *<b>
*<li>Rule 9:  LPGUserAction ::= $BadAction
 *</b>
 */
type LPGUserAction4 struct{
    *AstToken
}
func (my *LPGUserAction4)      GetBadAction()IToken{ return my.leftIToken; }

func NewLPGUserAction4(token IToken )*LPGUserAction4{
      my := new(LPGUserAction4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *LPGUserAction4)      AcceptWithVisitor(v Visitor) { v.VisitLPGUserAction4(my)}
func (my *LPGUserAction4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLPGUserAction4WithArg(my, o) }
func (my *LPGUserAction4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLPGUserAction4WithResult(my) }
func (my *LPGUserAction4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLPGUserAction4WithResultArgument(my, o) }


func AnyCastToLPGUserAction4(i interface{}) *LPGUserAction4 {
	if nil == i{
		return nil
	}else{
		return i.(*LPGUserAction4)
	}
}
/**
 *<b>
*<li>Rule 16:  IntegralType ::= byte
 *</b>
 */
type IntegralType0 struct{
    *AstToken
}
func (my *IntegralType0)      Getbyte()IToken{ return my.leftIToken; }

func NewIntegralType0(token IToken )*IntegralType0{
      my := new(IntegralType0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType0)      AcceptWithVisitor(v Visitor) { v.VisitIntegralType0(my)}
func (my *IntegralType0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitIntegralType0WithArg(my, o) }
func (my *IntegralType0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitIntegralType0WithResult(my) }
func (my *IntegralType0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitIntegralType0WithResultArgument(my, o) }


func AnyCastToIntegralType0(i interface{}) *IntegralType0 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType0)
	}
}
/**
 *<b>
*<li>Rule 17:  IntegralType ::= short
 *</b>
 */
type IntegralType1 struct{
    *AstToken
}
func (my *IntegralType1)      Getshort()IToken{ return my.leftIToken; }

func NewIntegralType1(token IToken )*IntegralType1{
      my := new(IntegralType1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType1)      AcceptWithVisitor(v Visitor) { v.VisitIntegralType1(my)}
func (my *IntegralType1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitIntegralType1WithArg(my, o) }
func (my *IntegralType1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitIntegralType1WithResult(my) }
func (my *IntegralType1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitIntegralType1WithResultArgument(my, o) }


func AnyCastToIntegralType1(i interface{}) *IntegralType1 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType1)
	}
}
/**
 *<b>
*<li>Rule 18:  IntegralType ::= int
 *</b>
 */
type IntegralType2 struct{
    *AstToken
}
func (my *IntegralType2)      Getint()IToken{ return my.leftIToken; }

func NewIntegralType2(token IToken )*IntegralType2{
      my := new(IntegralType2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType2)      AcceptWithVisitor(v Visitor) { v.VisitIntegralType2(my)}
func (my *IntegralType2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitIntegralType2WithArg(my, o) }
func (my *IntegralType2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitIntegralType2WithResult(my) }
func (my *IntegralType2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitIntegralType2WithResultArgument(my, o) }


func AnyCastToIntegralType2(i interface{}) *IntegralType2 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType2)
	}
}
/**
 *<b>
*<li>Rule 19:  IntegralType ::= long
 *</b>
 */
type IntegralType3 struct{
    *AstToken
}
func (my *IntegralType3)      Getlong()IToken{ return my.leftIToken; }

func NewIntegralType3(token IToken )*IntegralType3{
      my := new(IntegralType3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType3)      AcceptWithVisitor(v Visitor) { v.VisitIntegralType3(my)}
func (my *IntegralType3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitIntegralType3WithArg(my, o) }
func (my *IntegralType3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitIntegralType3WithResult(my) }
func (my *IntegralType3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitIntegralType3WithResultArgument(my, o) }


func AnyCastToIntegralType3(i interface{}) *IntegralType3 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType3)
	}
}
/**
 *<b>
*<li>Rule 20:  IntegralType ::= char
 *</b>
 */
type IntegralType4 struct{
    *AstToken
}
func (my *IntegralType4)      Getchar()IToken{ return my.leftIToken; }

func NewIntegralType4(token IToken )*IntegralType4{
      my := new(IntegralType4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *IntegralType4)      AcceptWithVisitor(v Visitor) { v.VisitIntegralType4(my)}
func (my *IntegralType4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitIntegralType4WithArg(my, o) }
func (my *IntegralType4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitIntegralType4WithResult(my) }
func (my *IntegralType4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitIntegralType4WithResultArgument(my, o) }


func AnyCastToIntegralType4(i interface{}) *IntegralType4 {
	if nil == i{
		return nil
	}else{
		return i.(*IntegralType4)
	}
}
/**
 *<b>
*<li>Rule 21:  FloatingPointType ::= float
 *</b>
 */
type FloatingPointType0 struct{
    *AstToken
}
func (my *FloatingPointType0)      Getfloat()IToken{ return my.leftIToken; }

func NewFloatingPointType0(token IToken )*FloatingPointType0{
      my := new(FloatingPointType0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FloatingPointType0)      AcceptWithVisitor(v Visitor) { v.VisitFloatingPointType0(my)}
func (my *FloatingPointType0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFloatingPointType0WithArg(my, o) }
func (my *FloatingPointType0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFloatingPointType0WithResult(my) }
func (my *FloatingPointType0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFloatingPointType0WithResultArgument(my, o) }


func AnyCastToFloatingPointType0(i interface{}) *FloatingPointType0 {
	if nil == i{
		return nil
	}else{
		return i.(*FloatingPointType0)
	}
}
/**
 *<b>
*<li>Rule 22:  FloatingPointType ::= double
 *</b>
 */
type FloatingPointType1 struct{
    *AstToken
}
func (my *FloatingPointType1)      Getdouble()IToken{ return my.leftIToken; }

func NewFloatingPointType1(token IToken )*FloatingPointType1{
      my := new(FloatingPointType1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FloatingPointType1)      AcceptWithVisitor(v Visitor) { v.VisitFloatingPointType1(my)}
func (my *FloatingPointType1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFloatingPointType1WithArg(my, o) }
func (my *FloatingPointType1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFloatingPointType1WithResult(my) }
func (my *FloatingPointType1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFloatingPointType1WithResultArgument(my, o) }


func AnyCastToFloatingPointType1(i interface{}) *FloatingPointType1 {
	if nil == i{
		return nil
	}else{
		return i.(*FloatingPointType1)
	}
}
/**
 *<b>
*<li>Rule 45:  WildcardBounds ::= extends ReferenceType
 *</b>
 */
type WildcardBounds0 struct{
    *Ast
      _extends *AstToken
      _ReferenceType IReferenceType
}
func (my *WildcardBounds0)      Getextends() *AstToken{ return my._extends}
func (my *WildcardBounds0)      Setextends( _extends *AstToken)  { my._extends = _extends }
func (my *WildcardBounds0)      GetReferenceType() IReferenceType{ return my._ReferenceType}
func (my *WildcardBounds0)      SetReferenceType( _ReferenceType IReferenceType)  { my._ReferenceType = _ReferenceType }

func NewWildcardBounds0(leftIToken IToken, rightIToken IToken ,
              _extends *AstToken,
              _ReferenceType IReferenceType)*WildcardBounds0{
      my := new(WildcardBounds0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._extends = _extends;
        if nil != _extends{
        var trait_ interface{} = _extends
         trait_.(IAst).SetParent(my)
}
        my._ReferenceType = _ReferenceType;
        if nil != _ReferenceType{
        var trait_ interface{} = _ReferenceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *WildcardBounds0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._extends{  list.Add(my._extends) }
        if nil != my._ReferenceType{  list.Add(my._ReferenceType) }
        return list
    }

func (my *WildcardBounds0)      AcceptWithVisitor(v Visitor) { v.VisitWildcardBounds0(my)}
func (my *WildcardBounds0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitWildcardBounds0WithArg(my, o) }
func (my *WildcardBounds0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitWildcardBounds0WithResult(my) }
func (my *WildcardBounds0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitWildcardBounds0WithResultArgument(my, o) }


func AnyCastToWildcardBounds0(i interface{}) *WildcardBounds0 {
	if nil == i{
		return nil
	}else{
		return i.(*WildcardBounds0)
	}
}
/**
 *<b>
*<li>Rule 46:  WildcardBounds ::= super ReferenceType
 *</b>
 */
type WildcardBounds1 struct{
    *Ast
      _super *AstToken
      _ReferenceType IReferenceType
}
func (my *WildcardBounds1)      Getsuper() *AstToken{ return my._super}
func (my *WildcardBounds1)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *WildcardBounds1)      GetReferenceType() IReferenceType{ return my._ReferenceType}
func (my *WildcardBounds1)      SetReferenceType( _ReferenceType IReferenceType)  { my._ReferenceType = _ReferenceType }

func NewWildcardBounds1(leftIToken IToken, rightIToken IToken ,
              _super *AstToken,
              _ReferenceType IReferenceType)*WildcardBounds1{
      my := new(WildcardBounds1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._ReferenceType = _ReferenceType;
        if nil != _ReferenceType{
        var trait_ interface{} = _ReferenceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *WildcardBounds1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._super{  list.Add(my._super) }
        if nil != my._ReferenceType{  list.Add(my._ReferenceType) }
        return list
    }

func (my *WildcardBounds1)      AcceptWithVisitor(v Visitor) { v.VisitWildcardBounds1(my)}
func (my *WildcardBounds1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitWildcardBounds1WithArg(my, o) }
func (my *WildcardBounds1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitWildcardBounds1WithResult(my) }
func (my *WildcardBounds1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitWildcardBounds1WithResultArgument(my, o) }


func AnyCastToWildcardBounds1(i interface{}) *WildcardBounds1 {
	if nil == i{
		return nil
	}else{
		return i.(*WildcardBounds1)
	}
}
/**
 *<b>
*<li>Rule 80:  ClassModifier ::= public
 *</b>
 */
type ClassModifier0 struct{
    *AstToken
}
func (my *ClassModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewClassModifier0(token IToken )*ClassModifier0{
      my := new(ClassModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier0)      AcceptWithVisitor(v Visitor) { v.VisitClassModifier0(my)}
func (my *ClassModifier0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassModifier0WithArg(my, o) }
func (my *ClassModifier0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassModifier0WithResult(my) }
func (my *ClassModifier0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassModifier0WithResultArgument(my, o) }


func AnyCastToClassModifier0(i interface{}) *ClassModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier0)
	}
}
/**
 *<b>
*<li>Rule 81:  ClassModifier ::= protected
 *</b>
 */
type ClassModifier1 struct{
    *AstToken
}
func (my *ClassModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewClassModifier1(token IToken )*ClassModifier1{
      my := new(ClassModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier1)      AcceptWithVisitor(v Visitor) { v.VisitClassModifier1(my)}
func (my *ClassModifier1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassModifier1WithArg(my, o) }
func (my *ClassModifier1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassModifier1WithResult(my) }
func (my *ClassModifier1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassModifier1WithResultArgument(my, o) }


func AnyCastToClassModifier1(i interface{}) *ClassModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier1)
	}
}
/**
 *<b>
*<li>Rule 82:  ClassModifier ::= private
 *</b>
 */
type ClassModifier2 struct{
    *AstToken
}
func (my *ClassModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewClassModifier2(token IToken )*ClassModifier2{
      my := new(ClassModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier2)      AcceptWithVisitor(v Visitor) { v.VisitClassModifier2(my)}
func (my *ClassModifier2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassModifier2WithArg(my, o) }
func (my *ClassModifier2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassModifier2WithResult(my) }
func (my *ClassModifier2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassModifier2WithResultArgument(my, o) }


func AnyCastToClassModifier2(i interface{}) *ClassModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier2)
	}
}
/**
 *<b>
*<li>Rule 83:  ClassModifier ::= abstract
 *</b>
 */
type ClassModifier3 struct{
    *AstToken
}
func (my *ClassModifier3)      Getabstract()IToken{ return my.leftIToken; }

func NewClassModifier3(token IToken )*ClassModifier3{
      my := new(ClassModifier3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier3)      AcceptWithVisitor(v Visitor) { v.VisitClassModifier3(my)}
func (my *ClassModifier3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassModifier3WithArg(my, o) }
func (my *ClassModifier3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassModifier3WithResult(my) }
func (my *ClassModifier3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassModifier3WithResultArgument(my, o) }


func AnyCastToClassModifier3(i interface{}) *ClassModifier3 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier3)
	}
}
/**
 *<b>
*<li>Rule 84:  ClassModifier ::= static
 *</b>
 */
type ClassModifier4 struct{
    *AstToken
}
func (my *ClassModifier4)      Getstatic()IToken{ return my.leftIToken; }

func NewClassModifier4(token IToken )*ClassModifier4{
      my := new(ClassModifier4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier4)      AcceptWithVisitor(v Visitor) { v.VisitClassModifier4(my)}
func (my *ClassModifier4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassModifier4WithArg(my, o) }
func (my *ClassModifier4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassModifier4WithResult(my) }
func (my *ClassModifier4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassModifier4WithResultArgument(my, o) }


func AnyCastToClassModifier4(i interface{}) *ClassModifier4 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier4)
	}
}
/**
 *<b>
*<li>Rule 85:  ClassModifier ::= final
 *</b>
 */
type ClassModifier5 struct{
    *AstToken
}
func (my *ClassModifier5)      Getfinal()IToken{ return my.leftIToken; }

func NewClassModifier5(token IToken )*ClassModifier5{
      my := new(ClassModifier5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier5)      AcceptWithVisitor(v Visitor) { v.VisitClassModifier5(my)}
func (my *ClassModifier5)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassModifier5WithArg(my, o) }
func (my *ClassModifier5)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassModifier5WithResult(my) }
func (my *ClassModifier5)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassModifier5WithResultArgument(my, o) }


func AnyCastToClassModifier5(i interface{}) *ClassModifier5 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier5)
	}
}
/**
 *<b>
*<li>Rule 86:  ClassModifier ::= strictfp
 *</b>
 */
type ClassModifier6 struct{
    *AstToken
}
func (my *ClassModifier6)      Getstrictfp()IToken{ return my.leftIToken; }

func NewClassModifier6(token IToken )*ClassModifier6{
      my := new(ClassModifier6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ClassModifier6)      AcceptWithVisitor(v Visitor) { v.VisitClassModifier6(my)}
func (my *ClassModifier6)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassModifier6WithArg(my, o) }
func (my *ClassModifier6)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassModifier6WithResult(my) }
func (my *ClassModifier6)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassModifier6WithResultArgument(my, o) }


func AnyCastToClassModifier6(i interface{}) *ClassModifier6 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassModifier6)
	}
}
/**
 *<b>
*<li>Rule 118:  FieldModifier ::= public
 *</b>
 */
type FieldModifier0 struct{
    *AstToken
}
func (my *FieldModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewFieldModifier0(token IToken )*FieldModifier0{
      my := new(FieldModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier0)      AcceptWithVisitor(v Visitor) { v.VisitFieldModifier0(my)}
func (my *FieldModifier0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldModifier0WithArg(my, o) }
func (my *FieldModifier0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldModifier0WithResult(my) }
func (my *FieldModifier0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldModifier0WithResultArgument(my, o) }


func AnyCastToFieldModifier0(i interface{}) *FieldModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier0)
	}
}
/**
 *<b>
*<li>Rule 119:  FieldModifier ::= protected
 *</b>
 */
type FieldModifier1 struct{
    *AstToken
}
func (my *FieldModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewFieldModifier1(token IToken )*FieldModifier1{
      my := new(FieldModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier1)      AcceptWithVisitor(v Visitor) { v.VisitFieldModifier1(my)}
func (my *FieldModifier1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldModifier1WithArg(my, o) }
func (my *FieldModifier1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldModifier1WithResult(my) }
func (my *FieldModifier1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldModifier1WithResultArgument(my, o) }


func AnyCastToFieldModifier1(i interface{}) *FieldModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier1)
	}
}
/**
 *<b>
*<li>Rule 120:  FieldModifier ::= private
 *</b>
 */
type FieldModifier2 struct{
    *AstToken
}
func (my *FieldModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewFieldModifier2(token IToken )*FieldModifier2{
      my := new(FieldModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier2)      AcceptWithVisitor(v Visitor) { v.VisitFieldModifier2(my)}
func (my *FieldModifier2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldModifier2WithArg(my, o) }
func (my *FieldModifier2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldModifier2WithResult(my) }
func (my *FieldModifier2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldModifier2WithResultArgument(my, o) }


func AnyCastToFieldModifier2(i interface{}) *FieldModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier2)
	}
}
/**
 *<b>
*<li>Rule 121:  FieldModifier ::= static
 *</b>
 */
type FieldModifier3 struct{
    *AstToken
}
func (my *FieldModifier3)      Getstatic()IToken{ return my.leftIToken; }

func NewFieldModifier3(token IToken )*FieldModifier3{
      my := new(FieldModifier3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier3)      AcceptWithVisitor(v Visitor) { v.VisitFieldModifier3(my)}
func (my *FieldModifier3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldModifier3WithArg(my, o) }
func (my *FieldModifier3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldModifier3WithResult(my) }
func (my *FieldModifier3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldModifier3WithResultArgument(my, o) }


func AnyCastToFieldModifier3(i interface{}) *FieldModifier3 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier3)
	}
}
/**
 *<b>
*<li>Rule 122:  FieldModifier ::= final
 *</b>
 */
type FieldModifier4 struct{
    *AstToken
}
func (my *FieldModifier4)      Getfinal()IToken{ return my.leftIToken; }

func NewFieldModifier4(token IToken )*FieldModifier4{
      my := new(FieldModifier4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier4)      AcceptWithVisitor(v Visitor) { v.VisitFieldModifier4(my)}
func (my *FieldModifier4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldModifier4WithArg(my, o) }
func (my *FieldModifier4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldModifier4WithResult(my) }
func (my *FieldModifier4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldModifier4WithResultArgument(my, o) }


func AnyCastToFieldModifier4(i interface{}) *FieldModifier4 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier4)
	}
}
/**
 *<b>
*<li>Rule 123:  FieldModifier ::= transient
 *</b>
 */
type FieldModifier5 struct{
    *AstToken
}
func (my *FieldModifier5)      Gettransient()IToken{ return my.leftIToken; }

func NewFieldModifier5(token IToken )*FieldModifier5{
      my := new(FieldModifier5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier5)      AcceptWithVisitor(v Visitor) { v.VisitFieldModifier5(my)}
func (my *FieldModifier5)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldModifier5WithArg(my, o) }
func (my *FieldModifier5)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldModifier5WithResult(my) }
func (my *FieldModifier5)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldModifier5WithResultArgument(my, o) }


func AnyCastToFieldModifier5(i interface{}) *FieldModifier5 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier5)
	}
}
/**
 *<b>
*<li>Rule 124:  FieldModifier ::= volatile
 *</b>
 */
type FieldModifier6 struct{
    *AstToken
}
func (my *FieldModifier6)      Getvolatile()IToken{ return my.leftIToken; }

func NewFieldModifier6(token IToken )*FieldModifier6{
      my := new(FieldModifier6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *FieldModifier6)      AcceptWithVisitor(v Visitor) { v.VisitFieldModifier6(my)}
func (my *FieldModifier6)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldModifier6WithArg(my, o) }
func (my *FieldModifier6)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldModifier6WithResult(my) }
func (my *FieldModifier6)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldModifier6WithResultArgument(my, o) }


func AnyCastToFieldModifier6(i interface{}) *FieldModifier6 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldModifier6)
	}
}
/**
 *<b>
*<li>Rule 129:  MethodDeclarator ::= identifier ( FormalParameterListopt )
 *</b>
 */
type MethodDeclarator0 struct{
    *Ast
      _identifier *identifier
      _LPAREN *AstToken
      _FormalParameterListopt IFormalParameterListopt
      _RPAREN *AstToken
}
func (my *MethodDeclarator0)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodDeclarator0)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodDeclarator0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodDeclarator0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetFormalParameterListopt</b> may be <b>null</b>
     */
func (my *MethodDeclarator0)      GetFormalParameterListopt() IFormalParameterListopt{ return my._FormalParameterListopt}
func (my *MethodDeclarator0)      SetFormalParameterListopt( _FormalParameterListopt IFormalParameterListopt)  { my._FormalParameterListopt = _FormalParameterListopt }
func (my *MethodDeclarator0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodDeclarator0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodDeclarator0(leftIToken IToken, rightIToken IToken ,
              _identifier *identifier,
              _LPAREN *AstToken,
              _FormalParameterListopt IFormalParameterListopt,
              _RPAREN *AstToken)*MethodDeclarator0{
      my := new(MethodDeclarator0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._FormalParameterListopt = _FormalParameterListopt;
        if nil != _FormalParameterListopt{
        var trait_ interface{} = _FormalParameterListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodDeclarator0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._FormalParameterListopt{  list.Add(my._FormalParameterListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodDeclarator0)      AcceptWithVisitor(v Visitor) { v.VisitMethodDeclarator0(my)}
func (my *MethodDeclarator0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodDeclarator0WithArg(my, o) }
func (my *MethodDeclarator0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodDeclarator0WithResult(my) }
func (my *MethodDeclarator0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodDeclarator0WithResultArgument(my, o) }


func AnyCastToMethodDeclarator0(i interface{}) *MethodDeclarator0 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodDeclarator0)
	}
}
/**
 *<b>
*<li>Rule 130:  MethodDeclarator ::= MethodDeclarator [ ]
 *</b>
 */
type MethodDeclarator1 struct{
    *Ast
      _MethodDeclarator IMethodDeclarator
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *MethodDeclarator1)      GetMethodDeclarator() IMethodDeclarator{ return my._MethodDeclarator}
func (my *MethodDeclarator1)      SetMethodDeclarator( _MethodDeclarator IMethodDeclarator)  { my._MethodDeclarator = _MethodDeclarator }
func (my *MethodDeclarator1)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *MethodDeclarator1)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *MethodDeclarator1)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *MethodDeclarator1)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewMethodDeclarator1(leftIToken IToken, rightIToken IToken ,
              _MethodDeclarator IMethodDeclarator,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*MethodDeclarator1{
      my := new(MethodDeclarator1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodDeclarator = _MethodDeclarator;
        if nil != _MethodDeclarator{
        var trait_ interface{} = _MethodDeclarator
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodDeclarator1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodDeclarator{  list.Add(my._MethodDeclarator) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *MethodDeclarator1)      AcceptWithVisitor(v Visitor) { v.VisitMethodDeclarator1(my)}
func (my *MethodDeclarator1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodDeclarator1WithArg(my, o) }
func (my *MethodDeclarator1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodDeclarator1WithResult(my) }
func (my *MethodDeclarator1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodDeclarator1WithResultArgument(my, o) }


func AnyCastToMethodDeclarator1(i interface{}) *MethodDeclarator1 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodDeclarator1)
	}
}
/**
 *<b>
*<li>Rule 144:  MethodModifier ::= public
 *</b>
 */
type MethodModifier0 struct{
    *AstToken
}
func (my *MethodModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewMethodModifier0(token IToken )*MethodModifier0{
      my := new(MethodModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier0)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier0(my)}
func (my *MethodModifier0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier0WithArg(my, o) }
func (my *MethodModifier0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier0WithResult(my) }
func (my *MethodModifier0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier0WithResultArgument(my, o) }


func AnyCastToMethodModifier0(i interface{}) *MethodModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier0)
	}
}
/**
 *<b>
*<li>Rule 145:  MethodModifier ::= protected
 *</b>
 */
type MethodModifier1 struct{
    *AstToken
}
func (my *MethodModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewMethodModifier1(token IToken )*MethodModifier1{
      my := new(MethodModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier1)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier1(my)}
func (my *MethodModifier1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier1WithArg(my, o) }
func (my *MethodModifier1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier1WithResult(my) }
func (my *MethodModifier1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier1WithResultArgument(my, o) }


func AnyCastToMethodModifier1(i interface{}) *MethodModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier1)
	}
}
/**
 *<b>
*<li>Rule 146:  MethodModifier ::= private
 *</b>
 */
type MethodModifier2 struct{
    *AstToken
}
func (my *MethodModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewMethodModifier2(token IToken )*MethodModifier2{
      my := new(MethodModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier2)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier2(my)}
func (my *MethodModifier2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier2WithArg(my, o) }
func (my *MethodModifier2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier2WithResult(my) }
func (my *MethodModifier2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier2WithResultArgument(my, o) }


func AnyCastToMethodModifier2(i interface{}) *MethodModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier2)
	}
}
/**
 *<b>
*<li>Rule 147:  MethodModifier ::= abstract
 *</b>
 */
type MethodModifier3 struct{
    *AstToken
}
func (my *MethodModifier3)      Getabstract()IToken{ return my.leftIToken; }

func NewMethodModifier3(token IToken )*MethodModifier3{
      my := new(MethodModifier3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier3)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier3(my)}
func (my *MethodModifier3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier3WithArg(my, o) }
func (my *MethodModifier3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier3WithResult(my) }
func (my *MethodModifier3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier3WithResultArgument(my, o) }


func AnyCastToMethodModifier3(i interface{}) *MethodModifier3 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier3)
	}
}
/**
 *<b>
*<li>Rule 148:  MethodModifier ::= static
 *</b>
 */
type MethodModifier4 struct{
    *AstToken
}
func (my *MethodModifier4)      Getstatic()IToken{ return my.leftIToken; }

func NewMethodModifier4(token IToken )*MethodModifier4{
      my := new(MethodModifier4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier4)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier4(my)}
func (my *MethodModifier4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier4WithArg(my, o) }
func (my *MethodModifier4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier4WithResult(my) }
func (my *MethodModifier4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier4WithResultArgument(my, o) }


func AnyCastToMethodModifier4(i interface{}) *MethodModifier4 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier4)
	}
}
/**
 *<b>
*<li>Rule 149:  MethodModifier ::= final
 *</b>
 */
type MethodModifier5 struct{
    *AstToken
}
func (my *MethodModifier5)      Getfinal()IToken{ return my.leftIToken; }

func NewMethodModifier5(token IToken )*MethodModifier5{
      my := new(MethodModifier5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier5)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier5(my)}
func (my *MethodModifier5)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier5WithArg(my, o) }
func (my *MethodModifier5)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier5WithResult(my) }
func (my *MethodModifier5)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier5WithResultArgument(my, o) }


func AnyCastToMethodModifier5(i interface{}) *MethodModifier5 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier5)
	}
}
/**
 *<b>
*<li>Rule 150:  MethodModifier ::= synchronized
 *</b>
 */
type MethodModifier6 struct{
    *AstToken
}
func (my *MethodModifier6)      Getsynchronized()IToken{ return my.leftIToken; }

func NewMethodModifier6(token IToken )*MethodModifier6{
      my := new(MethodModifier6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier6)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier6(my)}
func (my *MethodModifier6)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier6WithArg(my, o) }
func (my *MethodModifier6)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier6WithResult(my) }
func (my *MethodModifier6)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier6WithResultArgument(my, o) }


func AnyCastToMethodModifier6(i interface{}) *MethodModifier6 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier6)
	}
}
/**
 *<b>
*<li>Rule 151:  MethodModifier ::= native
 *</b>
 */
type MethodModifier7 struct{
    *AstToken
}
func (my *MethodModifier7)      Getnative()IToken{ return my.leftIToken; }

func NewMethodModifier7(token IToken )*MethodModifier7{
      my := new(MethodModifier7)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier7)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier7(my)}
func (my *MethodModifier7)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier7WithArg(my, o) }
func (my *MethodModifier7)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier7WithResult(my) }
func (my *MethodModifier7)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier7WithResultArgument(my, o) }


func AnyCastToMethodModifier7(i interface{}) *MethodModifier7 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier7)
	}
}
/**
 *<b>
*<li>Rule 152:  MethodModifier ::= strictfp
 *</b>
 */
type MethodModifier8 struct{
    *AstToken
}
func (my *MethodModifier8)      Getstrictfp()IToken{ return my.leftIToken; }

func NewMethodModifier8(token IToken )*MethodModifier8{
      my := new(MethodModifier8)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *MethodModifier8)      AcceptWithVisitor(v Visitor) { v.VisitMethodModifier8(my)}
func (my *MethodModifier8)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodModifier8WithArg(my, o) }
func (my *MethodModifier8)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodModifier8WithResult(my) }
func (my *MethodModifier8)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodModifier8WithResultArgument(my, o) }


func AnyCastToMethodModifier8(i interface{}) *MethodModifier8 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodModifier8)
	}
}
/**
 *<b>
*<li>Rule 168:  ConstructorModifier ::= public
 *</b>
 */
type ConstructorModifier0 struct{
    *AstToken
}
func (my *ConstructorModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewConstructorModifier0(token IToken )*ConstructorModifier0{
      my := new(ConstructorModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstructorModifier0)      AcceptWithVisitor(v Visitor) { v.VisitConstructorModifier0(my)}
func (my *ConstructorModifier0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstructorModifier0WithArg(my, o) }
func (my *ConstructorModifier0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstructorModifier0WithResult(my) }
func (my *ConstructorModifier0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstructorModifier0WithResultArgument(my, o) }


func AnyCastToConstructorModifier0(i interface{}) *ConstructorModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorModifier0)
	}
}
/**
 *<b>
*<li>Rule 169:  ConstructorModifier ::= protected
 *</b>
 */
type ConstructorModifier1 struct{
    *AstToken
}
func (my *ConstructorModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewConstructorModifier1(token IToken )*ConstructorModifier1{
      my := new(ConstructorModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstructorModifier1)      AcceptWithVisitor(v Visitor) { v.VisitConstructorModifier1(my)}
func (my *ConstructorModifier1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstructorModifier1WithArg(my, o) }
func (my *ConstructorModifier1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstructorModifier1WithResult(my) }
func (my *ConstructorModifier1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstructorModifier1WithResultArgument(my, o) }


func AnyCastToConstructorModifier1(i interface{}) *ConstructorModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorModifier1)
	}
}
/**
 *<b>
*<li>Rule 170:  ConstructorModifier ::= private
 *</b>
 */
type ConstructorModifier2 struct{
    *AstToken
}
func (my *ConstructorModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewConstructorModifier2(token IToken )*ConstructorModifier2{
      my := new(ConstructorModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstructorModifier2)      AcceptWithVisitor(v Visitor) { v.VisitConstructorModifier2(my)}
func (my *ConstructorModifier2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstructorModifier2WithArg(my, o) }
func (my *ConstructorModifier2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstructorModifier2WithResult(my) }
func (my *ConstructorModifier2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstructorModifier2WithResultArgument(my, o) }


func AnyCastToConstructorModifier2(i interface{}) *ConstructorModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstructorModifier2)
	}
}
/**
 *<b>
*<li>Rule 172:  ExplicitConstructorInvocation ::= TypeArgumentsopt this ( ArgumentListopt ) ;
 *</b>
 */
type ExplicitConstructorInvocation0 struct{
    *Ast
      _TypeArgumentsopt *TypeArguments
      _this *AstToken
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation0)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ExplicitConstructorInvocation0)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ExplicitConstructorInvocation0)      Getthis() *AstToken{ return my._this}
func (my *ExplicitConstructorInvocation0)      Setthis( _this *AstToken)  { my._this = _this }
func (my *ExplicitConstructorInvocation0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ExplicitConstructorInvocation0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation0)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ExplicitConstructorInvocation0)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ExplicitConstructorInvocation0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ExplicitConstructorInvocation0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *ExplicitConstructorInvocation0)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ExplicitConstructorInvocation0)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewExplicitConstructorInvocation0(leftIToken IToken, rightIToken IToken ,
              _TypeArgumentsopt *TypeArguments,
              _this *AstToken,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _SEMICOLON *AstToken)*ExplicitConstructorInvocation0{
      my := new(ExplicitConstructorInvocation0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._this = _this;
        if nil != _this{
        var trait_ interface{} = _this
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExplicitConstructorInvocation0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._this{  list.Add(my._this) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ExplicitConstructorInvocation0)      AcceptWithVisitor(v Visitor) { v.VisitExplicitConstructorInvocation0(my)}
func (my *ExplicitConstructorInvocation0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExplicitConstructorInvocation0WithArg(my, o) }
func (my *ExplicitConstructorInvocation0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExplicitConstructorInvocation0WithResult(my) }
func (my *ExplicitConstructorInvocation0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExplicitConstructorInvocation0WithResultArgument(my, o) }


func AnyCastToExplicitConstructorInvocation0(i interface{}) *ExplicitConstructorInvocation0 {
	if nil == i{
		return nil
	}else{
		return i.(*ExplicitConstructorInvocation0)
	}
}
/**
 *<b>
*<li>Rule 173:  ExplicitConstructorInvocation ::= TypeArgumentsopt super ( ArgumentListopt ) ;
 *</b>
 */
type ExplicitConstructorInvocation1 struct{
    *Ast
      _TypeArgumentsopt *TypeArguments
      _super *AstToken
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation1)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ExplicitConstructorInvocation1)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ExplicitConstructorInvocation1)      Getsuper() *AstToken{ return my._super}
func (my *ExplicitConstructorInvocation1)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *ExplicitConstructorInvocation1)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ExplicitConstructorInvocation1)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation1)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ExplicitConstructorInvocation1)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ExplicitConstructorInvocation1)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ExplicitConstructorInvocation1)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *ExplicitConstructorInvocation1)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ExplicitConstructorInvocation1)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewExplicitConstructorInvocation1(leftIToken IToken, rightIToken IToken ,
              _TypeArgumentsopt *TypeArguments,
              _super *AstToken,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _SEMICOLON *AstToken)*ExplicitConstructorInvocation1{
      my := new(ExplicitConstructorInvocation1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExplicitConstructorInvocation1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._super{  list.Add(my._super) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ExplicitConstructorInvocation1)      AcceptWithVisitor(v Visitor) { v.VisitExplicitConstructorInvocation1(my)}
func (my *ExplicitConstructorInvocation1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExplicitConstructorInvocation1WithArg(my, o) }
func (my *ExplicitConstructorInvocation1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExplicitConstructorInvocation1WithResult(my) }
func (my *ExplicitConstructorInvocation1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExplicitConstructorInvocation1WithResultArgument(my, o) }


func AnyCastToExplicitConstructorInvocation1(i interface{}) *ExplicitConstructorInvocation1 {
	if nil == i{
		return nil
	}else{
		return i.(*ExplicitConstructorInvocation1)
	}
}
/**
 *<b>
*<li>Rule 174:  ExplicitConstructorInvocation ::= Primary . TypeArgumentsopt super ( ArgumentListopt ) ;
 *</b>
 */
type ExplicitConstructorInvocation2 struct{
    *Ast
      _Primary IPrimary
      _DOT *AstToken
      _TypeArgumentsopt *TypeArguments
      _super *AstToken
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _SEMICOLON *AstToken
}
func (my *ExplicitConstructorInvocation2)      GetPrimary() IPrimary{ return my._Primary}
func (my *ExplicitConstructorInvocation2)      SetPrimary( _Primary IPrimary)  { my._Primary = _Primary }
func (my *ExplicitConstructorInvocation2)      GetDOT() *AstToken{ return my._DOT}
func (my *ExplicitConstructorInvocation2)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation2)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ExplicitConstructorInvocation2)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ExplicitConstructorInvocation2)      Getsuper() *AstToken{ return my._super}
func (my *ExplicitConstructorInvocation2)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *ExplicitConstructorInvocation2)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ExplicitConstructorInvocation2)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ExplicitConstructorInvocation2)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ExplicitConstructorInvocation2)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ExplicitConstructorInvocation2)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ExplicitConstructorInvocation2)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *ExplicitConstructorInvocation2)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *ExplicitConstructorInvocation2)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewExplicitConstructorInvocation2(leftIToken IToken, rightIToken IToken ,
              _Primary IPrimary,
              _DOT *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _super *AstToken,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _SEMICOLON *AstToken)*ExplicitConstructorInvocation2{
      my := new(ExplicitConstructorInvocation2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Primary = _Primary;
        if nil != _Primary{
        var trait_ interface{} = _Primary
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExplicitConstructorInvocation2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Primary{  list.Add(my._Primary) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._super{  list.Add(my._super) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *ExplicitConstructorInvocation2)      AcceptWithVisitor(v Visitor) { v.VisitExplicitConstructorInvocation2(my)}
func (my *ExplicitConstructorInvocation2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExplicitConstructorInvocation2WithArg(my, o) }
func (my *ExplicitConstructorInvocation2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExplicitConstructorInvocation2WithResult(my) }
func (my *ExplicitConstructorInvocation2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExplicitConstructorInvocation2WithResultArgument(my, o) }


func AnyCastToExplicitConstructorInvocation2(i interface{}) *ExplicitConstructorInvocation2 {
	if nil == i{
		return nil
	}else{
		return i.(*ExplicitConstructorInvocation2)
	}
}
/**
 *<b>
*<li>Rule 188:  InterfaceModifier ::= public
 *</b>
 */
type InterfaceModifier0 struct{
    *AstToken
}
func (my *InterfaceModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewInterfaceModifier0(token IToken )*InterfaceModifier0{
      my := new(InterfaceModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier0)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceModifier0(my)}
func (my *InterfaceModifier0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceModifier0WithArg(my, o) }
func (my *InterfaceModifier0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceModifier0WithResult(my) }
func (my *InterfaceModifier0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceModifier0WithResultArgument(my, o) }


func AnyCastToInterfaceModifier0(i interface{}) *InterfaceModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier0)
	}
}
/**
 *<b>
*<li>Rule 189:  InterfaceModifier ::= protected
 *</b>
 */
type InterfaceModifier1 struct{
    *AstToken
}
func (my *InterfaceModifier1)      Getprotected()IToken{ return my.leftIToken; }

func NewInterfaceModifier1(token IToken )*InterfaceModifier1{
      my := new(InterfaceModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier1)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceModifier1(my)}
func (my *InterfaceModifier1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceModifier1WithArg(my, o) }
func (my *InterfaceModifier1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceModifier1WithResult(my) }
func (my *InterfaceModifier1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceModifier1WithResultArgument(my, o) }


func AnyCastToInterfaceModifier1(i interface{}) *InterfaceModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier1)
	}
}
/**
 *<b>
*<li>Rule 190:  InterfaceModifier ::= private
 *</b>
 */
type InterfaceModifier2 struct{
    *AstToken
}
func (my *InterfaceModifier2)      Getprivate()IToken{ return my.leftIToken; }

func NewInterfaceModifier2(token IToken )*InterfaceModifier2{
      my := new(InterfaceModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier2)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceModifier2(my)}
func (my *InterfaceModifier2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceModifier2WithArg(my, o) }
func (my *InterfaceModifier2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceModifier2WithResult(my) }
func (my *InterfaceModifier2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceModifier2WithResultArgument(my, o) }


func AnyCastToInterfaceModifier2(i interface{}) *InterfaceModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier2)
	}
}
/**
 *<b>
*<li>Rule 191:  InterfaceModifier ::= abstract
 *</b>
 */
type InterfaceModifier3 struct{
    *AstToken
}
func (my *InterfaceModifier3)      Getabstract()IToken{ return my.leftIToken; }

func NewInterfaceModifier3(token IToken )*InterfaceModifier3{
      my := new(InterfaceModifier3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier3)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceModifier3(my)}
func (my *InterfaceModifier3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceModifier3WithArg(my, o) }
func (my *InterfaceModifier3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceModifier3WithResult(my) }
func (my *InterfaceModifier3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceModifier3WithResultArgument(my, o) }


func AnyCastToInterfaceModifier3(i interface{}) *InterfaceModifier3 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier3)
	}
}
/**
 *<b>
*<li>Rule 192:  InterfaceModifier ::= static
 *</b>
 */
type InterfaceModifier4 struct{
    *AstToken
}
func (my *InterfaceModifier4)      Getstatic()IToken{ return my.leftIToken; }

func NewInterfaceModifier4(token IToken )*InterfaceModifier4{
      my := new(InterfaceModifier4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier4)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceModifier4(my)}
func (my *InterfaceModifier4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceModifier4WithArg(my, o) }
func (my *InterfaceModifier4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceModifier4WithResult(my) }
func (my *InterfaceModifier4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceModifier4WithResultArgument(my, o) }


func AnyCastToInterfaceModifier4(i interface{}) *InterfaceModifier4 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier4)
	}
}
/**
 *<b>
*<li>Rule 193:  InterfaceModifier ::= strictfp
 *</b>
 */
type InterfaceModifier5 struct{
    *AstToken
}
func (my *InterfaceModifier5)      Getstrictfp()IToken{ return my.leftIToken; }

func NewInterfaceModifier5(token IToken )*InterfaceModifier5{
      my := new(InterfaceModifier5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *InterfaceModifier5)      AcceptWithVisitor(v Visitor) { v.VisitInterfaceModifier5(my)}
func (my *InterfaceModifier5)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitInterfaceModifier5WithArg(my, o) }
func (my *InterfaceModifier5)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitInterfaceModifier5WithResult(my) }
func (my *InterfaceModifier5)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitInterfaceModifier5WithResultArgument(my, o) }


func AnyCastToInterfaceModifier5(i interface{}) *InterfaceModifier5 {
	if nil == i{
		return nil
	}else{
		return i.(*InterfaceModifier5)
	}
}
/**
 *<b>
*<li>Rule 194:  ExtendsInterfaces ::= extends InterfaceType
 *</b>
 */
type ExtendsInterfaces0 struct{
    *Ast
      _extends *AstToken
      _InterfaceType *InterfaceType
}
func (my *ExtendsInterfaces0)      Getextends() *AstToken{ return my._extends}
func (my *ExtendsInterfaces0)      Setextends( _extends *AstToken)  { my._extends = _extends }
func (my *ExtendsInterfaces0)      GetInterfaceType() *InterfaceType{ return my._InterfaceType}
func (my *ExtendsInterfaces0)      SetInterfaceType( _InterfaceType *InterfaceType)  { my._InterfaceType = _InterfaceType }

func NewExtendsInterfaces0(leftIToken IToken, rightIToken IToken ,
              _extends *AstToken,
              _InterfaceType *InterfaceType)*ExtendsInterfaces0{
      my := new(ExtendsInterfaces0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._extends = _extends;
        if nil != _extends{
        var trait_ interface{} = _extends
         trait_.(IAst).SetParent(my)
}
        my._InterfaceType = _InterfaceType;
        if nil != _InterfaceType{
        var trait_ interface{} = _InterfaceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExtendsInterfaces0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._extends{  list.Add(my._extends) }
        if nil != my._InterfaceType{  list.Add(my._InterfaceType) }
        return list
    }

func (my *ExtendsInterfaces0)      AcceptWithVisitor(v Visitor) { v.VisitExtendsInterfaces0(my)}
func (my *ExtendsInterfaces0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExtendsInterfaces0WithArg(my, o) }
func (my *ExtendsInterfaces0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExtendsInterfaces0WithResult(my) }
func (my *ExtendsInterfaces0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExtendsInterfaces0WithResultArgument(my, o) }


func AnyCastToExtendsInterfaces0(i interface{}) *ExtendsInterfaces0 {
	if nil == i{
		return nil
	}else{
		return i.(*ExtendsInterfaces0)
	}
}
/**
 *<b>
*<li>Rule 195:  ExtendsInterfaces ::= ExtendsInterfaces , InterfaceType
 *</b>
 */
type ExtendsInterfaces1 struct{
    *Ast
      _ExtendsInterfaces IExtendsInterfaces
      _COMMA *AstToken
      _InterfaceType *InterfaceType
}
func (my *ExtendsInterfaces1)      GetExtendsInterfaces() IExtendsInterfaces{ return my._ExtendsInterfaces}
func (my *ExtendsInterfaces1)      SetExtendsInterfaces( _ExtendsInterfaces IExtendsInterfaces)  { my._ExtendsInterfaces = _ExtendsInterfaces }
func (my *ExtendsInterfaces1)      GetCOMMA() *AstToken{ return my._COMMA}
func (my *ExtendsInterfaces1)      SetCOMMA( _COMMA *AstToken)  { my._COMMA = _COMMA }
func (my *ExtendsInterfaces1)      GetInterfaceType() *InterfaceType{ return my._InterfaceType}
func (my *ExtendsInterfaces1)      SetInterfaceType( _InterfaceType *InterfaceType)  { my._InterfaceType = _InterfaceType }

func NewExtendsInterfaces1(leftIToken IToken, rightIToken IToken ,
              _ExtendsInterfaces IExtendsInterfaces,
              _COMMA *AstToken,
              _InterfaceType *InterfaceType)*ExtendsInterfaces1{
      my := new(ExtendsInterfaces1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ExtendsInterfaces = _ExtendsInterfaces;
        if nil != _ExtendsInterfaces{
        var trait_ interface{} = _ExtendsInterfaces
         trait_.(IAst).SetParent(my)
}
        my._COMMA = _COMMA;
        if nil != _COMMA{
        var trait_ interface{} = _COMMA
         trait_.(IAst).SetParent(my)
}
        my._InterfaceType = _InterfaceType;
        if nil != _InterfaceType{
        var trait_ interface{} = _InterfaceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ExtendsInterfaces1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ExtendsInterfaces{  list.Add(my._ExtendsInterfaces) }
        if nil != my._COMMA{  list.Add(my._COMMA) }
        if nil != my._InterfaceType{  list.Add(my._InterfaceType) }
        return list
    }

func (my *ExtendsInterfaces1)      AcceptWithVisitor(v Visitor) { v.VisitExtendsInterfaces1(my)}
func (my *ExtendsInterfaces1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitExtendsInterfaces1WithArg(my, o) }
func (my *ExtendsInterfaces1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitExtendsInterfaces1WithResult(my) }
func (my *ExtendsInterfaces1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitExtendsInterfaces1WithResultArgument(my, o) }


func AnyCastToExtendsInterfaces1(i interface{}) *ExtendsInterfaces1 {
	if nil == i{
		return nil
	}else{
		return i.(*ExtendsInterfaces1)
	}
}
/**
 *<b>
*<li>Rule 208:  ConstantModifier ::= public
 *</b>
 */
type ConstantModifier0 struct{
    *AstToken
}
func (my *ConstantModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewConstantModifier0(token IToken )*ConstantModifier0{
      my := new(ConstantModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstantModifier0)      AcceptWithVisitor(v Visitor) { v.VisitConstantModifier0(my)}
func (my *ConstantModifier0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstantModifier0WithArg(my, o) }
func (my *ConstantModifier0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstantModifier0WithResult(my) }
func (my *ConstantModifier0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstantModifier0WithResultArgument(my, o) }


func AnyCastToConstantModifier0(i interface{}) *ConstantModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantModifier0)
	}
}
/**
 *<b>
*<li>Rule 209:  ConstantModifier ::= static
 *</b>
 */
type ConstantModifier1 struct{
    *AstToken
}
func (my *ConstantModifier1)      Getstatic()IToken{ return my.leftIToken; }

func NewConstantModifier1(token IToken )*ConstantModifier1{
      my := new(ConstantModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstantModifier1)      AcceptWithVisitor(v Visitor) { v.VisitConstantModifier1(my)}
func (my *ConstantModifier1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstantModifier1WithArg(my, o) }
func (my *ConstantModifier1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstantModifier1WithResult(my) }
func (my *ConstantModifier1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstantModifier1WithResultArgument(my, o) }


func AnyCastToConstantModifier1(i interface{}) *ConstantModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantModifier1)
	}
}
/**
 *<b>
*<li>Rule 210:  ConstantModifier ::= final
 *</b>
 */
type ConstantModifier2 struct{
    *AstToken
}
func (my *ConstantModifier2)      Getfinal()IToken{ return my.leftIToken; }

func NewConstantModifier2(token IToken )*ConstantModifier2{
      my := new(ConstantModifier2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *ConstantModifier2)      AcceptWithVisitor(v Visitor) { v.VisitConstantModifier2(my)}
func (my *ConstantModifier2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitConstantModifier2WithArg(my, o) }
func (my *ConstantModifier2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitConstantModifier2WithResult(my) }
func (my *ConstantModifier2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitConstantModifier2WithResultArgument(my, o) }


func AnyCastToConstantModifier2(i interface{}) *ConstantModifier2 {
	if nil == i{
		return nil
	}else{
		return i.(*ConstantModifier2)
	}
}
/**
 *<b>
*<li>Rule 215:  AbstractMethodModifier ::= public
 *</b>
 */
type AbstractMethodModifier0 struct{
    *AstToken
}
func (my *AbstractMethodModifier0)      Getpublic()IToken{ return my.leftIToken; }

func NewAbstractMethodModifier0(token IToken )*AbstractMethodModifier0{
      my := new(AbstractMethodModifier0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AbstractMethodModifier0)      AcceptWithVisitor(v Visitor) { v.VisitAbstractMethodModifier0(my)}
func (my *AbstractMethodModifier0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAbstractMethodModifier0WithArg(my, o) }
func (my *AbstractMethodModifier0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAbstractMethodModifier0WithResult(my) }
func (my *AbstractMethodModifier0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAbstractMethodModifier0WithResultArgument(my, o) }


func AnyCastToAbstractMethodModifier0(i interface{}) *AbstractMethodModifier0 {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractMethodModifier0)
	}
}
/**
 *<b>
*<li>Rule 216:  AbstractMethodModifier ::= abstract
 *</b>
 */
type AbstractMethodModifier1 struct{
    *AstToken
}
func (my *AbstractMethodModifier1)      Getabstract()IToken{ return my.leftIToken; }

func NewAbstractMethodModifier1(token IToken )*AbstractMethodModifier1{
      my := new(AbstractMethodModifier1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AbstractMethodModifier1)      AcceptWithVisitor(v Visitor) { v.VisitAbstractMethodModifier1(my)}
func (my *AbstractMethodModifier1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAbstractMethodModifier1WithArg(my, o) }
func (my *AbstractMethodModifier1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAbstractMethodModifier1WithResult(my) }
func (my *AbstractMethodModifier1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAbstractMethodModifier1WithResultArgument(my, o) }


func AnyCastToAbstractMethodModifier1(i interface{}) *AbstractMethodModifier1 {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractMethodModifier1)
	}
}
/**
 *<b>
*<li>Rule 221:  AnnotationTypeElementDeclaration ::= AbstractMethodModifiersopt Type identifier ( ) DefaultValueopt ;
 *</b>
 */
type AnnotationTypeElementDeclaration0 struct{
    *Ast
      _AbstractMethodModifiersopt IAbstractMethodModifiersopt
      _Type IType
      _identifier *identifier
      _LPAREN *AstToken
      _RPAREN *AstToken
      _DefaultValueopt *DefaultValue
      _SEMICOLON *AstToken
}
    /**
     * The value returned by <b>GetAbstractMethodModifiersopt</b> may be <b>null</b>
     */
func (my *AnnotationTypeElementDeclaration0)      GetAbstractMethodModifiersopt() IAbstractMethodModifiersopt{ return my._AbstractMethodModifiersopt}
func (my *AnnotationTypeElementDeclaration0)      SetAbstractMethodModifiersopt( _AbstractMethodModifiersopt IAbstractMethodModifiersopt)  { my._AbstractMethodModifiersopt = _AbstractMethodModifiersopt }
func (my *AnnotationTypeElementDeclaration0)      GetType() IType{ return my._Type}
func (my *AnnotationTypeElementDeclaration0)      SetType( _Type IType)  { my._Type = _Type }
func (my *AnnotationTypeElementDeclaration0)      Getidentifier() *identifier{ return my._identifier}
func (my *AnnotationTypeElementDeclaration0)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *AnnotationTypeElementDeclaration0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *AnnotationTypeElementDeclaration0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *AnnotationTypeElementDeclaration0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *AnnotationTypeElementDeclaration0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
    /**
     * The value returned by <b>GetDefaultValueopt</b> may be <b>null</b>
     */
func (my *AnnotationTypeElementDeclaration0)      GetDefaultValueopt() *DefaultValue{ return my._DefaultValueopt}
func (my *AnnotationTypeElementDeclaration0)      SetDefaultValueopt( _DefaultValueopt *DefaultValue)  { my._DefaultValueopt = _DefaultValueopt }
func (my *AnnotationTypeElementDeclaration0)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *AnnotationTypeElementDeclaration0)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewAnnotationTypeElementDeclaration0(leftIToken IToken, rightIToken IToken ,
              _AbstractMethodModifiersopt IAbstractMethodModifiersopt,
              _Type IType,
              _identifier *identifier,
              _LPAREN *AstToken,
              _RPAREN *AstToken,
              _DefaultValueopt *DefaultValue,
              _SEMICOLON *AstToken)*AnnotationTypeElementDeclaration0{
      my := new(AnnotationTypeElementDeclaration0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AbstractMethodModifiersopt = _AbstractMethodModifiersopt;
        if nil != _AbstractMethodModifiersopt{
        var trait_ interface{} = _AbstractMethodModifiersopt
         trait_.(IAst).SetParent(my)
}
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._DefaultValueopt = _DefaultValueopt;
        if nil != _DefaultValueopt{
        var trait_ interface{} = _DefaultValueopt
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AnnotationTypeElementDeclaration0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AbstractMethodModifiersopt{  list.Add(my._AbstractMethodModifiersopt) }
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._DefaultValueopt{  list.Add(my._DefaultValueopt) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *AnnotationTypeElementDeclaration0)      AcceptWithVisitor(v Visitor) { v.VisitAnnotationTypeElementDeclaration0(my)}
func (my *AnnotationTypeElementDeclaration0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAnnotationTypeElementDeclaration0WithArg(my, o) }
func (my *AnnotationTypeElementDeclaration0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAnnotationTypeElementDeclaration0WithResult(my) }
func (my *AnnotationTypeElementDeclaration0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAnnotationTypeElementDeclaration0WithResultArgument(my, o) }


func AnyCastToAnnotationTypeElementDeclaration0(i interface{}) *AnnotationTypeElementDeclaration0 {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeElementDeclaration0)
	}
}
/**
 *<b>
*<li>Rule 227:  AnnotationTypeElementDeclaration ::= ;
 *</b>
 */
type AnnotationTypeElementDeclaration1 struct{
    *AstToken
}
func (my *AnnotationTypeElementDeclaration1)      GetSEMICOLON()IToken{ return my.leftIToken; }

func NewAnnotationTypeElementDeclaration1(token IToken )*AnnotationTypeElementDeclaration1{
      my := new(AnnotationTypeElementDeclaration1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AnnotationTypeElementDeclaration1)      AcceptWithVisitor(v Visitor) { v.VisitAnnotationTypeElementDeclaration1(my)}
func (my *AnnotationTypeElementDeclaration1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAnnotationTypeElementDeclaration1WithArg(my, o) }
func (my *AnnotationTypeElementDeclaration1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAnnotationTypeElementDeclaration1WithResult(my) }
func (my *AnnotationTypeElementDeclaration1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAnnotationTypeElementDeclaration1WithResultArgument(my, o) }


func AnyCastToAnnotationTypeElementDeclaration1(i interface{}) *AnnotationTypeElementDeclaration1 {
	if nil == i{
		return nil
	}else{
		return i.(*AnnotationTypeElementDeclaration1)
	}
}
/**
 *<b>
*<li>Rule 295:  AssertStatement ::= assert Expression ;
 *</b>
 */
type AssertStatement0 struct{
    *Ast
      _assert *AstToken
      _Expression IExpression
      _SEMICOLON *AstToken
}
func (my *AssertStatement0)      Getassert() *AstToken{ return my._assert}
func (my *AssertStatement0)      Setassert( _assert *AstToken)  { my._assert = _assert }
func (my *AssertStatement0)      GetExpression() IExpression{ return my._Expression}
func (my *AssertStatement0)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *AssertStatement0)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *AssertStatement0)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewAssertStatement0(leftIToken IToken, rightIToken IToken ,
              _assert *AstToken,
              _Expression IExpression,
              _SEMICOLON *AstToken)*AssertStatement0{
      my := new(AssertStatement0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._assert = _assert;
        if nil != _assert{
        var trait_ interface{} = _assert
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AssertStatement0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._assert{  list.Add(my._assert) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *AssertStatement0)      AcceptWithVisitor(v Visitor) { v.VisitAssertStatement0(my)}
func (my *AssertStatement0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssertStatement0WithArg(my, o) }
func (my *AssertStatement0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssertStatement0WithResult(my) }
func (my *AssertStatement0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssertStatement0WithResultArgument(my, o) }


func AnyCastToAssertStatement0(i interface{}) *AssertStatement0 {
	if nil == i{
		return nil
	}else{
		return i.(*AssertStatement0)
	}
}
/**
 *<b>
*<li>Rule 296:  AssertStatement ::= assert Expression : Expression ;
 *</b>
 */
type AssertStatement1 struct{
    *Ast
      _assert *AstToken
      _Expression IExpression
      _COLON *AstToken
      _Expression4 IExpression
      _SEMICOLON *AstToken
}
func (my *AssertStatement1)      Getassert() *AstToken{ return my._assert}
func (my *AssertStatement1)      Setassert( _assert *AstToken)  { my._assert = _assert }
func (my *AssertStatement1)      GetExpression() IExpression{ return my._Expression}
func (my *AssertStatement1)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *AssertStatement1)      GetCOLON() *AstToken{ return my._COLON}
func (my *AssertStatement1)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }
func (my *AssertStatement1)      GetExpression4() IExpression{ return my._Expression4}
func (my *AssertStatement1)      SetExpression4( _Expression4 IExpression)  { my._Expression4 = _Expression4 }
func (my *AssertStatement1)      GetSEMICOLON() *AstToken{ return my._SEMICOLON}
func (my *AssertStatement1)      SetSEMICOLON( _SEMICOLON *AstToken)  { my._SEMICOLON = _SEMICOLON }

func NewAssertStatement1(leftIToken IToken, rightIToken IToken ,
              _assert *AstToken,
              _Expression IExpression,
              _COLON *AstToken,
              _Expression4 IExpression,
              _SEMICOLON *AstToken)*AssertStatement1{
      my := new(AssertStatement1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._assert = _assert;
        if nil != _assert{
        var trait_ interface{} = _assert
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my._Expression4 = _Expression4;
        if nil != _Expression4{
        var trait_ interface{} = _Expression4
         trait_.(IAst).SetParent(my)
}
        my._SEMICOLON = _SEMICOLON;
        if nil != _SEMICOLON{
        var trait_ interface{} = _SEMICOLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AssertStatement1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._assert{  list.Add(my._assert) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._COLON{  list.Add(my._COLON) }
        if nil != my._Expression4{  list.Add(my._Expression4) }
        if nil != my._SEMICOLON{  list.Add(my._SEMICOLON) }
        return list
    }

func (my *AssertStatement1)      AcceptWithVisitor(v Visitor) { v.VisitAssertStatement1(my)}
func (my *AssertStatement1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssertStatement1WithArg(my, o) }
func (my *AssertStatement1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssertStatement1WithResult(my) }
func (my *AssertStatement1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssertStatement1WithResultArgument(my, o) }


func AnyCastToAssertStatement1(i interface{}) *AssertStatement1 {
	if nil == i{
		return nil
	}else{
		return i.(*AssertStatement1)
	}
}
/**
 *<b>
*<li>Rule 304:  SwitchLabel ::= case ConstantExpression :
 *</b>
 */
type SwitchLabel0 struct{
    *Ast
      _case *AstToken
      _ConstantExpression IConstantExpression
      _COLON *AstToken
}
func (my *SwitchLabel0)      Getcase() *AstToken{ return my._case}
func (my *SwitchLabel0)      Setcase( _case *AstToken)  { my._case = _case }
func (my *SwitchLabel0)      GetConstantExpression() IConstantExpression{ return my._ConstantExpression}
func (my *SwitchLabel0)      SetConstantExpression( _ConstantExpression IConstantExpression)  { my._ConstantExpression = _ConstantExpression }
func (my *SwitchLabel0)      GetCOLON() *AstToken{ return my._COLON}
func (my *SwitchLabel0)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }

func NewSwitchLabel0(leftIToken IToken, rightIToken IToken ,
              _case *AstToken,
              _ConstantExpression IConstantExpression,
              _COLON *AstToken)*SwitchLabel0{
      my := new(SwitchLabel0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._case = _case;
        if nil != _case{
        var trait_ interface{} = _case
         trait_.(IAst).SetParent(my)
}
        my._ConstantExpression = _ConstantExpression;
        if nil != _ConstantExpression{
        var trait_ interface{} = _ConstantExpression
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchLabel0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._case{  list.Add(my._case) }
        if nil != my._ConstantExpression{  list.Add(my._ConstantExpression) }
        if nil != my._COLON{  list.Add(my._COLON) }
        return list
    }

func (my *SwitchLabel0)      AcceptWithVisitor(v Visitor) { v.VisitSwitchLabel0(my)}
func (my *SwitchLabel0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSwitchLabel0WithArg(my, o) }
func (my *SwitchLabel0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSwitchLabel0WithResult(my) }
func (my *SwitchLabel0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSwitchLabel0WithResultArgument(my, o) }


func AnyCastToSwitchLabel0(i interface{}) *SwitchLabel0 {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchLabel0)
	}
}
/**
 *<b>
*<li>Rule 305:  SwitchLabel ::= case EnumConstant :
 *</b>
 */
type SwitchLabel1 struct{
    *Ast
      _case *AstToken
      _EnumConstant IEnumConstant
      _COLON *AstToken
}
func (my *SwitchLabel1)      Getcase() *AstToken{ return my._case}
func (my *SwitchLabel1)      Setcase( _case *AstToken)  { my._case = _case }
func (my *SwitchLabel1)      GetEnumConstant() IEnumConstant{ return my._EnumConstant}
func (my *SwitchLabel1)      SetEnumConstant( _EnumConstant IEnumConstant)  { my._EnumConstant = _EnumConstant }
func (my *SwitchLabel1)      GetCOLON() *AstToken{ return my._COLON}
func (my *SwitchLabel1)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }

func NewSwitchLabel1(leftIToken IToken, rightIToken IToken ,
              _case *AstToken,
              _EnumConstant IEnumConstant,
              _COLON *AstToken)*SwitchLabel1{
      my := new(SwitchLabel1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._case = _case;
        if nil != _case{
        var trait_ interface{} = _case
         trait_.(IAst).SetParent(my)
}
        my._EnumConstant = _EnumConstant;
        if nil != _EnumConstant{
        var trait_ interface{} = _EnumConstant
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchLabel1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._case{  list.Add(my._case) }
        if nil != my._EnumConstant{  list.Add(my._EnumConstant) }
        if nil != my._COLON{  list.Add(my._COLON) }
        return list
    }

func (my *SwitchLabel1)      AcceptWithVisitor(v Visitor) { v.VisitSwitchLabel1(my)}
func (my *SwitchLabel1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSwitchLabel1WithArg(my, o) }
func (my *SwitchLabel1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSwitchLabel1WithResult(my) }
func (my *SwitchLabel1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSwitchLabel1WithResultArgument(my, o) }


func AnyCastToSwitchLabel1(i interface{}) *SwitchLabel1 {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchLabel1)
	}
}
/**
 *<b>
*<li>Rule 306:  SwitchLabel ::= default :
 *</b>
 */
type SwitchLabel2 struct{
    *Ast
      _default *AstToken
      _COLON *AstToken
}
func (my *SwitchLabel2)      Getdefault() *AstToken{ return my._default}
func (my *SwitchLabel2)      Setdefault( _default *AstToken)  { my._default = _default }
func (my *SwitchLabel2)      GetCOLON() *AstToken{ return my._COLON}
func (my *SwitchLabel2)      SetCOLON( _COLON *AstToken)  { my._COLON = _COLON }

func NewSwitchLabel2(leftIToken IToken, rightIToken IToken ,
              _default *AstToken,
              _COLON *AstToken)*SwitchLabel2{
      my := new(SwitchLabel2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._default = _default;
        if nil != _default{
        var trait_ interface{} = _default
         trait_.(IAst).SetParent(my)
}
        my._COLON = _COLON;
        if nil != _COLON{
        var trait_ interface{} = _COLON
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *SwitchLabel2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._default{  list.Add(my._default) }
        if nil != my._COLON{  list.Add(my._COLON) }
        return list
    }

func (my *SwitchLabel2)      AcceptWithVisitor(v Visitor) { v.VisitSwitchLabel2(my)}
func (my *SwitchLabel2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitSwitchLabel2WithArg(my, o) }
func (my *SwitchLabel2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitSwitchLabel2WithResult(my) }
func (my *SwitchLabel2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitSwitchLabel2WithResultArgument(my, o) }


func AnyCastToSwitchLabel2(i interface{}) *SwitchLabel2 {
	if nil == i{
		return nil
	}else{
		return i.(*SwitchLabel2)
	}
}
/**
 *<b>
*<li>Rule 326:  TryStatement ::= try Block Catches
 *</b>
 */
type TryStatement0 struct{
    *Ast
      _try *AstToken
      _Block *Block
      _Catches ICatches
}
func (my *TryStatement0)      Gettry() *AstToken{ return my._try}
func (my *TryStatement0)      Settry( _try *AstToken)  { my._try = _try }
func (my *TryStatement0)      GetBlock() *Block{ return my._Block}
func (my *TryStatement0)      SetBlock( _Block *Block)  { my._Block = _Block }
func (my *TryStatement0)      GetCatches() ICatches{ return my._Catches}
func (my *TryStatement0)      SetCatches( _Catches ICatches)  { my._Catches = _Catches }

func NewTryStatement0(leftIToken IToken, rightIToken IToken ,
              _try *AstToken,
              _Block *Block,
              _Catches ICatches)*TryStatement0{
      my := new(TryStatement0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._try = _try;
        if nil != _try{
        var trait_ interface{} = _try
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my._Catches = _Catches;
        if nil != _Catches{
        var trait_ interface{} = _Catches
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TryStatement0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._try{  list.Add(my._try) }
        if nil != my._Block{  list.Add(my._Block) }
        if nil != my._Catches{  list.Add(my._Catches) }
        return list
    }

func (my *TryStatement0)      AcceptWithVisitor(v Visitor) { v.VisitTryStatement0(my)}
func (my *TryStatement0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTryStatement0WithArg(my, o) }
func (my *TryStatement0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTryStatement0WithResult(my) }
func (my *TryStatement0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTryStatement0WithResultArgument(my, o) }


func AnyCastToTryStatement0(i interface{}) *TryStatement0 {
	if nil == i{
		return nil
	}else{
		return i.(*TryStatement0)
	}
}
/**
 *<b>
*<li>Rule 327:  TryStatement ::= try Block Catchesopt Finally
 *</b>
 */
type TryStatement1 struct{
    *Ast
      _try *AstToken
      _Block *Block
      _Catchesopt ICatchesopt
      _Finally *Finally
}
func (my *TryStatement1)      Gettry() *AstToken{ return my._try}
func (my *TryStatement1)      Settry( _try *AstToken)  { my._try = _try }
func (my *TryStatement1)      GetBlock() *Block{ return my._Block}
func (my *TryStatement1)      SetBlock( _Block *Block)  { my._Block = _Block }
    /**
     * The value returned by <b>GetCatchesopt</b> may be <b>null</b>
     */
func (my *TryStatement1)      GetCatchesopt() ICatchesopt{ return my._Catchesopt}
func (my *TryStatement1)      SetCatchesopt( _Catchesopt ICatchesopt)  { my._Catchesopt = _Catchesopt }
func (my *TryStatement1)      GetFinally() *Finally{ return my._Finally}
func (my *TryStatement1)      SetFinally( _Finally *Finally)  { my._Finally = _Finally }

func NewTryStatement1(leftIToken IToken, rightIToken IToken ,
              _try *AstToken,
              _Block *Block,
              _Catchesopt ICatchesopt,
              _Finally *Finally)*TryStatement1{
      my := new(TryStatement1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._try = _try;
        if nil != _try{
        var trait_ interface{} = _try
         trait_.(IAst).SetParent(my)
}
        my._Block = _Block;
        if nil != _Block{
        var trait_ interface{} = _Block
         trait_.(IAst).SetParent(my)
}
        my._Catchesopt = _Catchesopt;
        if nil != _Catchesopt{
        var trait_ interface{} = _Catchesopt
         trait_.(IAst).SetParent(my)
}
        my._Finally = _Finally;
        if nil != _Finally{
        var trait_ interface{} = _Finally
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *TryStatement1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._try{  list.Add(my._try) }
        if nil != my._Block{  list.Add(my._Block) }
        if nil != my._Catchesopt{  list.Add(my._Catchesopt) }
        if nil != my._Finally{  list.Add(my._Finally) }
        return list
    }

func (my *TryStatement1)      AcceptWithVisitor(v Visitor) { v.VisitTryStatement1(my)}
func (my *TryStatement1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitTryStatement1WithArg(my, o) }
func (my *TryStatement1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitTryStatement1WithResult(my) }
func (my *TryStatement1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitTryStatement1WithResultArgument(my, o) }


func AnyCastToTryStatement1(i interface{}) *TryStatement1 {
	if nil == i{
		return nil
	}else{
		return i.(*TryStatement1)
	}
}
/**
 *<b>
*<li>Rule 335:  PrimaryNoNewArray ::= Type . class
 *</b>
 */
type PrimaryNoNewArray0 struct{
    *Ast
      _Type IType
      _DOT *AstToken
      _class *AstToken
}
func (my *PrimaryNoNewArray0)      GetType() IType{ return my._Type}
func (my *PrimaryNoNewArray0)      SetType( _Type IType)  { my._Type = _Type }
func (my *PrimaryNoNewArray0)      GetDOT() *AstToken{ return my._DOT}
func (my *PrimaryNoNewArray0)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PrimaryNoNewArray0)      Getclass() *AstToken{ return my._class}
func (my *PrimaryNoNewArray0)      Setclass( _class *AstToken)  { my._class = _class }

func NewPrimaryNoNewArray0(leftIToken IToken, rightIToken IToken ,
              _Type IType,
              _DOT *AstToken,
              _class *AstToken)*PrimaryNoNewArray0{
      my := new(PrimaryNoNewArray0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Type = _Type;
        if nil != _Type{
        var trait_ interface{} = _Type
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._class = _class;
        if nil != _class{
        var trait_ interface{} = _class
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PrimaryNoNewArray0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Type{  list.Add(my._Type) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._class{  list.Add(my._class) }
        return list
    }

func (my *PrimaryNoNewArray0)      AcceptWithVisitor(v Visitor) { v.VisitPrimaryNoNewArray0(my)}
func (my *PrimaryNoNewArray0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPrimaryNoNewArray0WithArg(my, o) }
func (my *PrimaryNoNewArray0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPrimaryNoNewArray0WithResult(my) }
func (my *PrimaryNoNewArray0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPrimaryNoNewArray0WithResultArgument(my, o) }


func AnyCastToPrimaryNoNewArray0(i interface{}) *PrimaryNoNewArray0 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray0)
	}
}
/**
 *<b>
*<li>Rule 336:  PrimaryNoNewArray ::= void . class
 *</b>
 */
type PrimaryNoNewArray1 struct{
    *Ast
      _void *AstToken
      _DOT *AstToken
      _class *AstToken
}
func (my *PrimaryNoNewArray1)      Getvoid() *AstToken{ return my._void}
func (my *PrimaryNoNewArray1)      Setvoid( _void *AstToken)  { my._void = _void }
func (my *PrimaryNoNewArray1)      GetDOT() *AstToken{ return my._DOT}
func (my *PrimaryNoNewArray1)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PrimaryNoNewArray1)      Getclass() *AstToken{ return my._class}
func (my *PrimaryNoNewArray1)      Setclass( _class *AstToken)  { my._class = _class }

func NewPrimaryNoNewArray1(leftIToken IToken, rightIToken IToken ,
              _void *AstToken,
              _DOT *AstToken,
              _class *AstToken)*PrimaryNoNewArray1{
      my := new(PrimaryNoNewArray1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._void = _void;
        if nil != _void{
        var trait_ interface{} = _void
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._class = _class;
        if nil != _class{
        var trait_ interface{} = _class
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PrimaryNoNewArray1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._void{  list.Add(my._void) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._class{  list.Add(my._class) }
        return list
    }

func (my *PrimaryNoNewArray1)      AcceptWithVisitor(v Visitor) { v.VisitPrimaryNoNewArray1(my)}
func (my *PrimaryNoNewArray1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPrimaryNoNewArray1WithArg(my, o) }
func (my *PrimaryNoNewArray1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPrimaryNoNewArray1WithResult(my) }
func (my *PrimaryNoNewArray1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPrimaryNoNewArray1WithResultArgument(my, o) }


func AnyCastToPrimaryNoNewArray1(i interface{}) *PrimaryNoNewArray1 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray1)
	}
}
/**
 *<b>
*<li>Rule 337:  PrimaryNoNewArray ::= this
 *</b>
 */
type PrimaryNoNewArray2 struct{
    *AstToken
}
func (my *PrimaryNoNewArray2)      Getthis()IToken{ return my.leftIToken; }

func NewPrimaryNoNewArray2(token IToken )*PrimaryNoNewArray2{
      my := new(PrimaryNoNewArray2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *PrimaryNoNewArray2)      AcceptWithVisitor(v Visitor) { v.VisitPrimaryNoNewArray2(my)}
func (my *PrimaryNoNewArray2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPrimaryNoNewArray2WithArg(my, o) }
func (my *PrimaryNoNewArray2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPrimaryNoNewArray2WithResult(my) }
func (my *PrimaryNoNewArray2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPrimaryNoNewArray2WithResultArgument(my, o) }


func AnyCastToPrimaryNoNewArray2(i interface{}) *PrimaryNoNewArray2 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray2)
	}
}
/**
 *<b>
*<li>Rule 338:  PrimaryNoNewArray ::= ClassName . this
 *</b>
 */
type PrimaryNoNewArray3 struct{
    *Ast
      _ClassName IClassName
      _DOT *AstToken
      _this *AstToken
}
func (my *PrimaryNoNewArray3)      GetClassName() IClassName{ return my._ClassName}
func (my *PrimaryNoNewArray3)      SetClassName( _ClassName IClassName)  { my._ClassName = _ClassName }
func (my *PrimaryNoNewArray3)      GetDOT() *AstToken{ return my._DOT}
func (my *PrimaryNoNewArray3)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *PrimaryNoNewArray3)      Getthis() *AstToken{ return my._this}
func (my *PrimaryNoNewArray3)      Setthis( _this *AstToken)  { my._this = _this }

func NewPrimaryNoNewArray3(leftIToken IToken, rightIToken IToken ,
              _ClassName IClassName,
              _DOT *AstToken,
              _this *AstToken)*PrimaryNoNewArray3{
      my := new(PrimaryNoNewArray3)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassName = _ClassName;
        if nil != _ClassName{
        var trait_ interface{} = _ClassName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._this = _this;
        if nil != _this{
        var trait_ interface{} = _this
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PrimaryNoNewArray3)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassName{  list.Add(my._ClassName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._this{  list.Add(my._this) }
        return list
    }

func (my *PrimaryNoNewArray3)      AcceptWithVisitor(v Visitor) { v.VisitPrimaryNoNewArray3(my)}
func (my *PrimaryNoNewArray3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPrimaryNoNewArray3WithArg(my, o) }
func (my *PrimaryNoNewArray3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPrimaryNoNewArray3WithResult(my) }
func (my *PrimaryNoNewArray3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPrimaryNoNewArray3WithResultArgument(my, o) }


func AnyCastToPrimaryNoNewArray3(i interface{}) *PrimaryNoNewArray3 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray3)
	}
}
/**
 *<b>
*<li>Rule 339:  PrimaryNoNewArray ::= ( Expression )
 *</b>
 */
type PrimaryNoNewArray4 struct{
    *Ast
      _LPAREN *AstToken
      _Expression IExpression
      _RPAREN *AstToken
}
func (my *PrimaryNoNewArray4)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *PrimaryNoNewArray4)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *PrimaryNoNewArray4)      GetExpression() IExpression{ return my._Expression}
func (my *PrimaryNoNewArray4)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *PrimaryNoNewArray4)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *PrimaryNoNewArray4)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewPrimaryNoNewArray4(leftIToken IToken, rightIToken IToken ,
              _LPAREN *AstToken,
              _Expression IExpression,
              _RPAREN *AstToken)*PrimaryNoNewArray4{
      my := new(PrimaryNoNewArray4)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *PrimaryNoNewArray4)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *PrimaryNoNewArray4)      AcceptWithVisitor(v Visitor) { v.VisitPrimaryNoNewArray4(my)}
func (my *PrimaryNoNewArray4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitPrimaryNoNewArray4WithArg(my, o) }
func (my *PrimaryNoNewArray4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitPrimaryNoNewArray4WithResult(my) }
func (my *PrimaryNoNewArray4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitPrimaryNoNewArray4WithResultArgument(my, o) }


func AnyCastToPrimaryNoNewArray4(i interface{}) *PrimaryNoNewArray4 {
	if nil == i{
		return nil
	}else{
		return i.(*PrimaryNoNewArray4)
	}
}
/**
 *<b>
*<li>Rule 344:  Literal ::= IntegerLiteral
 *</b>
 */
type Literal0 struct{
    *AstToken
}
func (my *Literal0)      GetIntegerLiteral()IToken{ return my.leftIToken; }

func NewLiteral0(token IToken )*Literal0{
      my := new(Literal0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal0)      AcceptWithVisitor(v Visitor) { v.VisitLiteral0(my)}
func (my *Literal0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLiteral0WithArg(my, o) }
func (my *Literal0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLiteral0WithResult(my) }
func (my *Literal0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLiteral0WithResultArgument(my, o) }


func AnyCastToLiteral0(i interface{}) *Literal0 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal0)
	}
}
/**
 *<b>
*<li>Rule 345:  Literal ::= LongLiteral
 *</b>
 */
type Literal1 struct{
    *AstToken
}
func (my *Literal1)      GetLongLiteral()IToken{ return my.leftIToken; }

func NewLiteral1(token IToken )*Literal1{
      my := new(Literal1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal1)      AcceptWithVisitor(v Visitor) { v.VisitLiteral1(my)}
func (my *Literal1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLiteral1WithArg(my, o) }
func (my *Literal1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLiteral1WithResult(my) }
func (my *Literal1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLiteral1WithResultArgument(my, o) }


func AnyCastToLiteral1(i interface{}) *Literal1 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal1)
	}
}
/**
 *<b>
*<li>Rule 346:  Literal ::= FloatingPointLiteral
 *</b>
 */
type Literal2 struct{
    *AstToken
}
func (my *Literal2)      GetFloatingPointLiteral()IToken{ return my.leftIToken; }

func NewLiteral2(token IToken )*Literal2{
      my := new(Literal2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal2)      AcceptWithVisitor(v Visitor) { v.VisitLiteral2(my)}
func (my *Literal2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLiteral2WithArg(my, o) }
func (my *Literal2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLiteral2WithResult(my) }
func (my *Literal2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLiteral2WithResultArgument(my, o) }


func AnyCastToLiteral2(i interface{}) *Literal2 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal2)
	}
}
/**
 *<b>
*<li>Rule 347:  Literal ::= DoubleLiteral
 *</b>
 */
type Literal3 struct{
    *AstToken
}
func (my *Literal3)      GetDoubleLiteral()IToken{ return my.leftIToken; }

func NewLiteral3(token IToken )*Literal3{
      my := new(Literal3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal3)      AcceptWithVisitor(v Visitor) { v.VisitLiteral3(my)}
func (my *Literal3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLiteral3WithArg(my, o) }
func (my *Literal3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLiteral3WithResult(my) }
func (my *Literal3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLiteral3WithResultArgument(my, o) }


func AnyCastToLiteral3(i interface{}) *Literal3 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal3)
	}
}
/**
 *<b>
*<li>Rule 349:  Literal ::= CharacterLiteral
 *</b>
 */
type Literal4 struct{
    *AstToken
}
func (my *Literal4)      GetCharacterLiteral()IToken{ return my.leftIToken; }

func NewLiteral4(token IToken )*Literal4{
      my := new(Literal4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal4)      AcceptWithVisitor(v Visitor) { v.VisitLiteral4(my)}
func (my *Literal4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLiteral4WithArg(my, o) }
func (my *Literal4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLiteral4WithResult(my) }
func (my *Literal4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLiteral4WithResultArgument(my, o) }


func AnyCastToLiteral4(i interface{}) *Literal4 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal4)
	}
}
/**
 *<b>
*<li>Rule 350:  Literal ::= StringLiteral
 *</b>
 */
type Literal5 struct{
    *AstToken
}
func (my *Literal5)      GetStringLiteral()IToken{ return my.leftIToken; }

func NewLiteral5(token IToken )*Literal5{
      my := new(Literal5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal5)      AcceptWithVisitor(v Visitor) { v.VisitLiteral5(my)}
func (my *Literal5)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLiteral5WithArg(my, o) }
func (my *Literal5)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLiteral5WithResult(my) }
func (my *Literal5)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLiteral5WithResultArgument(my, o) }


func AnyCastToLiteral5(i interface{}) *Literal5 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal5)
	}
}
/**
 *<b>
*<li>Rule 351:  Literal ::= null
 *</b>
 */
type Literal6 struct{
    *AstToken
}
func (my *Literal6)      Getnull()IToken{ return my.leftIToken; }

func NewLiteral6(token IToken )*Literal6{
      my := new(Literal6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *Literal6)      AcceptWithVisitor(v Visitor) { v.VisitLiteral6(my)}
func (my *Literal6)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitLiteral6WithArg(my, o) }
func (my *Literal6)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitLiteral6WithResult(my) }
func (my *Literal6)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitLiteral6WithResultArgument(my, o) }


func AnyCastToLiteral6(i interface{}) *Literal6 {
	if nil == i{
		return nil
	}else{
		return i.(*Literal6)
	}
}
/**
 *<b>
*<li>Rule 352:  BooleanLiteral ::= true
 *</b>
 */
type BooleanLiteral0 struct{
    *AstToken
}
func (my *BooleanLiteral0)      Gettrue()IToken{ return my.leftIToken; }

func NewBooleanLiteral0(token IToken )*BooleanLiteral0{
      my := new(BooleanLiteral0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *BooleanLiteral0)      AcceptWithVisitor(v Visitor) { v.VisitBooleanLiteral0(my)}
func (my *BooleanLiteral0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitBooleanLiteral0WithArg(my, o) }
func (my *BooleanLiteral0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitBooleanLiteral0WithResult(my) }
func (my *BooleanLiteral0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitBooleanLiteral0WithResultArgument(my, o) }


func AnyCastToBooleanLiteral0(i interface{}) *BooleanLiteral0 {
	if nil == i{
		return nil
	}else{
		return i.(*BooleanLiteral0)
	}
}
/**
 *<b>
*<li>Rule 353:  BooleanLiteral ::= false
 *</b>
 */
type BooleanLiteral1 struct{
    *AstToken
}
func (my *BooleanLiteral1)      Getfalse()IToken{ return my.leftIToken; }

func NewBooleanLiteral1(token IToken )*BooleanLiteral1{
      my := new(BooleanLiteral1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *BooleanLiteral1)      AcceptWithVisitor(v Visitor) { v.VisitBooleanLiteral1(my)}
func (my *BooleanLiteral1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitBooleanLiteral1WithArg(my, o) }
func (my *BooleanLiteral1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitBooleanLiteral1WithResult(my) }
func (my *BooleanLiteral1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitBooleanLiteral1WithResultArgument(my, o) }


func AnyCastToBooleanLiteral1(i interface{}) *BooleanLiteral1 {
	if nil == i{
		return nil
	}else{
		return i.(*BooleanLiteral1)
	}
}
/**
 *<b>
*<li>Rule 354:  ClassInstanceCreationExpression ::= new TypeArgumentsopt ClassOrInterfaceType TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
 *</b>
 */
type ClassInstanceCreationExpression0 struct{
    *Ast
      _new *AstToken
      _TypeArgumentsopt *TypeArguments
      _ClassOrInterfaceType *ClassType
      _TypeArgumentsopt4 *TypeArguments
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _ClassBodyopt *ClassBody
}
func (my *ClassInstanceCreationExpression0)      Getnew() *AstToken{ return my._new}
func (my *ClassInstanceCreationExpression0)      Setnew( _new *AstToken)  { my._new = _new }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression0)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ClassInstanceCreationExpression0)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ClassInstanceCreationExpression0)      GetClassOrInterfaceType() *ClassType{ return my._ClassOrInterfaceType}
func (my *ClassInstanceCreationExpression0)      SetClassOrInterfaceType( _ClassOrInterfaceType *ClassType)  { my._ClassOrInterfaceType = _ClassOrInterfaceType }
    /**
     * The value returned by <b>GetTypeArgumentsopt4</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression0)      GetTypeArgumentsopt4() *TypeArguments{ return my._TypeArgumentsopt4}
func (my *ClassInstanceCreationExpression0)      SetTypeArgumentsopt4( _TypeArgumentsopt4 *TypeArguments)  { my._TypeArgumentsopt4 = _TypeArgumentsopt4 }
func (my *ClassInstanceCreationExpression0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ClassInstanceCreationExpression0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression0)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ClassInstanceCreationExpression0)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ClassInstanceCreationExpression0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ClassInstanceCreationExpression0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
    /**
     * The value returned by <b>GetClassBodyopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression0)      GetClassBodyopt() *ClassBody{ return my._ClassBodyopt}
func (my *ClassInstanceCreationExpression0)      SetClassBodyopt( _ClassBodyopt *ClassBody)  { my._ClassBodyopt = _ClassBodyopt }

func NewClassInstanceCreationExpression0(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _ClassOrInterfaceType *ClassType,
              _TypeArgumentsopt4 *TypeArguments,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _ClassBodyopt *ClassBody)*ClassInstanceCreationExpression0{
      my := new(ClassInstanceCreationExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._ClassOrInterfaceType = _ClassOrInterfaceType;
        if nil != _ClassOrInterfaceType{
        var trait_ interface{} = _ClassOrInterfaceType
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt4 = _TypeArgumentsopt4;
        if nil != _TypeArgumentsopt4{
        var trait_ interface{} = _TypeArgumentsopt4
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyopt = _ClassBodyopt;
        if nil != _ClassBodyopt{
        var trait_ interface{} = _ClassBodyopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassInstanceCreationExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._ClassOrInterfaceType{  list.Add(my._ClassOrInterfaceType) }
        if nil != my._TypeArgumentsopt4{  list.Add(my._TypeArgumentsopt4) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._ClassBodyopt{  list.Add(my._ClassBodyopt) }
        return list
    }

func (my *ClassInstanceCreationExpression0)      AcceptWithVisitor(v Visitor) { v.VisitClassInstanceCreationExpression0(my)}
func (my *ClassInstanceCreationExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassInstanceCreationExpression0WithArg(my, o) }
func (my *ClassInstanceCreationExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassInstanceCreationExpression0WithResult(my) }
func (my *ClassInstanceCreationExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassInstanceCreationExpression0WithResultArgument(my, o) }


func AnyCastToClassInstanceCreationExpression0(i interface{}) *ClassInstanceCreationExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassInstanceCreationExpression0)
	}
}
/**
 *<b>
*<li>Rule 355:  ClassInstanceCreationExpression ::= Primary . new TypeArgumentsopt identifier TypeArgumentsopt ( ArgumentListopt ) ClassBodyopt
 *</b>
 */
type ClassInstanceCreationExpression1 struct{
    *Ast
      _Primary IPrimary
      _DOT *AstToken
      _new *AstToken
      _TypeArgumentsopt *TypeArguments
      _identifier *identifier
      _TypeArgumentsopt6 *TypeArguments
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
      _ClassBodyopt *ClassBody
}
func (my *ClassInstanceCreationExpression1)      GetPrimary() IPrimary{ return my._Primary}
func (my *ClassInstanceCreationExpression1)      SetPrimary( _Primary IPrimary)  { my._Primary = _Primary }
func (my *ClassInstanceCreationExpression1)      GetDOT() *AstToken{ return my._DOT}
func (my *ClassInstanceCreationExpression1)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *ClassInstanceCreationExpression1)      Getnew() *AstToken{ return my._new}
func (my *ClassInstanceCreationExpression1)      Setnew( _new *AstToken)  { my._new = _new }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression1)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *ClassInstanceCreationExpression1)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *ClassInstanceCreationExpression1)      Getidentifier() *identifier{ return my._identifier}
func (my *ClassInstanceCreationExpression1)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
    /**
     * The value returned by <b>GetTypeArgumentsopt6</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression1)      GetTypeArgumentsopt6() *TypeArguments{ return my._TypeArgumentsopt6}
func (my *ClassInstanceCreationExpression1)      SetTypeArgumentsopt6( _TypeArgumentsopt6 *TypeArguments)  { my._TypeArgumentsopt6 = _TypeArgumentsopt6 }
func (my *ClassInstanceCreationExpression1)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *ClassInstanceCreationExpression1)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression1)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *ClassInstanceCreationExpression1)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *ClassInstanceCreationExpression1)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *ClassInstanceCreationExpression1)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
    /**
     * The value returned by <b>GetClassBodyopt</b> may be <b>null</b>
     */
func (my *ClassInstanceCreationExpression1)      GetClassBodyopt() *ClassBody{ return my._ClassBodyopt}
func (my *ClassInstanceCreationExpression1)      SetClassBodyopt( _ClassBodyopt *ClassBody)  { my._ClassBodyopt = _ClassBodyopt }

func NewClassInstanceCreationExpression1(leftIToken IToken, rightIToken IToken ,
              _Primary IPrimary,
              _DOT *AstToken,
              _new *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _identifier *identifier,
              _TypeArgumentsopt6 *TypeArguments,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken,
              _ClassBodyopt *ClassBody)*ClassInstanceCreationExpression1{
      my := new(ClassInstanceCreationExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Primary = _Primary;
        if nil != _Primary{
        var trait_ interface{} = _Primary
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt6 = _TypeArgumentsopt6;
        if nil != _TypeArgumentsopt6{
        var trait_ interface{} = _TypeArgumentsopt6
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._ClassBodyopt = _ClassBodyopt;
        if nil != _ClassBodyopt{
        var trait_ interface{} = _ClassBodyopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ClassInstanceCreationExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Primary{  list.Add(my._Primary) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._new{  list.Add(my._new) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._TypeArgumentsopt6{  list.Add(my._TypeArgumentsopt6) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._ClassBodyopt{  list.Add(my._ClassBodyopt) }
        return list
    }

func (my *ClassInstanceCreationExpression1)      AcceptWithVisitor(v Visitor) { v.VisitClassInstanceCreationExpression1(my)}
func (my *ClassInstanceCreationExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitClassInstanceCreationExpression1WithArg(my, o) }
func (my *ClassInstanceCreationExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitClassInstanceCreationExpression1WithResult(my) }
func (my *ClassInstanceCreationExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitClassInstanceCreationExpression1WithResultArgument(my, o) }


func AnyCastToClassInstanceCreationExpression1(i interface{}) *ClassInstanceCreationExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*ClassInstanceCreationExpression1)
	}
}
/**
 *<b>
*<li>Rule 358:  ArrayCreationExpression ::= new PrimitiveType DimExprs Dimsopt
 *</b>
 */
type ArrayCreationExpression0 struct{
    *Ast
      _new *AstToken
      _PrimitiveType IPrimitiveType
      _DimExprs IDimExprs
      _Dimsopt IDimsopt
}
func (my *ArrayCreationExpression0)      Getnew() *AstToken{ return my._new}
func (my *ArrayCreationExpression0)      Setnew( _new *AstToken)  { my._new = _new }
func (my *ArrayCreationExpression0)      GetPrimitiveType() IPrimitiveType{ return my._PrimitiveType}
func (my *ArrayCreationExpression0)      SetPrimitiveType( _PrimitiveType IPrimitiveType)  { my._PrimitiveType = _PrimitiveType }
func (my *ArrayCreationExpression0)      GetDimExprs() IDimExprs{ return my._DimExprs}
func (my *ArrayCreationExpression0)      SetDimExprs( _DimExprs IDimExprs)  { my._DimExprs = _DimExprs }
    /**
     * The value returned by <b>GetDimsopt</b> may be <b>null</b>
     */
func (my *ArrayCreationExpression0)      GetDimsopt() IDimsopt{ return my._Dimsopt}
func (my *ArrayCreationExpression0)      SetDimsopt( _Dimsopt IDimsopt)  { my._Dimsopt = _Dimsopt }

func NewArrayCreationExpression0(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _PrimitiveType IPrimitiveType,
              _DimExprs IDimExprs,
              _Dimsopt IDimsopt)*ArrayCreationExpression0{
      my := new(ArrayCreationExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._PrimitiveType = _PrimitiveType;
        if nil != _PrimitiveType{
        var trait_ interface{} = _PrimitiveType
         trait_.(IAst).SetParent(my)
}
        my._DimExprs = _DimExprs;
        if nil != _DimExprs{
        var trait_ interface{} = _DimExprs
         trait_.(IAst).SetParent(my)
}
        my._Dimsopt = _Dimsopt;
        if nil != _Dimsopt{
        var trait_ interface{} = _Dimsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayCreationExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._PrimitiveType{  list.Add(my._PrimitiveType) }
        if nil != my._DimExprs{  list.Add(my._DimExprs) }
        if nil != my._Dimsopt{  list.Add(my._Dimsopt) }
        return list
    }

func (my *ArrayCreationExpression0)      AcceptWithVisitor(v Visitor) { v.VisitArrayCreationExpression0(my)}
func (my *ArrayCreationExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArrayCreationExpression0WithArg(my, o) }
func (my *ArrayCreationExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArrayCreationExpression0WithResult(my) }
func (my *ArrayCreationExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArrayCreationExpression0WithResultArgument(my, o) }


func AnyCastToArrayCreationExpression0(i interface{}) *ArrayCreationExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayCreationExpression0)
	}
}
/**
 *<b>
*<li>Rule 359:  ArrayCreationExpression ::= new ClassOrInterfaceType DimExprs Dimsopt
 *</b>
 */
type ArrayCreationExpression1 struct{
    *Ast
      _new *AstToken
      _ClassOrInterfaceType *ClassType
      _DimExprs IDimExprs
      _Dimsopt IDimsopt
}
func (my *ArrayCreationExpression1)      Getnew() *AstToken{ return my._new}
func (my *ArrayCreationExpression1)      Setnew( _new *AstToken)  { my._new = _new }
func (my *ArrayCreationExpression1)      GetClassOrInterfaceType() *ClassType{ return my._ClassOrInterfaceType}
func (my *ArrayCreationExpression1)      SetClassOrInterfaceType( _ClassOrInterfaceType *ClassType)  { my._ClassOrInterfaceType = _ClassOrInterfaceType }
func (my *ArrayCreationExpression1)      GetDimExprs() IDimExprs{ return my._DimExprs}
func (my *ArrayCreationExpression1)      SetDimExprs( _DimExprs IDimExprs)  { my._DimExprs = _DimExprs }
    /**
     * The value returned by <b>GetDimsopt</b> may be <b>null</b>
     */
func (my *ArrayCreationExpression1)      GetDimsopt() IDimsopt{ return my._Dimsopt}
func (my *ArrayCreationExpression1)      SetDimsopt( _Dimsopt IDimsopt)  { my._Dimsopt = _Dimsopt }

func NewArrayCreationExpression1(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _ClassOrInterfaceType *ClassType,
              _DimExprs IDimExprs,
              _Dimsopt IDimsopt)*ArrayCreationExpression1{
      my := new(ArrayCreationExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._ClassOrInterfaceType = _ClassOrInterfaceType;
        if nil != _ClassOrInterfaceType{
        var trait_ interface{} = _ClassOrInterfaceType
         trait_.(IAst).SetParent(my)
}
        my._DimExprs = _DimExprs;
        if nil != _DimExprs{
        var trait_ interface{} = _DimExprs
         trait_.(IAst).SetParent(my)
}
        my._Dimsopt = _Dimsopt;
        if nil != _Dimsopt{
        var trait_ interface{} = _Dimsopt
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayCreationExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._ClassOrInterfaceType{  list.Add(my._ClassOrInterfaceType) }
        if nil != my._DimExprs{  list.Add(my._DimExprs) }
        if nil != my._Dimsopt{  list.Add(my._Dimsopt) }
        return list
    }

func (my *ArrayCreationExpression1)      AcceptWithVisitor(v Visitor) { v.VisitArrayCreationExpression1(my)}
func (my *ArrayCreationExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArrayCreationExpression1WithArg(my, o) }
func (my *ArrayCreationExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArrayCreationExpression1WithResult(my) }
func (my *ArrayCreationExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArrayCreationExpression1WithResultArgument(my, o) }


func AnyCastToArrayCreationExpression1(i interface{}) *ArrayCreationExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayCreationExpression1)
	}
}
/**
 *<b>
*<li>Rule 360:  ArrayCreationExpression ::= new PrimitiveType Dims ArrayInitializer
 *</b>
 */
type ArrayCreationExpression2 struct{
    *Ast
      _new *AstToken
      _PrimitiveType IPrimitiveType
      _Dims IDims
      _ArrayInitializer *ArrayInitializer
}
func (my *ArrayCreationExpression2)      Getnew() *AstToken{ return my._new}
func (my *ArrayCreationExpression2)      Setnew( _new *AstToken)  { my._new = _new }
func (my *ArrayCreationExpression2)      GetPrimitiveType() IPrimitiveType{ return my._PrimitiveType}
func (my *ArrayCreationExpression2)      SetPrimitiveType( _PrimitiveType IPrimitiveType)  { my._PrimitiveType = _PrimitiveType }
func (my *ArrayCreationExpression2)      GetDims() IDims{ return my._Dims}
func (my *ArrayCreationExpression2)      SetDims( _Dims IDims)  { my._Dims = _Dims }
func (my *ArrayCreationExpression2)      GetArrayInitializer() *ArrayInitializer{ return my._ArrayInitializer}
func (my *ArrayCreationExpression2)      SetArrayInitializer( _ArrayInitializer *ArrayInitializer)  { my._ArrayInitializer = _ArrayInitializer }

func NewArrayCreationExpression2(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _PrimitiveType IPrimitiveType,
              _Dims IDims,
              _ArrayInitializer *ArrayInitializer)*ArrayCreationExpression2{
      my := new(ArrayCreationExpression2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._PrimitiveType = _PrimitiveType;
        if nil != _PrimitiveType{
        var trait_ interface{} = _PrimitiveType
         trait_.(IAst).SetParent(my)
}
        my._Dims = _Dims;
        if nil != _Dims{
        var trait_ interface{} = _Dims
         trait_.(IAst).SetParent(my)
}
        my._ArrayInitializer = _ArrayInitializer;
        if nil != _ArrayInitializer{
        var trait_ interface{} = _ArrayInitializer
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayCreationExpression2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._PrimitiveType{  list.Add(my._PrimitiveType) }
        if nil != my._Dims{  list.Add(my._Dims) }
        if nil != my._ArrayInitializer{  list.Add(my._ArrayInitializer) }
        return list
    }

func (my *ArrayCreationExpression2)      AcceptWithVisitor(v Visitor) { v.VisitArrayCreationExpression2(my)}
func (my *ArrayCreationExpression2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArrayCreationExpression2WithArg(my, o) }
func (my *ArrayCreationExpression2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArrayCreationExpression2WithResult(my) }
func (my *ArrayCreationExpression2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArrayCreationExpression2WithResultArgument(my, o) }


func AnyCastToArrayCreationExpression2(i interface{}) *ArrayCreationExpression2 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayCreationExpression2)
	}
}
/**
 *<b>
*<li>Rule 361:  ArrayCreationExpression ::= new ClassOrInterfaceType Dims ArrayInitializer
 *</b>
 */
type ArrayCreationExpression3 struct{
    *Ast
      _new *AstToken
      _ClassOrInterfaceType *ClassType
      _Dims IDims
      _ArrayInitializer *ArrayInitializer
}
func (my *ArrayCreationExpression3)      Getnew() *AstToken{ return my._new}
func (my *ArrayCreationExpression3)      Setnew( _new *AstToken)  { my._new = _new }
func (my *ArrayCreationExpression3)      GetClassOrInterfaceType() *ClassType{ return my._ClassOrInterfaceType}
func (my *ArrayCreationExpression3)      SetClassOrInterfaceType( _ClassOrInterfaceType *ClassType)  { my._ClassOrInterfaceType = _ClassOrInterfaceType }
func (my *ArrayCreationExpression3)      GetDims() IDims{ return my._Dims}
func (my *ArrayCreationExpression3)      SetDims( _Dims IDims)  { my._Dims = _Dims }
func (my *ArrayCreationExpression3)      GetArrayInitializer() *ArrayInitializer{ return my._ArrayInitializer}
func (my *ArrayCreationExpression3)      SetArrayInitializer( _ArrayInitializer *ArrayInitializer)  { my._ArrayInitializer = _ArrayInitializer }

func NewArrayCreationExpression3(leftIToken IToken, rightIToken IToken ,
              _new *AstToken,
              _ClassOrInterfaceType *ClassType,
              _Dims IDims,
              _ArrayInitializer *ArrayInitializer)*ArrayCreationExpression3{
      my := new(ArrayCreationExpression3)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._new = _new;
        if nil != _new{
        var trait_ interface{} = _new
         trait_.(IAst).SetParent(my)
}
        my._ClassOrInterfaceType = _ClassOrInterfaceType;
        if nil != _ClassOrInterfaceType{
        var trait_ interface{} = _ClassOrInterfaceType
         trait_.(IAst).SetParent(my)
}
        my._Dims = _Dims;
        if nil != _Dims{
        var trait_ interface{} = _Dims
         trait_.(IAst).SetParent(my)
}
        my._ArrayInitializer = _ArrayInitializer;
        if nil != _ArrayInitializer{
        var trait_ interface{} = _ArrayInitializer
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayCreationExpression3)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._new{  list.Add(my._new) }
        if nil != my._ClassOrInterfaceType{  list.Add(my._ClassOrInterfaceType) }
        if nil != my._Dims{  list.Add(my._Dims) }
        if nil != my._ArrayInitializer{  list.Add(my._ArrayInitializer) }
        return list
    }

func (my *ArrayCreationExpression3)      AcceptWithVisitor(v Visitor) { v.VisitArrayCreationExpression3(my)}
func (my *ArrayCreationExpression3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArrayCreationExpression3WithArg(my, o) }
func (my *ArrayCreationExpression3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArrayCreationExpression3WithResult(my) }
func (my *ArrayCreationExpression3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArrayCreationExpression3WithResultArgument(my, o) }


func AnyCastToArrayCreationExpression3(i interface{}) *ArrayCreationExpression3 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayCreationExpression3)
	}
}
/**
 *<b>
*<li>Rule 365:  Dims ::= [ ]
 *</b>
 */
type Dims0 struct{
    *Ast
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *Dims0)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *Dims0)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *Dims0)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *Dims0)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewDims0(leftIToken IToken, rightIToken IToken ,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*Dims0{
      my := new(Dims0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Dims0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *Dims0)      AcceptWithVisitor(v Visitor) { v.VisitDims0(my)}
func (my *Dims0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitDims0WithArg(my, o) }
func (my *Dims0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitDims0WithResult(my) }
func (my *Dims0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitDims0WithResultArgument(my, o) }


func AnyCastToDims0(i interface{}) *Dims0 {
	if nil == i{
		return nil
	}else{
		return i.(*Dims0)
	}
}
/**
 *<b>
*<li>Rule 366:  Dims ::= Dims [ ]
 *</b>
 */
type Dims1 struct{
    *Ast
      _Dims IDims
      _LBRACKET *AstToken
      _RBRACKET *AstToken
}
func (my *Dims1)      GetDims() IDims{ return my._Dims}
func (my *Dims1)      SetDims( _Dims IDims)  { my._Dims = _Dims }
func (my *Dims1)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *Dims1)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *Dims1)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *Dims1)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewDims1(leftIToken IToken, rightIToken IToken ,
              _Dims IDims,
              _LBRACKET *AstToken,
              _RBRACKET *AstToken)*Dims1{
      my := new(Dims1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Dims = _Dims;
        if nil != _Dims{
        var trait_ interface{} = _Dims
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *Dims1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Dims{  list.Add(my._Dims) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *Dims1)      AcceptWithVisitor(v Visitor) { v.VisitDims1(my)}
func (my *Dims1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitDims1WithArg(my, o) }
func (my *Dims1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitDims1WithResult(my) }
func (my *Dims1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitDims1WithResultArgument(my, o) }


func AnyCastToDims1(i interface{}) *Dims1 {
	if nil == i{
		return nil
	}else{
		return i.(*Dims1)
	}
}
/**
 *<b>
*<li>Rule 367:  FieldAccess ::= Primary . identifier
 *</b>
 */
type FieldAccess0 struct{
    *Ast
      _Primary IPrimary
      _DOT *AstToken
      _identifier *identifier
}
func (my *FieldAccess0)      GetPrimary() IPrimary{ return my._Primary}
func (my *FieldAccess0)      SetPrimary( _Primary IPrimary)  { my._Primary = _Primary }
func (my *FieldAccess0)      GetDOT() *AstToken{ return my._DOT}
func (my *FieldAccess0)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *FieldAccess0)      Getidentifier() *identifier{ return my._identifier}
func (my *FieldAccess0)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewFieldAccess0(leftIToken IToken, rightIToken IToken ,
              _Primary IPrimary,
              _DOT *AstToken,
              _identifier *identifier)*FieldAccess0{
      my := new(FieldAccess0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Primary = _Primary;
        if nil != _Primary{
        var trait_ interface{} = _Primary
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldAccess0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Primary{  list.Add(my._Primary) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *FieldAccess0)      AcceptWithVisitor(v Visitor) { v.VisitFieldAccess0(my)}
func (my *FieldAccess0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldAccess0WithArg(my, o) }
func (my *FieldAccess0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldAccess0WithResult(my) }
func (my *FieldAccess0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldAccess0WithResultArgument(my, o) }


func AnyCastToFieldAccess0(i interface{}) *FieldAccess0 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldAccess0)
	}
}
/**
 *<b>
*<li>Rule 368:  FieldAccess ::= super . identifier
 *</b>
 */
type FieldAccess1 struct{
    *Ast
      _super *AstToken
      _DOT *AstToken
      _identifier *identifier
}
func (my *FieldAccess1)      Getsuper() *AstToken{ return my._super}
func (my *FieldAccess1)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *FieldAccess1)      GetDOT() *AstToken{ return my._DOT}
func (my *FieldAccess1)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *FieldAccess1)      Getidentifier() *identifier{ return my._identifier}
func (my *FieldAccess1)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewFieldAccess1(leftIToken IToken, rightIToken IToken ,
              _super *AstToken,
              _DOT *AstToken,
              _identifier *identifier)*FieldAccess1{
      my := new(FieldAccess1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldAccess1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._super{  list.Add(my._super) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *FieldAccess1)      AcceptWithVisitor(v Visitor) { v.VisitFieldAccess1(my)}
func (my *FieldAccess1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldAccess1WithArg(my, o) }
func (my *FieldAccess1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldAccess1WithResult(my) }
func (my *FieldAccess1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldAccess1WithResultArgument(my, o) }


func AnyCastToFieldAccess1(i interface{}) *FieldAccess1 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldAccess1)
	}
}
/**
 *<b>
*<li>Rule 369:  FieldAccess ::= ClassName . super . identifier
 *</b>
 */
type FieldAccess2 struct{
    *Ast
      _ClassName IClassName
      _DOT *AstToken
      _super *AstToken
      _DOT4 *AstToken
      _identifier *identifier
}
func (my *FieldAccess2)      GetClassName() IClassName{ return my._ClassName}
func (my *FieldAccess2)      SetClassName( _ClassName IClassName)  { my._ClassName = _ClassName }
func (my *FieldAccess2)      GetDOT() *AstToken{ return my._DOT}
func (my *FieldAccess2)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *FieldAccess2)      Getsuper() *AstToken{ return my._super}
func (my *FieldAccess2)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *FieldAccess2)      GetDOT4() *AstToken{ return my._DOT4}
func (my *FieldAccess2)      SetDOT4( _DOT4 *AstToken)  { my._DOT4 = _DOT4 }
func (my *FieldAccess2)      Getidentifier() *identifier{ return my._identifier}
func (my *FieldAccess2)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }

func NewFieldAccess2(leftIToken IToken, rightIToken IToken ,
              _ClassName IClassName,
              _DOT *AstToken,
              _super *AstToken,
              _DOT4 *AstToken,
              _identifier *identifier)*FieldAccess2{
      my := new(FieldAccess2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassName = _ClassName;
        if nil != _ClassName{
        var trait_ interface{} = _ClassName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._DOT4 = _DOT4;
        if nil != _DOT4{
        var trait_ interface{} = _DOT4
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *FieldAccess2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassName{  list.Add(my._ClassName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._super{  list.Add(my._super) }
        if nil != my._DOT4{  list.Add(my._DOT4) }
        if nil != my._identifier{  list.Add(my._identifier) }
        return list
    }

func (my *FieldAccess2)      AcceptWithVisitor(v Visitor) { v.VisitFieldAccess2(my)}
func (my *FieldAccess2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitFieldAccess2WithArg(my, o) }
func (my *FieldAccess2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitFieldAccess2WithResult(my) }
func (my *FieldAccess2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitFieldAccess2WithResultArgument(my, o) }


func AnyCastToFieldAccess2(i interface{}) *FieldAccess2 {
	if nil == i{
		return nil
	}else{
		return i.(*FieldAccess2)
	}
}
/**
 *<b>
*<li>Rule 370:  MethodInvocation ::= MethodName ( ArgumentListopt )
 *</b>
 */
type MethodInvocation0 struct{
    *Ast
      _MethodName IMethodName
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation0)      GetMethodName() IMethodName{ return my._MethodName}
func (my *MethodInvocation0)      SetMethodName( _MethodName IMethodName)  { my._MethodName = _MethodName }
func (my *MethodInvocation0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation0)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation0)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation0(leftIToken IToken, rightIToken IToken ,
              _MethodName IMethodName,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation0{
      my := new(MethodInvocation0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MethodName = _MethodName;
        if nil != _MethodName{
        var trait_ interface{} = _MethodName
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MethodName{  list.Add(my._MethodName) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation0)      AcceptWithVisitor(v Visitor) { v.VisitMethodInvocation0(my)}
func (my *MethodInvocation0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodInvocation0WithArg(my, o) }
func (my *MethodInvocation0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodInvocation0WithResult(my) }
func (my *MethodInvocation0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodInvocation0WithResultArgument(my, o) }


func AnyCastToMethodInvocation0(i interface{}) *MethodInvocation0 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation0)
	}
}
/**
 *<b>
*<li>Rule 371:  MethodInvocation ::= Primary . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
type MethodInvocation1 struct{
    *Ast
      _Primary IPrimary
      _DOT *AstToken
      _TypeArgumentsopt *TypeArguments
      _identifier *identifier
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation1)      GetPrimary() IPrimary{ return my._Primary}
func (my *MethodInvocation1)      SetPrimary( _Primary IPrimary)  { my._Primary = _Primary }
func (my *MethodInvocation1)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodInvocation1)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *MethodInvocation1)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *MethodInvocation1)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *MethodInvocation1)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodInvocation1)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodInvocation1)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation1)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation1)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation1)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation1)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation1)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation1(leftIToken IToken, rightIToken IToken ,
              _Primary IPrimary,
              _DOT *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _identifier *identifier,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation1{
      my := new(MethodInvocation1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._Primary = _Primary;
        if nil != _Primary{
        var trait_ interface{} = _Primary
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._Primary{  list.Add(my._Primary) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation1)      AcceptWithVisitor(v Visitor) { v.VisitMethodInvocation1(my)}
func (my *MethodInvocation1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodInvocation1WithArg(my, o) }
func (my *MethodInvocation1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodInvocation1WithResult(my) }
func (my *MethodInvocation1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodInvocation1WithResultArgument(my, o) }


func AnyCastToMethodInvocation1(i interface{}) *MethodInvocation1 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation1)
	}
}
/**
 *<b>
*<li>Rule 372:  MethodInvocation ::= super . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
type MethodInvocation2 struct{
    *Ast
      _super *AstToken
      _DOT *AstToken
      _TypeArgumentsopt *TypeArguments
      _identifier *identifier
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation2)      Getsuper() *AstToken{ return my._super}
func (my *MethodInvocation2)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *MethodInvocation2)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodInvocation2)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *MethodInvocation2)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *MethodInvocation2)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *MethodInvocation2)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodInvocation2)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodInvocation2)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation2)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation2)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation2)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation2)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation2)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation2(leftIToken IToken, rightIToken IToken ,
              _super *AstToken,
              _DOT *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _identifier *identifier,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation2{
      my := new(MethodInvocation2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._super{  list.Add(my._super) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation2)      AcceptWithVisitor(v Visitor) { v.VisitMethodInvocation2(my)}
func (my *MethodInvocation2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodInvocation2WithArg(my, o) }
func (my *MethodInvocation2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodInvocation2WithResult(my) }
func (my *MethodInvocation2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodInvocation2WithResultArgument(my, o) }


func AnyCastToMethodInvocation2(i interface{}) *MethodInvocation2 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation2)
	}
}
/**
 *<b>
*<li>Rule 373:  MethodInvocation ::= ClassName . super . TypeArgumentsopt identifier ( ArgumentListopt )
 *</b>
 */
type MethodInvocation3 struct{
    *Ast
      _ClassName IClassName
      _DOT *AstToken
      _super *AstToken
      _DOT4 *AstToken
      _TypeArgumentsopt *TypeArguments
      _identifier *identifier
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation3)      GetClassName() IClassName{ return my._ClassName}
func (my *MethodInvocation3)      SetClassName( _ClassName IClassName)  { my._ClassName = _ClassName }
func (my *MethodInvocation3)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodInvocation3)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *MethodInvocation3)      Getsuper() *AstToken{ return my._super}
func (my *MethodInvocation3)      Setsuper( _super *AstToken)  { my._super = _super }
func (my *MethodInvocation3)      GetDOT4() *AstToken{ return my._DOT4}
func (my *MethodInvocation3)      SetDOT4( _DOT4 *AstToken)  { my._DOT4 = _DOT4 }
    /**
     * The value returned by <b>GetTypeArgumentsopt</b> may be <b>null</b>
     */
func (my *MethodInvocation3)      GetTypeArgumentsopt() *TypeArguments{ return my._TypeArgumentsopt}
func (my *MethodInvocation3)      SetTypeArgumentsopt( _TypeArgumentsopt *TypeArguments)  { my._TypeArgumentsopt = _TypeArgumentsopt }
func (my *MethodInvocation3)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodInvocation3)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodInvocation3)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation3)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation3)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation3)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation3)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation3)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation3(leftIToken IToken, rightIToken IToken ,
              _ClassName IClassName,
              _DOT *AstToken,
              _super *AstToken,
              _DOT4 *AstToken,
              _TypeArgumentsopt *TypeArguments,
              _identifier *identifier,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation3{
      my := new(MethodInvocation3)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ClassName = _ClassName;
        if nil != _ClassName{
        var trait_ interface{} = _ClassName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._super = _super;
        if nil != _super{
        var trait_ interface{} = _super
         trait_.(IAst).SetParent(my)
}
        my._DOT4 = _DOT4;
        if nil != _DOT4{
        var trait_ interface{} = _DOT4
         trait_.(IAst).SetParent(my)
}
        my._TypeArgumentsopt = _TypeArgumentsopt;
        if nil != _TypeArgumentsopt{
        var trait_ interface{} = _TypeArgumentsopt
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation3)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ClassName{  list.Add(my._ClassName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._super{  list.Add(my._super) }
        if nil != my._DOT4{  list.Add(my._DOT4) }
        if nil != my._TypeArgumentsopt{  list.Add(my._TypeArgumentsopt) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation3)      AcceptWithVisitor(v Visitor) { v.VisitMethodInvocation3(my)}
func (my *MethodInvocation3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodInvocation3WithArg(my, o) }
func (my *MethodInvocation3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodInvocation3WithResult(my) }
func (my *MethodInvocation3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodInvocation3WithResultArgument(my, o) }


func AnyCastToMethodInvocation3(i interface{}) *MethodInvocation3 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation3)
	}
}
/**
 *<b>
*<li>Rule 374:  MethodInvocation ::= TypeName . TypeArguments identifier ( ArgumentListopt )
 *</b>
 */
type MethodInvocation4 struct{
    *Ast
      _TypeName ITypeName
      _DOT *AstToken
      _TypeArguments *TypeArguments
      _identifier *identifier
      _LPAREN *AstToken
      _ArgumentListopt IArgumentListopt
      _RPAREN *AstToken
}
func (my *MethodInvocation4)      GetTypeName() ITypeName{ return my._TypeName}
func (my *MethodInvocation4)      SetTypeName( _TypeName ITypeName)  { my._TypeName = _TypeName }
func (my *MethodInvocation4)      GetDOT() *AstToken{ return my._DOT}
func (my *MethodInvocation4)      SetDOT( _DOT *AstToken)  { my._DOT = _DOT }
func (my *MethodInvocation4)      GetTypeArguments() *TypeArguments{ return my._TypeArguments}
func (my *MethodInvocation4)      SetTypeArguments( _TypeArguments *TypeArguments)  { my._TypeArguments = _TypeArguments }
func (my *MethodInvocation4)      Getidentifier() *identifier{ return my._identifier}
func (my *MethodInvocation4)      Setidentifier( _identifier *identifier)  { my._identifier = _identifier }
func (my *MethodInvocation4)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *MethodInvocation4)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
    /**
     * The value returned by <b>GetArgumentListopt</b> may be <b>null</b>
     */
func (my *MethodInvocation4)      GetArgumentListopt() IArgumentListopt{ return my._ArgumentListopt}
func (my *MethodInvocation4)      SetArgumentListopt( _ArgumentListopt IArgumentListopt)  { my._ArgumentListopt = _ArgumentListopt }
func (my *MethodInvocation4)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *MethodInvocation4)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }

func NewMethodInvocation4(leftIToken IToken, rightIToken IToken ,
              _TypeName ITypeName,
              _DOT *AstToken,
              _TypeArguments *TypeArguments,
              _identifier *identifier,
              _LPAREN *AstToken,
              _ArgumentListopt IArgumentListopt,
              _RPAREN *AstToken)*MethodInvocation4{
      my := new(MethodInvocation4)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TypeName = _TypeName;
        if nil != _TypeName{
        var trait_ interface{} = _TypeName
         trait_.(IAst).SetParent(my)
}
        my._DOT = _DOT;
        if nil != _DOT{
        var trait_ interface{} = _DOT
         trait_.(IAst).SetParent(my)
}
        my._TypeArguments = _TypeArguments;
        if nil != _TypeArguments{
        var trait_ interface{} = _TypeArguments
         trait_.(IAst).SetParent(my)
}
        my._identifier = _identifier;
        if nil != _identifier{
        var trait_ interface{} = _identifier
         trait_.(IAst).SetParent(my)
}
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ArgumentListopt = _ArgumentListopt;
        if nil != _ArgumentListopt{
        var trait_ interface{} = _ArgumentListopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MethodInvocation4)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TypeName{  list.Add(my._TypeName) }
        if nil != my._DOT{  list.Add(my._DOT) }
        if nil != my._TypeArguments{  list.Add(my._TypeArguments) }
        if nil != my._identifier{  list.Add(my._identifier) }
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ArgumentListopt{  list.Add(my._ArgumentListopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        return list
    }

func (my *MethodInvocation4)      AcceptWithVisitor(v Visitor) { v.VisitMethodInvocation4(my)}
func (my *MethodInvocation4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMethodInvocation4WithArg(my, o) }
func (my *MethodInvocation4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMethodInvocation4WithResult(my) }
func (my *MethodInvocation4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMethodInvocation4WithResultArgument(my, o) }


func AnyCastToMethodInvocation4(i interface{}) *MethodInvocation4 {
	if nil == i{
		return nil
	}else{
		return i.(*MethodInvocation4)
	}
}
/**
 *<b>
*<li>Rule 375:  ArrayAccess ::= ExpressionName [ Expression ]
 *</b>
 */
type ArrayAccess0 struct{
    *Ast
      _ExpressionName IExpressionName
      _LBRACKET *AstToken
      _Expression IExpression
      _RBRACKET *AstToken
}
func (my *ArrayAccess0)      GetExpressionName() IExpressionName{ return my._ExpressionName}
func (my *ArrayAccess0)      SetExpressionName( _ExpressionName IExpressionName)  { my._ExpressionName = _ExpressionName }
func (my *ArrayAccess0)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *ArrayAccess0)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *ArrayAccess0)      GetExpression() IExpression{ return my._Expression}
func (my *ArrayAccess0)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *ArrayAccess0)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *ArrayAccess0)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewArrayAccess0(leftIToken IToken, rightIToken IToken ,
              _ExpressionName IExpressionName,
              _LBRACKET *AstToken,
              _Expression IExpression,
              _RBRACKET *AstToken)*ArrayAccess0{
      my := new(ArrayAccess0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ExpressionName = _ExpressionName;
        if nil != _ExpressionName{
        var trait_ interface{} = _ExpressionName
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayAccess0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ExpressionName{  list.Add(my._ExpressionName) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *ArrayAccess0)      AcceptWithVisitor(v Visitor) { v.VisitArrayAccess0(my)}
func (my *ArrayAccess0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArrayAccess0WithArg(my, o) }
func (my *ArrayAccess0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArrayAccess0WithResult(my) }
func (my *ArrayAccess0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArrayAccess0WithResultArgument(my, o) }


func AnyCastToArrayAccess0(i interface{}) *ArrayAccess0 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayAccess0)
	}
}
/**
 *<b>
*<li>Rule 376:  ArrayAccess ::= PrimaryNoNewArray [ Expression ]
 *</b>
 */
type ArrayAccess1 struct{
    *Ast
      _PrimaryNoNewArray IPrimaryNoNewArray
      _LBRACKET *AstToken
      _Expression IExpression
      _RBRACKET *AstToken
}
func (my *ArrayAccess1)      GetPrimaryNoNewArray() IPrimaryNoNewArray{ return my._PrimaryNoNewArray}
func (my *ArrayAccess1)      SetPrimaryNoNewArray( _PrimaryNoNewArray IPrimaryNoNewArray)  { my._PrimaryNoNewArray = _PrimaryNoNewArray }
func (my *ArrayAccess1)      GetLBRACKET() *AstToken{ return my._LBRACKET}
func (my *ArrayAccess1)      SetLBRACKET( _LBRACKET *AstToken)  { my._LBRACKET = _LBRACKET }
func (my *ArrayAccess1)      GetExpression() IExpression{ return my._Expression}
func (my *ArrayAccess1)      SetExpression( _Expression IExpression)  { my._Expression = _Expression }
func (my *ArrayAccess1)      GetRBRACKET() *AstToken{ return my._RBRACKET}
func (my *ArrayAccess1)      SetRBRACKET( _RBRACKET *AstToken)  { my._RBRACKET = _RBRACKET }

func NewArrayAccess1(leftIToken IToken, rightIToken IToken ,
              _PrimaryNoNewArray IPrimaryNoNewArray,
              _LBRACKET *AstToken,
              _Expression IExpression,
              _RBRACKET *AstToken)*ArrayAccess1{
      my := new(ArrayAccess1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PrimaryNoNewArray = _PrimaryNoNewArray;
        if nil != _PrimaryNoNewArray{
        var trait_ interface{} = _PrimaryNoNewArray
         trait_.(IAst).SetParent(my)
}
        my._LBRACKET = _LBRACKET;
        if nil != _LBRACKET{
        var trait_ interface{} = _LBRACKET
         trait_.(IAst).SetParent(my)
}
        my._Expression = _Expression;
        if nil != _Expression{
        var trait_ interface{} = _Expression
         trait_.(IAst).SetParent(my)
}
        my._RBRACKET = _RBRACKET;
        if nil != _RBRACKET{
        var trait_ interface{} = _RBRACKET
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ArrayAccess1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PrimaryNoNewArray{  list.Add(my._PrimaryNoNewArray) }
        if nil != my._LBRACKET{  list.Add(my._LBRACKET) }
        if nil != my._Expression{  list.Add(my._Expression) }
        if nil != my._RBRACKET{  list.Add(my._RBRACKET) }
        return list
    }

func (my *ArrayAccess1)      AcceptWithVisitor(v Visitor) { v.VisitArrayAccess1(my)}
func (my *ArrayAccess1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitArrayAccess1WithArg(my, o) }
func (my *ArrayAccess1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitArrayAccess1WithResult(my) }
func (my *ArrayAccess1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitArrayAccess1WithResultArgument(my, o) }


func AnyCastToArrayAccess1(i interface{}) *ArrayAccess1 {
	if nil == i{
		return nil
	}else{
		return i.(*ArrayAccess1)
	}
}
/**
 *<b>
*<li>Rule 385:  UnaryExpression ::= + UnaryExpression
 *</b>
 */
type UnaryExpression0 struct{
    *Ast
      _PLUS *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *UnaryExpression0)      GetPLUS() *AstToken{ return my._PLUS}
func (my *UnaryExpression0)      SetPLUS( _PLUS *AstToken)  { my._PLUS = _PLUS }
func (my *UnaryExpression0)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *UnaryExpression0)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewUnaryExpression0(leftIToken IToken, rightIToken IToken ,
              _PLUS *AstToken,
              _UnaryExpression IUnaryExpression)*UnaryExpression0{
      my := new(UnaryExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._PLUS = _PLUS;
        if nil != _PLUS{
        var trait_ interface{} = _PLUS
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *UnaryExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._PLUS{  list.Add(my._PLUS) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *UnaryExpression0)      AcceptWithVisitor(v Visitor) { v.VisitUnaryExpression0(my)}
func (my *UnaryExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitUnaryExpression0WithArg(my, o) }
func (my *UnaryExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitUnaryExpression0WithResult(my) }
func (my *UnaryExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitUnaryExpression0WithResultArgument(my, o) }


func AnyCastToUnaryExpression0(i interface{}) *UnaryExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*UnaryExpression0)
	}
}
/**
 *<b>
*<li>Rule 386:  UnaryExpression ::= - UnaryExpression
 *</b>
 */
type UnaryExpression1 struct{
    *Ast
      _MINUS *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *UnaryExpression1)      GetMINUS() *AstToken{ return my._MINUS}
func (my *UnaryExpression1)      SetMINUS( _MINUS *AstToken)  { my._MINUS = _MINUS }
func (my *UnaryExpression1)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *UnaryExpression1)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewUnaryExpression1(leftIToken IToken, rightIToken IToken ,
              _MINUS *AstToken,
              _UnaryExpression IUnaryExpression)*UnaryExpression1{
      my := new(UnaryExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MINUS = _MINUS;
        if nil != _MINUS{
        var trait_ interface{} = _MINUS
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *UnaryExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MINUS{  list.Add(my._MINUS) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *UnaryExpression1)      AcceptWithVisitor(v Visitor) { v.VisitUnaryExpression1(my)}
func (my *UnaryExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitUnaryExpression1WithArg(my, o) }
func (my *UnaryExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitUnaryExpression1WithResult(my) }
func (my *UnaryExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitUnaryExpression1WithResultArgument(my, o) }


func AnyCastToUnaryExpression1(i interface{}) *UnaryExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*UnaryExpression1)
	}
}
/**
 *<b>
*<li>Rule 391:  UnaryExpressionNotPlusMinus ::= ~ UnaryExpression
 *</b>
 */
type UnaryExpressionNotPlusMinus0 struct{
    *Ast
      _TWIDDLE *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *UnaryExpressionNotPlusMinus0)      GetTWIDDLE() *AstToken{ return my._TWIDDLE}
func (my *UnaryExpressionNotPlusMinus0)      SetTWIDDLE( _TWIDDLE *AstToken)  { my._TWIDDLE = _TWIDDLE }
func (my *UnaryExpressionNotPlusMinus0)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *UnaryExpressionNotPlusMinus0)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewUnaryExpressionNotPlusMinus0(leftIToken IToken, rightIToken IToken ,
              _TWIDDLE *AstToken,
              _UnaryExpression IUnaryExpression)*UnaryExpressionNotPlusMinus0{
      my := new(UnaryExpressionNotPlusMinus0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._TWIDDLE = _TWIDDLE;
        if nil != _TWIDDLE{
        var trait_ interface{} = _TWIDDLE
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *UnaryExpressionNotPlusMinus0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._TWIDDLE{  list.Add(my._TWIDDLE) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *UnaryExpressionNotPlusMinus0)      AcceptWithVisitor(v Visitor) { v.VisitUnaryExpressionNotPlusMinus0(my)}
func (my *UnaryExpressionNotPlusMinus0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitUnaryExpressionNotPlusMinus0WithArg(my, o) }
func (my *UnaryExpressionNotPlusMinus0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitUnaryExpressionNotPlusMinus0WithResult(my) }
func (my *UnaryExpressionNotPlusMinus0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitUnaryExpressionNotPlusMinus0WithResultArgument(my, o) }


func AnyCastToUnaryExpressionNotPlusMinus0(i interface{}) *UnaryExpressionNotPlusMinus0 {
	if nil == i{
		return nil
	}else{
		return i.(*UnaryExpressionNotPlusMinus0)
	}
}
/**
 *<b>
*<li>Rule 392:  UnaryExpressionNotPlusMinus ::= ! UnaryExpression
 *</b>
 */
type UnaryExpressionNotPlusMinus1 struct{
    *Ast
      _NOT *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *UnaryExpressionNotPlusMinus1)      GetNOT() *AstToken{ return my._NOT}
func (my *UnaryExpressionNotPlusMinus1)      SetNOT( _NOT *AstToken)  { my._NOT = _NOT }
func (my *UnaryExpressionNotPlusMinus1)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *UnaryExpressionNotPlusMinus1)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewUnaryExpressionNotPlusMinus1(leftIToken IToken, rightIToken IToken ,
              _NOT *AstToken,
              _UnaryExpression IUnaryExpression)*UnaryExpressionNotPlusMinus1{
      my := new(UnaryExpressionNotPlusMinus1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._NOT = _NOT;
        if nil != _NOT{
        var trait_ interface{} = _NOT
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *UnaryExpressionNotPlusMinus1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._NOT{  list.Add(my._NOT) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *UnaryExpressionNotPlusMinus1)      AcceptWithVisitor(v Visitor) { v.VisitUnaryExpressionNotPlusMinus1(my)}
func (my *UnaryExpressionNotPlusMinus1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitUnaryExpressionNotPlusMinus1WithArg(my, o) }
func (my *UnaryExpressionNotPlusMinus1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitUnaryExpressionNotPlusMinus1WithResult(my) }
func (my *UnaryExpressionNotPlusMinus1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitUnaryExpressionNotPlusMinus1WithResultArgument(my, o) }


func AnyCastToUnaryExpressionNotPlusMinus1(i interface{}) *UnaryExpressionNotPlusMinus1 {
	if nil == i{
		return nil
	}else{
		return i.(*UnaryExpressionNotPlusMinus1)
	}
}
/**
 *<b>
*<li>Rule 394:  CastExpression ::= ( PrimitiveType Dimsopt ) UnaryExpression
 *</b>
 */
type CastExpression0 struct{
    *Ast
      _LPAREN *AstToken
      _PrimitiveType IPrimitiveType
      _Dimsopt IDimsopt
      _RPAREN *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *CastExpression0)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *CastExpression0)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *CastExpression0)      GetPrimitiveType() IPrimitiveType{ return my._PrimitiveType}
func (my *CastExpression0)      SetPrimitiveType( _PrimitiveType IPrimitiveType)  { my._PrimitiveType = _PrimitiveType }
    /**
     * The value returned by <b>GetDimsopt</b> may be <b>null</b>
     */
func (my *CastExpression0)      GetDimsopt() IDimsopt{ return my._Dimsopt}
func (my *CastExpression0)      SetDimsopt( _Dimsopt IDimsopt)  { my._Dimsopt = _Dimsopt }
func (my *CastExpression0)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *CastExpression0)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *CastExpression0)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *CastExpression0)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewCastExpression0(leftIToken IToken, rightIToken IToken ,
              _LPAREN *AstToken,
              _PrimitiveType IPrimitiveType,
              _Dimsopt IDimsopt,
              _RPAREN *AstToken,
              _UnaryExpression IUnaryExpression)*CastExpression0{
      my := new(CastExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._PrimitiveType = _PrimitiveType;
        if nil != _PrimitiveType{
        var trait_ interface{} = _PrimitiveType
         trait_.(IAst).SetParent(my)
}
        my._Dimsopt = _Dimsopt;
        if nil != _Dimsopt{
        var trait_ interface{} = _Dimsopt
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *CastExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._PrimitiveType{  list.Add(my._PrimitiveType) }
        if nil != my._Dimsopt{  list.Add(my._Dimsopt) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *CastExpression0)      AcceptWithVisitor(v Visitor) { v.VisitCastExpression0(my)}
func (my *CastExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitCastExpression0WithArg(my, o) }
func (my *CastExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitCastExpression0WithResult(my) }
func (my *CastExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitCastExpression0WithResultArgument(my, o) }


func AnyCastToCastExpression0(i interface{}) *CastExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*CastExpression0)
	}
}
/**
 *<b>
*<li>Rule 395:  CastExpression ::= ( ReferenceType ) UnaryExpressionNotPlusMinus
 *</b>
 */
type CastExpression1 struct{
    *Ast
      _LPAREN *AstToken
      _ReferenceType IReferenceType
      _RPAREN *AstToken
      _UnaryExpressionNotPlusMinus IUnaryExpressionNotPlusMinus
}
func (my *CastExpression1)      GetLPAREN() *AstToken{ return my._LPAREN}
func (my *CastExpression1)      SetLPAREN( _LPAREN *AstToken)  { my._LPAREN = _LPAREN }
func (my *CastExpression1)      GetReferenceType() IReferenceType{ return my._ReferenceType}
func (my *CastExpression1)      SetReferenceType( _ReferenceType IReferenceType)  { my._ReferenceType = _ReferenceType }
func (my *CastExpression1)      GetRPAREN() *AstToken{ return my._RPAREN}
func (my *CastExpression1)      SetRPAREN( _RPAREN *AstToken)  { my._RPAREN = _RPAREN }
func (my *CastExpression1)      GetUnaryExpressionNotPlusMinus() IUnaryExpressionNotPlusMinus{ return my._UnaryExpressionNotPlusMinus}
func (my *CastExpression1)      SetUnaryExpressionNotPlusMinus( _UnaryExpressionNotPlusMinus IUnaryExpressionNotPlusMinus)  { my._UnaryExpressionNotPlusMinus = _UnaryExpressionNotPlusMinus }

func NewCastExpression1(leftIToken IToken, rightIToken IToken ,
              _LPAREN *AstToken,
              _ReferenceType IReferenceType,
              _RPAREN *AstToken,
              _UnaryExpressionNotPlusMinus IUnaryExpressionNotPlusMinus)*CastExpression1{
      my := new(CastExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._LPAREN = _LPAREN;
        if nil != _LPAREN{
        var trait_ interface{} = _LPAREN
         trait_.(IAst).SetParent(my)
}
        my._ReferenceType = _ReferenceType;
        if nil != _ReferenceType{
        var trait_ interface{} = _ReferenceType
         trait_.(IAst).SetParent(my)
}
        my._RPAREN = _RPAREN;
        if nil != _RPAREN{
        var trait_ interface{} = _RPAREN
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpressionNotPlusMinus = _UnaryExpressionNotPlusMinus;
        if nil != _UnaryExpressionNotPlusMinus{
        var trait_ interface{} = _UnaryExpressionNotPlusMinus
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *CastExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._LPAREN{  list.Add(my._LPAREN) }
        if nil != my._ReferenceType{  list.Add(my._ReferenceType) }
        if nil != my._RPAREN{  list.Add(my._RPAREN) }
        if nil != my._UnaryExpressionNotPlusMinus{  list.Add(my._UnaryExpressionNotPlusMinus) }
        return list
    }

func (my *CastExpression1)      AcceptWithVisitor(v Visitor) { v.VisitCastExpression1(my)}
func (my *CastExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitCastExpression1WithArg(my, o) }
func (my *CastExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitCastExpression1WithResult(my) }
func (my *CastExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitCastExpression1WithResultArgument(my, o) }


func AnyCastToCastExpression1(i interface{}) *CastExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*CastExpression1)
	}
}
/**
 *<b>
*<li>Rule 397:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
 *</b>
 */
type MultiplicativeExpression0 struct{
    *Ast
      _MultiplicativeExpression IMultiplicativeExpression
      _MULTIPLY *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *MultiplicativeExpression0)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *MultiplicativeExpression0)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }
func (my *MultiplicativeExpression0)      GetMULTIPLY() *AstToken{ return my._MULTIPLY}
func (my *MultiplicativeExpression0)      SetMULTIPLY( _MULTIPLY *AstToken)  { my._MULTIPLY = _MULTIPLY }
func (my *MultiplicativeExpression0)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *MultiplicativeExpression0)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewMultiplicativeExpression0(leftIToken IToken, rightIToken IToken ,
              _MultiplicativeExpression IMultiplicativeExpression,
              _MULTIPLY *AstToken,
              _UnaryExpression IUnaryExpression)*MultiplicativeExpression0{
      my := new(MultiplicativeExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my._MULTIPLY = _MULTIPLY;
        if nil != _MULTIPLY{
        var trait_ interface{} = _MULTIPLY
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MultiplicativeExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        if nil != my._MULTIPLY{  list.Add(my._MULTIPLY) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *MultiplicativeExpression0)      AcceptWithVisitor(v Visitor) { v.VisitMultiplicativeExpression0(my)}
func (my *MultiplicativeExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMultiplicativeExpression0WithArg(my, o) }
func (my *MultiplicativeExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMultiplicativeExpression0WithResult(my) }
func (my *MultiplicativeExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMultiplicativeExpression0WithResultArgument(my, o) }


func AnyCastToMultiplicativeExpression0(i interface{}) *MultiplicativeExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*MultiplicativeExpression0)
	}
}
/**
 *<b>
*<li>Rule 398:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
 *</b>
 */
type MultiplicativeExpression1 struct{
    *Ast
      _MultiplicativeExpression IMultiplicativeExpression
      _DIVIDE *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *MultiplicativeExpression1)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *MultiplicativeExpression1)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }
func (my *MultiplicativeExpression1)      GetDIVIDE() *AstToken{ return my._DIVIDE}
func (my *MultiplicativeExpression1)      SetDIVIDE( _DIVIDE *AstToken)  { my._DIVIDE = _DIVIDE }
func (my *MultiplicativeExpression1)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *MultiplicativeExpression1)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewMultiplicativeExpression1(leftIToken IToken, rightIToken IToken ,
              _MultiplicativeExpression IMultiplicativeExpression,
              _DIVIDE *AstToken,
              _UnaryExpression IUnaryExpression)*MultiplicativeExpression1{
      my := new(MultiplicativeExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my._DIVIDE = _DIVIDE;
        if nil != _DIVIDE{
        var trait_ interface{} = _DIVIDE
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MultiplicativeExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        if nil != my._DIVIDE{  list.Add(my._DIVIDE) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *MultiplicativeExpression1)      AcceptWithVisitor(v Visitor) { v.VisitMultiplicativeExpression1(my)}
func (my *MultiplicativeExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMultiplicativeExpression1WithArg(my, o) }
func (my *MultiplicativeExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMultiplicativeExpression1WithResult(my) }
func (my *MultiplicativeExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMultiplicativeExpression1WithResultArgument(my, o) }


func AnyCastToMultiplicativeExpression1(i interface{}) *MultiplicativeExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*MultiplicativeExpression1)
	}
}
/**
 *<b>
*<li>Rule 399:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
 *</b>
 */
type MultiplicativeExpression2 struct{
    *Ast
      _MultiplicativeExpression IMultiplicativeExpression
      _REMAINDER *AstToken
      _UnaryExpression IUnaryExpression
}
func (my *MultiplicativeExpression2)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *MultiplicativeExpression2)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }
func (my *MultiplicativeExpression2)      GetREMAINDER() *AstToken{ return my._REMAINDER}
func (my *MultiplicativeExpression2)      SetREMAINDER( _REMAINDER *AstToken)  { my._REMAINDER = _REMAINDER }
func (my *MultiplicativeExpression2)      GetUnaryExpression() IUnaryExpression{ return my._UnaryExpression}
func (my *MultiplicativeExpression2)      SetUnaryExpression( _UnaryExpression IUnaryExpression)  { my._UnaryExpression = _UnaryExpression }

func NewMultiplicativeExpression2(leftIToken IToken, rightIToken IToken ,
              _MultiplicativeExpression IMultiplicativeExpression,
              _REMAINDER *AstToken,
              _UnaryExpression IUnaryExpression)*MultiplicativeExpression2{
      my := new(MultiplicativeExpression2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my._REMAINDER = _REMAINDER;
        if nil != _REMAINDER{
        var trait_ interface{} = _REMAINDER
         trait_.(IAst).SetParent(my)
}
        my._UnaryExpression = _UnaryExpression;
        if nil != _UnaryExpression{
        var trait_ interface{} = _UnaryExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *MultiplicativeExpression2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        if nil != my._REMAINDER{  list.Add(my._REMAINDER) }
        if nil != my._UnaryExpression{  list.Add(my._UnaryExpression) }
        return list
    }

func (my *MultiplicativeExpression2)      AcceptWithVisitor(v Visitor) { v.VisitMultiplicativeExpression2(my)}
func (my *MultiplicativeExpression2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitMultiplicativeExpression2WithArg(my, o) }
func (my *MultiplicativeExpression2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitMultiplicativeExpression2WithResult(my) }
func (my *MultiplicativeExpression2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitMultiplicativeExpression2WithResultArgument(my, o) }


func AnyCastToMultiplicativeExpression2(i interface{}) *MultiplicativeExpression2 {
	if nil == i{
		return nil
	}else{
		return i.(*MultiplicativeExpression2)
	}
}
/**
 *<b>
*<li>Rule 401:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
 *</b>
 */
type AdditiveExpression0 struct{
    *Ast
      _AdditiveExpression IAdditiveExpression
      _PLUS *AstToken
      _MultiplicativeExpression IMultiplicativeExpression
}
func (my *AdditiveExpression0)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *AdditiveExpression0)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }
func (my *AdditiveExpression0)      GetPLUS() *AstToken{ return my._PLUS}
func (my *AdditiveExpression0)      SetPLUS( _PLUS *AstToken)  { my._PLUS = _PLUS }
func (my *AdditiveExpression0)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *AdditiveExpression0)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }

func NewAdditiveExpression0(leftIToken IToken, rightIToken IToken ,
              _AdditiveExpression IAdditiveExpression,
              _PLUS *AstToken,
              _MultiplicativeExpression IMultiplicativeExpression)*AdditiveExpression0{
      my := new(AdditiveExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my._PLUS = _PLUS;
        if nil != _PLUS{
        var trait_ interface{} = _PLUS
         trait_.(IAst).SetParent(my)
}
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AdditiveExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        if nil != my._PLUS{  list.Add(my._PLUS) }
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        return list
    }

func (my *AdditiveExpression0)      AcceptWithVisitor(v Visitor) { v.VisitAdditiveExpression0(my)}
func (my *AdditiveExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAdditiveExpression0WithArg(my, o) }
func (my *AdditiveExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAdditiveExpression0WithResult(my) }
func (my *AdditiveExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAdditiveExpression0WithResultArgument(my, o) }


func AnyCastToAdditiveExpression0(i interface{}) *AdditiveExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*AdditiveExpression0)
	}
}
/**
 *<b>
*<li>Rule 402:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
 *</b>
 */
type AdditiveExpression1 struct{
    *Ast
      _AdditiveExpression IAdditiveExpression
      _MINUS *AstToken
      _MultiplicativeExpression IMultiplicativeExpression
}
func (my *AdditiveExpression1)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *AdditiveExpression1)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }
func (my *AdditiveExpression1)      GetMINUS() *AstToken{ return my._MINUS}
func (my *AdditiveExpression1)      SetMINUS( _MINUS *AstToken)  { my._MINUS = _MINUS }
func (my *AdditiveExpression1)      GetMultiplicativeExpression() IMultiplicativeExpression{ return my._MultiplicativeExpression}
func (my *AdditiveExpression1)      SetMultiplicativeExpression( _MultiplicativeExpression IMultiplicativeExpression)  { my._MultiplicativeExpression = _MultiplicativeExpression }

func NewAdditiveExpression1(leftIToken IToken, rightIToken IToken ,
              _AdditiveExpression IAdditiveExpression,
              _MINUS *AstToken,
              _MultiplicativeExpression IMultiplicativeExpression)*AdditiveExpression1{
      my := new(AdditiveExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my._MINUS = _MINUS;
        if nil != _MINUS{
        var trait_ interface{} = _MINUS
         trait_.(IAst).SetParent(my)
}
        my._MultiplicativeExpression = _MultiplicativeExpression;
        if nil != _MultiplicativeExpression{
        var trait_ interface{} = _MultiplicativeExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AdditiveExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        if nil != my._MINUS{  list.Add(my._MINUS) }
        if nil != my._MultiplicativeExpression{  list.Add(my._MultiplicativeExpression) }
        return list
    }

func (my *AdditiveExpression1)      AcceptWithVisitor(v Visitor) { v.VisitAdditiveExpression1(my)}
func (my *AdditiveExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAdditiveExpression1WithArg(my, o) }
func (my *AdditiveExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAdditiveExpression1WithResult(my) }
func (my *AdditiveExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAdditiveExpression1WithResultArgument(my, o) }


func AnyCastToAdditiveExpression1(i interface{}) *AdditiveExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*AdditiveExpression1)
	}
}
/**
 *<b>
*<li>Rule 404:  ShiftExpression ::= ShiftExpression << AdditiveExpression
 *</b>
 */
type ShiftExpression0 struct{
    *Ast
      _ShiftExpression IShiftExpression
      _LEFT_SHIFT *AstToken
      _AdditiveExpression IAdditiveExpression
}
func (my *ShiftExpression0)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *ShiftExpression0)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }
func (my *ShiftExpression0)      GetLEFT_SHIFT() *AstToken{ return my._LEFT_SHIFT}
func (my *ShiftExpression0)      SetLEFT_SHIFT( _LEFT_SHIFT *AstToken)  { my._LEFT_SHIFT = _LEFT_SHIFT }
func (my *ShiftExpression0)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *ShiftExpression0)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }

func NewShiftExpression0(leftIToken IToken, rightIToken IToken ,
              _ShiftExpression IShiftExpression,
              _LEFT_SHIFT *AstToken,
              _AdditiveExpression IAdditiveExpression)*ShiftExpression0{
      my := new(ShiftExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my._LEFT_SHIFT = _LEFT_SHIFT;
        if nil != _LEFT_SHIFT{
        var trait_ interface{} = _LEFT_SHIFT
         trait_.(IAst).SetParent(my)
}
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ShiftExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        if nil != my._LEFT_SHIFT{  list.Add(my._LEFT_SHIFT) }
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        return list
    }

func (my *ShiftExpression0)      AcceptWithVisitor(v Visitor) { v.VisitShiftExpression0(my)}
func (my *ShiftExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitShiftExpression0WithArg(my, o) }
func (my *ShiftExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitShiftExpression0WithResult(my) }
func (my *ShiftExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitShiftExpression0WithResultArgument(my, o) }


func AnyCastToShiftExpression0(i interface{}) *ShiftExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*ShiftExpression0)
	}
}
/**
 *<b>
*<li>Rule 405:  ShiftExpression ::= ShiftExpression > > AdditiveExpression
 *</b>
 */
type ShiftExpression1 struct{
    *Ast
      _ShiftExpression IShiftExpression
      _GREATER *AstToken
      _GREATER3 *AstToken
      _AdditiveExpression IAdditiveExpression
}
func (my *ShiftExpression1)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *ShiftExpression1)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }
func (my *ShiftExpression1)      GetGREATER() *AstToken{ return my._GREATER}
func (my *ShiftExpression1)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *ShiftExpression1)      GetGREATER3() *AstToken{ return my._GREATER3}
func (my *ShiftExpression1)      SetGREATER3( _GREATER3 *AstToken)  { my._GREATER3 = _GREATER3 }
func (my *ShiftExpression1)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *ShiftExpression1)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }

func NewShiftExpression1(leftIToken IToken, rightIToken IToken ,
              _ShiftExpression IShiftExpression,
              _GREATER *AstToken,
              _GREATER3 *AstToken,
              _AdditiveExpression IAdditiveExpression)*ShiftExpression1{
      my := new(ShiftExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._GREATER3 = _GREATER3;
        if nil != _GREATER3{
        var trait_ interface{} = _GREATER3
         trait_.(IAst).SetParent(my)
}
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ShiftExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._GREATER3{  list.Add(my._GREATER3) }
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        return list
    }

func (my *ShiftExpression1)      AcceptWithVisitor(v Visitor) { v.VisitShiftExpression1(my)}
func (my *ShiftExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitShiftExpression1WithArg(my, o) }
func (my *ShiftExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitShiftExpression1WithResult(my) }
func (my *ShiftExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitShiftExpression1WithResultArgument(my, o) }


func AnyCastToShiftExpression1(i interface{}) *ShiftExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*ShiftExpression1)
	}
}
/**
 *<b>
*<li>Rule 406:  ShiftExpression ::= ShiftExpression > > > AdditiveExpression
 *</b>
 */
type ShiftExpression2 struct{
    *Ast
      _ShiftExpression IShiftExpression
      _GREATER *AstToken
      _GREATER3 *AstToken
      _GREATER4 *AstToken
      _AdditiveExpression IAdditiveExpression
}
func (my *ShiftExpression2)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *ShiftExpression2)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }
func (my *ShiftExpression2)      GetGREATER() *AstToken{ return my._GREATER}
func (my *ShiftExpression2)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *ShiftExpression2)      GetGREATER3() *AstToken{ return my._GREATER3}
func (my *ShiftExpression2)      SetGREATER3( _GREATER3 *AstToken)  { my._GREATER3 = _GREATER3 }
func (my *ShiftExpression2)      GetGREATER4() *AstToken{ return my._GREATER4}
func (my *ShiftExpression2)      SetGREATER4( _GREATER4 *AstToken)  { my._GREATER4 = _GREATER4 }
func (my *ShiftExpression2)      GetAdditiveExpression() IAdditiveExpression{ return my._AdditiveExpression}
func (my *ShiftExpression2)      SetAdditiveExpression( _AdditiveExpression IAdditiveExpression)  { my._AdditiveExpression = _AdditiveExpression }

func NewShiftExpression2(leftIToken IToken, rightIToken IToken ,
              _ShiftExpression IShiftExpression,
              _GREATER *AstToken,
              _GREATER3 *AstToken,
              _GREATER4 *AstToken,
              _AdditiveExpression IAdditiveExpression)*ShiftExpression2{
      my := new(ShiftExpression2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._GREATER3 = _GREATER3;
        if nil != _GREATER3{
        var trait_ interface{} = _GREATER3
         trait_.(IAst).SetParent(my)
}
        my._GREATER4 = _GREATER4;
        if nil != _GREATER4{
        var trait_ interface{} = _GREATER4
         trait_.(IAst).SetParent(my)
}
        my._AdditiveExpression = _AdditiveExpression;
        if nil != _AdditiveExpression{
        var trait_ interface{} = _AdditiveExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *ShiftExpression2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._GREATER3{  list.Add(my._GREATER3) }
        if nil != my._GREATER4{  list.Add(my._GREATER4) }
        if nil != my._AdditiveExpression{  list.Add(my._AdditiveExpression) }
        return list
    }

func (my *ShiftExpression2)      AcceptWithVisitor(v Visitor) { v.VisitShiftExpression2(my)}
func (my *ShiftExpression2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitShiftExpression2WithArg(my, o) }
func (my *ShiftExpression2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitShiftExpression2WithResult(my) }
func (my *ShiftExpression2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitShiftExpression2WithResultArgument(my, o) }


func AnyCastToShiftExpression2(i interface{}) *ShiftExpression2 {
	if nil == i{
		return nil
	}else{
		return i.(*ShiftExpression2)
	}
}
/**
 *<b>
*<li>Rule 408:  RelationalExpression ::= RelationalExpression < ShiftExpression
 *</b>
 */
type RelationalExpression0 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _LESS *AstToken
      _ShiftExpression IShiftExpression
}
func (my *RelationalExpression0)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression0)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression0)      GetLESS() *AstToken{ return my._LESS}
func (my *RelationalExpression0)      SetLESS( _LESS *AstToken)  { my._LESS = _LESS }
func (my *RelationalExpression0)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *RelationalExpression0)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }

func NewRelationalExpression0(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _LESS *AstToken,
              _ShiftExpression IShiftExpression)*RelationalExpression0{
      my := new(RelationalExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._LESS = _LESS;
        if nil != _LESS{
        var trait_ interface{} = _LESS
         trait_.(IAst).SetParent(my)
}
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._LESS{  list.Add(my._LESS) }
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        return list
    }

func (my *RelationalExpression0)      AcceptWithVisitor(v Visitor) { v.VisitRelationalExpression0(my)}
func (my *RelationalExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitRelationalExpression0WithArg(my, o) }
func (my *RelationalExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitRelationalExpression0WithResult(my) }
func (my *RelationalExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitRelationalExpression0WithResultArgument(my, o) }


func AnyCastToRelationalExpression0(i interface{}) *RelationalExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression0)
	}
}
/**
 *<b>
*<li>Rule 409:  RelationalExpression ::= RelationalExpression > ShiftExpression
 *</b>
 */
type RelationalExpression1 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _GREATER *AstToken
      _ShiftExpression IShiftExpression
}
func (my *RelationalExpression1)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression1)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression1)      GetGREATER() *AstToken{ return my._GREATER}
func (my *RelationalExpression1)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *RelationalExpression1)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *RelationalExpression1)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }

func NewRelationalExpression1(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _GREATER *AstToken,
              _ShiftExpression IShiftExpression)*RelationalExpression1{
      my := new(RelationalExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        return list
    }

func (my *RelationalExpression1)      AcceptWithVisitor(v Visitor) { v.VisitRelationalExpression1(my)}
func (my *RelationalExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitRelationalExpression1WithArg(my, o) }
func (my *RelationalExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitRelationalExpression1WithResult(my) }
func (my *RelationalExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitRelationalExpression1WithResultArgument(my, o) }


func AnyCastToRelationalExpression1(i interface{}) *RelationalExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression1)
	}
}
/**
 *<b>
*<li>Rule 410:  RelationalExpression ::= RelationalExpression <= ShiftExpression
 *</b>
 */
type RelationalExpression2 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _LESS_EQUAL *AstToken
      _ShiftExpression IShiftExpression
}
func (my *RelationalExpression2)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression2)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression2)      GetLESS_EQUAL() *AstToken{ return my._LESS_EQUAL}
func (my *RelationalExpression2)      SetLESS_EQUAL( _LESS_EQUAL *AstToken)  { my._LESS_EQUAL = _LESS_EQUAL }
func (my *RelationalExpression2)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *RelationalExpression2)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }

func NewRelationalExpression2(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _LESS_EQUAL *AstToken,
              _ShiftExpression IShiftExpression)*RelationalExpression2{
      my := new(RelationalExpression2)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._LESS_EQUAL = _LESS_EQUAL;
        if nil != _LESS_EQUAL{
        var trait_ interface{} = _LESS_EQUAL
         trait_.(IAst).SetParent(my)
}
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression2)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._LESS_EQUAL{  list.Add(my._LESS_EQUAL) }
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        return list
    }

func (my *RelationalExpression2)      AcceptWithVisitor(v Visitor) { v.VisitRelationalExpression2(my)}
func (my *RelationalExpression2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitRelationalExpression2WithArg(my, o) }
func (my *RelationalExpression2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitRelationalExpression2WithResult(my) }
func (my *RelationalExpression2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitRelationalExpression2WithResultArgument(my, o) }


func AnyCastToRelationalExpression2(i interface{}) *RelationalExpression2 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression2)
	}
}
/**
 *<b>
*<li>Rule 411:  RelationalExpression ::= RelationalExpression > = ShiftExpression
 *</b>
 */
type RelationalExpression3 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _GREATER *AstToken
      _EQUAL *AstToken
      _ShiftExpression IShiftExpression
}
func (my *RelationalExpression3)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression3)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression3)      GetGREATER() *AstToken{ return my._GREATER}
func (my *RelationalExpression3)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *RelationalExpression3)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *RelationalExpression3)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }
func (my *RelationalExpression3)      GetShiftExpression() IShiftExpression{ return my._ShiftExpression}
func (my *RelationalExpression3)      SetShiftExpression( _ShiftExpression IShiftExpression)  { my._ShiftExpression = _ShiftExpression }

func NewRelationalExpression3(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _GREATER *AstToken,
              _EQUAL *AstToken,
              _ShiftExpression IShiftExpression)*RelationalExpression3{
      my := new(RelationalExpression3)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my._ShiftExpression = _ShiftExpression;
        if nil != _ShiftExpression{
        var trait_ interface{} = _ShiftExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression3)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        if nil != my._ShiftExpression{  list.Add(my._ShiftExpression) }
        return list
    }

func (my *RelationalExpression3)      AcceptWithVisitor(v Visitor) { v.VisitRelationalExpression3(my)}
func (my *RelationalExpression3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitRelationalExpression3WithArg(my, o) }
func (my *RelationalExpression3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitRelationalExpression3WithResult(my) }
func (my *RelationalExpression3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitRelationalExpression3WithResultArgument(my, o) }


func AnyCastToRelationalExpression3(i interface{}) *RelationalExpression3 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression3)
	}
}
/**
 *<b>
*<li>Rule 412:  RelationalExpression ::= RelationalExpression instanceof ReferenceType
 *</b>
 */
type RelationalExpression4 struct{
    *Ast
      _RelationalExpression IRelationalExpression
      _instanceof *AstToken
      _ReferenceType IReferenceType
}
func (my *RelationalExpression4)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *RelationalExpression4)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }
func (my *RelationalExpression4)      Getinstanceof() *AstToken{ return my._instanceof}
func (my *RelationalExpression4)      Setinstanceof( _instanceof *AstToken)  { my._instanceof = _instanceof }
func (my *RelationalExpression4)      GetReferenceType() IReferenceType{ return my._ReferenceType}
func (my *RelationalExpression4)      SetReferenceType( _ReferenceType IReferenceType)  { my._ReferenceType = _ReferenceType }

func NewRelationalExpression4(leftIToken IToken, rightIToken IToken ,
              _RelationalExpression IRelationalExpression,
              _instanceof *AstToken,
              _ReferenceType IReferenceType)*RelationalExpression4{
      my := new(RelationalExpression4)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my._instanceof = _instanceof;
        if nil != _instanceof{
        var trait_ interface{} = _instanceof
         trait_.(IAst).SetParent(my)
}
        my._ReferenceType = _ReferenceType;
        if nil != _ReferenceType{
        var trait_ interface{} = _ReferenceType
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *RelationalExpression4)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        if nil != my._instanceof{  list.Add(my._instanceof) }
        if nil != my._ReferenceType{  list.Add(my._ReferenceType) }
        return list
    }

func (my *RelationalExpression4)      AcceptWithVisitor(v Visitor) { v.VisitRelationalExpression4(my)}
func (my *RelationalExpression4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitRelationalExpression4WithArg(my, o) }
func (my *RelationalExpression4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitRelationalExpression4WithResult(my) }
func (my *RelationalExpression4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitRelationalExpression4WithResultArgument(my, o) }


func AnyCastToRelationalExpression4(i interface{}) *RelationalExpression4 {
	if nil == i{
		return nil
	}else{
		return i.(*RelationalExpression4)
	}
}
/**
 *<b>
*<li>Rule 414:  EqualityExpression ::= EqualityExpression == RelationalExpression
 *</b>
 */
type EqualityExpression0 struct{
    *Ast
      _EqualityExpression IEqualityExpression
      _EQUAL_EQUAL *AstToken
      _RelationalExpression IRelationalExpression
}
func (my *EqualityExpression0)      GetEqualityExpression() IEqualityExpression{ return my._EqualityExpression}
func (my *EqualityExpression0)      SetEqualityExpression( _EqualityExpression IEqualityExpression)  { my._EqualityExpression = _EqualityExpression }
func (my *EqualityExpression0)      GetEQUAL_EQUAL() *AstToken{ return my._EQUAL_EQUAL}
func (my *EqualityExpression0)      SetEQUAL_EQUAL( _EQUAL_EQUAL *AstToken)  { my._EQUAL_EQUAL = _EQUAL_EQUAL }
func (my *EqualityExpression0)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *EqualityExpression0)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }

func NewEqualityExpression0(leftIToken IToken, rightIToken IToken ,
              _EqualityExpression IEqualityExpression,
              _EQUAL_EQUAL *AstToken,
              _RelationalExpression IRelationalExpression)*EqualityExpression0{
      my := new(EqualityExpression0)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._EqualityExpression = _EqualityExpression;
        if nil != _EqualityExpression{
        var trait_ interface{} = _EqualityExpression
         trait_.(IAst).SetParent(my)
}
        my._EQUAL_EQUAL = _EQUAL_EQUAL;
        if nil != _EQUAL_EQUAL{
        var trait_ interface{} = _EQUAL_EQUAL
         trait_.(IAst).SetParent(my)
}
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EqualityExpression0)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._EqualityExpression{  list.Add(my._EqualityExpression) }
        if nil != my._EQUAL_EQUAL{  list.Add(my._EQUAL_EQUAL) }
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        return list
    }

func (my *EqualityExpression0)      AcceptWithVisitor(v Visitor) { v.VisitEqualityExpression0(my)}
func (my *EqualityExpression0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEqualityExpression0WithArg(my, o) }
func (my *EqualityExpression0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEqualityExpression0WithResult(my) }
func (my *EqualityExpression0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEqualityExpression0WithResultArgument(my, o) }


func AnyCastToEqualityExpression0(i interface{}) *EqualityExpression0 {
	if nil == i{
		return nil
	}else{
		return i.(*EqualityExpression0)
	}
}
/**
 *<b>
*<li>Rule 415:  EqualityExpression ::= EqualityExpression != RelationalExpression
 *</b>
 */
type EqualityExpression1 struct{
    *Ast
      _EqualityExpression IEqualityExpression
      _NOT_EQUAL *AstToken
      _RelationalExpression IRelationalExpression
}
func (my *EqualityExpression1)      GetEqualityExpression() IEqualityExpression{ return my._EqualityExpression}
func (my *EqualityExpression1)      SetEqualityExpression( _EqualityExpression IEqualityExpression)  { my._EqualityExpression = _EqualityExpression }
func (my *EqualityExpression1)      GetNOT_EQUAL() *AstToken{ return my._NOT_EQUAL}
func (my *EqualityExpression1)      SetNOT_EQUAL( _NOT_EQUAL *AstToken)  { my._NOT_EQUAL = _NOT_EQUAL }
func (my *EqualityExpression1)      GetRelationalExpression() IRelationalExpression{ return my._RelationalExpression}
func (my *EqualityExpression1)      SetRelationalExpression( _RelationalExpression IRelationalExpression)  { my._RelationalExpression = _RelationalExpression }

func NewEqualityExpression1(leftIToken IToken, rightIToken IToken ,
              _EqualityExpression IEqualityExpression,
              _NOT_EQUAL *AstToken,
              _RelationalExpression IRelationalExpression)*EqualityExpression1{
      my := new(EqualityExpression1)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._EqualityExpression = _EqualityExpression;
        if nil != _EqualityExpression{
        var trait_ interface{} = _EqualityExpression
         trait_.(IAst).SetParent(my)
}
        my._NOT_EQUAL = _NOT_EQUAL;
        if nil != _NOT_EQUAL{
        var trait_ interface{} = _NOT_EQUAL
         trait_.(IAst).SetParent(my)
}
        my._RelationalExpression = _RelationalExpression;
        if nil != _RelationalExpression{
        var trait_ interface{} = _RelationalExpression
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *EqualityExpression1)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._EqualityExpression{  list.Add(my._EqualityExpression) }
        if nil != my._NOT_EQUAL{  list.Add(my._NOT_EQUAL) }
        if nil != my._RelationalExpression{  list.Add(my._RelationalExpression) }
        return list
    }

func (my *EqualityExpression1)      AcceptWithVisitor(v Visitor) { v.VisitEqualityExpression1(my)}
func (my *EqualityExpression1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitEqualityExpression1WithArg(my, o) }
func (my *EqualityExpression1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitEqualityExpression1WithResult(my) }
func (my *EqualityExpression1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitEqualityExpression1WithResultArgument(my, o) }


func AnyCastToEqualityExpression1(i interface{}) *EqualityExpression1 {
	if nil == i{
		return nil
	}else{
		return i.(*EqualityExpression1)
	}
}
/**
 *<b>
*<li>Rule 434:  AssignmentOperator ::= =
 *</b>
 */
type AssignmentOperator0 struct{
    *AstToken
}
func (my *AssignmentOperator0)      GetEQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator0(token IToken )*AssignmentOperator0{
      my := new(AssignmentOperator0)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator0)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator0(my)}
func (my *AssignmentOperator0)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator0WithArg(my, o) }
func (my *AssignmentOperator0)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator0WithResult(my) }
func (my *AssignmentOperator0)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator0WithResultArgument(my, o) }


func AnyCastToAssignmentOperator0(i interface{}) *AssignmentOperator0 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator0)
	}
}
/**
 *<b>
*<li>Rule 435:  AssignmentOperator ::= *=
 *</b>
 */
type AssignmentOperator1 struct{
    *AstToken
}
func (my *AssignmentOperator1)      GetMULTIPLY_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator1(token IToken )*AssignmentOperator1{
      my := new(AssignmentOperator1)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator1)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator1(my)}
func (my *AssignmentOperator1)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator1WithArg(my, o) }
func (my *AssignmentOperator1)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator1WithResult(my) }
func (my *AssignmentOperator1)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator1WithResultArgument(my, o) }


func AnyCastToAssignmentOperator1(i interface{}) *AssignmentOperator1 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator1)
	}
}
/**
 *<b>
*<li>Rule 436:  AssignmentOperator ::= /=
 *</b>
 */
type AssignmentOperator2 struct{
    *AstToken
}
func (my *AssignmentOperator2)      GetDIVIDE_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator2(token IToken )*AssignmentOperator2{
      my := new(AssignmentOperator2)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator2)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator2(my)}
func (my *AssignmentOperator2)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator2WithArg(my, o) }
func (my *AssignmentOperator2)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator2WithResult(my) }
func (my *AssignmentOperator2)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator2WithResultArgument(my, o) }


func AnyCastToAssignmentOperator2(i interface{}) *AssignmentOperator2 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator2)
	}
}
/**
 *<b>
*<li>Rule 437:  AssignmentOperator ::= %=
 *</b>
 */
type AssignmentOperator3 struct{
    *AstToken
}
func (my *AssignmentOperator3)      GetREMAINDER_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator3(token IToken )*AssignmentOperator3{
      my := new(AssignmentOperator3)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator3)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator3(my)}
func (my *AssignmentOperator3)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator3WithArg(my, o) }
func (my *AssignmentOperator3)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator3WithResult(my) }
func (my *AssignmentOperator3)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator3WithResultArgument(my, o) }


func AnyCastToAssignmentOperator3(i interface{}) *AssignmentOperator3 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator3)
	}
}
/**
 *<b>
*<li>Rule 438:  AssignmentOperator ::= +=
 *</b>
 */
type AssignmentOperator4 struct{
    *AstToken
}
func (my *AssignmentOperator4)      GetPLUS_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator4(token IToken )*AssignmentOperator4{
      my := new(AssignmentOperator4)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator4)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator4(my)}
func (my *AssignmentOperator4)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator4WithArg(my, o) }
func (my *AssignmentOperator4)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator4WithResult(my) }
func (my *AssignmentOperator4)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator4WithResultArgument(my, o) }


func AnyCastToAssignmentOperator4(i interface{}) *AssignmentOperator4 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator4)
	}
}
/**
 *<b>
*<li>Rule 439:  AssignmentOperator ::= -=
 *</b>
 */
type AssignmentOperator5 struct{
    *AstToken
}
func (my *AssignmentOperator5)      GetMINUS_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator5(token IToken )*AssignmentOperator5{
      my := new(AssignmentOperator5)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator5)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator5(my)}
func (my *AssignmentOperator5)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator5WithArg(my, o) }
func (my *AssignmentOperator5)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator5WithResult(my) }
func (my *AssignmentOperator5)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator5WithResultArgument(my, o) }


func AnyCastToAssignmentOperator5(i interface{}) *AssignmentOperator5 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator5)
	}
}
/**
 *<b>
*<li>Rule 440:  AssignmentOperator ::= <<=
 *</b>
 */
type AssignmentOperator6 struct{
    *AstToken
}
func (my *AssignmentOperator6)      GetLEFT_SHIFT_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator6(token IToken )*AssignmentOperator6{
      my := new(AssignmentOperator6)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator6)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator6(my)}
func (my *AssignmentOperator6)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator6WithArg(my, o) }
func (my *AssignmentOperator6)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator6WithResult(my) }
func (my *AssignmentOperator6)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator6WithResultArgument(my, o) }


func AnyCastToAssignmentOperator6(i interface{}) *AssignmentOperator6 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator6)
	}
}
/**
 *<b>
*<li>Rule 441:  AssignmentOperator ::= > > =
 *</b>
 */
type AssignmentOperator7 struct{
    *Ast
      _GREATER *AstToken
      _GREATER2 *AstToken
      _EQUAL *AstToken
}
func (my *AssignmentOperator7)      GetGREATER() *AstToken{ return my._GREATER}
func (my *AssignmentOperator7)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *AssignmentOperator7)      GetGREATER2() *AstToken{ return my._GREATER2}
func (my *AssignmentOperator7)      SetGREATER2( _GREATER2 *AstToken)  { my._GREATER2 = _GREATER2 }
func (my *AssignmentOperator7)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *AssignmentOperator7)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }

func NewAssignmentOperator7(leftIToken IToken, rightIToken IToken ,
              _GREATER *AstToken,
              _GREATER2 *AstToken,
              _EQUAL *AstToken)*AssignmentOperator7{
      my := new(AssignmentOperator7)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._GREATER2 = _GREATER2;
        if nil != _GREATER2{
        var trait_ interface{} = _GREATER2
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AssignmentOperator7)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._GREATER2{  list.Add(my._GREATER2) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        return list
    }

func (my *AssignmentOperator7)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator7(my)}
func (my *AssignmentOperator7)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator7WithArg(my, o) }
func (my *AssignmentOperator7)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator7WithResult(my) }
func (my *AssignmentOperator7)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator7WithResultArgument(my, o) }


func AnyCastToAssignmentOperator7(i interface{}) *AssignmentOperator7 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator7)
	}
}
/**
 *<b>
*<li>Rule 442:  AssignmentOperator ::= > > > =
 *</b>
 */
type AssignmentOperator8 struct{
    *Ast
      _GREATER *AstToken
      _GREATER2 *AstToken
      _GREATER3 *AstToken
      _EQUAL *AstToken
}
func (my *AssignmentOperator8)      GetGREATER() *AstToken{ return my._GREATER}
func (my *AssignmentOperator8)      SetGREATER( _GREATER *AstToken)  { my._GREATER = _GREATER }
func (my *AssignmentOperator8)      GetGREATER2() *AstToken{ return my._GREATER2}
func (my *AssignmentOperator8)      SetGREATER2( _GREATER2 *AstToken)  { my._GREATER2 = _GREATER2 }
func (my *AssignmentOperator8)      GetGREATER3() *AstToken{ return my._GREATER3}
func (my *AssignmentOperator8)      SetGREATER3( _GREATER3 *AstToken)  { my._GREATER3 = _GREATER3 }
func (my *AssignmentOperator8)      GetEQUAL() *AstToken{ return my._EQUAL}
func (my *AssignmentOperator8)      SetEQUAL( _EQUAL *AstToken)  { my._EQUAL = _EQUAL }

func NewAssignmentOperator8(leftIToken IToken, rightIToken IToken ,
              _GREATER *AstToken,
              _GREATER2 *AstToken,
              _GREATER3 *AstToken,
              _EQUAL *AstToken)*AssignmentOperator8{
      my := new(AssignmentOperator8)
      my.Ast = NewAst2(leftIToken, rightIToken)
        my._GREATER = _GREATER;
        if nil != _GREATER{
        var trait_ interface{} = _GREATER
         trait_.(IAst).SetParent(my)
}
        my._GREATER2 = _GREATER2;
        if nil != _GREATER2{
        var trait_ interface{} = _GREATER2
         trait_.(IAst).SetParent(my)
}
        my._GREATER3 = _GREATER3;
        if nil != _GREATER3{
        var trait_ interface{} = _GREATER3
         trait_.(IAst).SetParent(my)
}
        my._EQUAL = _EQUAL;
        if nil != _EQUAL{
        var trait_ interface{} = _EQUAL
         trait_.(IAst).SetParent(my)
}
        my.Initialize()
        return my
    }

    /**
     * A list of all children of my node, don't including the null ones.
     */
func (my *AssignmentOperator8)        GetAllChildren() * ArrayList{
        var list = NewArrayList()
        if nil != my._GREATER{  list.Add(my._GREATER) }
        if nil != my._GREATER2{  list.Add(my._GREATER2) }
        if nil != my._GREATER3{  list.Add(my._GREATER3) }
        if nil != my._EQUAL{  list.Add(my._EQUAL) }
        return list
    }

func (my *AssignmentOperator8)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator8(my)}
func (my *AssignmentOperator8)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator8WithArg(my, o) }
func (my *AssignmentOperator8)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator8WithResult(my) }
func (my *AssignmentOperator8)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator8WithResultArgument(my, o) }


func AnyCastToAssignmentOperator8(i interface{}) *AssignmentOperator8 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator8)
	}
}
/**
 *<b>
*<li>Rule 443:  AssignmentOperator ::= &=
 *</b>
 */
type AssignmentOperator9 struct{
    *AstToken
}
func (my *AssignmentOperator9)      GetAND_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator9(token IToken )*AssignmentOperator9{
      my := new(AssignmentOperator9)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator9)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator9(my)}
func (my *AssignmentOperator9)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator9WithArg(my, o) }
func (my *AssignmentOperator9)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator9WithResult(my) }
func (my *AssignmentOperator9)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator9WithResultArgument(my, o) }


func AnyCastToAssignmentOperator9(i interface{}) *AssignmentOperator9 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator9)
	}
}
/**
 *<b>
*<li>Rule 444:  AssignmentOperator ::= ^=
 *</b>
 */
type AssignmentOperator10 struct{
    *AstToken
}
func (my *AssignmentOperator10)      GetXOR_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator10(token IToken )*AssignmentOperator10{
      my := new(AssignmentOperator10)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator10)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator10(my)}
func (my *AssignmentOperator10)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator10WithArg(my, o) }
func (my *AssignmentOperator10)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator10WithResult(my) }
func (my *AssignmentOperator10)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator10WithResultArgument(my, o) }


func AnyCastToAssignmentOperator10(i interface{}) *AssignmentOperator10 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator10)
	}
}
/**
 *<b>
*<li>Rule 445:  AssignmentOperator ::= |=
 *</b>
 */
type AssignmentOperator11 struct{
    *AstToken
}
func (my *AssignmentOperator11)      GetOR_EQUAL()IToken{ return my.leftIToken; }

func NewAssignmentOperator11(token IToken )*AssignmentOperator11{
      my := new(AssignmentOperator11)
      my.AstToken = NewAstToken(token)
      my.Initialize()
      return my
    }

func (my *AssignmentOperator11)      AcceptWithVisitor(v Visitor) { v.VisitAssignmentOperator11(my)}
func (my *AssignmentOperator11)      AcceptWithArg(v ArgumentVisitor, o interface{}){ v.VisitAssignmentOperator11WithArg(my, o) }
func (my *AssignmentOperator11)      AcceptWithResult(v ResultVisitor) interface{}{return v.VisitAssignmentOperator11WithResult(my) }
func (my *AssignmentOperator11)      AcceptWithResultArgument(v ResultArgumentVisitor, o interface{}) interface{}{return v.VisitAssignmentOperator11WithResultArgument(my, o) }


func AnyCastToAssignmentOperator11(i interface{}) *AssignmentOperator11 {
	if nil == i{
		return nil
	}else{
		return i.(*AssignmentOperator11)
	}
}
type Visitor interface{
    VisitAstToken(n  *AstToken) 
    Visitidentifier(n  *identifier) 
    VisitPrimitiveType(n  *PrimitiveType) 
    VisitClassType(n  *ClassType) 
    VisitInterfaceType(n  *InterfaceType) 
    VisitTypeName(n  *TypeName) 
    VisitArrayType(n  *ArrayType) 
    VisitTypeParameter(n  *TypeParameter) 
    VisitTypeBound(n  *TypeBound) 
    VisitAdditionalBoundList(n  *AdditionalBoundList) 
    VisitAdditionalBound(n  *AdditionalBound) 
    VisitTypeArguments(n  *TypeArguments) 
    VisitActualTypeArgumentList(n  *ActualTypeArgumentList) 
    VisitWildcard(n  *Wildcard) 
    VisitPackageName(n  *PackageName) 
    VisitExpressionName(n  *ExpressionName) 
    VisitMethodName(n  *MethodName) 
    VisitPackageOrTypeName(n  *PackageOrTypeName) 
    VisitAmbiguousName(n  *AmbiguousName) 
    VisitCompilationUnit(n  *CompilationUnit) 
    VisitImportDeclarations(n  *ImportDeclarations) 
    VisitTypeDeclarations(n  *TypeDeclarations) 
    VisitPackageDeclaration(n  *PackageDeclaration) 
    VisitSingleTypeImportDeclaration(n  *SingleTypeImportDeclaration) 
    VisitTypeImportOnDemandDeclaration(n  *TypeImportOnDemandDeclaration) 
    VisitSingleStaticImportDeclaration(n  *SingleStaticImportDeclaration) 
    VisitStaticImportOnDemandDeclaration(n  *StaticImportOnDemandDeclaration) 
    VisitTypeDeclaration(n  *TypeDeclaration) 
    VisitNormalClassDeclaration(n  *NormalClassDeclaration) 
    VisitClassModifiers(n  *ClassModifiers) 
    VisitTypeParameters(n  *TypeParameters) 
    VisitTypeParameterList(n  *TypeParameterList) 
    VisitSuper(n  *Super) 
    VisitInterfaces(n  *Interfaces) 
    VisitInterfaceTypeList(n  *InterfaceTypeList) 
    VisitClassBody(n  *ClassBody) 
    VisitClassBodyDeclarations(n  *ClassBodyDeclarations) 
    VisitClassMemberDeclaration(n  *ClassMemberDeclaration) 
    VisitFieldDeclaration(n  *FieldDeclaration) 
    VisitVariableDeclarators(n  *VariableDeclarators) 
    VisitVariableDeclarator(n  *VariableDeclarator) 
    VisitVariableDeclaratorId(n  *VariableDeclaratorId) 
    VisitFieldModifiers(n  *FieldModifiers) 
    VisitMethodDeclaration(n  *MethodDeclaration) 
    VisitMethodHeader(n  *MethodHeader) 
    VisitResultType(n  *ResultType) 
    VisitFormalParameterList(n  *FormalParameterList) 
    VisitFormalParameters(n  *FormalParameters) 
    VisitFormalParameter(n  *FormalParameter) 
    VisitVariableModifiers(n  *VariableModifiers) 
    VisitVariableModifier(n  *VariableModifier) 
    VisitLastFormalParameter(n  *LastFormalParameter) 
    VisitMethodModifiers(n  *MethodModifiers) 
    VisitThrows(n  *Throws) 
    VisitExceptionTypeList(n  *ExceptionTypeList) 
    VisitMethodBody(n  *MethodBody) 
    VisitStaticInitializer(n  *StaticInitializer) 
    VisitConstructorDeclaration(n  *ConstructorDeclaration) 
    VisitConstructorDeclarator(n  *ConstructorDeclarator) 
    VisitConstructorModifiers(n  *ConstructorModifiers) 
    VisitConstructorBody(n  *ConstructorBody) 
    VisitEnumDeclaration(n  *EnumDeclaration) 
    VisitEnumBody(n  *EnumBody) 
    VisitEnumConstants(n  *EnumConstants) 
    VisitEnumConstant(n  *EnumConstant) 
    VisitArguments(n  *Arguments) 
    VisitEnumBodyDeclarations(n  *EnumBodyDeclarations) 
    VisitNormalInterfaceDeclaration(n  *NormalInterfaceDeclaration) 
    VisitInterfaceModifiers(n  *InterfaceModifiers) 
    VisitInterfaceBody(n  *InterfaceBody) 
    VisitInterfaceMemberDeclarations(n  *InterfaceMemberDeclarations) 
    VisitInterfaceMemberDeclaration(n  *InterfaceMemberDeclaration) 
    VisitConstantDeclaration(n  *ConstantDeclaration) 
    VisitConstantModifiers(n  *ConstantModifiers) 
    VisitAbstractMethodDeclaration(n  *AbstractMethodDeclaration) 
    VisitAbstractMethodModifiers(n  *AbstractMethodModifiers) 
    VisitAnnotationTypeDeclaration(n  *AnnotationTypeDeclaration) 
    VisitAnnotationTypeBody(n  *AnnotationTypeBody) 
    VisitAnnotationTypeElementDeclarations(n  *AnnotationTypeElementDeclarations) 
    VisitDefaultValue(n  *DefaultValue) 
    VisitAnnotations(n  *Annotations) 
    VisitNormalAnnotation(n  *NormalAnnotation) 
    VisitElementValuePairs(n  *ElementValuePairs) 
    VisitElementValuePair(n  *ElementValuePair) 
    VisitElementValueArrayInitializer(n  *ElementValueArrayInitializer) 
    VisitElementValues(n  *ElementValues) 
    VisitMarkerAnnotation(n  *MarkerAnnotation) 
    VisitSingleElementAnnotation(n  *SingleElementAnnotation) 
    VisitArrayInitializer(n  *ArrayInitializer) 
    VisitVariableInitializers(n  *VariableInitializers) 
    VisitBlock(n  *Block) 
    VisitBlockStatements(n  *BlockStatements) 
    VisitLocalVariableDeclarationStatement(n  *LocalVariableDeclarationStatement) 
    VisitLocalVariableDeclaration(n  *LocalVariableDeclaration) 
    VisitIfThenStatement(n  *IfThenStatement) 
    VisitIfThenElseStatement(n  *IfThenElseStatement) 
    VisitIfThenElseStatementNoShortIf(n  *IfThenElseStatementNoShortIf) 
    VisitEmptyStatement(n  *EmptyStatement) 
    VisitLabeledStatement(n  *LabeledStatement) 
    VisitLabeledStatementNoShortIf(n  *LabeledStatementNoShortIf) 
    VisitExpressionStatement(n  *ExpressionStatement) 
    VisitSwitchStatement(n  *SwitchStatement) 
    VisitSwitchBlock(n  *SwitchBlock) 
    VisitSwitchBlockStatementGroups(n  *SwitchBlockStatementGroups) 
    VisitSwitchBlockStatementGroup(n  *SwitchBlockStatementGroup) 
    VisitSwitchLabels(n  *SwitchLabels) 
    VisitWhileStatement(n  *WhileStatement) 
    VisitWhileStatementNoShortIf(n  *WhileStatementNoShortIf) 
    VisitDoStatement(n  *DoStatement) 
    VisitBasicForStatement(n  *BasicForStatement) 
    VisitForStatementNoShortIf(n  *ForStatementNoShortIf) 
    VisitStatementExpressionList(n  *StatementExpressionList) 
    VisitEnhancedForStatement(n  *EnhancedForStatement) 
    VisitBreakStatement(n  *BreakStatement) 
    VisitContinueStatement(n  *ContinueStatement) 
    VisitReturnStatement(n  *ReturnStatement) 
    VisitThrowStatement(n  *ThrowStatement) 
    VisitSynchronizedStatement(n  *SynchronizedStatement) 
    VisitCatches(n  *Catches) 
    VisitCatchClause(n  *CatchClause) 
    VisitFinally(n  *Finally) 
    VisitArgumentList(n  *ArgumentList) 
    VisitDimExprs(n  *DimExprs) 
    VisitDimExpr(n  *DimExpr) 
    VisitPostIncrementExpression(n  *PostIncrementExpression) 
    VisitPostDecrementExpression(n  *PostDecrementExpression) 
    VisitPreIncrementExpression(n  *PreIncrementExpression) 
    VisitPreDecrementExpression(n  *PreDecrementExpression) 
    VisitAndExpression(n  *AndExpression) 
    VisitExclusiveOrExpression(n  *ExclusiveOrExpression) 
    VisitInclusiveOrExpression(n  *InclusiveOrExpression) 
    VisitConditionalAndExpression(n  *ConditionalAndExpression) 
    VisitConditionalOrExpression(n  *ConditionalOrExpression) 
    VisitConditionalExpression(n  *ConditionalExpression) 
    VisitAssignment(n  *Assignment) 
    VisitCommaopt(n  *Commaopt) 
    VisitEllipsisopt(n  *Ellipsisopt) 
    VisitLPGUserAction0(n  *LPGUserAction0) 
    VisitLPGUserAction1(n  *LPGUserAction1) 
    VisitLPGUserAction2(n  *LPGUserAction2) 
    VisitLPGUserAction3(n  *LPGUserAction3) 
    VisitLPGUserAction4(n  *LPGUserAction4) 
    VisitIntegralType0(n  *IntegralType0) 
    VisitIntegralType1(n  *IntegralType1) 
    VisitIntegralType2(n  *IntegralType2) 
    VisitIntegralType3(n  *IntegralType3) 
    VisitIntegralType4(n  *IntegralType4) 
    VisitFloatingPointType0(n  *FloatingPointType0) 
    VisitFloatingPointType1(n  *FloatingPointType1) 
    VisitWildcardBounds0(n  *WildcardBounds0) 
    VisitWildcardBounds1(n  *WildcardBounds1) 
    VisitClassModifier0(n  *ClassModifier0) 
    VisitClassModifier1(n  *ClassModifier1) 
    VisitClassModifier2(n  *ClassModifier2) 
    VisitClassModifier3(n  *ClassModifier3) 
    VisitClassModifier4(n  *ClassModifier4) 
    VisitClassModifier5(n  *ClassModifier5) 
    VisitClassModifier6(n  *ClassModifier6) 
    VisitFieldModifier0(n  *FieldModifier0) 
    VisitFieldModifier1(n  *FieldModifier1) 
    VisitFieldModifier2(n  *FieldModifier2) 
    VisitFieldModifier3(n  *FieldModifier3) 
    VisitFieldModifier4(n  *FieldModifier4) 
    VisitFieldModifier5(n  *FieldModifier5) 
    VisitFieldModifier6(n  *FieldModifier6) 
    VisitMethodDeclarator0(n  *MethodDeclarator0) 
    VisitMethodDeclarator1(n  *MethodDeclarator1) 
    VisitMethodModifier0(n  *MethodModifier0) 
    VisitMethodModifier1(n  *MethodModifier1) 
    VisitMethodModifier2(n  *MethodModifier2) 
    VisitMethodModifier3(n  *MethodModifier3) 
    VisitMethodModifier4(n  *MethodModifier4) 
    VisitMethodModifier5(n  *MethodModifier5) 
    VisitMethodModifier6(n  *MethodModifier6) 
    VisitMethodModifier7(n  *MethodModifier7) 
    VisitMethodModifier8(n  *MethodModifier8) 
    VisitConstructorModifier0(n  *ConstructorModifier0) 
    VisitConstructorModifier1(n  *ConstructorModifier1) 
    VisitConstructorModifier2(n  *ConstructorModifier2) 
    VisitExplicitConstructorInvocation0(n  *ExplicitConstructorInvocation0) 
    VisitExplicitConstructorInvocation1(n  *ExplicitConstructorInvocation1) 
    VisitExplicitConstructorInvocation2(n  *ExplicitConstructorInvocation2) 
    VisitInterfaceModifier0(n  *InterfaceModifier0) 
    VisitInterfaceModifier1(n  *InterfaceModifier1) 
    VisitInterfaceModifier2(n  *InterfaceModifier2) 
    VisitInterfaceModifier3(n  *InterfaceModifier3) 
    VisitInterfaceModifier4(n  *InterfaceModifier4) 
    VisitInterfaceModifier5(n  *InterfaceModifier5) 
    VisitExtendsInterfaces0(n  *ExtendsInterfaces0) 
    VisitExtendsInterfaces1(n  *ExtendsInterfaces1) 
    VisitConstantModifier0(n  *ConstantModifier0) 
    VisitConstantModifier1(n  *ConstantModifier1) 
    VisitConstantModifier2(n  *ConstantModifier2) 
    VisitAbstractMethodModifier0(n  *AbstractMethodModifier0) 
    VisitAbstractMethodModifier1(n  *AbstractMethodModifier1) 
    VisitAnnotationTypeElementDeclaration0(n  *AnnotationTypeElementDeclaration0) 
    VisitAnnotationTypeElementDeclaration1(n  *AnnotationTypeElementDeclaration1) 
    VisitAssertStatement0(n  *AssertStatement0) 
    VisitAssertStatement1(n  *AssertStatement1) 
    VisitSwitchLabel0(n  *SwitchLabel0) 
    VisitSwitchLabel1(n  *SwitchLabel1) 
    VisitSwitchLabel2(n  *SwitchLabel2) 
    VisitTryStatement0(n  *TryStatement0) 
    VisitTryStatement1(n  *TryStatement1) 
    VisitPrimaryNoNewArray0(n  *PrimaryNoNewArray0) 
    VisitPrimaryNoNewArray1(n  *PrimaryNoNewArray1) 
    VisitPrimaryNoNewArray2(n  *PrimaryNoNewArray2) 
    VisitPrimaryNoNewArray3(n  *PrimaryNoNewArray3) 
    VisitPrimaryNoNewArray4(n  *PrimaryNoNewArray4) 
    VisitLiteral0(n  *Literal0) 
    VisitLiteral1(n  *Literal1) 
    VisitLiteral2(n  *Literal2) 
    VisitLiteral3(n  *Literal3) 
    VisitLiteral4(n  *Literal4) 
    VisitLiteral5(n  *Literal5) 
    VisitLiteral6(n  *Literal6) 
    VisitBooleanLiteral0(n  *BooleanLiteral0) 
    VisitBooleanLiteral1(n  *BooleanLiteral1) 
    VisitClassInstanceCreationExpression0(n  *ClassInstanceCreationExpression0) 
    VisitClassInstanceCreationExpression1(n  *ClassInstanceCreationExpression1) 
    VisitArrayCreationExpression0(n  *ArrayCreationExpression0) 
    VisitArrayCreationExpression1(n  *ArrayCreationExpression1) 
    VisitArrayCreationExpression2(n  *ArrayCreationExpression2) 
    VisitArrayCreationExpression3(n  *ArrayCreationExpression3) 
    VisitDims0(n  *Dims0) 
    VisitDims1(n  *Dims1) 
    VisitFieldAccess0(n  *FieldAccess0) 
    VisitFieldAccess1(n  *FieldAccess1) 
    VisitFieldAccess2(n  *FieldAccess2) 
    VisitMethodInvocation0(n  *MethodInvocation0) 
    VisitMethodInvocation1(n  *MethodInvocation1) 
    VisitMethodInvocation2(n  *MethodInvocation2) 
    VisitMethodInvocation3(n  *MethodInvocation3) 
    VisitMethodInvocation4(n  *MethodInvocation4) 
    VisitArrayAccess0(n  *ArrayAccess0) 
    VisitArrayAccess1(n  *ArrayAccess1) 
    VisitUnaryExpression0(n  *UnaryExpression0) 
    VisitUnaryExpression1(n  *UnaryExpression1) 
    VisitUnaryExpressionNotPlusMinus0(n  *UnaryExpressionNotPlusMinus0) 
    VisitUnaryExpressionNotPlusMinus1(n  *UnaryExpressionNotPlusMinus1) 
    VisitCastExpression0(n  *CastExpression0) 
    VisitCastExpression1(n  *CastExpression1) 
    VisitMultiplicativeExpression0(n  *MultiplicativeExpression0) 
    VisitMultiplicativeExpression1(n  *MultiplicativeExpression1) 
    VisitMultiplicativeExpression2(n  *MultiplicativeExpression2) 
    VisitAdditiveExpression0(n  *AdditiveExpression0) 
    VisitAdditiveExpression1(n  *AdditiveExpression1) 
    VisitShiftExpression0(n  *ShiftExpression0) 
    VisitShiftExpression1(n  *ShiftExpression1) 
    VisitShiftExpression2(n  *ShiftExpression2) 
    VisitRelationalExpression0(n  *RelationalExpression0) 
    VisitRelationalExpression1(n  *RelationalExpression1) 
    VisitRelationalExpression2(n  *RelationalExpression2) 
    VisitRelationalExpression3(n  *RelationalExpression3) 
    VisitRelationalExpression4(n  *RelationalExpression4) 
    VisitEqualityExpression0(n  *EqualityExpression0) 
    VisitEqualityExpression1(n  *EqualityExpression1) 
    VisitAssignmentOperator0(n  *AssignmentOperator0) 
    VisitAssignmentOperator1(n  *AssignmentOperator1) 
    VisitAssignmentOperator2(n  *AssignmentOperator2) 
    VisitAssignmentOperator3(n  *AssignmentOperator3) 
    VisitAssignmentOperator4(n  *AssignmentOperator4) 
    VisitAssignmentOperator5(n  *AssignmentOperator5) 
    VisitAssignmentOperator6(n  *AssignmentOperator6) 
    VisitAssignmentOperator7(n  *AssignmentOperator7) 
    VisitAssignmentOperator8(n  *AssignmentOperator8) 
    VisitAssignmentOperator9(n  *AssignmentOperator9) 
    VisitAssignmentOperator10(n  *AssignmentOperator10) 
    VisitAssignmentOperator11(n  *AssignmentOperator11) 

    Visit(n  IAst)
}
func AnyCastToVisitor(i interface{}) Visitor {
	  if nil == i{
		 return nil
	  }else{
		 return i.(Visitor)
	  }
}
type ArgumentVisitor interface{
    VisitAstTokenWithArg(n  *AstToken, o interface{}) 
    VisitidentifierWithArg(n  *identifier, o interface{}) 
    VisitPrimitiveTypeWithArg(n  *PrimitiveType, o interface{}) 
    VisitClassTypeWithArg(n  *ClassType, o interface{}) 
    VisitInterfaceTypeWithArg(n  *InterfaceType, o interface{}) 
    VisitTypeNameWithArg(n  *TypeName, o interface{}) 
    VisitArrayTypeWithArg(n  *ArrayType, o interface{}) 
    VisitTypeParameterWithArg(n  *TypeParameter, o interface{}) 
    VisitTypeBoundWithArg(n  *TypeBound, o interface{}) 
    VisitAdditionalBoundListWithArg(n  *AdditionalBoundList, o interface{}) 
    VisitAdditionalBoundWithArg(n  *AdditionalBound, o interface{}) 
    VisitTypeArgumentsWithArg(n  *TypeArguments, o interface{}) 
    VisitActualTypeArgumentListWithArg(n  *ActualTypeArgumentList, o interface{}) 
    VisitWildcardWithArg(n  *Wildcard, o interface{}) 
    VisitPackageNameWithArg(n  *PackageName, o interface{}) 
    VisitExpressionNameWithArg(n  *ExpressionName, o interface{}) 
    VisitMethodNameWithArg(n  *MethodName, o interface{}) 
    VisitPackageOrTypeNameWithArg(n  *PackageOrTypeName, o interface{}) 
    VisitAmbiguousNameWithArg(n  *AmbiguousName, o interface{}) 
    VisitCompilationUnitWithArg(n  *CompilationUnit, o interface{}) 
    VisitImportDeclarationsWithArg(n  *ImportDeclarations, o interface{}) 
    VisitTypeDeclarationsWithArg(n  *TypeDeclarations, o interface{}) 
    VisitPackageDeclarationWithArg(n  *PackageDeclaration, o interface{}) 
    VisitSingleTypeImportDeclarationWithArg(n  *SingleTypeImportDeclaration, o interface{}) 
    VisitTypeImportOnDemandDeclarationWithArg(n  *TypeImportOnDemandDeclaration, o interface{}) 
    VisitSingleStaticImportDeclarationWithArg(n  *SingleStaticImportDeclaration, o interface{}) 
    VisitStaticImportOnDemandDeclarationWithArg(n  *StaticImportOnDemandDeclaration, o interface{}) 
    VisitTypeDeclarationWithArg(n  *TypeDeclaration, o interface{}) 
    VisitNormalClassDeclarationWithArg(n  *NormalClassDeclaration, o interface{}) 
    VisitClassModifiersWithArg(n  *ClassModifiers, o interface{}) 
    VisitTypeParametersWithArg(n  *TypeParameters, o interface{}) 
    VisitTypeParameterListWithArg(n  *TypeParameterList, o interface{}) 
    VisitSuperWithArg(n  *Super, o interface{}) 
    VisitInterfacesWithArg(n  *Interfaces, o interface{}) 
    VisitInterfaceTypeListWithArg(n  *InterfaceTypeList, o interface{}) 
    VisitClassBodyWithArg(n  *ClassBody, o interface{}) 
    VisitClassBodyDeclarationsWithArg(n  *ClassBodyDeclarations, o interface{}) 
    VisitClassMemberDeclarationWithArg(n  *ClassMemberDeclaration, o interface{}) 
    VisitFieldDeclarationWithArg(n  *FieldDeclaration, o interface{}) 
    VisitVariableDeclaratorsWithArg(n  *VariableDeclarators, o interface{}) 
    VisitVariableDeclaratorWithArg(n  *VariableDeclarator, o interface{}) 
    VisitVariableDeclaratorIdWithArg(n  *VariableDeclaratorId, o interface{}) 
    VisitFieldModifiersWithArg(n  *FieldModifiers, o interface{}) 
    VisitMethodDeclarationWithArg(n  *MethodDeclaration, o interface{}) 
    VisitMethodHeaderWithArg(n  *MethodHeader, o interface{}) 
    VisitResultTypeWithArg(n  *ResultType, o interface{}) 
    VisitFormalParameterListWithArg(n  *FormalParameterList, o interface{}) 
    VisitFormalParametersWithArg(n  *FormalParameters, o interface{}) 
    VisitFormalParameterWithArg(n  *FormalParameter, o interface{}) 
    VisitVariableModifiersWithArg(n  *VariableModifiers, o interface{}) 
    VisitVariableModifierWithArg(n  *VariableModifier, o interface{}) 
    VisitLastFormalParameterWithArg(n  *LastFormalParameter, o interface{}) 
    VisitMethodModifiersWithArg(n  *MethodModifiers, o interface{}) 
    VisitThrowsWithArg(n  *Throws, o interface{}) 
    VisitExceptionTypeListWithArg(n  *ExceptionTypeList, o interface{}) 
    VisitMethodBodyWithArg(n  *MethodBody, o interface{}) 
    VisitStaticInitializerWithArg(n  *StaticInitializer, o interface{}) 
    VisitConstructorDeclarationWithArg(n  *ConstructorDeclaration, o interface{}) 
    VisitConstructorDeclaratorWithArg(n  *ConstructorDeclarator, o interface{}) 
    VisitConstructorModifiersWithArg(n  *ConstructorModifiers, o interface{}) 
    VisitConstructorBodyWithArg(n  *ConstructorBody, o interface{}) 
    VisitEnumDeclarationWithArg(n  *EnumDeclaration, o interface{}) 
    VisitEnumBodyWithArg(n  *EnumBody, o interface{}) 
    VisitEnumConstantsWithArg(n  *EnumConstants, o interface{}) 
    VisitEnumConstantWithArg(n  *EnumConstant, o interface{}) 
    VisitArgumentsWithArg(n  *Arguments, o interface{}) 
    VisitEnumBodyDeclarationsWithArg(n  *EnumBodyDeclarations, o interface{}) 
    VisitNormalInterfaceDeclarationWithArg(n  *NormalInterfaceDeclaration, o interface{}) 
    VisitInterfaceModifiersWithArg(n  *InterfaceModifiers, o interface{}) 
    VisitInterfaceBodyWithArg(n  *InterfaceBody, o interface{}) 
    VisitInterfaceMemberDeclarationsWithArg(n  *InterfaceMemberDeclarations, o interface{}) 
    VisitInterfaceMemberDeclarationWithArg(n  *InterfaceMemberDeclaration, o interface{}) 
    VisitConstantDeclarationWithArg(n  *ConstantDeclaration, o interface{}) 
    VisitConstantModifiersWithArg(n  *ConstantModifiers, o interface{}) 
    VisitAbstractMethodDeclarationWithArg(n  *AbstractMethodDeclaration, o interface{}) 
    VisitAbstractMethodModifiersWithArg(n  *AbstractMethodModifiers, o interface{}) 
    VisitAnnotationTypeDeclarationWithArg(n  *AnnotationTypeDeclaration, o interface{}) 
    VisitAnnotationTypeBodyWithArg(n  *AnnotationTypeBody, o interface{}) 
    VisitAnnotationTypeElementDeclarationsWithArg(n  *AnnotationTypeElementDeclarations, o interface{}) 
    VisitDefaultValueWithArg(n  *DefaultValue, o interface{}) 
    VisitAnnotationsWithArg(n  *Annotations, o interface{}) 
    VisitNormalAnnotationWithArg(n  *NormalAnnotation, o interface{}) 
    VisitElementValuePairsWithArg(n  *ElementValuePairs, o interface{}) 
    VisitElementValuePairWithArg(n  *ElementValuePair, o interface{}) 
    VisitElementValueArrayInitializerWithArg(n  *ElementValueArrayInitializer, o interface{}) 
    VisitElementValuesWithArg(n  *ElementValues, o interface{}) 
    VisitMarkerAnnotationWithArg(n  *MarkerAnnotation, o interface{}) 
    VisitSingleElementAnnotationWithArg(n  *SingleElementAnnotation, o interface{}) 
    VisitArrayInitializerWithArg(n  *ArrayInitializer, o interface{}) 
    VisitVariableInitializersWithArg(n  *VariableInitializers, o interface{}) 
    VisitBlockWithArg(n  *Block, o interface{}) 
    VisitBlockStatementsWithArg(n  *BlockStatements, o interface{}) 
    VisitLocalVariableDeclarationStatementWithArg(n  *LocalVariableDeclarationStatement, o interface{}) 
    VisitLocalVariableDeclarationWithArg(n  *LocalVariableDeclaration, o interface{}) 
    VisitIfThenStatementWithArg(n  *IfThenStatement, o interface{}) 
    VisitIfThenElseStatementWithArg(n  *IfThenElseStatement, o interface{}) 
    VisitIfThenElseStatementNoShortIfWithArg(n  *IfThenElseStatementNoShortIf, o interface{}) 
    VisitEmptyStatementWithArg(n  *EmptyStatement, o interface{}) 
    VisitLabeledStatementWithArg(n  *LabeledStatement, o interface{}) 
    VisitLabeledStatementNoShortIfWithArg(n  *LabeledStatementNoShortIf, o interface{}) 
    VisitExpressionStatementWithArg(n  *ExpressionStatement, o interface{}) 
    VisitSwitchStatementWithArg(n  *SwitchStatement, o interface{}) 
    VisitSwitchBlockWithArg(n  *SwitchBlock, o interface{}) 
    VisitSwitchBlockStatementGroupsWithArg(n  *SwitchBlockStatementGroups, o interface{}) 
    VisitSwitchBlockStatementGroupWithArg(n  *SwitchBlockStatementGroup, o interface{}) 
    VisitSwitchLabelsWithArg(n  *SwitchLabels, o interface{}) 
    VisitWhileStatementWithArg(n  *WhileStatement, o interface{}) 
    VisitWhileStatementNoShortIfWithArg(n  *WhileStatementNoShortIf, o interface{}) 
    VisitDoStatementWithArg(n  *DoStatement, o interface{}) 
    VisitBasicForStatementWithArg(n  *BasicForStatement, o interface{}) 
    VisitForStatementNoShortIfWithArg(n  *ForStatementNoShortIf, o interface{}) 
    VisitStatementExpressionListWithArg(n  *StatementExpressionList, o interface{}) 
    VisitEnhancedForStatementWithArg(n  *EnhancedForStatement, o interface{}) 
    VisitBreakStatementWithArg(n  *BreakStatement, o interface{}) 
    VisitContinueStatementWithArg(n  *ContinueStatement, o interface{}) 
    VisitReturnStatementWithArg(n  *ReturnStatement, o interface{}) 
    VisitThrowStatementWithArg(n  *ThrowStatement, o interface{}) 
    VisitSynchronizedStatementWithArg(n  *SynchronizedStatement, o interface{}) 
    VisitCatchesWithArg(n  *Catches, o interface{}) 
    VisitCatchClauseWithArg(n  *CatchClause, o interface{}) 
    VisitFinallyWithArg(n  *Finally, o interface{}) 
    VisitArgumentListWithArg(n  *ArgumentList, o interface{}) 
    VisitDimExprsWithArg(n  *DimExprs, o interface{}) 
    VisitDimExprWithArg(n  *DimExpr, o interface{}) 
    VisitPostIncrementExpressionWithArg(n  *PostIncrementExpression, o interface{}) 
    VisitPostDecrementExpressionWithArg(n  *PostDecrementExpression, o interface{}) 
    VisitPreIncrementExpressionWithArg(n  *PreIncrementExpression, o interface{}) 
    VisitPreDecrementExpressionWithArg(n  *PreDecrementExpression, o interface{}) 
    VisitAndExpressionWithArg(n  *AndExpression, o interface{}) 
    VisitExclusiveOrExpressionWithArg(n  *ExclusiveOrExpression, o interface{}) 
    VisitInclusiveOrExpressionWithArg(n  *InclusiveOrExpression, o interface{}) 
    VisitConditionalAndExpressionWithArg(n  *ConditionalAndExpression, o interface{}) 
    VisitConditionalOrExpressionWithArg(n  *ConditionalOrExpression, o interface{}) 
    VisitConditionalExpressionWithArg(n  *ConditionalExpression, o interface{}) 
    VisitAssignmentWithArg(n  *Assignment, o interface{}) 
    VisitCommaoptWithArg(n  *Commaopt, o interface{}) 
    VisitEllipsisoptWithArg(n  *Ellipsisopt, o interface{}) 
    VisitLPGUserAction0WithArg(n  *LPGUserAction0, o interface{}) 
    VisitLPGUserAction1WithArg(n  *LPGUserAction1, o interface{}) 
    VisitLPGUserAction2WithArg(n  *LPGUserAction2, o interface{}) 
    VisitLPGUserAction3WithArg(n  *LPGUserAction3, o interface{}) 
    VisitLPGUserAction4WithArg(n  *LPGUserAction4, o interface{}) 
    VisitIntegralType0WithArg(n  *IntegralType0, o interface{}) 
    VisitIntegralType1WithArg(n  *IntegralType1, o interface{}) 
    VisitIntegralType2WithArg(n  *IntegralType2, o interface{}) 
    VisitIntegralType3WithArg(n  *IntegralType3, o interface{}) 
    VisitIntegralType4WithArg(n  *IntegralType4, o interface{}) 
    VisitFloatingPointType0WithArg(n  *FloatingPointType0, o interface{}) 
    VisitFloatingPointType1WithArg(n  *FloatingPointType1, o interface{}) 
    VisitWildcardBounds0WithArg(n  *WildcardBounds0, o interface{}) 
    VisitWildcardBounds1WithArg(n  *WildcardBounds1, o interface{}) 
    VisitClassModifier0WithArg(n  *ClassModifier0, o interface{}) 
    VisitClassModifier1WithArg(n  *ClassModifier1, o interface{}) 
    VisitClassModifier2WithArg(n  *ClassModifier2, o interface{}) 
    VisitClassModifier3WithArg(n  *ClassModifier3, o interface{}) 
    VisitClassModifier4WithArg(n  *ClassModifier4, o interface{}) 
    VisitClassModifier5WithArg(n  *ClassModifier5, o interface{}) 
    VisitClassModifier6WithArg(n  *ClassModifier6, o interface{}) 
    VisitFieldModifier0WithArg(n  *FieldModifier0, o interface{}) 
    VisitFieldModifier1WithArg(n  *FieldModifier1, o interface{}) 
    VisitFieldModifier2WithArg(n  *FieldModifier2, o interface{}) 
    VisitFieldModifier3WithArg(n  *FieldModifier3, o interface{}) 
    VisitFieldModifier4WithArg(n  *FieldModifier4, o interface{}) 
    VisitFieldModifier5WithArg(n  *FieldModifier5, o interface{}) 
    VisitFieldModifier6WithArg(n  *FieldModifier6, o interface{}) 
    VisitMethodDeclarator0WithArg(n  *MethodDeclarator0, o interface{}) 
    VisitMethodDeclarator1WithArg(n  *MethodDeclarator1, o interface{}) 
    VisitMethodModifier0WithArg(n  *MethodModifier0, o interface{}) 
    VisitMethodModifier1WithArg(n  *MethodModifier1, o interface{}) 
    VisitMethodModifier2WithArg(n  *MethodModifier2, o interface{}) 
    VisitMethodModifier3WithArg(n  *MethodModifier3, o interface{}) 
    VisitMethodModifier4WithArg(n  *MethodModifier4, o interface{}) 
    VisitMethodModifier5WithArg(n  *MethodModifier5, o interface{}) 
    VisitMethodModifier6WithArg(n  *MethodModifier6, o interface{}) 
    VisitMethodModifier7WithArg(n  *MethodModifier7, o interface{}) 
    VisitMethodModifier8WithArg(n  *MethodModifier8, o interface{}) 
    VisitConstructorModifier0WithArg(n  *ConstructorModifier0, o interface{}) 
    VisitConstructorModifier1WithArg(n  *ConstructorModifier1, o interface{}) 
    VisitConstructorModifier2WithArg(n  *ConstructorModifier2, o interface{}) 
    VisitExplicitConstructorInvocation0WithArg(n  *ExplicitConstructorInvocation0, o interface{}) 
    VisitExplicitConstructorInvocation1WithArg(n  *ExplicitConstructorInvocation1, o interface{}) 
    VisitExplicitConstructorInvocation2WithArg(n  *ExplicitConstructorInvocation2, o interface{}) 
    VisitInterfaceModifier0WithArg(n  *InterfaceModifier0, o interface{}) 
    VisitInterfaceModifier1WithArg(n  *InterfaceModifier1, o interface{}) 
    VisitInterfaceModifier2WithArg(n  *InterfaceModifier2, o interface{}) 
    VisitInterfaceModifier3WithArg(n  *InterfaceModifier3, o interface{}) 
    VisitInterfaceModifier4WithArg(n  *InterfaceModifier4, o interface{}) 
    VisitInterfaceModifier5WithArg(n  *InterfaceModifier5, o interface{}) 
    VisitExtendsInterfaces0WithArg(n  *ExtendsInterfaces0, o interface{}) 
    VisitExtendsInterfaces1WithArg(n  *ExtendsInterfaces1, o interface{}) 
    VisitConstantModifier0WithArg(n  *ConstantModifier0, o interface{}) 
    VisitConstantModifier1WithArg(n  *ConstantModifier1, o interface{}) 
    VisitConstantModifier2WithArg(n  *ConstantModifier2, o interface{}) 
    VisitAbstractMethodModifier0WithArg(n  *AbstractMethodModifier0, o interface{}) 
    VisitAbstractMethodModifier1WithArg(n  *AbstractMethodModifier1, o interface{}) 
    VisitAnnotationTypeElementDeclaration0WithArg(n  *AnnotationTypeElementDeclaration0, o interface{}) 
    VisitAnnotationTypeElementDeclaration1WithArg(n  *AnnotationTypeElementDeclaration1, o interface{}) 
    VisitAssertStatement0WithArg(n  *AssertStatement0, o interface{}) 
    VisitAssertStatement1WithArg(n  *AssertStatement1, o interface{}) 
    VisitSwitchLabel0WithArg(n  *SwitchLabel0, o interface{}) 
    VisitSwitchLabel1WithArg(n  *SwitchLabel1, o interface{}) 
    VisitSwitchLabel2WithArg(n  *SwitchLabel2, o interface{}) 
    VisitTryStatement0WithArg(n  *TryStatement0, o interface{}) 
    VisitTryStatement1WithArg(n  *TryStatement1, o interface{}) 
    VisitPrimaryNoNewArray0WithArg(n  *PrimaryNoNewArray0, o interface{}) 
    VisitPrimaryNoNewArray1WithArg(n  *PrimaryNoNewArray1, o interface{}) 
    VisitPrimaryNoNewArray2WithArg(n  *PrimaryNoNewArray2, o interface{}) 
    VisitPrimaryNoNewArray3WithArg(n  *PrimaryNoNewArray3, o interface{}) 
    VisitPrimaryNoNewArray4WithArg(n  *PrimaryNoNewArray4, o interface{}) 
    VisitLiteral0WithArg(n  *Literal0, o interface{}) 
    VisitLiteral1WithArg(n  *Literal1, o interface{}) 
    VisitLiteral2WithArg(n  *Literal2, o interface{}) 
    VisitLiteral3WithArg(n  *Literal3, o interface{}) 
    VisitLiteral4WithArg(n  *Literal4, o interface{}) 
    VisitLiteral5WithArg(n  *Literal5, o interface{}) 
    VisitLiteral6WithArg(n  *Literal6, o interface{}) 
    VisitBooleanLiteral0WithArg(n  *BooleanLiteral0, o interface{}) 
    VisitBooleanLiteral1WithArg(n  *BooleanLiteral1, o interface{}) 
    VisitClassInstanceCreationExpression0WithArg(n  *ClassInstanceCreationExpression0, o interface{}) 
    VisitClassInstanceCreationExpression1WithArg(n  *ClassInstanceCreationExpression1, o interface{}) 
    VisitArrayCreationExpression0WithArg(n  *ArrayCreationExpression0, o interface{}) 
    VisitArrayCreationExpression1WithArg(n  *ArrayCreationExpression1, o interface{}) 
    VisitArrayCreationExpression2WithArg(n  *ArrayCreationExpression2, o interface{}) 
    VisitArrayCreationExpression3WithArg(n  *ArrayCreationExpression3, o interface{}) 
    VisitDims0WithArg(n  *Dims0, o interface{}) 
    VisitDims1WithArg(n  *Dims1, o interface{}) 
    VisitFieldAccess0WithArg(n  *FieldAccess0, o interface{}) 
    VisitFieldAccess1WithArg(n  *FieldAccess1, o interface{}) 
    VisitFieldAccess2WithArg(n  *FieldAccess2, o interface{}) 
    VisitMethodInvocation0WithArg(n  *MethodInvocation0, o interface{}) 
    VisitMethodInvocation1WithArg(n  *MethodInvocation1, o interface{}) 
    VisitMethodInvocation2WithArg(n  *MethodInvocation2, o interface{}) 
    VisitMethodInvocation3WithArg(n  *MethodInvocation3, o interface{}) 
    VisitMethodInvocation4WithArg(n  *MethodInvocation4, o interface{}) 
    VisitArrayAccess0WithArg(n  *ArrayAccess0, o interface{}) 
    VisitArrayAccess1WithArg(n  *ArrayAccess1, o interface{}) 
    VisitUnaryExpression0WithArg(n  *UnaryExpression0, o interface{}) 
    VisitUnaryExpression1WithArg(n  *UnaryExpression1, o interface{}) 
    VisitUnaryExpressionNotPlusMinus0WithArg(n  *UnaryExpressionNotPlusMinus0, o interface{}) 
    VisitUnaryExpressionNotPlusMinus1WithArg(n  *UnaryExpressionNotPlusMinus1, o interface{}) 
    VisitCastExpression0WithArg(n  *CastExpression0, o interface{}) 
    VisitCastExpression1WithArg(n  *CastExpression1, o interface{}) 
    VisitMultiplicativeExpression0WithArg(n  *MultiplicativeExpression0, o interface{}) 
    VisitMultiplicativeExpression1WithArg(n  *MultiplicativeExpression1, o interface{}) 
    VisitMultiplicativeExpression2WithArg(n  *MultiplicativeExpression2, o interface{}) 
    VisitAdditiveExpression0WithArg(n  *AdditiveExpression0, o interface{}) 
    VisitAdditiveExpression1WithArg(n  *AdditiveExpression1, o interface{}) 
    VisitShiftExpression0WithArg(n  *ShiftExpression0, o interface{}) 
    VisitShiftExpression1WithArg(n  *ShiftExpression1, o interface{}) 
    VisitShiftExpression2WithArg(n  *ShiftExpression2, o interface{}) 
    VisitRelationalExpression0WithArg(n  *RelationalExpression0, o interface{}) 
    VisitRelationalExpression1WithArg(n  *RelationalExpression1, o interface{}) 
    VisitRelationalExpression2WithArg(n  *RelationalExpression2, o interface{}) 
    VisitRelationalExpression3WithArg(n  *RelationalExpression3, o interface{}) 
    VisitRelationalExpression4WithArg(n  *RelationalExpression4, o interface{}) 
    VisitEqualityExpression0WithArg(n  *EqualityExpression0, o interface{}) 
    VisitEqualityExpression1WithArg(n  *EqualityExpression1, o interface{}) 
    VisitAssignmentOperator0WithArg(n  *AssignmentOperator0, o interface{}) 
    VisitAssignmentOperator1WithArg(n  *AssignmentOperator1, o interface{}) 
    VisitAssignmentOperator2WithArg(n  *AssignmentOperator2, o interface{}) 
    VisitAssignmentOperator3WithArg(n  *AssignmentOperator3, o interface{}) 
    VisitAssignmentOperator4WithArg(n  *AssignmentOperator4, o interface{}) 
    VisitAssignmentOperator5WithArg(n  *AssignmentOperator5, o interface{}) 
    VisitAssignmentOperator6WithArg(n  *AssignmentOperator6, o interface{}) 
    VisitAssignmentOperator7WithArg(n  *AssignmentOperator7, o interface{}) 
    VisitAssignmentOperator8WithArg(n  *AssignmentOperator8, o interface{}) 
    VisitAssignmentOperator9WithArg(n  *AssignmentOperator9, o interface{}) 
    VisitAssignmentOperator10WithArg(n  *AssignmentOperator10, o interface{}) 
    VisitAssignmentOperator11WithArg(n  *AssignmentOperator11, o interface{}) 

    VisitWithArg(n  IAst, o interface{}) 
}
func AnyCastToArgumentVisitor(i interface{}) ArgumentVisitor {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ArgumentVisitor)
	  }
}
type ResultVisitor interface{
    VisitAstTokenWithResult(n  *AstToken) interface{}
    VisitidentifierWithResult(n  *identifier) interface{}
    VisitPrimitiveTypeWithResult(n  *PrimitiveType) interface{}
    VisitClassTypeWithResult(n  *ClassType) interface{}
    VisitInterfaceTypeWithResult(n  *InterfaceType) interface{}
    VisitTypeNameWithResult(n  *TypeName) interface{}
    VisitArrayTypeWithResult(n  *ArrayType) interface{}
    VisitTypeParameterWithResult(n  *TypeParameter) interface{}
    VisitTypeBoundWithResult(n  *TypeBound) interface{}
    VisitAdditionalBoundListWithResult(n  *AdditionalBoundList) interface{}
    VisitAdditionalBoundWithResult(n  *AdditionalBound) interface{}
    VisitTypeArgumentsWithResult(n  *TypeArguments) interface{}
    VisitActualTypeArgumentListWithResult(n  *ActualTypeArgumentList) interface{}
    VisitWildcardWithResult(n  *Wildcard) interface{}
    VisitPackageNameWithResult(n  *PackageName) interface{}
    VisitExpressionNameWithResult(n  *ExpressionName) interface{}
    VisitMethodNameWithResult(n  *MethodName) interface{}
    VisitPackageOrTypeNameWithResult(n  *PackageOrTypeName) interface{}
    VisitAmbiguousNameWithResult(n  *AmbiguousName) interface{}
    VisitCompilationUnitWithResult(n  *CompilationUnit) interface{}
    VisitImportDeclarationsWithResult(n  *ImportDeclarations) interface{}
    VisitTypeDeclarationsWithResult(n  *TypeDeclarations) interface{}
    VisitPackageDeclarationWithResult(n  *PackageDeclaration) interface{}
    VisitSingleTypeImportDeclarationWithResult(n  *SingleTypeImportDeclaration) interface{}
    VisitTypeImportOnDemandDeclarationWithResult(n  *TypeImportOnDemandDeclaration) interface{}
    VisitSingleStaticImportDeclarationWithResult(n  *SingleStaticImportDeclaration) interface{}
    VisitStaticImportOnDemandDeclarationWithResult(n  *StaticImportOnDemandDeclaration) interface{}
    VisitTypeDeclarationWithResult(n  *TypeDeclaration) interface{}
    VisitNormalClassDeclarationWithResult(n  *NormalClassDeclaration) interface{}
    VisitClassModifiersWithResult(n  *ClassModifiers) interface{}
    VisitTypeParametersWithResult(n  *TypeParameters) interface{}
    VisitTypeParameterListWithResult(n  *TypeParameterList) interface{}
    VisitSuperWithResult(n  *Super) interface{}
    VisitInterfacesWithResult(n  *Interfaces) interface{}
    VisitInterfaceTypeListWithResult(n  *InterfaceTypeList) interface{}
    VisitClassBodyWithResult(n  *ClassBody) interface{}
    VisitClassBodyDeclarationsWithResult(n  *ClassBodyDeclarations) interface{}
    VisitClassMemberDeclarationWithResult(n  *ClassMemberDeclaration) interface{}
    VisitFieldDeclarationWithResult(n  *FieldDeclaration) interface{}
    VisitVariableDeclaratorsWithResult(n  *VariableDeclarators) interface{}
    VisitVariableDeclaratorWithResult(n  *VariableDeclarator) interface{}
    VisitVariableDeclaratorIdWithResult(n  *VariableDeclaratorId) interface{}
    VisitFieldModifiersWithResult(n  *FieldModifiers) interface{}
    VisitMethodDeclarationWithResult(n  *MethodDeclaration) interface{}
    VisitMethodHeaderWithResult(n  *MethodHeader) interface{}
    VisitResultTypeWithResult(n  *ResultType) interface{}
    VisitFormalParameterListWithResult(n  *FormalParameterList) interface{}
    VisitFormalParametersWithResult(n  *FormalParameters) interface{}
    VisitFormalParameterWithResult(n  *FormalParameter) interface{}
    VisitVariableModifiersWithResult(n  *VariableModifiers) interface{}
    VisitVariableModifierWithResult(n  *VariableModifier) interface{}
    VisitLastFormalParameterWithResult(n  *LastFormalParameter) interface{}
    VisitMethodModifiersWithResult(n  *MethodModifiers) interface{}
    VisitThrowsWithResult(n  *Throws) interface{}
    VisitExceptionTypeListWithResult(n  *ExceptionTypeList) interface{}
    VisitMethodBodyWithResult(n  *MethodBody) interface{}
    VisitStaticInitializerWithResult(n  *StaticInitializer) interface{}
    VisitConstructorDeclarationWithResult(n  *ConstructorDeclaration) interface{}
    VisitConstructorDeclaratorWithResult(n  *ConstructorDeclarator) interface{}
    VisitConstructorModifiersWithResult(n  *ConstructorModifiers) interface{}
    VisitConstructorBodyWithResult(n  *ConstructorBody) interface{}
    VisitEnumDeclarationWithResult(n  *EnumDeclaration) interface{}
    VisitEnumBodyWithResult(n  *EnumBody) interface{}
    VisitEnumConstantsWithResult(n  *EnumConstants) interface{}
    VisitEnumConstantWithResult(n  *EnumConstant) interface{}
    VisitArgumentsWithResult(n  *Arguments) interface{}
    VisitEnumBodyDeclarationsWithResult(n  *EnumBodyDeclarations) interface{}
    VisitNormalInterfaceDeclarationWithResult(n  *NormalInterfaceDeclaration) interface{}
    VisitInterfaceModifiersWithResult(n  *InterfaceModifiers) interface{}
    VisitInterfaceBodyWithResult(n  *InterfaceBody) interface{}
    VisitInterfaceMemberDeclarationsWithResult(n  *InterfaceMemberDeclarations) interface{}
    VisitInterfaceMemberDeclarationWithResult(n  *InterfaceMemberDeclaration) interface{}
    VisitConstantDeclarationWithResult(n  *ConstantDeclaration) interface{}
    VisitConstantModifiersWithResult(n  *ConstantModifiers) interface{}
    VisitAbstractMethodDeclarationWithResult(n  *AbstractMethodDeclaration) interface{}
    VisitAbstractMethodModifiersWithResult(n  *AbstractMethodModifiers) interface{}
    VisitAnnotationTypeDeclarationWithResult(n  *AnnotationTypeDeclaration) interface{}
    VisitAnnotationTypeBodyWithResult(n  *AnnotationTypeBody) interface{}
    VisitAnnotationTypeElementDeclarationsWithResult(n  *AnnotationTypeElementDeclarations) interface{}
    VisitDefaultValueWithResult(n  *DefaultValue) interface{}
    VisitAnnotationsWithResult(n  *Annotations) interface{}
    VisitNormalAnnotationWithResult(n  *NormalAnnotation) interface{}
    VisitElementValuePairsWithResult(n  *ElementValuePairs) interface{}
    VisitElementValuePairWithResult(n  *ElementValuePair) interface{}
    VisitElementValueArrayInitializerWithResult(n  *ElementValueArrayInitializer) interface{}
    VisitElementValuesWithResult(n  *ElementValues) interface{}
    VisitMarkerAnnotationWithResult(n  *MarkerAnnotation) interface{}
    VisitSingleElementAnnotationWithResult(n  *SingleElementAnnotation) interface{}
    VisitArrayInitializerWithResult(n  *ArrayInitializer) interface{}
    VisitVariableInitializersWithResult(n  *VariableInitializers) interface{}
    VisitBlockWithResult(n  *Block) interface{}
    VisitBlockStatementsWithResult(n  *BlockStatements) interface{}
    VisitLocalVariableDeclarationStatementWithResult(n  *LocalVariableDeclarationStatement) interface{}
    VisitLocalVariableDeclarationWithResult(n  *LocalVariableDeclaration) interface{}
    VisitIfThenStatementWithResult(n  *IfThenStatement) interface{}
    VisitIfThenElseStatementWithResult(n  *IfThenElseStatement) interface{}
    VisitIfThenElseStatementNoShortIfWithResult(n  *IfThenElseStatementNoShortIf) interface{}
    VisitEmptyStatementWithResult(n  *EmptyStatement) interface{}
    VisitLabeledStatementWithResult(n  *LabeledStatement) interface{}
    VisitLabeledStatementNoShortIfWithResult(n  *LabeledStatementNoShortIf) interface{}
    VisitExpressionStatementWithResult(n  *ExpressionStatement) interface{}
    VisitSwitchStatementWithResult(n  *SwitchStatement) interface{}
    VisitSwitchBlockWithResult(n  *SwitchBlock) interface{}
    VisitSwitchBlockStatementGroupsWithResult(n  *SwitchBlockStatementGroups) interface{}
    VisitSwitchBlockStatementGroupWithResult(n  *SwitchBlockStatementGroup) interface{}
    VisitSwitchLabelsWithResult(n  *SwitchLabels) interface{}
    VisitWhileStatementWithResult(n  *WhileStatement) interface{}
    VisitWhileStatementNoShortIfWithResult(n  *WhileStatementNoShortIf) interface{}
    VisitDoStatementWithResult(n  *DoStatement) interface{}
    VisitBasicForStatementWithResult(n  *BasicForStatement) interface{}
    VisitForStatementNoShortIfWithResult(n  *ForStatementNoShortIf) interface{}
    VisitStatementExpressionListWithResult(n  *StatementExpressionList) interface{}
    VisitEnhancedForStatementWithResult(n  *EnhancedForStatement) interface{}
    VisitBreakStatementWithResult(n  *BreakStatement) interface{}
    VisitContinueStatementWithResult(n  *ContinueStatement) interface{}
    VisitReturnStatementWithResult(n  *ReturnStatement) interface{}
    VisitThrowStatementWithResult(n  *ThrowStatement) interface{}
    VisitSynchronizedStatementWithResult(n  *SynchronizedStatement) interface{}
    VisitCatchesWithResult(n  *Catches) interface{}
    VisitCatchClauseWithResult(n  *CatchClause) interface{}
    VisitFinallyWithResult(n  *Finally) interface{}
    VisitArgumentListWithResult(n  *ArgumentList) interface{}
    VisitDimExprsWithResult(n  *DimExprs) interface{}
    VisitDimExprWithResult(n  *DimExpr) interface{}
    VisitPostIncrementExpressionWithResult(n  *PostIncrementExpression) interface{}
    VisitPostDecrementExpressionWithResult(n  *PostDecrementExpression) interface{}
    VisitPreIncrementExpressionWithResult(n  *PreIncrementExpression) interface{}
    VisitPreDecrementExpressionWithResult(n  *PreDecrementExpression) interface{}
    VisitAndExpressionWithResult(n  *AndExpression) interface{}
    VisitExclusiveOrExpressionWithResult(n  *ExclusiveOrExpression) interface{}
    VisitInclusiveOrExpressionWithResult(n  *InclusiveOrExpression) interface{}
    VisitConditionalAndExpressionWithResult(n  *ConditionalAndExpression) interface{}
    VisitConditionalOrExpressionWithResult(n  *ConditionalOrExpression) interface{}
    VisitConditionalExpressionWithResult(n  *ConditionalExpression) interface{}
    VisitAssignmentWithResult(n  *Assignment) interface{}
    VisitCommaoptWithResult(n  *Commaopt) interface{}
    VisitEllipsisoptWithResult(n  *Ellipsisopt) interface{}
    VisitLPGUserAction0WithResult(n  *LPGUserAction0) interface{}
    VisitLPGUserAction1WithResult(n  *LPGUserAction1) interface{}
    VisitLPGUserAction2WithResult(n  *LPGUserAction2) interface{}
    VisitLPGUserAction3WithResult(n  *LPGUserAction3) interface{}
    VisitLPGUserAction4WithResult(n  *LPGUserAction4) interface{}
    VisitIntegralType0WithResult(n  *IntegralType0) interface{}
    VisitIntegralType1WithResult(n  *IntegralType1) interface{}
    VisitIntegralType2WithResult(n  *IntegralType2) interface{}
    VisitIntegralType3WithResult(n  *IntegralType3) interface{}
    VisitIntegralType4WithResult(n  *IntegralType4) interface{}
    VisitFloatingPointType0WithResult(n  *FloatingPointType0) interface{}
    VisitFloatingPointType1WithResult(n  *FloatingPointType1) interface{}
    VisitWildcardBounds0WithResult(n  *WildcardBounds0) interface{}
    VisitWildcardBounds1WithResult(n  *WildcardBounds1) interface{}
    VisitClassModifier0WithResult(n  *ClassModifier0) interface{}
    VisitClassModifier1WithResult(n  *ClassModifier1) interface{}
    VisitClassModifier2WithResult(n  *ClassModifier2) interface{}
    VisitClassModifier3WithResult(n  *ClassModifier3) interface{}
    VisitClassModifier4WithResult(n  *ClassModifier4) interface{}
    VisitClassModifier5WithResult(n  *ClassModifier5) interface{}
    VisitClassModifier6WithResult(n  *ClassModifier6) interface{}
    VisitFieldModifier0WithResult(n  *FieldModifier0) interface{}
    VisitFieldModifier1WithResult(n  *FieldModifier1) interface{}
    VisitFieldModifier2WithResult(n  *FieldModifier2) interface{}
    VisitFieldModifier3WithResult(n  *FieldModifier3) interface{}
    VisitFieldModifier4WithResult(n  *FieldModifier4) interface{}
    VisitFieldModifier5WithResult(n  *FieldModifier5) interface{}
    VisitFieldModifier6WithResult(n  *FieldModifier6) interface{}
    VisitMethodDeclarator0WithResult(n  *MethodDeclarator0) interface{}
    VisitMethodDeclarator1WithResult(n  *MethodDeclarator1) interface{}
    VisitMethodModifier0WithResult(n  *MethodModifier0) interface{}
    VisitMethodModifier1WithResult(n  *MethodModifier1) interface{}
    VisitMethodModifier2WithResult(n  *MethodModifier2) interface{}
    VisitMethodModifier3WithResult(n  *MethodModifier3) interface{}
    VisitMethodModifier4WithResult(n  *MethodModifier4) interface{}
    VisitMethodModifier5WithResult(n  *MethodModifier5) interface{}
    VisitMethodModifier6WithResult(n  *MethodModifier6) interface{}
    VisitMethodModifier7WithResult(n  *MethodModifier7) interface{}
    VisitMethodModifier8WithResult(n  *MethodModifier8) interface{}
    VisitConstructorModifier0WithResult(n  *ConstructorModifier0) interface{}
    VisitConstructorModifier1WithResult(n  *ConstructorModifier1) interface{}
    VisitConstructorModifier2WithResult(n  *ConstructorModifier2) interface{}
    VisitExplicitConstructorInvocation0WithResult(n  *ExplicitConstructorInvocation0) interface{}
    VisitExplicitConstructorInvocation1WithResult(n  *ExplicitConstructorInvocation1) interface{}
    VisitExplicitConstructorInvocation2WithResult(n  *ExplicitConstructorInvocation2) interface{}
    VisitInterfaceModifier0WithResult(n  *InterfaceModifier0) interface{}
    VisitInterfaceModifier1WithResult(n  *InterfaceModifier1) interface{}
    VisitInterfaceModifier2WithResult(n  *InterfaceModifier2) interface{}
    VisitInterfaceModifier3WithResult(n  *InterfaceModifier3) interface{}
    VisitInterfaceModifier4WithResult(n  *InterfaceModifier4) interface{}
    VisitInterfaceModifier5WithResult(n  *InterfaceModifier5) interface{}
    VisitExtendsInterfaces0WithResult(n  *ExtendsInterfaces0) interface{}
    VisitExtendsInterfaces1WithResult(n  *ExtendsInterfaces1) interface{}
    VisitConstantModifier0WithResult(n  *ConstantModifier0) interface{}
    VisitConstantModifier1WithResult(n  *ConstantModifier1) interface{}
    VisitConstantModifier2WithResult(n  *ConstantModifier2) interface{}
    VisitAbstractMethodModifier0WithResult(n  *AbstractMethodModifier0) interface{}
    VisitAbstractMethodModifier1WithResult(n  *AbstractMethodModifier1) interface{}
    VisitAnnotationTypeElementDeclaration0WithResult(n  *AnnotationTypeElementDeclaration0) interface{}
    VisitAnnotationTypeElementDeclaration1WithResult(n  *AnnotationTypeElementDeclaration1) interface{}
    VisitAssertStatement0WithResult(n  *AssertStatement0) interface{}
    VisitAssertStatement1WithResult(n  *AssertStatement1) interface{}
    VisitSwitchLabel0WithResult(n  *SwitchLabel0) interface{}
    VisitSwitchLabel1WithResult(n  *SwitchLabel1) interface{}
    VisitSwitchLabel2WithResult(n  *SwitchLabel2) interface{}
    VisitTryStatement0WithResult(n  *TryStatement0) interface{}
    VisitTryStatement1WithResult(n  *TryStatement1) interface{}
    VisitPrimaryNoNewArray0WithResult(n  *PrimaryNoNewArray0) interface{}
    VisitPrimaryNoNewArray1WithResult(n  *PrimaryNoNewArray1) interface{}
    VisitPrimaryNoNewArray2WithResult(n  *PrimaryNoNewArray2) interface{}
    VisitPrimaryNoNewArray3WithResult(n  *PrimaryNoNewArray3) interface{}
    VisitPrimaryNoNewArray4WithResult(n  *PrimaryNoNewArray4) interface{}
    VisitLiteral0WithResult(n  *Literal0) interface{}
    VisitLiteral1WithResult(n  *Literal1) interface{}
    VisitLiteral2WithResult(n  *Literal2) interface{}
    VisitLiteral3WithResult(n  *Literal3) interface{}
    VisitLiteral4WithResult(n  *Literal4) interface{}
    VisitLiteral5WithResult(n  *Literal5) interface{}
    VisitLiteral6WithResult(n  *Literal6) interface{}
    VisitBooleanLiteral0WithResult(n  *BooleanLiteral0) interface{}
    VisitBooleanLiteral1WithResult(n  *BooleanLiteral1) interface{}
    VisitClassInstanceCreationExpression0WithResult(n  *ClassInstanceCreationExpression0) interface{}
    VisitClassInstanceCreationExpression1WithResult(n  *ClassInstanceCreationExpression1) interface{}
    VisitArrayCreationExpression0WithResult(n  *ArrayCreationExpression0) interface{}
    VisitArrayCreationExpression1WithResult(n  *ArrayCreationExpression1) interface{}
    VisitArrayCreationExpression2WithResult(n  *ArrayCreationExpression2) interface{}
    VisitArrayCreationExpression3WithResult(n  *ArrayCreationExpression3) interface{}
    VisitDims0WithResult(n  *Dims0) interface{}
    VisitDims1WithResult(n  *Dims1) interface{}
    VisitFieldAccess0WithResult(n  *FieldAccess0) interface{}
    VisitFieldAccess1WithResult(n  *FieldAccess1) interface{}
    VisitFieldAccess2WithResult(n  *FieldAccess2) interface{}
    VisitMethodInvocation0WithResult(n  *MethodInvocation0) interface{}
    VisitMethodInvocation1WithResult(n  *MethodInvocation1) interface{}
    VisitMethodInvocation2WithResult(n  *MethodInvocation2) interface{}
    VisitMethodInvocation3WithResult(n  *MethodInvocation3) interface{}
    VisitMethodInvocation4WithResult(n  *MethodInvocation4) interface{}
    VisitArrayAccess0WithResult(n  *ArrayAccess0) interface{}
    VisitArrayAccess1WithResult(n  *ArrayAccess1) interface{}
    VisitUnaryExpression0WithResult(n  *UnaryExpression0) interface{}
    VisitUnaryExpression1WithResult(n  *UnaryExpression1) interface{}
    VisitUnaryExpressionNotPlusMinus0WithResult(n  *UnaryExpressionNotPlusMinus0) interface{}
    VisitUnaryExpressionNotPlusMinus1WithResult(n  *UnaryExpressionNotPlusMinus1) interface{}
    VisitCastExpression0WithResult(n  *CastExpression0) interface{}
    VisitCastExpression1WithResult(n  *CastExpression1) interface{}
    VisitMultiplicativeExpression0WithResult(n  *MultiplicativeExpression0) interface{}
    VisitMultiplicativeExpression1WithResult(n  *MultiplicativeExpression1) interface{}
    VisitMultiplicativeExpression2WithResult(n  *MultiplicativeExpression2) interface{}
    VisitAdditiveExpression0WithResult(n  *AdditiveExpression0) interface{}
    VisitAdditiveExpression1WithResult(n  *AdditiveExpression1) interface{}
    VisitShiftExpression0WithResult(n  *ShiftExpression0) interface{}
    VisitShiftExpression1WithResult(n  *ShiftExpression1) interface{}
    VisitShiftExpression2WithResult(n  *ShiftExpression2) interface{}
    VisitRelationalExpression0WithResult(n  *RelationalExpression0) interface{}
    VisitRelationalExpression1WithResult(n  *RelationalExpression1) interface{}
    VisitRelationalExpression2WithResult(n  *RelationalExpression2) interface{}
    VisitRelationalExpression3WithResult(n  *RelationalExpression3) interface{}
    VisitRelationalExpression4WithResult(n  *RelationalExpression4) interface{}
    VisitEqualityExpression0WithResult(n  *EqualityExpression0) interface{}
    VisitEqualityExpression1WithResult(n  *EqualityExpression1) interface{}
    VisitAssignmentOperator0WithResult(n  *AssignmentOperator0) interface{}
    VisitAssignmentOperator1WithResult(n  *AssignmentOperator1) interface{}
    VisitAssignmentOperator2WithResult(n  *AssignmentOperator2) interface{}
    VisitAssignmentOperator3WithResult(n  *AssignmentOperator3) interface{}
    VisitAssignmentOperator4WithResult(n  *AssignmentOperator4) interface{}
    VisitAssignmentOperator5WithResult(n  *AssignmentOperator5) interface{}
    VisitAssignmentOperator6WithResult(n  *AssignmentOperator6) interface{}
    VisitAssignmentOperator7WithResult(n  *AssignmentOperator7) interface{}
    VisitAssignmentOperator8WithResult(n  *AssignmentOperator8) interface{}
    VisitAssignmentOperator9WithResult(n  *AssignmentOperator9) interface{}
    VisitAssignmentOperator10WithResult(n  *AssignmentOperator10) interface{}
    VisitAssignmentOperator11WithResult(n  *AssignmentOperator11) interface{}

    VisitWithResult(n  IAst) interface{}
}
func AnyCastToResultVisitor(i interface{}) ResultVisitor {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ResultVisitor)
	  }
}
type ResultArgumentVisitor interface{
    VisitAstTokenWithResultArgument(n  *AstToken, o interface{}) interface{}
    VisitidentifierWithResultArgument(n  *identifier, o interface{}) interface{}
    VisitPrimitiveTypeWithResultArgument(n  *PrimitiveType, o interface{}) interface{}
    VisitClassTypeWithResultArgument(n  *ClassType, o interface{}) interface{}
    VisitInterfaceTypeWithResultArgument(n  *InterfaceType, o interface{}) interface{}
    VisitTypeNameWithResultArgument(n  *TypeName, o interface{}) interface{}
    VisitArrayTypeWithResultArgument(n  *ArrayType, o interface{}) interface{}
    VisitTypeParameterWithResultArgument(n  *TypeParameter, o interface{}) interface{}
    VisitTypeBoundWithResultArgument(n  *TypeBound, o interface{}) interface{}
    VisitAdditionalBoundListWithResultArgument(n  *AdditionalBoundList, o interface{}) interface{}
    VisitAdditionalBoundWithResultArgument(n  *AdditionalBound, o interface{}) interface{}
    VisitTypeArgumentsWithResultArgument(n  *TypeArguments, o interface{}) interface{}
    VisitActualTypeArgumentListWithResultArgument(n  *ActualTypeArgumentList, o interface{}) interface{}
    VisitWildcardWithResultArgument(n  *Wildcard, o interface{}) interface{}
    VisitPackageNameWithResultArgument(n  *PackageName, o interface{}) interface{}
    VisitExpressionNameWithResultArgument(n  *ExpressionName, o interface{}) interface{}
    VisitMethodNameWithResultArgument(n  *MethodName, o interface{}) interface{}
    VisitPackageOrTypeNameWithResultArgument(n  *PackageOrTypeName, o interface{}) interface{}
    VisitAmbiguousNameWithResultArgument(n  *AmbiguousName, o interface{}) interface{}
    VisitCompilationUnitWithResultArgument(n  *CompilationUnit, o interface{}) interface{}
    VisitImportDeclarationsWithResultArgument(n  *ImportDeclarations, o interface{}) interface{}
    VisitTypeDeclarationsWithResultArgument(n  *TypeDeclarations, o interface{}) interface{}
    VisitPackageDeclarationWithResultArgument(n  *PackageDeclaration, o interface{}) interface{}
    VisitSingleTypeImportDeclarationWithResultArgument(n  *SingleTypeImportDeclaration, o interface{}) interface{}
    VisitTypeImportOnDemandDeclarationWithResultArgument(n  *TypeImportOnDemandDeclaration, o interface{}) interface{}
    VisitSingleStaticImportDeclarationWithResultArgument(n  *SingleStaticImportDeclaration, o interface{}) interface{}
    VisitStaticImportOnDemandDeclarationWithResultArgument(n  *StaticImportOnDemandDeclaration, o interface{}) interface{}
    VisitTypeDeclarationWithResultArgument(n  *TypeDeclaration, o interface{}) interface{}
    VisitNormalClassDeclarationWithResultArgument(n  *NormalClassDeclaration, o interface{}) interface{}
    VisitClassModifiersWithResultArgument(n  *ClassModifiers, o interface{}) interface{}
    VisitTypeParametersWithResultArgument(n  *TypeParameters, o interface{}) interface{}
    VisitTypeParameterListWithResultArgument(n  *TypeParameterList, o interface{}) interface{}
    VisitSuperWithResultArgument(n  *Super, o interface{}) interface{}
    VisitInterfacesWithResultArgument(n  *Interfaces, o interface{}) interface{}
    VisitInterfaceTypeListWithResultArgument(n  *InterfaceTypeList, o interface{}) interface{}
    VisitClassBodyWithResultArgument(n  *ClassBody, o interface{}) interface{}
    VisitClassBodyDeclarationsWithResultArgument(n  *ClassBodyDeclarations, o interface{}) interface{}
    VisitClassMemberDeclarationWithResultArgument(n  *ClassMemberDeclaration, o interface{}) interface{}
    VisitFieldDeclarationWithResultArgument(n  *FieldDeclaration, o interface{}) interface{}
    VisitVariableDeclaratorsWithResultArgument(n  *VariableDeclarators, o interface{}) interface{}
    VisitVariableDeclaratorWithResultArgument(n  *VariableDeclarator, o interface{}) interface{}
    VisitVariableDeclaratorIdWithResultArgument(n  *VariableDeclaratorId, o interface{}) interface{}
    VisitFieldModifiersWithResultArgument(n  *FieldModifiers, o interface{}) interface{}
    VisitMethodDeclarationWithResultArgument(n  *MethodDeclaration, o interface{}) interface{}
    VisitMethodHeaderWithResultArgument(n  *MethodHeader, o interface{}) interface{}
    VisitResultTypeWithResultArgument(n  *ResultType, o interface{}) interface{}
    VisitFormalParameterListWithResultArgument(n  *FormalParameterList, o interface{}) interface{}
    VisitFormalParametersWithResultArgument(n  *FormalParameters, o interface{}) interface{}
    VisitFormalParameterWithResultArgument(n  *FormalParameter, o interface{}) interface{}
    VisitVariableModifiersWithResultArgument(n  *VariableModifiers, o interface{}) interface{}
    VisitVariableModifierWithResultArgument(n  *VariableModifier, o interface{}) interface{}
    VisitLastFormalParameterWithResultArgument(n  *LastFormalParameter, o interface{}) interface{}
    VisitMethodModifiersWithResultArgument(n  *MethodModifiers, o interface{}) interface{}
    VisitThrowsWithResultArgument(n  *Throws, o interface{}) interface{}
    VisitExceptionTypeListWithResultArgument(n  *ExceptionTypeList, o interface{}) interface{}
    VisitMethodBodyWithResultArgument(n  *MethodBody, o interface{}) interface{}
    VisitStaticInitializerWithResultArgument(n  *StaticInitializer, o interface{}) interface{}
    VisitConstructorDeclarationWithResultArgument(n  *ConstructorDeclaration, o interface{}) interface{}
    VisitConstructorDeclaratorWithResultArgument(n  *ConstructorDeclarator, o interface{}) interface{}
    VisitConstructorModifiersWithResultArgument(n  *ConstructorModifiers, o interface{}) interface{}
    VisitConstructorBodyWithResultArgument(n  *ConstructorBody, o interface{}) interface{}
    VisitEnumDeclarationWithResultArgument(n  *EnumDeclaration, o interface{}) interface{}
    VisitEnumBodyWithResultArgument(n  *EnumBody, o interface{}) interface{}
    VisitEnumConstantsWithResultArgument(n  *EnumConstants, o interface{}) interface{}
    VisitEnumConstantWithResultArgument(n  *EnumConstant, o interface{}) interface{}
    VisitArgumentsWithResultArgument(n  *Arguments, o interface{}) interface{}
    VisitEnumBodyDeclarationsWithResultArgument(n  *EnumBodyDeclarations, o interface{}) interface{}
    VisitNormalInterfaceDeclarationWithResultArgument(n  *NormalInterfaceDeclaration, o interface{}) interface{}
    VisitInterfaceModifiersWithResultArgument(n  *InterfaceModifiers, o interface{}) interface{}
    VisitInterfaceBodyWithResultArgument(n  *InterfaceBody, o interface{}) interface{}
    VisitInterfaceMemberDeclarationsWithResultArgument(n  *InterfaceMemberDeclarations, o interface{}) interface{}
    VisitInterfaceMemberDeclarationWithResultArgument(n  *InterfaceMemberDeclaration, o interface{}) interface{}
    VisitConstantDeclarationWithResultArgument(n  *ConstantDeclaration, o interface{}) interface{}
    VisitConstantModifiersWithResultArgument(n  *ConstantModifiers, o interface{}) interface{}
    VisitAbstractMethodDeclarationWithResultArgument(n  *AbstractMethodDeclaration, o interface{}) interface{}
    VisitAbstractMethodModifiersWithResultArgument(n  *AbstractMethodModifiers, o interface{}) interface{}
    VisitAnnotationTypeDeclarationWithResultArgument(n  *AnnotationTypeDeclaration, o interface{}) interface{}
    VisitAnnotationTypeBodyWithResultArgument(n  *AnnotationTypeBody, o interface{}) interface{}
    VisitAnnotationTypeElementDeclarationsWithResultArgument(n  *AnnotationTypeElementDeclarations, o interface{}) interface{}
    VisitDefaultValueWithResultArgument(n  *DefaultValue, o interface{}) interface{}
    VisitAnnotationsWithResultArgument(n  *Annotations, o interface{}) interface{}
    VisitNormalAnnotationWithResultArgument(n  *NormalAnnotation, o interface{}) interface{}
    VisitElementValuePairsWithResultArgument(n  *ElementValuePairs, o interface{}) interface{}
    VisitElementValuePairWithResultArgument(n  *ElementValuePair, o interface{}) interface{}
    VisitElementValueArrayInitializerWithResultArgument(n  *ElementValueArrayInitializer, o interface{}) interface{}
    VisitElementValuesWithResultArgument(n  *ElementValues, o interface{}) interface{}
    VisitMarkerAnnotationWithResultArgument(n  *MarkerAnnotation, o interface{}) interface{}
    VisitSingleElementAnnotationWithResultArgument(n  *SingleElementAnnotation, o interface{}) interface{}
    VisitArrayInitializerWithResultArgument(n  *ArrayInitializer, o interface{}) interface{}
    VisitVariableInitializersWithResultArgument(n  *VariableInitializers, o interface{}) interface{}
    VisitBlockWithResultArgument(n  *Block, o interface{}) interface{}
    VisitBlockStatementsWithResultArgument(n  *BlockStatements, o interface{}) interface{}
    VisitLocalVariableDeclarationStatementWithResultArgument(n  *LocalVariableDeclarationStatement, o interface{}) interface{}
    VisitLocalVariableDeclarationWithResultArgument(n  *LocalVariableDeclaration, o interface{}) interface{}
    VisitIfThenStatementWithResultArgument(n  *IfThenStatement, o interface{}) interface{}
    VisitIfThenElseStatementWithResultArgument(n  *IfThenElseStatement, o interface{}) interface{}
    VisitIfThenElseStatementNoShortIfWithResultArgument(n  *IfThenElseStatementNoShortIf, o interface{}) interface{}
    VisitEmptyStatementWithResultArgument(n  *EmptyStatement, o interface{}) interface{}
    VisitLabeledStatementWithResultArgument(n  *LabeledStatement, o interface{}) interface{}
    VisitLabeledStatementNoShortIfWithResultArgument(n  *LabeledStatementNoShortIf, o interface{}) interface{}
    VisitExpressionStatementWithResultArgument(n  *ExpressionStatement, o interface{}) interface{}
    VisitSwitchStatementWithResultArgument(n  *SwitchStatement, o interface{}) interface{}
    VisitSwitchBlockWithResultArgument(n  *SwitchBlock, o interface{}) interface{}
    VisitSwitchBlockStatementGroupsWithResultArgument(n  *SwitchBlockStatementGroups, o interface{}) interface{}
    VisitSwitchBlockStatementGroupWithResultArgument(n  *SwitchBlockStatementGroup, o interface{}) interface{}
    VisitSwitchLabelsWithResultArgument(n  *SwitchLabels, o interface{}) interface{}
    VisitWhileStatementWithResultArgument(n  *WhileStatement, o interface{}) interface{}
    VisitWhileStatementNoShortIfWithResultArgument(n  *WhileStatementNoShortIf, o interface{}) interface{}
    VisitDoStatementWithResultArgument(n  *DoStatement, o interface{}) interface{}
    VisitBasicForStatementWithResultArgument(n  *BasicForStatement, o interface{}) interface{}
    VisitForStatementNoShortIfWithResultArgument(n  *ForStatementNoShortIf, o interface{}) interface{}
    VisitStatementExpressionListWithResultArgument(n  *StatementExpressionList, o interface{}) interface{}
    VisitEnhancedForStatementWithResultArgument(n  *EnhancedForStatement, o interface{}) interface{}
    VisitBreakStatementWithResultArgument(n  *BreakStatement, o interface{}) interface{}
    VisitContinueStatementWithResultArgument(n  *ContinueStatement, o interface{}) interface{}
    VisitReturnStatementWithResultArgument(n  *ReturnStatement, o interface{}) interface{}
    VisitThrowStatementWithResultArgument(n  *ThrowStatement, o interface{}) interface{}
    VisitSynchronizedStatementWithResultArgument(n  *SynchronizedStatement, o interface{}) interface{}
    VisitCatchesWithResultArgument(n  *Catches, o interface{}) interface{}
    VisitCatchClauseWithResultArgument(n  *CatchClause, o interface{}) interface{}
    VisitFinallyWithResultArgument(n  *Finally, o interface{}) interface{}
    VisitArgumentListWithResultArgument(n  *ArgumentList, o interface{}) interface{}
    VisitDimExprsWithResultArgument(n  *DimExprs, o interface{}) interface{}
    VisitDimExprWithResultArgument(n  *DimExpr, o interface{}) interface{}
    VisitPostIncrementExpressionWithResultArgument(n  *PostIncrementExpression, o interface{}) interface{}
    VisitPostDecrementExpressionWithResultArgument(n  *PostDecrementExpression, o interface{}) interface{}
    VisitPreIncrementExpressionWithResultArgument(n  *PreIncrementExpression, o interface{}) interface{}
    VisitPreDecrementExpressionWithResultArgument(n  *PreDecrementExpression, o interface{}) interface{}
    VisitAndExpressionWithResultArgument(n  *AndExpression, o interface{}) interface{}
    VisitExclusiveOrExpressionWithResultArgument(n  *ExclusiveOrExpression, o interface{}) interface{}
    VisitInclusiveOrExpressionWithResultArgument(n  *InclusiveOrExpression, o interface{}) interface{}
    VisitConditionalAndExpressionWithResultArgument(n  *ConditionalAndExpression, o interface{}) interface{}
    VisitConditionalOrExpressionWithResultArgument(n  *ConditionalOrExpression, o interface{}) interface{}
    VisitConditionalExpressionWithResultArgument(n  *ConditionalExpression, o interface{}) interface{}
    VisitAssignmentWithResultArgument(n  *Assignment, o interface{}) interface{}
    VisitCommaoptWithResultArgument(n  *Commaopt, o interface{}) interface{}
    VisitEllipsisoptWithResultArgument(n  *Ellipsisopt, o interface{}) interface{}
    VisitLPGUserAction0WithResultArgument(n  *LPGUserAction0, o interface{}) interface{}
    VisitLPGUserAction1WithResultArgument(n  *LPGUserAction1, o interface{}) interface{}
    VisitLPGUserAction2WithResultArgument(n  *LPGUserAction2, o interface{}) interface{}
    VisitLPGUserAction3WithResultArgument(n  *LPGUserAction3, o interface{}) interface{}
    VisitLPGUserAction4WithResultArgument(n  *LPGUserAction4, o interface{}) interface{}
    VisitIntegralType0WithResultArgument(n  *IntegralType0, o interface{}) interface{}
    VisitIntegralType1WithResultArgument(n  *IntegralType1, o interface{}) interface{}
    VisitIntegralType2WithResultArgument(n  *IntegralType2, o interface{}) interface{}
    VisitIntegralType3WithResultArgument(n  *IntegralType3, o interface{}) interface{}
    VisitIntegralType4WithResultArgument(n  *IntegralType4, o interface{}) interface{}
    VisitFloatingPointType0WithResultArgument(n  *FloatingPointType0, o interface{}) interface{}
    VisitFloatingPointType1WithResultArgument(n  *FloatingPointType1, o interface{}) interface{}
    VisitWildcardBounds0WithResultArgument(n  *WildcardBounds0, o interface{}) interface{}
    VisitWildcardBounds1WithResultArgument(n  *WildcardBounds1, o interface{}) interface{}
    VisitClassModifier0WithResultArgument(n  *ClassModifier0, o interface{}) interface{}
    VisitClassModifier1WithResultArgument(n  *ClassModifier1, o interface{}) interface{}
    VisitClassModifier2WithResultArgument(n  *ClassModifier2, o interface{}) interface{}
    VisitClassModifier3WithResultArgument(n  *ClassModifier3, o interface{}) interface{}
    VisitClassModifier4WithResultArgument(n  *ClassModifier4, o interface{}) interface{}
    VisitClassModifier5WithResultArgument(n  *ClassModifier5, o interface{}) interface{}
    VisitClassModifier6WithResultArgument(n  *ClassModifier6, o interface{}) interface{}
    VisitFieldModifier0WithResultArgument(n  *FieldModifier0, o interface{}) interface{}
    VisitFieldModifier1WithResultArgument(n  *FieldModifier1, o interface{}) interface{}
    VisitFieldModifier2WithResultArgument(n  *FieldModifier2, o interface{}) interface{}
    VisitFieldModifier3WithResultArgument(n  *FieldModifier3, o interface{}) interface{}
    VisitFieldModifier4WithResultArgument(n  *FieldModifier4, o interface{}) interface{}
    VisitFieldModifier5WithResultArgument(n  *FieldModifier5, o interface{}) interface{}
    VisitFieldModifier6WithResultArgument(n  *FieldModifier6, o interface{}) interface{}
    VisitMethodDeclarator0WithResultArgument(n  *MethodDeclarator0, o interface{}) interface{}
    VisitMethodDeclarator1WithResultArgument(n  *MethodDeclarator1, o interface{}) interface{}
    VisitMethodModifier0WithResultArgument(n  *MethodModifier0, o interface{}) interface{}
    VisitMethodModifier1WithResultArgument(n  *MethodModifier1, o interface{}) interface{}
    VisitMethodModifier2WithResultArgument(n  *MethodModifier2, o interface{}) interface{}
    VisitMethodModifier3WithResultArgument(n  *MethodModifier3, o interface{}) interface{}
    VisitMethodModifier4WithResultArgument(n  *MethodModifier4, o interface{}) interface{}
    VisitMethodModifier5WithResultArgument(n  *MethodModifier5, o interface{}) interface{}
    VisitMethodModifier6WithResultArgument(n  *MethodModifier6, o interface{}) interface{}
    VisitMethodModifier7WithResultArgument(n  *MethodModifier7, o interface{}) interface{}
    VisitMethodModifier8WithResultArgument(n  *MethodModifier8, o interface{}) interface{}
    VisitConstructorModifier0WithResultArgument(n  *ConstructorModifier0, o interface{}) interface{}
    VisitConstructorModifier1WithResultArgument(n  *ConstructorModifier1, o interface{}) interface{}
    VisitConstructorModifier2WithResultArgument(n  *ConstructorModifier2, o interface{}) interface{}
    VisitExplicitConstructorInvocation0WithResultArgument(n  *ExplicitConstructorInvocation0, o interface{}) interface{}
    VisitExplicitConstructorInvocation1WithResultArgument(n  *ExplicitConstructorInvocation1, o interface{}) interface{}
    VisitExplicitConstructorInvocation2WithResultArgument(n  *ExplicitConstructorInvocation2, o interface{}) interface{}
    VisitInterfaceModifier0WithResultArgument(n  *InterfaceModifier0, o interface{}) interface{}
    VisitInterfaceModifier1WithResultArgument(n  *InterfaceModifier1, o interface{}) interface{}
    VisitInterfaceModifier2WithResultArgument(n  *InterfaceModifier2, o interface{}) interface{}
    VisitInterfaceModifier3WithResultArgument(n  *InterfaceModifier3, o interface{}) interface{}
    VisitInterfaceModifier4WithResultArgument(n  *InterfaceModifier4, o interface{}) interface{}
    VisitInterfaceModifier5WithResultArgument(n  *InterfaceModifier5, o interface{}) interface{}
    VisitExtendsInterfaces0WithResultArgument(n  *ExtendsInterfaces0, o interface{}) interface{}
    VisitExtendsInterfaces1WithResultArgument(n  *ExtendsInterfaces1, o interface{}) interface{}
    VisitConstantModifier0WithResultArgument(n  *ConstantModifier0, o interface{}) interface{}
    VisitConstantModifier1WithResultArgument(n  *ConstantModifier1, o interface{}) interface{}
    VisitConstantModifier2WithResultArgument(n  *ConstantModifier2, o interface{}) interface{}
    VisitAbstractMethodModifier0WithResultArgument(n  *AbstractMethodModifier0, o interface{}) interface{}
    VisitAbstractMethodModifier1WithResultArgument(n  *AbstractMethodModifier1, o interface{}) interface{}
    VisitAnnotationTypeElementDeclaration0WithResultArgument(n  *AnnotationTypeElementDeclaration0, o interface{}) interface{}
    VisitAnnotationTypeElementDeclaration1WithResultArgument(n  *AnnotationTypeElementDeclaration1, o interface{}) interface{}
    VisitAssertStatement0WithResultArgument(n  *AssertStatement0, o interface{}) interface{}
    VisitAssertStatement1WithResultArgument(n  *AssertStatement1, o interface{}) interface{}
    VisitSwitchLabel0WithResultArgument(n  *SwitchLabel0, o interface{}) interface{}
    VisitSwitchLabel1WithResultArgument(n  *SwitchLabel1, o interface{}) interface{}
    VisitSwitchLabel2WithResultArgument(n  *SwitchLabel2, o interface{}) interface{}
    VisitTryStatement0WithResultArgument(n  *TryStatement0, o interface{}) interface{}
    VisitTryStatement1WithResultArgument(n  *TryStatement1, o interface{}) interface{}
    VisitPrimaryNoNewArray0WithResultArgument(n  *PrimaryNoNewArray0, o interface{}) interface{}
    VisitPrimaryNoNewArray1WithResultArgument(n  *PrimaryNoNewArray1, o interface{}) interface{}
    VisitPrimaryNoNewArray2WithResultArgument(n  *PrimaryNoNewArray2, o interface{}) interface{}
    VisitPrimaryNoNewArray3WithResultArgument(n  *PrimaryNoNewArray3, o interface{}) interface{}
    VisitPrimaryNoNewArray4WithResultArgument(n  *PrimaryNoNewArray4, o interface{}) interface{}
    VisitLiteral0WithResultArgument(n  *Literal0, o interface{}) interface{}
    VisitLiteral1WithResultArgument(n  *Literal1, o interface{}) interface{}
    VisitLiteral2WithResultArgument(n  *Literal2, o interface{}) interface{}
    VisitLiteral3WithResultArgument(n  *Literal3, o interface{}) interface{}
    VisitLiteral4WithResultArgument(n  *Literal4, o interface{}) interface{}
    VisitLiteral5WithResultArgument(n  *Literal5, o interface{}) interface{}
    VisitLiteral6WithResultArgument(n  *Literal6, o interface{}) interface{}
    VisitBooleanLiteral0WithResultArgument(n  *BooleanLiteral0, o interface{}) interface{}
    VisitBooleanLiteral1WithResultArgument(n  *BooleanLiteral1, o interface{}) interface{}
    VisitClassInstanceCreationExpression0WithResultArgument(n  *ClassInstanceCreationExpression0, o interface{}) interface{}
    VisitClassInstanceCreationExpression1WithResultArgument(n  *ClassInstanceCreationExpression1, o interface{}) interface{}
    VisitArrayCreationExpression0WithResultArgument(n  *ArrayCreationExpression0, o interface{}) interface{}
    VisitArrayCreationExpression1WithResultArgument(n  *ArrayCreationExpression1, o interface{}) interface{}
    VisitArrayCreationExpression2WithResultArgument(n  *ArrayCreationExpression2, o interface{}) interface{}
    VisitArrayCreationExpression3WithResultArgument(n  *ArrayCreationExpression3, o interface{}) interface{}
    VisitDims0WithResultArgument(n  *Dims0, o interface{}) interface{}
    VisitDims1WithResultArgument(n  *Dims1, o interface{}) interface{}
    VisitFieldAccess0WithResultArgument(n  *FieldAccess0, o interface{}) interface{}
    VisitFieldAccess1WithResultArgument(n  *FieldAccess1, o interface{}) interface{}
    VisitFieldAccess2WithResultArgument(n  *FieldAccess2, o interface{}) interface{}
    VisitMethodInvocation0WithResultArgument(n  *MethodInvocation0, o interface{}) interface{}
    VisitMethodInvocation1WithResultArgument(n  *MethodInvocation1, o interface{}) interface{}
    VisitMethodInvocation2WithResultArgument(n  *MethodInvocation2, o interface{}) interface{}
    VisitMethodInvocation3WithResultArgument(n  *MethodInvocation3, o interface{}) interface{}
    VisitMethodInvocation4WithResultArgument(n  *MethodInvocation4, o interface{}) interface{}
    VisitArrayAccess0WithResultArgument(n  *ArrayAccess0, o interface{}) interface{}
    VisitArrayAccess1WithResultArgument(n  *ArrayAccess1, o interface{}) interface{}
    VisitUnaryExpression0WithResultArgument(n  *UnaryExpression0, o interface{}) interface{}
    VisitUnaryExpression1WithResultArgument(n  *UnaryExpression1, o interface{}) interface{}
    VisitUnaryExpressionNotPlusMinus0WithResultArgument(n  *UnaryExpressionNotPlusMinus0, o interface{}) interface{}
    VisitUnaryExpressionNotPlusMinus1WithResultArgument(n  *UnaryExpressionNotPlusMinus1, o interface{}) interface{}
    VisitCastExpression0WithResultArgument(n  *CastExpression0, o interface{}) interface{}
    VisitCastExpression1WithResultArgument(n  *CastExpression1, o interface{}) interface{}
    VisitMultiplicativeExpression0WithResultArgument(n  *MultiplicativeExpression0, o interface{}) interface{}
    VisitMultiplicativeExpression1WithResultArgument(n  *MultiplicativeExpression1, o interface{}) interface{}
    VisitMultiplicativeExpression2WithResultArgument(n  *MultiplicativeExpression2, o interface{}) interface{}
    VisitAdditiveExpression0WithResultArgument(n  *AdditiveExpression0, o interface{}) interface{}
    VisitAdditiveExpression1WithResultArgument(n  *AdditiveExpression1, o interface{}) interface{}
    VisitShiftExpression0WithResultArgument(n  *ShiftExpression0, o interface{}) interface{}
    VisitShiftExpression1WithResultArgument(n  *ShiftExpression1, o interface{}) interface{}
    VisitShiftExpression2WithResultArgument(n  *ShiftExpression2, o interface{}) interface{}
    VisitRelationalExpression0WithResultArgument(n  *RelationalExpression0, o interface{}) interface{}
    VisitRelationalExpression1WithResultArgument(n  *RelationalExpression1, o interface{}) interface{}
    VisitRelationalExpression2WithResultArgument(n  *RelationalExpression2, o interface{}) interface{}
    VisitRelationalExpression3WithResultArgument(n  *RelationalExpression3, o interface{}) interface{}
    VisitRelationalExpression4WithResultArgument(n  *RelationalExpression4, o interface{}) interface{}
    VisitEqualityExpression0WithResultArgument(n  *EqualityExpression0, o interface{}) interface{}
    VisitEqualityExpression1WithResultArgument(n  *EqualityExpression1, o interface{}) interface{}
    VisitAssignmentOperator0WithResultArgument(n  *AssignmentOperator0, o interface{}) interface{}
    VisitAssignmentOperator1WithResultArgument(n  *AssignmentOperator1, o interface{}) interface{}
    VisitAssignmentOperator2WithResultArgument(n  *AssignmentOperator2, o interface{}) interface{}
    VisitAssignmentOperator3WithResultArgument(n  *AssignmentOperator3, o interface{}) interface{}
    VisitAssignmentOperator4WithResultArgument(n  *AssignmentOperator4, o interface{}) interface{}
    VisitAssignmentOperator5WithResultArgument(n  *AssignmentOperator5, o interface{}) interface{}
    VisitAssignmentOperator6WithResultArgument(n  *AssignmentOperator6, o interface{}) interface{}
    VisitAssignmentOperator7WithResultArgument(n  *AssignmentOperator7, o interface{}) interface{}
    VisitAssignmentOperator8WithResultArgument(n  *AssignmentOperator8, o interface{}) interface{}
    VisitAssignmentOperator9WithResultArgument(n  *AssignmentOperator9, o interface{}) interface{}
    VisitAssignmentOperator10WithResultArgument(n  *AssignmentOperator10, o interface{}) interface{}
    VisitAssignmentOperator11WithResultArgument(n  *AssignmentOperator11, o interface{}) interface{}

    VisitWithResultArgument(n IAst, o interface{}) interface{}
}
func AnyCastToResultArgumentVisitor(i interface{}) ResultArgumentVisitor {
	  if nil == i{
		 return nil
	  }else{
		 return i.(ResultArgumentVisitor)
	  }
}
type VisitorArgumentVisitor interface{
   Visitor
   ArgumentVisitor
   }
type AbstractVisitor struct{
   dispatch VisitorArgumentVisitor
   }
func NewAbstractVisitor(dispatch VisitorArgumentVisitor) *AbstractVisitor{
         my := new(AbstractVisitor)
         if dispatch != nil{
           my.dispatch = dispatch
         }else{
           my.dispatch = my
         }
        return my
}

func (my *AbstractVisitor)      UnimplementedVisitor(s  string){}

func (my *AbstractVisitor)      VisitAstToken(n *AstToken)  { my.UnimplementedVisitor("VisitAstToken(AstToken)") }

func (my *AbstractVisitor)      VisitAstTokenWithArg(n *AstToken, o interface{})  { my.UnimplementedVisitor("VisitAstTokenWithArg(AstToken, interface{})") }

func (my *AbstractVisitor)      Visitidentifier(n *identifier)  { my.UnimplementedVisitor("Visitidentifier(identifier)") }

func (my *AbstractVisitor)      VisitidentifierWithArg(n *identifier, o interface{})  { my.UnimplementedVisitor("VisitidentifierWithArg(identifier, interface{})") }

func (my *AbstractVisitor)      VisitPrimitiveType(n *PrimitiveType)  { my.UnimplementedVisitor("VisitPrimitiveType(PrimitiveType)") }

func (my *AbstractVisitor)      VisitPrimitiveTypeWithArg(n *PrimitiveType, o interface{})  { my.UnimplementedVisitor("VisitPrimitiveTypeWithArg(PrimitiveType, interface{})") }

func (my *AbstractVisitor)      VisitClassType(n *ClassType)  { my.UnimplementedVisitor("VisitClassType(ClassType)") }

func (my *AbstractVisitor)      VisitClassTypeWithArg(n *ClassType, o interface{})  { my.UnimplementedVisitor("VisitClassTypeWithArg(ClassType, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceType(n *InterfaceType)  { my.UnimplementedVisitor("VisitInterfaceType(InterfaceType)") }

func (my *AbstractVisitor)      VisitInterfaceTypeWithArg(n *InterfaceType, o interface{})  { my.UnimplementedVisitor("VisitInterfaceTypeWithArg(InterfaceType, interface{})") }

func (my *AbstractVisitor)      VisitTypeName(n *TypeName)  { my.UnimplementedVisitor("VisitTypeName(TypeName)") }

func (my *AbstractVisitor)      VisitTypeNameWithArg(n *TypeName, o interface{})  { my.UnimplementedVisitor("VisitTypeNameWithArg(TypeName, interface{})") }

func (my *AbstractVisitor)      VisitArrayType(n *ArrayType)  { my.UnimplementedVisitor("VisitArrayType(ArrayType)") }

func (my *AbstractVisitor)      VisitArrayTypeWithArg(n *ArrayType, o interface{})  { my.UnimplementedVisitor("VisitArrayTypeWithArg(ArrayType, interface{})") }

func (my *AbstractVisitor)      VisitTypeParameter(n *TypeParameter)  { my.UnimplementedVisitor("VisitTypeParameter(TypeParameter)") }

func (my *AbstractVisitor)      VisitTypeParameterWithArg(n *TypeParameter, o interface{})  { my.UnimplementedVisitor("VisitTypeParameterWithArg(TypeParameter, interface{})") }

func (my *AbstractVisitor)      VisitTypeBound(n *TypeBound)  { my.UnimplementedVisitor("VisitTypeBound(TypeBound)") }

func (my *AbstractVisitor)      VisitTypeBoundWithArg(n *TypeBound, o interface{})  { my.UnimplementedVisitor("VisitTypeBoundWithArg(TypeBound, interface{})") }

func (my *AbstractVisitor)      VisitAdditionalBoundList(n *AdditionalBoundList)  { my.UnimplementedVisitor("VisitAdditionalBoundList(AdditionalBoundList)") }

func (my *AbstractVisitor)      VisitAdditionalBoundListWithArg(n *AdditionalBoundList, o interface{})  { my.UnimplementedVisitor("VisitAdditionalBoundListWithArg(AdditionalBoundList, interface{})") }

func (my *AbstractVisitor)      VisitAdditionalBound(n *AdditionalBound)  { my.UnimplementedVisitor("VisitAdditionalBound(AdditionalBound)") }

func (my *AbstractVisitor)      VisitAdditionalBoundWithArg(n *AdditionalBound, o interface{})  { my.UnimplementedVisitor("VisitAdditionalBoundWithArg(AdditionalBound, interface{})") }

func (my *AbstractVisitor)      VisitTypeArguments(n *TypeArguments)  { my.UnimplementedVisitor("VisitTypeArguments(TypeArguments)") }

func (my *AbstractVisitor)      VisitTypeArgumentsWithArg(n *TypeArguments, o interface{})  { my.UnimplementedVisitor("VisitTypeArgumentsWithArg(TypeArguments, interface{})") }

func (my *AbstractVisitor)      VisitActualTypeArgumentList(n *ActualTypeArgumentList)  { my.UnimplementedVisitor("VisitActualTypeArgumentList(ActualTypeArgumentList)") }

func (my *AbstractVisitor)      VisitActualTypeArgumentListWithArg(n *ActualTypeArgumentList, o interface{})  { my.UnimplementedVisitor("VisitActualTypeArgumentListWithArg(ActualTypeArgumentList, interface{})") }

func (my *AbstractVisitor)      VisitWildcard(n *Wildcard)  { my.UnimplementedVisitor("VisitWildcard(Wildcard)") }

func (my *AbstractVisitor)      VisitWildcardWithArg(n *Wildcard, o interface{})  { my.UnimplementedVisitor("VisitWildcardWithArg(Wildcard, interface{})") }

func (my *AbstractVisitor)      VisitPackageName(n *PackageName)  { my.UnimplementedVisitor("VisitPackageName(PackageName)") }

func (my *AbstractVisitor)      VisitPackageNameWithArg(n *PackageName, o interface{})  { my.UnimplementedVisitor("VisitPackageNameWithArg(PackageName, interface{})") }

func (my *AbstractVisitor)      VisitExpressionName(n *ExpressionName)  { my.UnimplementedVisitor("VisitExpressionName(ExpressionName)") }

func (my *AbstractVisitor)      VisitExpressionNameWithArg(n *ExpressionName, o interface{})  { my.UnimplementedVisitor("VisitExpressionNameWithArg(ExpressionName, interface{})") }

func (my *AbstractVisitor)      VisitMethodName(n *MethodName)  { my.UnimplementedVisitor("VisitMethodName(MethodName)") }

func (my *AbstractVisitor)      VisitMethodNameWithArg(n *MethodName, o interface{})  { my.UnimplementedVisitor("VisitMethodNameWithArg(MethodName, interface{})") }

func (my *AbstractVisitor)      VisitPackageOrTypeName(n *PackageOrTypeName)  { my.UnimplementedVisitor("VisitPackageOrTypeName(PackageOrTypeName)") }

func (my *AbstractVisitor)      VisitPackageOrTypeNameWithArg(n *PackageOrTypeName, o interface{})  { my.UnimplementedVisitor("VisitPackageOrTypeNameWithArg(PackageOrTypeName, interface{})") }

func (my *AbstractVisitor)      VisitAmbiguousName(n *AmbiguousName)  { my.UnimplementedVisitor("VisitAmbiguousName(AmbiguousName)") }

func (my *AbstractVisitor)      VisitAmbiguousNameWithArg(n *AmbiguousName, o interface{})  { my.UnimplementedVisitor("VisitAmbiguousNameWithArg(AmbiguousName, interface{})") }

func (my *AbstractVisitor)      VisitCompilationUnit(n *CompilationUnit)  { my.UnimplementedVisitor("VisitCompilationUnit(CompilationUnit)") }

func (my *AbstractVisitor)      VisitCompilationUnitWithArg(n *CompilationUnit, o interface{})  { my.UnimplementedVisitor("VisitCompilationUnitWithArg(CompilationUnit, interface{})") }

func (my *AbstractVisitor)      VisitImportDeclarations(n *ImportDeclarations)  { my.UnimplementedVisitor("VisitImportDeclarations(ImportDeclarations)") }

func (my *AbstractVisitor)      VisitImportDeclarationsWithArg(n *ImportDeclarations, o interface{})  { my.UnimplementedVisitor("VisitImportDeclarationsWithArg(ImportDeclarations, interface{})") }

func (my *AbstractVisitor)      VisitTypeDeclarations(n *TypeDeclarations)  { my.UnimplementedVisitor("VisitTypeDeclarations(TypeDeclarations)") }

func (my *AbstractVisitor)      VisitTypeDeclarationsWithArg(n *TypeDeclarations, o interface{})  { my.UnimplementedVisitor("VisitTypeDeclarationsWithArg(TypeDeclarations, interface{})") }

func (my *AbstractVisitor)      VisitPackageDeclaration(n *PackageDeclaration)  { my.UnimplementedVisitor("VisitPackageDeclaration(PackageDeclaration)") }

func (my *AbstractVisitor)      VisitPackageDeclarationWithArg(n *PackageDeclaration, o interface{})  { my.UnimplementedVisitor("VisitPackageDeclarationWithArg(PackageDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitSingleTypeImportDeclaration(n *SingleTypeImportDeclaration)  { my.UnimplementedVisitor("VisitSingleTypeImportDeclaration(SingleTypeImportDeclaration)") }

func (my *AbstractVisitor)      VisitSingleTypeImportDeclarationWithArg(n *SingleTypeImportDeclaration, o interface{})  { my.UnimplementedVisitor("VisitSingleTypeImportDeclarationWithArg(SingleTypeImportDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitTypeImportOnDemandDeclaration(n *TypeImportOnDemandDeclaration)  { my.UnimplementedVisitor("VisitTypeImportOnDemandDeclaration(TypeImportOnDemandDeclaration)") }

func (my *AbstractVisitor)      VisitTypeImportOnDemandDeclarationWithArg(n *TypeImportOnDemandDeclaration, o interface{})  { my.UnimplementedVisitor("VisitTypeImportOnDemandDeclarationWithArg(TypeImportOnDemandDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitSingleStaticImportDeclaration(n *SingleStaticImportDeclaration)  { my.UnimplementedVisitor("VisitSingleStaticImportDeclaration(SingleStaticImportDeclaration)") }

func (my *AbstractVisitor)      VisitSingleStaticImportDeclarationWithArg(n *SingleStaticImportDeclaration, o interface{})  { my.UnimplementedVisitor("VisitSingleStaticImportDeclarationWithArg(SingleStaticImportDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitStaticImportOnDemandDeclaration(n *StaticImportOnDemandDeclaration)  { my.UnimplementedVisitor("VisitStaticImportOnDemandDeclaration(StaticImportOnDemandDeclaration)") }

func (my *AbstractVisitor)      VisitStaticImportOnDemandDeclarationWithArg(n *StaticImportOnDemandDeclaration, o interface{})  { my.UnimplementedVisitor("VisitStaticImportOnDemandDeclarationWithArg(StaticImportOnDemandDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitTypeDeclaration(n *TypeDeclaration)  { my.UnimplementedVisitor("VisitTypeDeclaration(TypeDeclaration)") }

func (my *AbstractVisitor)      VisitTypeDeclarationWithArg(n *TypeDeclaration, o interface{})  { my.UnimplementedVisitor("VisitTypeDeclarationWithArg(TypeDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitNormalClassDeclaration(n *NormalClassDeclaration)  { my.UnimplementedVisitor("VisitNormalClassDeclaration(NormalClassDeclaration)") }

func (my *AbstractVisitor)      VisitNormalClassDeclarationWithArg(n *NormalClassDeclaration, o interface{})  { my.UnimplementedVisitor("VisitNormalClassDeclarationWithArg(NormalClassDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitClassModifiers(n *ClassModifiers)  { my.UnimplementedVisitor("VisitClassModifiers(ClassModifiers)") }

func (my *AbstractVisitor)      VisitClassModifiersWithArg(n *ClassModifiers, o interface{})  { my.UnimplementedVisitor("VisitClassModifiersWithArg(ClassModifiers, interface{})") }

func (my *AbstractVisitor)      VisitTypeParameters(n *TypeParameters)  { my.UnimplementedVisitor("VisitTypeParameters(TypeParameters)") }

func (my *AbstractVisitor)      VisitTypeParametersWithArg(n *TypeParameters, o interface{})  { my.UnimplementedVisitor("VisitTypeParametersWithArg(TypeParameters, interface{})") }

func (my *AbstractVisitor)      VisitTypeParameterList(n *TypeParameterList)  { my.UnimplementedVisitor("VisitTypeParameterList(TypeParameterList)") }

func (my *AbstractVisitor)      VisitTypeParameterListWithArg(n *TypeParameterList, o interface{})  { my.UnimplementedVisitor("VisitTypeParameterListWithArg(TypeParameterList, interface{})") }

func (my *AbstractVisitor)      VisitSuper(n *Super)  { my.UnimplementedVisitor("VisitSuper(Super)") }

func (my *AbstractVisitor)      VisitSuperWithArg(n *Super, o interface{})  { my.UnimplementedVisitor("VisitSuperWithArg(Super, interface{})") }

func (my *AbstractVisitor)      VisitInterfaces(n *Interfaces)  { my.UnimplementedVisitor("VisitInterfaces(Interfaces)") }

func (my *AbstractVisitor)      VisitInterfacesWithArg(n *Interfaces, o interface{})  { my.UnimplementedVisitor("VisitInterfacesWithArg(Interfaces, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceTypeList(n *InterfaceTypeList)  { my.UnimplementedVisitor("VisitInterfaceTypeList(InterfaceTypeList)") }

func (my *AbstractVisitor)      VisitInterfaceTypeListWithArg(n *InterfaceTypeList, o interface{})  { my.UnimplementedVisitor("VisitInterfaceTypeListWithArg(InterfaceTypeList, interface{})") }

func (my *AbstractVisitor)      VisitClassBody(n *ClassBody)  { my.UnimplementedVisitor("VisitClassBody(ClassBody)") }

func (my *AbstractVisitor)      VisitClassBodyWithArg(n *ClassBody, o interface{})  { my.UnimplementedVisitor("VisitClassBodyWithArg(ClassBody, interface{})") }

func (my *AbstractVisitor)      VisitClassBodyDeclarations(n *ClassBodyDeclarations)  { my.UnimplementedVisitor("VisitClassBodyDeclarations(ClassBodyDeclarations)") }

func (my *AbstractVisitor)      VisitClassBodyDeclarationsWithArg(n *ClassBodyDeclarations, o interface{})  { my.UnimplementedVisitor("VisitClassBodyDeclarationsWithArg(ClassBodyDeclarations, interface{})") }

func (my *AbstractVisitor)      VisitClassMemberDeclaration(n *ClassMemberDeclaration)  { my.UnimplementedVisitor("VisitClassMemberDeclaration(ClassMemberDeclaration)") }

func (my *AbstractVisitor)      VisitClassMemberDeclarationWithArg(n *ClassMemberDeclaration, o interface{})  { my.UnimplementedVisitor("VisitClassMemberDeclarationWithArg(ClassMemberDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitFieldDeclaration(n *FieldDeclaration)  { my.UnimplementedVisitor("VisitFieldDeclaration(FieldDeclaration)") }

func (my *AbstractVisitor)      VisitFieldDeclarationWithArg(n *FieldDeclaration, o interface{})  { my.UnimplementedVisitor("VisitFieldDeclarationWithArg(FieldDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitVariableDeclarators(n *VariableDeclarators)  { my.UnimplementedVisitor("VisitVariableDeclarators(VariableDeclarators)") }

func (my *AbstractVisitor)      VisitVariableDeclaratorsWithArg(n *VariableDeclarators, o interface{})  { my.UnimplementedVisitor("VisitVariableDeclaratorsWithArg(VariableDeclarators, interface{})") }

func (my *AbstractVisitor)      VisitVariableDeclarator(n *VariableDeclarator)  { my.UnimplementedVisitor("VisitVariableDeclarator(VariableDeclarator)") }

func (my *AbstractVisitor)      VisitVariableDeclaratorWithArg(n *VariableDeclarator, o interface{})  { my.UnimplementedVisitor("VisitVariableDeclaratorWithArg(VariableDeclarator, interface{})") }

func (my *AbstractVisitor)      VisitVariableDeclaratorId(n *VariableDeclaratorId)  { my.UnimplementedVisitor("VisitVariableDeclaratorId(VariableDeclaratorId)") }

func (my *AbstractVisitor)      VisitVariableDeclaratorIdWithArg(n *VariableDeclaratorId, o interface{})  { my.UnimplementedVisitor("VisitVariableDeclaratorIdWithArg(VariableDeclaratorId, interface{})") }

func (my *AbstractVisitor)      VisitFieldModifiers(n *FieldModifiers)  { my.UnimplementedVisitor("VisitFieldModifiers(FieldModifiers)") }

func (my *AbstractVisitor)      VisitFieldModifiersWithArg(n *FieldModifiers, o interface{})  { my.UnimplementedVisitor("VisitFieldModifiersWithArg(FieldModifiers, interface{})") }

func (my *AbstractVisitor)      VisitMethodDeclaration(n *MethodDeclaration)  { my.UnimplementedVisitor("VisitMethodDeclaration(MethodDeclaration)") }

func (my *AbstractVisitor)      VisitMethodDeclarationWithArg(n *MethodDeclaration, o interface{})  { my.UnimplementedVisitor("VisitMethodDeclarationWithArg(MethodDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitMethodHeader(n *MethodHeader)  { my.UnimplementedVisitor("VisitMethodHeader(MethodHeader)") }

func (my *AbstractVisitor)      VisitMethodHeaderWithArg(n *MethodHeader, o interface{})  { my.UnimplementedVisitor("VisitMethodHeaderWithArg(MethodHeader, interface{})") }

func (my *AbstractVisitor)      VisitResultType(n *ResultType)  { my.UnimplementedVisitor("VisitResultType(ResultType)") }

func (my *AbstractVisitor)      VisitResultTypeWithArg(n *ResultType, o interface{})  { my.UnimplementedVisitor("VisitResultTypeWithArg(ResultType, interface{})") }

func (my *AbstractVisitor)      VisitFormalParameterList(n *FormalParameterList)  { my.UnimplementedVisitor("VisitFormalParameterList(FormalParameterList)") }

func (my *AbstractVisitor)      VisitFormalParameterListWithArg(n *FormalParameterList, o interface{})  { my.UnimplementedVisitor("VisitFormalParameterListWithArg(FormalParameterList, interface{})") }

func (my *AbstractVisitor)      VisitFormalParameters(n *FormalParameters)  { my.UnimplementedVisitor("VisitFormalParameters(FormalParameters)") }

func (my *AbstractVisitor)      VisitFormalParametersWithArg(n *FormalParameters, o interface{})  { my.UnimplementedVisitor("VisitFormalParametersWithArg(FormalParameters, interface{})") }

func (my *AbstractVisitor)      VisitFormalParameter(n *FormalParameter)  { my.UnimplementedVisitor("VisitFormalParameter(FormalParameter)") }

func (my *AbstractVisitor)      VisitFormalParameterWithArg(n *FormalParameter, o interface{})  { my.UnimplementedVisitor("VisitFormalParameterWithArg(FormalParameter, interface{})") }

func (my *AbstractVisitor)      VisitVariableModifiers(n *VariableModifiers)  { my.UnimplementedVisitor("VisitVariableModifiers(VariableModifiers)") }

func (my *AbstractVisitor)      VisitVariableModifiersWithArg(n *VariableModifiers, o interface{})  { my.UnimplementedVisitor("VisitVariableModifiersWithArg(VariableModifiers, interface{})") }

func (my *AbstractVisitor)      VisitVariableModifier(n *VariableModifier)  { my.UnimplementedVisitor("VisitVariableModifier(VariableModifier)") }

func (my *AbstractVisitor)      VisitVariableModifierWithArg(n *VariableModifier, o interface{})  { my.UnimplementedVisitor("VisitVariableModifierWithArg(VariableModifier, interface{})") }

func (my *AbstractVisitor)      VisitLastFormalParameter(n *LastFormalParameter)  { my.UnimplementedVisitor("VisitLastFormalParameter(LastFormalParameter)") }

func (my *AbstractVisitor)      VisitLastFormalParameterWithArg(n *LastFormalParameter, o interface{})  { my.UnimplementedVisitor("VisitLastFormalParameterWithArg(LastFormalParameter, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifiers(n *MethodModifiers)  { my.UnimplementedVisitor("VisitMethodModifiers(MethodModifiers)") }

func (my *AbstractVisitor)      VisitMethodModifiersWithArg(n *MethodModifiers, o interface{})  { my.UnimplementedVisitor("VisitMethodModifiersWithArg(MethodModifiers, interface{})") }

func (my *AbstractVisitor)      VisitThrows(n *Throws)  { my.UnimplementedVisitor("VisitThrows(Throws)") }

func (my *AbstractVisitor)      VisitThrowsWithArg(n *Throws, o interface{})  { my.UnimplementedVisitor("VisitThrowsWithArg(Throws, interface{})") }

func (my *AbstractVisitor)      VisitExceptionTypeList(n *ExceptionTypeList)  { my.UnimplementedVisitor("VisitExceptionTypeList(ExceptionTypeList)") }

func (my *AbstractVisitor)      VisitExceptionTypeListWithArg(n *ExceptionTypeList, o interface{})  { my.UnimplementedVisitor("VisitExceptionTypeListWithArg(ExceptionTypeList, interface{})") }

func (my *AbstractVisitor)      VisitMethodBody(n *MethodBody)  { my.UnimplementedVisitor("VisitMethodBody(MethodBody)") }

func (my *AbstractVisitor)      VisitMethodBodyWithArg(n *MethodBody, o interface{})  { my.UnimplementedVisitor("VisitMethodBodyWithArg(MethodBody, interface{})") }

func (my *AbstractVisitor)      VisitStaticInitializer(n *StaticInitializer)  { my.UnimplementedVisitor("VisitStaticInitializer(StaticInitializer)") }

func (my *AbstractVisitor)      VisitStaticInitializerWithArg(n *StaticInitializer, o interface{})  { my.UnimplementedVisitor("VisitStaticInitializerWithArg(StaticInitializer, interface{})") }

func (my *AbstractVisitor)      VisitConstructorDeclaration(n *ConstructorDeclaration)  { my.UnimplementedVisitor("VisitConstructorDeclaration(ConstructorDeclaration)") }

func (my *AbstractVisitor)      VisitConstructorDeclarationWithArg(n *ConstructorDeclaration, o interface{})  { my.UnimplementedVisitor("VisitConstructorDeclarationWithArg(ConstructorDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitConstructorDeclarator(n *ConstructorDeclarator)  { my.UnimplementedVisitor("VisitConstructorDeclarator(ConstructorDeclarator)") }

func (my *AbstractVisitor)      VisitConstructorDeclaratorWithArg(n *ConstructorDeclarator, o interface{})  { my.UnimplementedVisitor("VisitConstructorDeclaratorWithArg(ConstructorDeclarator, interface{})") }

func (my *AbstractVisitor)      VisitConstructorModifiers(n *ConstructorModifiers)  { my.UnimplementedVisitor("VisitConstructorModifiers(ConstructorModifiers)") }

func (my *AbstractVisitor)      VisitConstructorModifiersWithArg(n *ConstructorModifiers, o interface{})  { my.UnimplementedVisitor("VisitConstructorModifiersWithArg(ConstructorModifiers, interface{})") }

func (my *AbstractVisitor)      VisitConstructorBody(n *ConstructorBody)  { my.UnimplementedVisitor("VisitConstructorBody(ConstructorBody)") }

func (my *AbstractVisitor)      VisitConstructorBodyWithArg(n *ConstructorBody, o interface{})  { my.UnimplementedVisitor("VisitConstructorBodyWithArg(ConstructorBody, interface{})") }

func (my *AbstractVisitor)      VisitEnumDeclaration(n *EnumDeclaration)  { my.UnimplementedVisitor("VisitEnumDeclaration(EnumDeclaration)") }

func (my *AbstractVisitor)      VisitEnumDeclarationWithArg(n *EnumDeclaration, o interface{})  { my.UnimplementedVisitor("VisitEnumDeclarationWithArg(EnumDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitEnumBody(n *EnumBody)  { my.UnimplementedVisitor("VisitEnumBody(EnumBody)") }

func (my *AbstractVisitor)      VisitEnumBodyWithArg(n *EnumBody, o interface{})  { my.UnimplementedVisitor("VisitEnumBodyWithArg(EnumBody, interface{})") }

func (my *AbstractVisitor)      VisitEnumConstants(n *EnumConstants)  { my.UnimplementedVisitor("VisitEnumConstants(EnumConstants)") }

func (my *AbstractVisitor)      VisitEnumConstantsWithArg(n *EnumConstants, o interface{})  { my.UnimplementedVisitor("VisitEnumConstantsWithArg(EnumConstants, interface{})") }

func (my *AbstractVisitor)      VisitEnumConstant(n *EnumConstant)  { my.UnimplementedVisitor("VisitEnumConstant(EnumConstant)") }

func (my *AbstractVisitor)      VisitEnumConstantWithArg(n *EnumConstant, o interface{})  { my.UnimplementedVisitor("VisitEnumConstantWithArg(EnumConstant, interface{})") }

func (my *AbstractVisitor)      VisitArguments(n *Arguments)  { my.UnimplementedVisitor("VisitArguments(Arguments)") }

func (my *AbstractVisitor)      VisitArgumentsWithArg(n *Arguments, o interface{})  { my.UnimplementedVisitor("VisitArgumentsWithArg(Arguments, interface{})") }

func (my *AbstractVisitor)      VisitEnumBodyDeclarations(n *EnumBodyDeclarations)  { my.UnimplementedVisitor("VisitEnumBodyDeclarations(EnumBodyDeclarations)") }

func (my *AbstractVisitor)      VisitEnumBodyDeclarationsWithArg(n *EnumBodyDeclarations, o interface{})  { my.UnimplementedVisitor("VisitEnumBodyDeclarationsWithArg(EnumBodyDeclarations, interface{})") }

func (my *AbstractVisitor)      VisitNormalInterfaceDeclaration(n *NormalInterfaceDeclaration)  { my.UnimplementedVisitor("VisitNormalInterfaceDeclaration(NormalInterfaceDeclaration)") }

func (my *AbstractVisitor)      VisitNormalInterfaceDeclarationWithArg(n *NormalInterfaceDeclaration, o interface{})  { my.UnimplementedVisitor("VisitNormalInterfaceDeclarationWithArg(NormalInterfaceDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceModifiers(n *InterfaceModifiers)  { my.UnimplementedVisitor("VisitInterfaceModifiers(InterfaceModifiers)") }

func (my *AbstractVisitor)      VisitInterfaceModifiersWithArg(n *InterfaceModifiers, o interface{})  { my.UnimplementedVisitor("VisitInterfaceModifiersWithArg(InterfaceModifiers, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceBody(n *InterfaceBody)  { my.UnimplementedVisitor("VisitInterfaceBody(InterfaceBody)") }

func (my *AbstractVisitor)      VisitInterfaceBodyWithArg(n *InterfaceBody, o interface{})  { my.UnimplementedVisitor("VisitInterfaceBodyWithArg(InterfaceBody, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceMemberDeclarations(n *InterfaceMemberDeclarations)  { my.UnimplementedVisitor("VisitInterfaceMemberDeclarations(InterfaceMemberDeclarations)") }

func (my *AbstractVisitor)      VisitInterfaceMemberDeclarationsWithArg(n *InterfaceMemberDeclarations, o interface{})  { my.UnimplementedVisitor("VisitInterfaceMemberDeclarationsWithArg(InterfaceMemberDeclarations, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceMemberDeclaration(n *InterfaceMemberDeclaration)  { my.UnimplementedVisitor("VisitInterfaceMemberDeclaration(InterfaceMemberDeclaration)") }

func (my *AbstractVisitor)      VisitInterfaceMemberDeclarationWithArg(n *InterfaceMemberDeclaration, o interface{})  { my.UnimplementedVisitor("VisitInterfaceMemberDeclarationWithArg(InterfaceMemberDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitConstantDeclaration(n *ConstantDeclaration)  { my.UnimplementedVisitor("VisitConstantDeclaration(ConstantDeclaration)") }

func (my *AbstractVisitor)      VisitConstantDeclarationWithArg(n *ConstantDeclaration, o interface{})  { my.UnimplementedVisitor("VisitConstantDeclarationWithArg(ConstantDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitConstantModifiers(n *ConstantModifiers)  { my.UnimplementedVisitor("VisitConstantModifiers(ConstantModifiers)") }

func (my *AbstractVisitor)      VisitConstantModifiersWithArg(n *ConstantModifiers, o interface{})  { my.UnimplementedVisitor("VisitConstantModifiersWithArg(ConstantModifiers, interface{})") }

func (my *AbstractVisitor)      VisitAbstractMethodDeclaration(n *AbstractMethodDeclaration)  { my.UnimplementedVisitor("VisitAbstractMethodDeclaration(AbstractMethodDeclaration)") }

func (my *AbstractVisitor)      VisitAbstractMethodDeclarationWithArg(n *AbstractMethodDeclaration, o interface{})  { my.UnimplementedVisitor("VisitAbstractMethodDeclarationWithArg(AbstractMethodDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitAbstractMethodModifiers(n *AbstractMethodModifiers)  { my.UnimplementedVisitor("VisitAbstractMethodModifiers(AbstractMethodModifiers)") }

func (my *AbstractVisitor)      VisitAbstractMethodModifiersWithArg(n *AbstractMethodModifiers, o interface{})  { my.UnimplementedVisitor("VisitAbstractMethodModifiersWithArg(AbstractMethodModifiers, interface{})") }

func (my *AbstractVisitor)      VisitAnnotationTypeDeclaration(n *AnnotationTypeDeclaration)  { my.UnimplementedVisitor("VisitAnnotationTypeDeclaration(AnnotationTypeDeclaration)") }

func (my *AbstractVisitor)      VisitAnnotationTypeDeclarationWithArg(n *AnnotationTypeDeclaration, o interface{})  { my.UnimplementedVisitor("VisitAnnotationTypeDeclarationWithArg(AnnotationTypeDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitAnnotationTypeBody(n *AnnotationTypeBody)  { my.UnimplementedVisitor("VisitAnnotationTypeBody(AnnotationTypeBody)") }

func (my *AbstractVisitor)      VisitAnnotationTypeBodyWithArg(n *AnnotationTypeBody, o interface{})  { my.UnimplementedVisitor("VisitAnnotationTypeBodyWithArg(AnnotationTypeBody, interface{})") }

func (my *AbstractVisitor)      VisitAnnotationTypeElementDeclarations(n *AnnotationTypeElementDeclarations)  { my.UnimplementedVisitor("VisitAnnotationTypeElementDeclarations(AnnotationTypeElementDeclarations)") }

func (my *AbstractVisitor)      VisitAnnotationTypeElementDeclarationsWithArg(n *AnnotationTypeElementDeclarations, o interface{})  { my.UnimplementedVisitor("VisitAnnotationTypeElementDeclarationsWithArg(AnnotationTypeElementDeclarations, interface{})") }

func (my *AbstractVisitor)      VisitDefaultValue(n *DefaultValue)  { my.UnimplementedVisitor("VisitDefaultValue(DefaultValue)") }

func (my *AbstractVisitor)      VisitDefaultValueWithArg(n *DefaultValue, o interface{})  { my.UnimplementedVisitor("VisitDefaultValueWithArg(DefaultValue, interface{})") }

func (my *AbstractVisitor)      VisitAnnotations(n *Annotations)  { my.UnimplementedVisitor("VisitAnnotations(Annotations)") }

func (my *AbstractVisitor)      VisitAnnotationsWithArg(n *Annotations, o interface{})  { my.UnimplementedVisitor("VisitAnnotationsWithArg(Annotations, interface{})") }

func (my *AbstractVisitor)      VisitNormalAnnotation(n *NormalAnnotation)  { my.UnimplementedVisitor("VisitNormalAnnotation(NormalAnnotation)") }

func (my *AbstractVisitor)      VisitNormalAnnotationWithArg(n *NormalAnnotation, o interface{})  { my.UnimplementedVisitor("VisitNormalAnnotationWithArg(NormalAnnotation, interface{})") }

func (my *AbstractVisitor)      VisitElementValuePairs(n *ElementValuePairs)  { my.UnimplementedVisitor("VisitElementValuePairs(ElementValuePairs)") }

func (my *AbstractVisitor)      VisitElementValuePairsWithArg(n *ElementValuePairs, o interface{})  { my.UnimplementedVisitor("VisitElementValuePairsWithArg(ElementValuePairs, interface{})") }

func (my *AbstractVisitor)      VisitElementValuePair(n *ElementValuePair)  { my.UnimplementedVisitor("VisitElementValuePair(ElementValuePair)") }

func (my *AbstractVisitor)      VisitElementValuePairWithArg(n *ElementValuePair, o interface{})  { my.UnimplementedVisitor("VisitElementValuePairWithArg(ElementValuePair, interface{})") }

func (my *AbstractVisitor)      VisitElementValueArrayInitializer(n *ElementValueArrayInitializer)  { my.UnimplementedVisitor("VisitElementValueArrayInitializer(ElementValueArrayInitializer)") }

func (my *AbstractVisitor)      VisitElementValueArrayInitializerWithArg(n *ElementValueArrayInitializer, o interface{})  { my.UnimplementedVisitor("VisitElementValueArrayInitializerWithArg(ElementValueArrayInitializer, interface{})") }

func (my *AbstractVisitor)      VisitElementValues(n *ElementValues)  { my.UnimplementedVisitor("VisitElementValues(ElementValues)") }

func (my *AbstractVisitor)      VisitElementValuesWithArg(n *ElementValues, o interface{})  { my.UnimplementedVisitor("VisitElementValuesWithArg(ElementValues, interface{})") }

func (my *AbstractVisitor)      VisitMarkerAnnotation(n *MarkerAnnotation)  { my.UnimplementedVisitor("VisitMarkerAnnotation(MarkerAnnotation)") }

func (my *AbstractVisitor)      VisitMarkerAnnotationWithArg(n *MarkerAnnotation, o interface{})  { my.UnimplementedVisitor("VisitMarkerAnnotationWithArg(MarkerAnnotation, interface{})") }

func (my *AbstractVisitor)      VisitSingleElementAnnotation(n *SingleElementAnnotation)  { my.UnimplementedVisitor("VisitSingleElementAnnotation(SingleElementAnnotation)") }

func (my *AbstractVisitor)      VisitSingleElementAnnotationWithArg(n *SingleElementAnnotation, o interface{})  { my.UnimplementedVisitor("VisitSingleElementAnnotationWithArg(SingleElementAnnotation, interface{})") }

func (my *AbstractVisitor)      VisitArrayInitializer(n *ArrayInitializer)  { my.UnimplementedVisitor("VisitArrayInitializer(ArrayInitializer)") }

func (my *AbstractVisitor)      VisitArrayInitializerWithArg(n *ArrayInitializer, o interface{})  { my.UnimplementedVisitor("VisitArrayInitializerWithArg(ArrayInitializer, interface{})") }

func (my *AbstractVisitor)      VisitVariableInitializers(n *VariableInitializers)  { my.UnimplementedVisitor("VisitVariableInitializers(VariableInitializers)") }

func (my *AbstractVisitor)      VisitVariableInitializersWithArg(n *VariableInitializers, o interface{})  { my.UnimplementedVisitor("VisitVariableInitializersWithArg(VariableInitializers, interface{})") }

func (my *AbstractVisitor)      VisitBlock(n *Block)  { my.UnimplementedVisitor("VisitBlock(Block)") }

func (my *AbstractVisitor)      VisitBlockWithArg(n *Block, o interface{})  { my.UnimplementedVisitor("VisitBlockWithArg(Block, interface{})") }

func (my *AbstractVisitor)      VisitBlockStatements(n *BlockStatements)  { my.UnimplementedVisitor("VisitBlockStatements(BlockStatements)") }

func (my *AbstractVisitor)      VisitBlockStatementsWithArg(n *BlockStatements, o interface{})  { my.UnimplementedVisitor("VisitBlockStatementsWithArg(BlockStatements, interface{})") }

func (my *AbstractVisitor)      VisitLocalVariableDeclarationStatement(n *LocalVariableDeclarationStatement)  { my.UnimplementedVisitor("VisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatement)") }

func (my *AbstractVisitor)      VisitLocalVariableDeclarationStatementWithArg(n *LocalVariableDeclarationStatement, o interface{})  { my.UnimplementedVisitor("VisitLocalVariableDeclarationStatementWithArg(LocalVariableDeclarationStatement, interface{})") }

func (my *AbstractVisitor)      VisitLocalVariableDeclaration(n *LocalVariableDeclaration)  { my.UnimplementedVisitor("VisitLocalVariableDeclaration(LocalVariableDeclaration)") }

func (my *AbstractVisitor)      VisitLocalVariableDeclarationWithArg(n *LocalVariableDeclaration, o interface{})  { my.UnimplementedVisitor("VisitLocalVariableDeclarationWithArg(LocalVariableDeclaration, interface{})") }

func (my *AbstractVisitor)      VisitIfThenStatement(n *IfThenStatement)  { my.UnimplementedVisitor("VisitIfThenStatement(IfThenStatement)") }

func (my *AbstractVisitor)      VisitIfThenStatementWithArg(n *IfThenStatement, o interface{})  { my.UnimplementedVisitor("VisitIfThenStatementWithArg(IfThenStatement, interface{})") }

func (my *AbstractVisitor)      VisitIfThenElseStatement(n *IfThenElseStatement)  { my.UnimplementedVisitor("VisitIfThenElseStatement(IfThenElseStatement)") }

func (my *AbstractVisitor)      VisitIfThenElseStatementWithArg(n *IfThenElseStatement, o interface{})  { my.UnimplementedVisitor("VisitIfThenElseStatementWithArg(IfThenElseStatement, interface{})") }

func (my *AbstractVisitor)      VisitIfThenElseStatementNoShortIf(n *IfThenElseStatementNoShortIf)  { my.UnimplementedVisitor("VisitIfThenElseStatementNoShortIf(IfThenElseStatementNoShortIf)") }

func (my *AbstractVisitor)      VisitIfThenElseStatementNoShortIfWithArg(n *IfThenElseStatementNoShortIf, o interface{})  { my.UnimplementedVisitor("VisitIfThenElseStatementNoShortIfWithArg(IfThenElseStatementNoShortIf, interface{})") }

func (my *AbstractVisitor)      VisitEmptyStatement(n *EmptyStatement)  { my.UnimplementedVisitor("VisitEmptyStatement(EmptyStatement)") }

func (my *AbstractVisitor)      VisitEmptyStatementWithArg(n *EmptyStatement, o interface{})  { my.UnimplementedVisitor("VisitEmptyStatementWithArg(EmptyStatement, interface{})") }

func (my *AbstractVisitor)      VisitLabeledStatement(n *LabeledStatement)  { my.UnimplementedVisitor("VisitLabeledStatement(LabeledStatement)") }

func (my *AbstractVisitor)      VisitLabeledStatementWithArg(n *LabeledStatement, o interface{})  { my.UnimplementedVisitor("VisitLabeledStatementWithArg(LabeledStatement, interface{})") }

func (my *AbstractVisitor)      VisitLabeledStatementNoShortIf(n *LabeledStatementNoShortIf)  { my.UnimplementedVisitor("VisitLabeledStatementNoShortIf(LabeledStatementNoShortIf)") }

func (my *AbstractVisitor)      VisitLabeledStatementNoShortIfWithArg(n *LabeledStatementNoShortIf, o interface{})  { my.UnimplementedVisitor("VisitLabeledStatementNoShortIfWithArg(LabeledStatementNoShortIf, interface{})") }

func (my *AbstractVisitor)      VisitExpressionStatement(n *ExpressionStatement)  { my.UnimplementedVisitor("VisitExpressionStatement(ExpressionStatement)") }

func (my *AbstractVisitor)      VisitExpressionStatementWithArg(n *ExpressionStatement, o interface{})  { my.UnimplementedVisitor("VisitExpressionStatementWithArg(ExpressionStatement, interface{})") }

func (my *AbstractVisitor)      VisitSwitchStatement(n *SwitchStatement)  { my.UnimplementedVisitor("VisitSwitchStatement(SwitchStatement)") }

func (my *AbstractVisitor)      VisitSwitchStatementWithArg(n *SwitchStatement, o interface{})  { my.UnimplementedVisitor("VisitSwitchStatementWithArg(SwitchStatement, interface{})") }

func (my *AbstractVisitor)      VisitSwitchBlock(n *SwitchBlock)  { my.UnimplementedVisitor("VisitSwitchBlock(SwitchBlock)") }

func (my *AbstractVisitor)      VisitSwitchBlockWithArg(n *SwitchBlock, o interface{})  { my.UnimplementedVisitor("VisitSwitchBlockWithArg(SwitchBlock, interface{})") }

func (my *AbstractVisitor)      VisitSwitchBlockStatementGroups(n *SwitchBlockStatementGroups)  { my.UnimplementedVisitor("VisitSwitchBlockStatementGroups(SwitchBlockStatementGroups)") }

func (my *AbstractVisitor)      VisitSwitchBlockStatementGroupsWithArg(n *SwitchBlockStatementGroups, o interface{})  { my.UnimplementedVisitor("VisitSwitchBlockStatementGroupsWithArg(SwitchBlockStatementGroups, interface{})") }

func (my *AbstractVisitor)      VisitSwitchBlockStatementGroup(n *SwitchBlockStatementGroup)  { my.UnimplementedVisitor("VisitSwitchBlockStatementGroup(SwitchBlockStatementGroup)") }

func (my *AbstractVisitor)      VisitSwitchBlockStatementGroupWithArg(n *SwitchBlockStatementGroup, o interface{})  { my.UnimplementedVisitor("VisitSwitchBlockStatementGroupWithArg(SwitchBlockStatementGroup, interface{})") }

func (my *AbstractVisitor)      VisitSwitchLabels(n *SwitchLabels)  { my.UnimplementedVisitor("VisitSwitchLabels(SwitchLabels)") }

func (my *AbstractVisitor)      VisitSwitchLabelsWithArg(n *SwitchLabels, o interface{})  { my.UnimplementedVisitor("VisitSwitchLabelsWithArg(SwitchLabels, interface{})") }

func (my *AbstractVisitor)      VisitWhileStatement(n *WhileStatement)  { my.UnimplementedVisitor("VisitWhileStatement(WhileStatement)") }

func (my *AbstractVisitor)      VisitWhileStatementWithArg(n *WhileStatement, o interface{})  { my.UnimplementedVisitor("VisitWhileStatementWithArg(WhileStatement, interface{})") }

func (my *AbstractVisitor)      VisitWhileStatementNoShortIf(n *WhileStatementNoShortIf)  { my.UnimplementedVisitor("VisitWhileStatementNoShortIf(WhileStatementNoShortIf)") }

func (my *AbstractVisitor)      VisitWhileStatementNoShortIfWithArg(n *WhileStatementNoShortIf, o interface{})  { my.UnimplementedVisitor("VisitWhileStatementNoShortIfWithArg(WhileStatementNoShortIf, interface{})") }

func (my *AbstractVisitor)      VisitDoStatement(n *DoStatement)  { my.UnimplementedVisitor("VisitDoStatement(DoStatement)") }

func (my *AbstractVisitor)      VisitDoStatementWithArg(n *DoStatement, o interface{})  { my.UnimplementedVisitor("VisitDoStatementWithArg(DoStatement, interface{})") }

func (my *AbstractVisitor)      VisitBasicForStatement(n *BasicForStatement)  { my.UnimplementedVisitor("VisitBasicForStatement(BasicForStatement)") }

func (my *AbstractVisitor)      VisitBasicForStatementWithArg(n *BasicForStatement, o interface{})  { my.UnimplementedVisitor("VisitBasicForStatementWithArg(BasicForStatement, interface{})") }

func (my *AbstractVisitor)      VisitForStatementNoShortIf(n *ForStatementNoShortIf)  { my.UnimplementedVisitor("VisitForStatementNoShortIf(ForStatementNoShortIf)") }

func (my *AbstractVisitor)      VisitForStatementNoShortIfWithArg(n *ForStatementNoShortIf, o interface{})  { my.UnimplementedVisitor("VisitForStatementNoShortIfWithArg(ForStatementNoShortIf, interface{})") }

func (my *AbstractVisitor)      VisitStatementExpressionList(n *StatementExpressionList)  { my.UnimplementedVisitor("VisitStatementExpressionList(StatementExpressionList)") }

func (my *AbstractVisitor)      VisitStatementExpressionListWithArg(n *StatementExpressionList, o interface{})  { my.UnimplementedVisitor("VisitStatementExpressionListWithArg(StatementExpressionList, interface{})") }

func (my *AbstractVisitor)      VisitEnhancedForStatement(n *EnhancedForStatement)  { my.UnimplementedVisitor("VisitEnhancedForStatement(EnhancedForStatement)") }

func (my *AbstractVisitor)      VisitEnhancedForStatementWithArg(n *EnhancedForStatement, o interface{})  { my.UnimplementedVisitor("VisitEnhancedForStatementWithArg(EnhancedForStatement, interface{})") }

func (my *AbstractVisitor)      VisitBreakStatement(n *BreakStatement)  { my.UnimplementedVisitor("VisitBreakStatement(BreakStatement)") }

func (my *AbstractVisitor)      VisitBreakStatementWithArg(n *BreakStatement, o interface{})  { my.UnimplementedVisitor("VisitBreakStatementWithArg(BreakStatement, interface{})") }

func (my *AbstractVisitor)      VisitContinueStatement(n *ContinueStatement)  { my.UnimplementedVisitor("VisitContinueStatement(ContinueStatement)") }

func (my *AbstractVisitor)      VisitContinueStatementWithArg(n *ContinueStatement, o interface{})  { my.UnimplementedVisitor("VisitContinueStatementWithArg(ContinueStatement, interface{})") }

func (my *AbstractVisitor)      VisitReturnStatement(n *ReturnStatement)  { my.UnimplementedVisitor("VisitReturnStatement(ReturnStatement)") }

func (my *AbstractVisitor)      VisitReturnStatementWithArg(n *ReturnStatement, o interface{})  { my.UnimplementedVisitor("VisitReturnStatementWithArg(ReturnStatement, interface{})") }

func (my *AbstractVisitor)      VisitThrowStatement(n *ThrowStatement)  { my.UnimplementedVisitor("VisitThrowStatement(ThrowStatement)") }

func (my *AbstractVisitor)      VisitThrowStatementWithArg(n *ThrowStatement, o interface{})  { my.UnimplementedVisitor("VisitThrowStatementWithArg(ThrowStatement, interface{})") }

func (my *AbstractVisitor)      VisitSynchronizedStatement(n *SynchronizedStatement)  { my.UnimplementedVisitor("VisitSynchronizedStatement(SynchronizedStatement)") }

func (my *AbstractVisitor)      VisitSynchronizedStatementWithArg(n *SynchronizedStatement, o interface{})  { my.UnimplementedVisitor("VisitSynchronizedStatementWithArg(SynchronizedStatement, interface{})") }

func (my *AbstractVisitor)      VisitCatches(n *Catches)  { my.UnimplementedVisitor("VisitCatches(Catches)") }

func (my *AbstractVisitor)      VisitCatchesWithArg(n *Catches, o interface{})  { my.UnimplementedVisitor("VisitCatchesWithArg(Catches, interface{})") }

func (my *AbstractVisitor)      VisitCatchClause(n *CatchClause)  { my.UnimplementedVisitor("VisitCatchClause(CatchClause)") }

func (my *AbstractVisitor)      VisitCatchClauseWithArg(n *CatchClause, o interface{})  { my.UnimplementedVisitor("VisitCatchClauseWithArg(CatchClause, interface{})") }

func (my *AbstractVisitor)      VisitFinally(n *Finally)  { my.UnimplementedVisitor("VisitFinally(Finally)") }

func (my *AbstractVisitor)      VisitFinallyWithArg(n *Finally, o interface{})  { my.UnimplementedVisitor("VisitFinallyWithArg(Finally, interface{})") }

func (my *AbstractVisitor)      VisitArgumentList(n *ArgumentList)  { my.UnimplementedVisitor("VisitArgumentList(ArgumentList)") }

func (my *AbstractVisitor)      VisitArgumentListWithArg(n *ArgumentList, o interface{})  { my.UnimplementedVisitor("VisitArgumentListWithArg(ArgumentList, interface{})") }

func (my *AbstractVisitor)      VisitDimExprs(n *DimExprs)  { my.UnimplementedVisitor("VisitDimExprs(DimExprs)") }

func (my *AbstractVisitor)      VisitDimExprsWithArg(n *DimExprs, o interface{})  { my.UnimplementedVisitor("VisitDimExprsWithArg(DimExprs, interface{})") }

func (my *AbstractVisitor)      VisitDimExpr(n *DimExpr)  { my.UnimplementedVisitor("VisitDimExpr(DimExpr)") }

func (my *AbstractVisitor)      VisitDimExprWithArg(n *DimExpr, o interface{})  { my.UnimplementedVisitor("VisitDimExprWithArg(DimExpr, interface{})") }

func (my *AbstractVisitor)      VisitPostIncrementExpression(n *PostIncrementExpression)  { my.UnimplementedVisitor("VisitPostIncrementExpression(PostIncrementExpression)") }

func (my *AbstractVisitor)      VisitPostIncrementExpressionWithArg(n *PostIncrementExpression, o interface{})  { my.UnimplementedVisitor("VisitPostIncrementExpressionWithArg(PostIncrementExpression, interface{})") }

func (my *AbstractVisitor)      VisitPostDecrementExpression(n *PostDecrementExpression)  { my.UnimplementedVisitor("VisitPostDecrementExpression(PostDecrementExpression)") }

func (my *AbstractVisitor)      VisitPostDecrementExpressionWithArg(n *PostDecrementExpression, o interface{})  { my.UnimplementedVisitor("VisitPostDecrementExpressionWithArg(PostDecrementExpression, interface{})") }

func (my *AbstractVisitor)      VisitPreIncrementExpression(n *PreIncrementExpression)  { my.UnimplementedVisitor("VisitPreIncrementExpression(PreIncrementExpression)") }

func (my *AbstractVisitor)      VisitPreIncrementExpressionWithArg(n *PreIncrementExpression, o interface{})  { my.UnimplementedVisitor("VisitPreIncrementExpressionWithArg(PreIncrementExpression, interface{})") }

func (my *AbstractVisitor)      VisitPreDecrementExpression(n *PreDecrementExpression)  { my.UnimplementedVisitor("VisitPreDecrementExpression(PreDecrementExpression)") }

func (my *AbstractVisitor)      VisitPreDecrementExpressionWithArg(n *PreDecrementExpression, o interface{})  { my.UnimplementedVisitor("VisitPreDecrementExpressionWithArg(PreDecrementExpression, interface{})") }

func (my *AbstractVisitor)      VisitAndExpression(n *AndExpression)  { my.UnimplementedVisitor("VisitAndExpression(AndExpression)") }

func (my *AbstractVisitor)      VisitAndExpressionWithArg(n *AndExpression, o interface{})  { my.UnimplementedVisitor("VisitAndExpressionWithArg(AndExpression, interface{})") }

func (my *AbstractVisitor)      VisitExclusiveOrExpression(n *ExclusiveOrExpression)  { my.UnimplementedVisitor("VisitExclusiveOrExpression(ExclusiveOrExpression)") }

func (my *AbstractVisitor)      VisitExclusiveOrExpressionWithArg(n *ExclusiveOrExpression, o interface{})  { my.UnimplementedVisitor("VisitExclusiveOrExpressionWithArg(ExclusiveOrExpression, interface{})") }

func (my *AbstractVisitor)      VisitInclusiveOrExpression(n *InclusiveOrExpression)  { my.UnimplementedVisitor("VisitInclusiveOrExpression(InclusiveOrExpression)") }

func (my *AbstractVisitor)      VisitInclusiveOrExpressionWithArg(n *InclusiveOrExpression, o interface{})  { my.UnimplementedVisitor("VisitInclusiveOrExpressionWithArg(InclusiveOrExpression, interface{})") }

func (my *AbstractVisitor)      VisitConditionalAndExpression(n *ConditionalAndExpression)  { my.UnimplementedVisitor("VisitConditionalAndExpression(ConditionalAndExpression)") }

func (my *AbstractVisitor)      VisitConditionalAndExpressionWithArg(n *ConditionalAndExpression, o interface{})  { my.UnimplementedVisitor("VisitConditionalAndExpressionWithArg(ConditionalAndExpression, interface{})") }

func (my *AbstractVisitor)      VisitConditionalOrExpression(n *ConditionalOrExpression)  { my.UnimplementedVisitor("VisitConditionalOrExpression(ConditionalOrExpression)") }

func (my *AbstractVisitor)      VisitConditionalOrExpressionWithArg(n *ConditionalOrExpression, o interface{})  { my.UnimplementedVisitor("VisitConditionalOrExpressionWithArg(ConditionalOrExpression, interface{})") }

func (my *AbstractVisitor)      VisitConditionalExpression(n *ConditionalExpression)  { my.UnimplementedVisitor("VisitConditionalExpression(ConditionalExpression)") }

func (my *AbstractVisitor)      VisitConditionalExpressionWithArg(n *ConditionalExpression, o interface{})  { my.UnimplementedVisitor("VisitConditionalExpressionWithArg(ConditionalExpression, interface{})") }

func (my *AbstractVisitor)      VisitAssignment(n *Assignment)  { my.UnimplementedVisitor("VisitAssignment(Assignment)") }

func (my *AbstractVisitor)      VisitAssignmentWithArg(n *Assignment, o interface{})  { my.UnimplementedVisitor("VisitAssignmentWithArg(Assignment, interface{})") }

func (my *AbstractVisitor)      VisitCommaopt(n *Commaopt)  { my.UnimplementedVisitor("VisitCommaopt(Commaopt)") }

func (my *AbstractVisitor)      VisitCommaoptWithArg(n *Commaopt, o interface{})  { my.UnimplementedVisitor("VisitCommaoptWithArg(Commaopt, interface{})") }

func (my *AbstractVisitor)      VisitEllipsisopt(n *Ellipsisopt)  { my.UnimplementedVisitor("VisitEllipsisopt(Ellipsisopt)") }

func (my *AbstractVisitor)      VisitEllipsisoptWithArg(n *Ellipsisopt, o interface{})  { my.UnimplementedVisitor("VisitEllipsisoptWithArg(Ellipsisopt, interface{})") }

func (my *AbstractVisitor)      VisitLPGUserAction0(n *LPGUserAction0)  { my.UnimplementedVisitor("VisitLPGUserAction0(LPGUserAction0)") }

func (my *AbstractVisitor)      VisitLPGUserAction0WithArg(n *LPGUserAction0, o interface{})  { my.UnimplementedVisitor("VisitLPGUserAction0WithArg(LPGUserAction0, interface{})") }

func (my *AbstractVisitor)      VisitLPGUserAction1(n *LPGUserAction1)  { my.UnimplementedVisitor("VisitLPGUserAction1(LPGUserAction1)") }

func (my *AbstractVisitor)      VisitLPGUserAction1WithArg(n *LPGUserAction1, o interface{})  { my.UnimplementedVisitor("VisitLPGUserAction1WithArg(LPGUserAction1, interface{})") }

func (my *AbstractVisitor)      VisitLPGUserAction2(n *LPGUserAction2)  { my.UnimplementedVisitor("VisitLPGUserAction2(LPGUserAction2)") }

func (my *AbstractVisitor)      VisitLPGUserAction2WithArg(n *LPGUserAction2, o interface{})  { my.UnimplementedVisitor("VisitLPGUserAction2WithArg(LPGUserAction2, interface{})") }

func (my *AbstractVisitor)      VisitLPGUserAction3(n *LPGUserAction3)  { my.UnimplementedVisitor("VisitLPGUserAction3(LPGUserAction3)") }

func (my *AbstractVisitor)      VisitLPGUserAction3WithArg(n *LPGUserAction3, o interface{})  { my.UnimplementedVisitor("VisitLPGUserAction3WithArg(LPGUserAction3, interface{})") }

func (my *AbstractVisitor)      VisitLPGUserAction4(n *LPGUserAction4)  { my.UnimplementedVisitor("VisitLPGUserAction4(LPGUserAction4)") }

func (my *AbstractVisitor)      VisitLPGUserAction4WithArg(n *LPGUserAction4, o interface{})  { my.UnimplementedVisitor("VisitLPGUserAction4WithArg(LPGUserAction4, interface{})") }

func (my *AbstractVisitor)      VisitIntegralType0(n *IntegralType0)  { my.UnimplementedVisitor("VisitIntegralType0(IntegralType0)") }

func (my *AbstractVisitor)      VisitIntegralType0WithArg(n *IntegralType0, o interface{})  { my.UnimplementedVisitor("VisitIntegralType0WithArg(IntegralType0, interface{})") }

func (my *AbstractVisitor)      VisitIntegralType1(n *IntegralType1)  { my.UnimplementedVisitor("VisitIntegralType1(IntegralType1)") }

func (my *AbstractVisitor)      VisitIntegralType1WithArg(n *IntegralType1, o interface{})  { my.UnimplementedVisitor("VisitIntegralType1WithArg(IntegralType1, interface{})") }

func (my *AbstractVisitor)      VisitIntegralType2(n *IntegralType2)  { my.UnimplementedVisitor("VisitIntegralType2(IntegralType2)") }

func (my *AbstractVisitor)      VisitIntegralType2WithArg(n *IntegralType2, o interface{})  { my.UnimplementedVisitor("VisitIntegralType2WithArg(IntegralType2, interface{})") }

func (my *AbstractVisitor)      VisitIntegralType3(n *IntegralType3)  { my.UnimplementedVisitor("VisitIntegralType3(IntegralType3)") }

func (my *AbstractVisitor)      VisitIntegralType3WithArg(n *IntegralType3, o interface{})  { my.UnimplementedVisitor("VisitIntegralType3WithArg(IntegralType3, interface{})") }

func (my *AbstractVisitor)      VisitIntegralType4(n *IntegralType4)  { my.UnimplementedVisitor("VisitIntegralType4(IntegralType4)") }

func (my *AbstractVisitor)      VisitIntegralType4WithArg(n *IntegralType4, o interface{})  { my.UnimplementedVisitor("VisitIntegralType4WithArg(IntegralType4, interface{})") }

func (my *AbstractVisitor)      VisitFloatingPointType0(n *FloatingPointType0)  { my.UnimplementedVisitor("VisitFloatingPointType0(FloatingPointType0)") }

func (my *AbstractVisitor)      VisitFloatingPointType0WithArg(n *FloatingPointType0, o interface{})  { my.UnimplementedVisitor("VisitFloatingPointType0WithArg(FloatingPointType0, interface{})") }

func (my *AbstractVisitor)      VisitFloatingPointType1(n *FloatingPointType1)  { my.UnimplementedVisitor("VisitFloatingPointType1(FloatingPointType1)") }

func (my *AbstractVisitor)      VisitFloatingPointType1WithArg(n *FloatingPointType1, o interface{})  { my.UnimplementedVisitor("VisitFloatingPointType1WithArg(FloatingPointType1, interface{})") }

func (my *AbstractVisitor)      VisitWildcardBounds0(n *WildcardBounds0)  { my.UnimplementedVisitor("VisitWildcardBounds0(WildcardBounds0)") }

func (my *AbstractVisitor)      VisitWildcardBounds0WithArg(n *WildcardBounds0, o interface{})  { my.UnimplementedVisitor("VisitWildcardBounds0WithArg(WildcardBounds0, interface{})") }

func (my *AbstractVisitor)      VisitWildcardBounds1(n *WildcardBounds1)  { my.UnimplementedVisitor("VisitWildcardBounds1(WildcardBounds1)") }

func (my *AbstractVisitor)      VisitWildcardBounds1WithArg(n *WildcardBounds1, o interface{})  { my.UnimplementedVisitor("VisitWildcardBounds1WithArg(WildcardBounds1, interface{})") }

func (my *AbstractVisitor)      VisitClassModifier0(n *ClassModifier0)  { my.UnimplementedVisitor("VisitClassModifier0(ClassModifier0)") }

func (my *AbstractVisitor)      VisitClassModifier0WithArg(n *ClassModifier0, o interface{})  { my.UnimplementedVisitor("VisitClassModifier0WithArg(ClassModifier0, interface{})") }

func (my *AbstractVisitor)      VisitClassModifier1(n *ClassModifier1)  { my.UnimplementedVisitor("VisitClassModifier1(ClassModifier1)") }

func (my *AbstractVisitor)      VisitClassModifier1WithArg(n *ClassModifier1, o interface{})  { my.UnimplementedVisitor("VisitClassModifier1WithArg(ClassModifier1, interface{})") }

func (my *AbstractVisitor)      VisitClassModifier2(n *ClassModifier2)  { my.UnimplementedVisitor("VisitClassModifier2(ClassModifier2)") }

func (my *AbstractVisitor)      VisitClassModifier2WithArg(n *ClassModifier2, o interface{})  { my.UnimplementedVisitor("VisitClassModifier2WithArg(ClassModifier2, interface{})") }

func (my *AbstractVisitor)      VisitClassModifier3(n *ClassModifier3)  { my.UnimplementedVisitor("VisitClassModifier3(ClassModifier3)") }

func (my *AbstractVisitor)      VisitClassModifier3WithArg(n *ClassModifier3, o interface{})  { my.UnimplementedVisitor("VisitClassModifier3WithArg(ClassModifier3, interface{})") }

func (my *AbstractVisitor)      VisitClassModifier4(n *ClassModifier4)  { my.UnimplementedVisitor("VisitClassModifier4(ClassModifier4)") }

func (my *AbstractVisitor)      VisitClassModifier4WithArg(n *ClassModifier4, o interface{})  { my.UnimplementedVisitor("VisitClassModifier4WithArg(ClassModifier4, interface{})") }

func (my *AbstractVisitor)      VisitClassModifier5(n *ClassModifier5)  { my.UnimplementedVisitor("VisitClassModifier5(ClassModifier5)") }

func (my *AbstractVisitor)      VisitClassModifier5WithArg(n *ClassModifier5, o interface{})  { my.UnimplementedVisitor("VisitClassModifier5WithArg(ClassModifier5, interface{})") }

func (my *AbstractVisitor)      VisitClassModifier6(n *ClassModifier6)  { my.UnimplementedVisitor("VisitClassModifier6(ClassModifier6)") }

func (my *AbstractVisitor)      VisitClassModifier6WithArg(n *ClassModifier6, o interface{})  { my.UnimplementedVisitor("VisitClassModifier6WithArg(ClassModifier6, interface{})") }

func (my *AbstractVisitor)      VisitFieldModifier0(n *FieldModifier0)  { my.UnimplementedVisitor("VisitFieldModifier0(FieldModifier0)") }

func (my *AbstractVisitor)      VisitFieldModifier0WithArg(n *FieldModifier0, o interface{})  { my.UnimplementedVisitor("VisitFieldModifier0WithArg(FieldModifier0, interface{})") }

func (my *AbstractVisitor)      VisitFieldModifier1(n *FieldModifier1)  { my.UnimplementedVisitor("VisitFieldModifier1(FieldModifier1)") }

func (my *AbstractVisitor)      VisitFieldModifier1WithArg(n *FieldModifier1, o interface{})  { my.UnimplementedVisitor("VisitFieldModifier1WithArg(FieldModifier1, interface{})") }

func (my *AbstractVisitor)      VisitFieldModifier2(n *FieldModifier2)  { my.UnimplementedVisitor("VisitFieldModifier2(FieldModifier2)") }

func (my *AbstractVisitor)      VisitFieldModifier2WithArg(n *FieldModifier2, o interface{})  { my.UnimplementedVisitor("VisitFieldModifier2WithArg(FieldModifier2, interface{})") }

func (my *AbstractVisitor)      VisitFieldModifier3(n *FieldModifier3)  { my.UnimplementedVisitor("VisitFieldModifier3(FieldModifier3)") }

func (my *AbstractVisitor)      VisitFieldModifier3WithArg(n *FieldModifier3, o interface{})  { my.UnimplementedVisitor("VisitFieldModifier3WithArg(FieldModifier3, interface{})") }

func (my *AbstractVisitor)      VisitFieldModifier4(n *FieldModifier4)  { my.UnimplementedVisitor("VisitFieldModifier4(FieldModifier4)") }

func (my *AbstractVisitor)      VisitFieldModifier4WithArg(n *FieldModifier4, o interface{})  { my.UnimplementedVisitor("VisitFieldModifier4WithArg(FieldModifier4, interface{})") }

func (my *AbstractVisitor)      VisitFieldModifier5(n *FieldModifier5)  { my.UnimplementedVisitor("VisitFieldModifier5(FieldModifier5)") }

func (my *AbstractVisitor)      VisitFieldModifier5WithArg(n *FieldModifier5, o interface{})  { my.UnimplementedVisitor("VisitFieldModifier5WithArg(FieldModifier5, interface{})") }

func (my *AbstractVisitor)      VisitFieldModifier6(n *FieldModifier6)  { my.UnimplementedVisitor("VisitFieldModifier6(FieldModifier6)") }

func (my *AbstractVisitor)      VisitFieldModifier6WithArg(n *FieldModifier6, o interface{})  { my.UnimplementedVisitor("VisitFieldModifier6WithArg(FieldModifier6, interface{})") }

func (my *AbstractVisitor)      VisitMethodDeclarator0(n *MethodDeclarator0)  { my.UnimplementedVisitor("VisitMethodDeclarator0(MethodDeclarator0)") }

func (my *AbstractVisitor)      VisitMethodDeclarator0WithArg(n *MethodDeclarator0, o interface{})  { my.UnimplementedVisitor("VisitMethodDeclarator0WithArg(MethodDeclarator0, interface{})") }

func (my *AbstractVisitor)      VisitMethodDeclarator1(n *MethodDeclarator1)  { my.UnimplementedVisitor("VisitMethodDeclarator1(MethodDeclarator1)") }

func (my *AbstractVisitor)      VisitMethodDeclarator1WithArg(n *MethodDeclarator1, o interface{})  { my.UnimplementedVisitor("VisitMethodDeclarator1WithArg(MethodDeclarator1, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier0(n *MethodModifier0)  { my.UnimplementedVisitor("VisitMethodModifier0(MethodModifier0)") }

func (my *AbstractVisitor)      VisitMethodModifier0WithArg(n *MethodModifier0, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier0WithArg(MethodModifier0, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier1(n *MethodModifier1)  { my.UnimplementedVisitor("VisitMethodModifier1(MethodModifier1)") }

func (my *AbstractVisitor)      VisitMethodModifier1WithArg(n *MethodModifier1, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier1WithArg(MethodModifier1, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier2(n *MethodModifier2)  { my.UnimplementedVisitor("VisitMethodModifier2(MethodModifier2)") }

func (my *AbstractVisitor)      VisitMethodModifier2WithArg(n *MethodModifier2, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier2WithArg(MethodModifier2, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier3(n *MethodModifier3)  { my.UnimplementedVisitor("VisitMethodModifier3(MethodModifier3)") }

func (my *AbstractVisitor)      VisitMethodModifier3WithArg(n *MethodModifier3, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier3WithArg(MethodModifier3, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier4(n *MethodModifier4)  { my.UnimplementedVisitor("VisitMethodModifier4(MethodModifier4)") }

func (my *AbstractVisitor)      VisitMethodModifier4WithArg(n *MethodModifier4, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier4WithArg(MethodModifier4, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier5(n *MethodModifier5)  { my.UnimplementedVisitor("VisitMethodModifier5(MethodModifier5)") }

func (my *AbstractVisitor)      VisitMethodModifier5WithArg(n *MethodModifier5, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier5WithArg(MethodModifier5, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier6(n *MethodModifier6)  { my.UnimplementedVisitor("VisitMethodModifier6(MethodModifier6)") }

func (my *AbstractVisitor)      VisitMethodModifier6WithArg(n *MethodModifier6, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier6WithArg(MethodModifier6, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier7(n *MethodModifier7)  { my.UnimplementedVisitor("VisitMethodModifier7(MethodModifier7)") }

func (my *AbstractVisitor)      VisitMethodModifier7WithArg(n *MethodModifier7, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier7WithArg(MethodModifier7, interface{})") }

func (my *AbstractVisitor)      VisitMethodModifier8(n *MethodModifier8)  { my.UnimplementedVisitor("VisitMethodModifier8(MethodModifier8)") }

func (my *AbstractVisitor)      VisitMethodModifier8WithArg(n *MethodModifier8, o interface{})  { my.UnimplementedVisitor("VisitMethodModifier8WithArg(MethodModifier8, interface{})") }

func (my *AbstractVisitor)      VisitConstructorModifier0(n *ConstructorModifier0)  { my.UnimplementedVisitor("VisitConstructorModifier0(ConstructorModifier0)") }

func (my *AbstractVisitor)      VisitConstructorModifier0WithArg(n *ConstructorModifier0, o interface{})  { my.UnimplementedVisitor("VisitConstructorModifier0WithArg(ConstructorModifier0, interface{})") }

func (my *AbstractVisitor)      VisitConstructorModifier1(n *ConstructorModifier1)  { my.UnimplementedVisitor("VisitConstructorModifier1(ConstructorModifier1)") }

func (my *AbstractVisitor)      VisitConstructorModifier1WithArg(n *ConstructorModifier1, o interface{})  { my.UnimplementedVisitor("VisitConstructorModifier1WithArg(ConstructorModifier1, interface{})") }

func (my *AbstractVisitor)      VisitConstructorModifier2(n *ConstructorModifier2)  { my.UnimplementedVisitor("VisitConstructorModifier2(ConstructorModifier2)") }

func (my *AbstractVisitor)      VisitConstructorModifier2WithArg(n *ConstructorModifier2, o interface{})  { my.UnimplementedVisitor("VisitConstructorModifier2WithArg(ConstructorModifier2, interface{})") }

func (my *AbstractVisitor)      VisitExplicitConstructorInvocation0(n *ExplicitConstructorInvocation0)  { my.UnimplementedVisitor("VisitExplicitConstructorInvocation0(ExplicitConstructorInvocation0)") }

func (my *AbstractVisitor)      VisitExplicitConstructorInvocation0WithArg(n *ExplicitConstructorInvocation0, o interface{})  { my.UnimplementedVisitor("VisitExplicitConstructorInvocation0WithArg(ExplicitConstructorInvocation0, interface{})") }

func (my *AbstractVisitor)      VisitExplicitConstructorInvocation1(n *ExplicitConstructorInvocation1)  { my.UnimplementedVisitor("VisitExplicitConstructorInvocation1(ExplicitConstructorInvocation1)") }

func (my *AbstractVisitor)      VisitExplicitConstructorInvocation1WithArg(n *ExplicitConstructorInvocation1, o interface{})  { my.UnimplementedVisitor("VisitExplicitConstructorInvocation1WithArg(ExplicitConstructorInvocation1, interface{})") }

func (my *AbstractVisitor)      VisitExplicitConstructorInvocation2(n *ExplicitConstructorInvocation2)  { my.UnimplementedVisitor("VisitExplicitConstructorInvocation2(ExplicitConstructorInvocation2)") }

func (my *AbstractVisitor)      VisitExplicitConstructorInvocation2WithArg(n *ExplicitConstructorInvocation2, o interface{})  { my.UnimplementedVisitor("VisitExplicitConstructorInvocation2WithArg(ExplicitConstructorInvocation2, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceModifier0(n *InterfaceModifier0)  { my.UnimplementedVisitor("VisitInterfaceModifier0(InterfaceModifier0)") }

func (my *AbstractVisitor)      VisitInterfaceModifier0WithArg(n *InterfaceModifier0, o interface{})  { my.UnimplementedVisitor("VisitInterfaceModifier0WithArg(InterfaceModifier0, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceModifier1(n *InterfaceModifier1)  { my.UnimplementedVisitor("VisitInterfaceModifier1(InterfaceModifier1)") }

func (my *AbstractVisitor)      VisitInterfaceModifier1WithArg(n *InterfaceModifier1, o interface{})  { my.UnimplementedVisitor("VisitInterfaceModifier1WithArg(InterfaceModifier1, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceModifier2(n *InterfaceModifier2)  { my.UnimplementedVisitor("VisitInterfaceModifier2(InterfaceModifier2)") }

func (my *AbstractVisitor)      VisitInterfaceModifier2WithArg(n *InterfaceModifier2, o interface{})  { my.UnimplementedVisitor("VisitInterfaceModifier2WithArg(InterfaceModifier2, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceModifier3(n *InterfaceModifier3)  { my.UnimplementedVisitor("VisitInterfaceModifier3(InterfaceModifier3)") }

func (my *AbstractVisitor)      VisitInterfaceModifier3WithArg(n *InterfaceModifier3, o interface{})  { my.UnimplementedVisitor("VisitInterfaceModifier3WithArg(InterfaceModifier3, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceModifier4(n *InterfaceModifier4)  { my.UnimplementedVisitor("VisitInterfaceModifier4(InterfaceModifier4)") }

func (my *AbstractVisitor)      VisitInterfaceModifier4WithArg(n *InterfaceModifier4, o interface{})  { my.UnimplementedVisitor("VisitInterfaceModifier4WithArg(InterfaceModifier4, interface{})") }

func (my *AbstractVisitor)      VisitInterfaceModifier5(n *InterfaceModifier5)  { my.UnimplementedVisitor("VisitInterfaceModifier5(InterfaceModifier5)") }

func (my *AbstractVisitor)      VisitInterfaceModifier5WithArg(n *InterfaceModifier5, o interface{})  { my.UnimplementedVisitor("VisitInterfaceModifier5WithArg(InterfaceModifier5, interface{})") }

func (my *AbstractVisitor)      VisitExtendsInterfaces0(n *ExtendsInterfaces0)  { my.UnimplementedVisitor("VisitExtendsInterfaces0(ExtendsInterfaces0)") }

func (my *AbstractVisitor)      VisitExtendsInterfaces0WithArg(n *ExtendsInterfaces0, o interface{})  { my.UnimplementedVisitor("VisitExtendsInterfaces0WithArg(ExtendsInterfaces0, interface{})") }

func (my *AbstractVisitor)      VisitExtendsInterfaces1(n *ExtendsInterfaces1)  { my.UnimplementedVisitor("VisitExtendsInterfaces1(ExtendsInterfaces1)") }

func (my *AbstractVisitor)      VisitExtendsInterfaces1WithArg(n *ExtendsInterfaces1, o interface{})  { my.UnimplementedVisitor("VisitExtendsInterfaces1WithArg(ExtendsInterfaces1, interface{})") }

func (my *AbstractVisitor)      VisitConstantModifier0(n *ConstantModifier0)  { my.UnimplementedVisitor("VisitConstantModifier0(ConstantModifier0)") }

func (my *AbstractVisitor)      VisitConstantModifier0WithArg(n *ConstantModifier0, o interface{})  { my.UnimplementedVisitor("VisitConstantModifier0WithArg(ConstantModifier0, interface{})") }

func (my *AbstractVisitor)      VisitConstantModifier1(n *ConstantModifier1)  { my.UnimplementedVisitor("VisitConstantModifier1(ConstantModifier1)") }

func (my *AbstractVisitor)      VisitConstantModifier1WithArg(n *ConstantModifier1, o interface{})  { my.UnimplementedVisitor("VisitConstantModifier1WithArg(ConstantModifier1, interface{})") }

func (my *AbstractVisitor)      VisitConstantModifier2(n *ConstantModifier2)  { my.UnimplementedVisitor("VisitConstantModifier2(ConstantModifier2)") }

func (my *AbstractVisitor)      VisitConstantModifier2WithArg(n *ConstantModifier2, o interface{})  { my.UnimplementedVisitor("VisitConstantModifier2WithArg(ConstantModifier2, interface{})") }

func (my *AbstractVisitor)      VisitAbstractMethodModifier0(n *AbstractMethodModifier0)  { my.UnimplementedVisitor("VisitAbstractMethodModifier0(AbstractMethodModifier0)") }

func (my *AbstractVisitor)      VisitAbstractMethodModifier0WithArg(n *AbstractMethodModifier0, o interface{})  { my.UnimplementedVisitor("VisitAbstractMethodModifier0WithArg(AbstractMethodModifier0, interface{})") }

func (my *AbstractVisitor)      VisitAbstractMethodModifier1(n *AbstractMethodModifier1)  { my.UnimplementedVisitor("VisitAbstractMethodModifier1(AbstractMethodModifier1)") }

func (my *AbstractVisitor)      VisitAbstractMethodModifier1WithArg(n *AbstractMethodModifier1, o interface{})  { my.UnimplementedVisitor("VisitAbstractMethodModifier1WithArg(AbstractMethodModifier1, interface{})") }

func (my *AbstractVisitor)      VisitAnnotationTypeElementDeclaration0(n *AnnotationTypeElementDeclaration0)  { my.UnimplementedVisitor("VisitAnnotationTypeElementDeclaration0(AnnotationTypeElementDeclaration0)") }

func (my *AbstractVisitor)      VisitAnnotationTypeElementDeclaration0WithArg(n *AnnotationTypeElementDeclaration0, o interface{})  { my.UnimplementedVisitor("VisitAnnotationTypeElementDeclaration0WithArg(AnnotationTypeElementDeclaration0, interface{})") }

func (my *AbstractVisitor)      VisitAnnotationTypeElementDeclaration1(n *AnnotationTypeElementDeclaration1)  { my.UnimplementedVisitor("VisitAnnotationTypeElementDeclaration1(AnnotationTypeElementDeclaration1)") }

func (my *AbstractVisitor)      VisitAnnotationTypeElementDeclaration1WithArg(n *AnnotationTypeElementDeclaration1, o interface{})  { my.UnimplementedVisitor("VisitAnnotationTypeElementDeclaration1WithArg(AnnotationTypeElementDeclaration1, interface{})") }

func (my *AbstractVisitor)      VisitAssertStatement0(n *AssertStatement0)  { my.UnimplementedVisitor("VisitAssertStatement0(AssertStatement0)") }

func (my *AbstractVisitor)      VisitAssertStatement0WithArg(n *AssertStatement0, o interface{})  { my.UnimplementedVisitor("VisitAssertStatement0WithArg(AssertStatement0, interface{})") }

func (my *AbstractVisitor)      VisitAssertStatement1(n *AssertStatement1)  { my.UnimplementedVisitor("VisitAssertStatement1(AssertStatement1)") }

func (my *AbstractVisitor)      VisitAssertStatement1WithArg(n *AssertStatement1, o interface{})  { my.UnimplementedVisitor("VisitAssertStatement1WithArg(AssertStatement1, interface{})") }

func (my *AbstractVisitor)      VisitSwitchLabel0(n *SwitchLabel0)  { my.UnimplementedVisitor("VisitSwitchLabel0(SwitchLabel0)") }

func (my *AbstractVisitor)      VisitSwitchLabel0WithArg(n *SwitchLabel0, o interface{})  { my.UnimplementedVisitor("VisitSwitchLabel0WithArg(SwitchLabel0, interface{})") }

func (my *AbstractVisitor)      VisitSwitchLabel1(n *SwitchLabel1)  { my.UnimplementedVisitor("VisitSwitchLabel1(SwitchLabel1)") }

func (my *AbstractVisitor)      VisitSwitchLabel1WithArg(n *SwitchLabel1, o interface{})  { my.UnimplementedVisitor("VisitSwitchLabel1WithArg(SwitchLabel1, interface{})") }

func (my *AbstractVisitor)      VisitSwitchLabel2(n *SwitchLabel2)  { my.UnimplementedVisitor("VisitSwitchLabel2(SwitchLabel2)") }

func (my *AbstractVisitor)      VisitSwitchLabel2WithArg(n *SwitchLabel2, o interface{})  { my.UnimplementedVisitor("VisitSwitchLabel2WithArg(SwitchLabel2, interface{})") }

func (my *AbstractVisitor)      VisitTryStatement0(n *TryStatement0)  { my.UnimplementedVisitor("VisitTryStatement0(TryStatement0)") }

func (my *AbstractVisitor)      VisitTryStatement0WithArg(n *TryStatement0, o interface{})  { my.UnimplementedVisitor("VisitTryStatement0WithArg(TryStatement0, interface{})") }

func (my *AbstractVisitor)      VisitTryStatement1(n *TryStatement1)  { my.UnimplementedVisitor("VisitTryStatement1(TryStatement1)") }

func (my *AbstractVisitor)      VisitTryStatement1WithArg(n *TryStatement1, o interface{})  { my.UnimplementedVisitor("VisitTryStatement1WithArg(TryStatement1, interface{})") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray0(n *PrimaryNoNewArray0)  { my.UnimplementedVisitor("VisitPrimaryNoNewArray0(PrimaryNoNewArray0)") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray0WithArg(n *PrimaryNoNewArray0, o interface{})  { my.UnimplementedVisitor("VisitPrimaryNoNewArray0WithArg(PrimaryNoNewArray0, interface{})") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray1(n *PrimaryNoNewArray1)  { my.UnimplementedVisitor("VisitPrimaryNoNewArray1(PrimaryNoNewArray1)") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray1WithArg(n *PrimaryNoNewArray1, o interface{})  { my.UnimplementedVisitor("VisitPrimaryNoNewArray1WithArg(PrimaryNoNewArray1, interface{})") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray2(n *PrimaryNoNewArray2)  { my.UnimplementedVisitor("VisitPrimaryNoNewArray2(PrimaryNoNewArray2)") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray2WithArg(n *PrimaryNoNewArray2, o interface{})  { my.UnimplementedVisitor("VisitPrimaryNoNewArray2WithArg(PrimaryNoNewArray2, interface{})") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray3(n *PrimaryNoNewArray3)  { my.UnimplementedVisitor("VisitPrimaryNoNewArray3(PrimaryNoNewArray3)") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray3WithArg(n *PrimaryNoNewArray3, o interface{})  { my.UnimplementedVisitor("VisitPrimaryNoNewArray3WithArg(PrimaryNoNewArray3, interface{})") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray4(n *PrimaryNoNewArray4)  { my.UnimplementedVisitor("VisitPrimaryNoNewArray4(PrimaryNoNewArray4)") }

func (my *AbstractVisitor)      VisitPrimaryNoNewArray4WithArg(n *PrimaryNoNewArray4, o interface{})  { my.UnimplementedVisitor("VisitPrimaryNoNewArray4WithArg(PrimaryNoNewArray4, interface{})") }

func (my *AbstractVisitor)      VisitLiteral0(n *Literal0)  { my.UnimplementedVisitor("VisitLiteral0(Literal0)") }

func (my *AbstractVisitor)      VisitLiteral0WithArg(n *Literal0, o interface{})  { my.UnimplementedVisitor("VisitLiteral0WithArg(Literal0, interface{})") }

func (my *AbstractVisitor)      VisitLiteral1(n *Literal1)  { my.UnimplementedVisitor("VisitLiteral1(Literal1)") }

func (my *AbstractVisitor)      VisitLiteral1WithArg(n *Literal1, o interface{})  { my.UnimplementedVisitor("VisitLiteral1WithArg(Literal1, interface{})") }

func (my *AbstractVisitor)      VisitLiteral2(n *Literal2)  { my.UnimplementedVisitor("VisitLiteral2(Literal2)") }

func (my *AbstractVisitor)      VisitLiteral2WithArg(n *Literal2, o interface{})  { my.UnimplementedVisitor("VisitLiteral2WithArg(Literal2, interface{})") }

func (my *AbstractVisitor)      VisitLiteral3(n *Literal3)  { my.UnimplementedVisitor("VisitLiteral3(Literal3)") }

func (my *AbstractVisitor)      VisitLiteral3WithArg(n *Literal3, o interface{})  { my.UnimplementedVisitor("VisitLiteral3WithArg(Literal3, interface{})") }

func (my *AbstractVisitor)      VisitLiteral4(n *Literal4)  { my.UnimplementedVisitor("VisitLiteral4(Literal4)") }

func (my *AbstractVisitor)      VisitLiteral4WithArg(n *Literal4, o interface{})  { my.UnimplementedVisitor("VisitLiteral4WithArg(Literal4, interface{})") }

func (my *AbstractVisitor)      VisitLiteral5(n *Literal5)  { my.UnimplementedVisitor("VisitLiteral5(Literal5)") }

func (my *AbstractVisitor)      VisitLiteral5WithArg(n *Literal5, o interface{})  { my.UnimplementedVisitor("VisitLiteral5WithArg(Literal5, interface{})") }

func (my *AbstractVisitor)      VisitLiteral6(n *Literal6)  { my.UnimplementedVisitor("VisitLiteral6(Literal6)") }

func (my *AbstractVisitor)      VisitLiteral6WithArg(n *Literal6, o interface{})  { my.UnimplementedVisitor("VisitLiteral6WithArg(Literal6, interface{})") }

func (my *AbstractVisitor)      VisitBooleanLiteral0(n *BooleanLiteral0)  { my.UnimplementedVisitor("VisitBooleanLiteral0(BooleanLiteral0)") }

func (my *AbstractVisitor)      VisitBooleanLiteral0WithArg(n *BooleanLiteral0, o interface{})  { my.UnimplementedVisitor("VisitBooleanLiteral0WithArg(BooleanLiteral0, interface{})") }

func (my *AbstractVisitor)      VisitBooleanLiteral1(n *BooleanLiteral1)  { my.UnimplementedVisitor("VisitBooleanLiteral1(BooleanLiteral1)") }

func (my *AbstractVisitor)      VisitBooleanLiteral1WithArg(n *BooleanLiteral1, o interface{})  { my.UnimplementedVisitor("VisitBooleanLiteral1WithArg(BooleanLiteral1, interface{})") }

func (my *AbstractVisitor)      VisitClassInstanceCreationExpression0(n *ClassInstanceCreationExpression0)  { my.UnimplementedVisitor("VisitClassInstanceCreationExpression0(ClassInstanceCreationExpression0)") }

func (my *AbstractVisitor)      VisitClassInstanceCreationExpression0WithArg(n *ClassInstanceCreationExpression0, o interface{})  { my.UnimplementedVisitor("VisitClassInstanceCreationExpression0WithArg(ClassInstanceCreationExpression0, interface{})") }

func (my *AbstractVisitor)      VisitClassInstanceCreationExpression1(n *ClassInstanceCreationExpression1)  { my.UnimplementedVisitor("VisitClassInstanceCreationExpression1(ClassInstanceCreationExpression1)") }

func (my *AbstractVisitor)      VisitClassInstanceCreationExpression1WithArg(n *ClassInstanceCreationExpression1, o interface{})  { my.UnimplementedVisitor("VisitClassInstanceCreationExpression1WithArg(ClassInstanceCreationExpression1, interface{})") }

func (my *AbstractVisitor)      VisitArrayCreationExpression0(n *ArrayCreationExpression0)  { my.UnimplementedVisitor("VisitArrayCreationExpression0(ArrayCreationExpression0)") }

func (my *AbstractVisitor)      VisitArrayCreationExpression0WithArg(n *ArrayCreationExpression0, o interface{})  { my.UnimplementedVisitor("VisitArrayCreationExpression0WithArg(ArrayCreationExpression0, interface{})") }

func (my *AbstractVisitor)      VisitArrayCreationExpression1(n *ArrayCreationExpression1)  { my.UnimplementedVisitor("VisitArrayCreationExpression1(ArrayCreationExpression1)") }

func (my *AbstractVisitor)      VisitArrayCreationExpression1WithArg(n *ArrayCreationExpression1, o interface{})  { my.UnimplementedVisitor("VisitArrayCreationExpression1WithArg(ArrayCreationExpression1, interface{})") }

func (my *AbstractVisitor)      VisitArrayCreationExpression2(n *ArrayCreationExpression2)  { my.UnimplementedVisitor("VisitArrayCreationExpression2(ArrayCreationExpression2)") }

func (my *AbstractVisitor)      VisitArrayCreationExpression2WithArg(n *ArrayCreationExpression2, o interface{})  { my.UnimplementedVisitor("VisitArrayCreationExpression2WithArg(ArrayCreationExpression2, interface{})") }

func (my *AbstractVisitor)      VisitArrayCreationExpression3(n *ArrayCreationExpression3)  { my.UnimplementedVisitor("VisitArrayCreationExpression3(ArrayCreationExpression3)") }

func (my *AbstractVisitor)      VisitArrayCreationExpression3WithArg(n *ArrayCreationExpression3, o interface{})  { my.UnimplementedVisitor("VisitArrayCreationExpression3WithArg(ArrayCreationExpression3, interface{})") }

func (my *AbstractVisitor)      VisitDims0(n *Dims0)  { my.UnimplementedVisitor("VisitDims0(Dims0)") }

func (my *AbstractVisitor)      VisitDims0WithArg(n *Dims0, o interface{})  { my.UnimplementedVisitor("VisitDims0WithArg(Dims0, interface{})") }

func (my *AbstractVisitor)      VisitDims1(n *Dims1)  { my.UnimplementedVisitor("VisitDims1(Dims1)") }

func (my *AbstractVisitor)      VisitDims1WithArg(n *Dims1, o interface{})  { my.UnimplementedVisitor("VisitDims1WithArg(Dims1, interface{})") }

func (my *AbstractVisitor)      VisitFieldAccess0(n *FieldAccess0)  { my.UnimplementedVisitor("VisitFieldAccess0(FieldAccess0)") }

func (my *AbstractVisitor)      VisitFieldAccess0WithArg(n *FieldAccess0, o interface{})  { my.UnimplementedVisitor("VisitFieldAccess0WithArg(FieldAccess0, interface{})") }

func (my *AbstractVisitor)      VisitFieldAccess1(n *FieldAccess1)  { my.UnimplementedVisitor("VisitFieldAccess1(FieldAccess1)") }

func (my *AbstractVisitor)      VisitFieldAccess1WithArg(n *FieldAccess1, o interface{})  { my.UnimplementedVisitor("VisitFieldAccess1WithArg(FieldAccess1, interface{})") }

func (my *AbstractVisitor)      VisitFieldAccess2(n *FieldAccess2)  { my.UnimplementedVisitor("VisitFieldAccess2(FieldAccess2)") }

func (my *AbstractVisitor)      VisitFieldAccess2WithArg(n *FieldAccess2, o interface{})  { my.UnimplementedVisitor("VisitFieldAccess2WithArg(FieldAccess2, interface{})") }

func (my *AbstractVisitor)      VisitMethodInvocation0(n *MethodInvocation0)  { my.UnimplementedVisitor("VisitMethodInvocation0(MethodInvocation0)") }

func (my *AbstractVisitor)      VisitMethodInvocation0WithArg(n *MethodInvocation0, o interface{})  { my.UnimplementedVisitor("VisitMethodInvocation0WithArg(MethodInvocation0, interface{})") }

func (my *AbstractVisitor)      VisitMethodInvocation1(n *MethodInvocation1)  { my.UnimplementedVisitor("VisitMethodInvocation1(MethodInvocation1)") }

func (my *AbstractVisitor)      VisitMethodInvocation1WithArg(n *MethodInvocation1, o interface{})  { my.UnimplementedVisitor("VisitMethodInvocation1WithArg(MethodInvocation1, interface{})") }

func (my *AbstractVisitor)      VisitMethodInvocation2(n *MethodInvocation2)  { my.UnimplementedVisitor("VisitMethodInvocation2(MethodInvocation2)") }

func (my *AbstractVisitor)      VisitMethodInvocation2WithArg(n *MethodInvocation2, o interface{})  { my.UnimplementedVisitor("VisitMethodInvocation2WithArg(MethodInvocation2, interface{})") }

func (my *AbstractVisitor)      VisitMethodInvocation3(n *MethodInvocation3)  { my.UnimplementedVisitor("VisitMethodInvocation3(MethodInvocation3)") }

func (my *AbstractVisitor)      VisitMethodInvocation3WithArg(n *MethodInvocation3, o interface{})  { my.UnimplementedVisitor("VisitMethodInvocation3WithArg(MethodInvocation3, interface{})") }

func (my *AbstractVisitor)      VisitMethodInvocation4(n *MethodInvocation4)  { my.UnimplementedVisitor("VisitMethodInvocation4(MethodInvocation4)") }

func (my *AbstractVisitor)      VisitMethodInvocation4WithArg(n *MethodInvocation4, o interface{})  { my.UnimplementedVisitor("VisitMethodInvocation4WithArg(MethodInvocation4, interface{})") }

func (my *AbstractVisitor)      VisitArrayAccess0(n *ArrayAccess0)  { my.UnimplementedVisitor("VisitArrayAccess0(ArrayAccess0)") }

func (my *AbstractVisitor)      VisitArrayAccess0WithArg(n *ArrayAccess0, o interface{})  { my.UnimplementedVisitor("VisitArrayAccess0WithArg(ArrayAccess0, interface{})") }

func (my *AbstractVisitor)      VisitArrayAccess1(n *ArrayAccess1)  { my.UnimplementedVisitor("VisitArrayAccess1(ArrayAccess1)") }

func (my *AbstractVisitor)      VisitArrayAccess1WithArg(n *ArrayAccess1, o interface{})  { my.UnimplementedVisitor("VisitArrayAccess1WithArg(ArrayAccess1, interface{})") }

func (my *AbstractVisitor)      VisitUnaryExpression0(n *UnaryExpression0)  { my.UnimplementedVisitor("VisitUnaryExpression0(UnaryExpression0)") }

func (my *AbstractVisitor)      VisitUnaryExpression0WithArg(n *UnaryExpression0, o interface{})  { my.UnimplementedVisitor("VisitUnaryExpression0WithArg(UnaryExpression0, interface{})") }

func (my *AbstractVisitor)      VisitUnaryExpression1(n *UnaryExpression1)  { my.UnimplementedVisitor("VisitUnaryExpression1(UnaryExpression1)") }

func (my *AbstractVisitor)      VisitUnaryExpression1WithArg(n *UnaryExpression1, o interface{})  { my.UnimplementedVisitor("VisitUnaryExpression1WithArg(UnaryExpression1, interface{})") }

func (my *AbstractVisitor)      VisitUnaryExpressionNotPlusMinus0(n *UnaryExpressionNotPlusMinus0)  { my.UnimplementedVisitor("VisitUnaryExpressionNotPlusMinus0(UnaryExpressionNotPlusMinus0)") }

func (my *AbstractVisitor)      VisitUnaryExpressionNotPlusMinus0WithArg(n *UnaryExpressionNotPlusMinus0, o interface{})  { my.UnimplementedVisitor("VisitUnaryExpressionNotPlusMinus0WithArg(UnaryExpressionNotPlusMinus0, interface{})") }

func (my *AbstractVisitor)      VisitUnaryExpressionNotPlusMinus1(n *UnaryExpressionNotPlusMinus1)  { my.UnimplementedVisitor("VisitUnaryExpressionNotPlusMinus1(UnaryExpressionNotPlusMinus1)") }

func (my *AbstractVisitor)      VisitUnaryExpressionNotPlusMinus1WithArg(n *UnaryExpressionNotPlusMinus1, o interface{})  { my.UnimplementedVisitor("VisitUnaryExpressionNotPlusMinus1WithArg(UnaryExpressionNotPlusMinus1, interface{})") }

func (my *AbstractVisitor)      VisitCastExpression0(n *CastExpression0)  { my.UnimplementedVisitor("VisitCastExpression0(CastExpression0)") }

func (my *AbstractVisitor)      VisitCastExpression0WithArg(n *CastExpression0, o interface{})  { my.UnimplementedVisitor("VisitCastExpression0WithArg(CastExpression0, interface{})") }

func (my *AbstractVisitor)      VisitCastExpression1(n *CastExpression1)  { my.UnimplementedVisitor("VisitCastExpression1(CastExpression1)") }

func (my *AbstractVisitor)      VisitCastExpression1WithArg(n *CastExpression1, o interface{})  { my.UnimplementedVisitor("VisitCastExpression1WithArg(CastExpression1, interface{})") }

func (my *AbstractVisitor)      VisitMultiplicativeExpression0(n *MultiplicativeExpression0)  { my.UnimplementedVisitor("VisitMultiplicativeExpression0(MultiplicativeExpression0)") }

func (my *AbstractVisitor)      VisitMultiplicativeExpression0WithArg(n *MultiplicativeExpression0, o interface{})  { my.UnimplementedVisitor("VisitMultiplicativeExpression0WithArg(MultiplicativeExpression0, interface{})") }

func (my *AbstractVisitor)      VisitMultiplicativeExpression1(n *MultiplicativeExpression1)  { my.UnimplementedVisitor("VisitMultiplicativeExpression1(MultiplicativeExpression1)") }

func (my *AbstractVisitor)      VisitMultiplicativeExpression1WithArg(n *MultiplicativeExpression1, o interface{})  { my.UnimplementedVisitor("VisitMultiplicativeExpression1WithArg(MultiplicativeExpression1, interface{})") }

func (my *AbstractVisitor)      VisitMultiplicativeExpression2(n *MultiplicativeExpression2)  { my.UnimplementedVisitor("VisitMultiplicativeExpression2(MultiplicativeExpression2)") }

func (my *AbstractVisitor)      VisitMultiplicativeExpression2WithArg(n *MultiplicativeExpression2, o interface{})  { my.UnimplementedVisitor("VisitMultiplicativeExpression2WithArg(MultiplicativeExpression2, interface{})") }

func (my *AbstractVisitor)      VisitAdditiveExpression0(n *AdditiveExpression0)  { my.UnimplementedVisitor("VisitAdditiveExpression0(AdditiveExpression0)") }

func (my *AbstractVisitor)      VisitAdditiveExpression0WithArg(n *AdditiveExpression0, o interface{})  { my.UnimplementedVisitor("VisitAdditiveExpression0WithArg(AdditiveExpression0, interface{})") }

func (my *AbstractVisitor)      VisitAdditiveExpression1(n *AdditiveExpression1)  { my.UnimplementedVisitor("VisitAdditiveExpression1(AdditiveExpression1)") }

func (my *AbstractVisitor)      VisitAdditiveExpression1WithArg(n *AdditiveExpression1, o interface{})  { my.UnimplementedVisitor("VisitAdditiveExpression1WithArg(AdditiveExpression1, interface{})") }

func (my *AbstractVisitor)      VisitShiftExpression0(n *ShiftExpression0)  { my.UnimplementedVisitor("VisitShiftExpression0(ShiftExpression0)") }

func (my *AbstractVisitor)      VisitShiftExpression0WithArg(n *ShiftExpression0, o interface{})  { my.UnimplementedVisitor("VisitShiftExpression0WithArg(ShiftExpression0, interface{})") }

func (my *AbstractVisitor)      VisitShiftExpression1(n *ShiftExpression1)  { my.UnimplementedVisitor("VisitShiftExpression1(ShiftExpression1)") }

func (my *AbstractVisitor)      VisitShiftExpression1WithArg(n *ShiftExpression1, o interface{})  { my.UnimplementedVisitor("VisitShiftExpression1WithArg(ShiftExpression1, interface{})") }

func (my *AbstractVisitor)      VisitShiftExpression2(n *ShiftExpression2)  { my.UnimplementedVisitor("VisitShiftExpression2(ShiftExpression2)") }

func (my *AbstractVisitor)      VisitShiftExpression2WithArg(n *ShiftExpression2, o interface{})  { my.UnimplementedVisitor("VisitShiftExpression2WithArg(ShiftExpression2, interface{})") }

func (my *AbstractVisitor)      VisitRelationalExpression0(n *RelationalExpression0)  { my.UnimplementedVisitor("VisitRelationalExpression0(RelationalExpression0)") }

func (my *AbstractVisitor)      VisitRelationalExpression0WithArg(n *RelationalExpression0, o interface{})  { my.UnimplementedVisitor("VisitRelationalExpression0WithArg(RelationalExpression0, interface{})") }

func (my *AbstractVisitor)      VisitRelationalExpression1(n *RelationalExpression1)  { my.UnimplementedVisitor("VisitRelationalExpression1(RelationalExpression1)") }

func (my *AbstractVisitor)      VisitRelationalExpression1WithArg(n *RelationalExpression1, o interface{})  { my.UnimplementedVisitor("VisitRelationalExpression1WithArg(RelationalExpression1, interface{})") }

func (my *AbstractVisitor)      VisitRelationalExpression2(n *RelationalExpression2)  { my.UnimplementedVisitor("VisitRelationalExpression2(RelationalExpression2)") }

func (my *AbstractVisitor)      VisitRelationalExpression2WithArg(n *RelationalExpression2, o interface{})  { my.UnimplementedVisitor("VisitRelationalExpression2WithArg(RelationalExpression2, interface{})") }

func (my *AbstractVisitor)      VisitRelationalExpression3(n *RelationalExpression3)  { my.UnimplementedVisitor("VisitRelationalExpression3(RelationalExpression3)") }

func (my *AbstractVisitor)      VisitRelationalExpression3WithArg(n *RelationalExpression3, o interface{})  { my.UnimplementedVisitor("VisitRelationalExpression3WithArg(RelationalExpression3, interface{})") }

func (my *AbstractVisitor)      VisitRelationalExpression4(n *RelationalExpression4)  { my.UnimplementedVisitor("VisitRelationalExpression4(RelationalExpression4)") }

func (my *AbstractVisitor)      VisitRelationalExpression4WithArg(n *RelationalExpression4, o interface{})  { my.UnimplementedVisitor("VisitRelationalExpression4WithArg(RelationalExpression4, interface{})") }

func (my *AbstractVisitor)      VisitEqualityExpression0(n *EqualityExpression0)  { my.UnimplementedVisitor("VisitEqualityExpression0(EqualityExpression0)") }

func (my *AbstractVisitor)      VisitEqualityExpression0WithArg(n *EqualityExpression0, o interface{})  { my.UnimplementedVisitor("VisitEqualityExpression0WithArg(EqualityExpression0, interface{})") }

func (my *AbstractVisitor)      VisitEqualityExpression1(n *EqualityExpression1)  { my.UnimplementedVisitor("VisitEqualityExpression1(EqualityExpression1)") }

func (my *AbstractVisitor)      VisitEqualityExpression1WithArg(n *EqualityExpression1, o interface{})  { my.UnimplementedVisitor("VisitEqualityExpression1WithArg(EqualityExpression1, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator0(n *AssignmentOperator0)  { my.UnimplementedVisitor("VisitAssignmentOperator0(AssignmentOperator0)") }

func (my *AbstractVisitor)      VisitAssignmentOperator0WithArg(n *AssignmentOperator0, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator0WithArg(AssignmentOperator0, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator1(n *AssignmentOperator1)  { my.UnimplementedVisitor("VisitAssignmentOperator1(AssignmentOperator1)") }

func (my *AbstractVisitor)      VisitAssignmentOperator1WithArg(n *AssignmentOperator1, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator1WithArg(AssignmentOperator1, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator2(n *AssignmentOperator2)  { my.UnimplementedVisitor("VisitAssignmentOperator2(AssignmentOperator2)") }

func (my *AbstractVisitor)      VisitAssignmentOperator2WithArg(n *AssignmentOperator2, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator2WithArg(AssignmentOperator2, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator3(n *AssignmentOperator3)  { my.UnimplementedVisitor("VisitAssignmentOperator3(AssignmentOperator3)") }

func (my *AbstractVisitor)      VisitAssignmentOperator3WithArg(n *AssignmentOperator3, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator3WithArg(AssignmentOperator3, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator4(n *AssignmentOperator4)  { my.UnimplementedVisitor("VisitAssignmentOperator4(AssignmentOperator4)") }

func (my *AbstractVisitor)      VisitAssignmentOperator4WithArg(n *AssignmentOperator4, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator4WithArg(AssignmentOperator4, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator5(n *AssignmentOperator5)  { my.UnimplementedVisitor("VisitAssignmentOperator5(AssignmentOperator5)") }

func (my *AbstractVisitor)      VisitAssignmentOperator5WithArg(n *AssignmentOperator5, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator5WithArg(AssignmentOperator5, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator6(n *AssignmentOperator6)  { my.UnimplementedVisitor("VisitAssignmentOperator6(AssignmentOperator6)") }

func (my *AbstractVisitor)      VisitAssignmentOperator6WithArg(n *AssignmentOperator6, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator6WithArg(AssignmentOperator6, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator7(n *AssignmentOperator7)  { my.UnimplementedVisitor("VisitAssignmentOperator7(AssignmentOperator7)") }

func (my *AbstractVisitor)      VisitAssignmentOperator7WithArg(n *AssignmentOperator7, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator7WithArg(AssignmentOperator7, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator8(n *AssignmentOperator8)  { my.UnimplementedVisitor("VisitAssignmentOperator8(AssignmentOperator8)") }

func (my *AbstractVisitor)      VisitAssignmentOperator8WithArg(n *AssignmentOperator8, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator8WithArg(AssignmentOperator8, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator9(n *AssignmentOperator9)  { my.UnimplementedVisitor("VisitAssignmentOperator9(AssignmentOperator9)") }

func (my *AbstractVisitor)      VisitAssignmentOperator9WithArg(n *AssignmentOperator9, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator9WithArg(AssignmentOperator9, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator10(n *AssignmentOperator10)  { my.UnimplementedVisitor("VisitAssignmentOperator10(AssignmentOperator10)") }

func (my *AbstractVisitor)      VisitAssignmentOperator10WithArg(n *AssignmentOperator10, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator10WithArg(AssignmentOperator10, interface{})") }

func (my *AbstractVisitor)      VisitAssignmentOperator11(n *AssignmentOperator11)  { my.UnimplementedVisitor("VisitAssignmentOperator11(AssignmentOperator11)") }

func (my *AbstractVisitor)      VisitAssignmentOperator11WithArg(n *AssignmentOperator11, o interface{})  { my.UnimplementedVisitor("VisitAssignmentOperator11WithArg(AssignmentOperator11, interface{})") }


func (my *AbstractVisitor)     Visit(n IAst){
        {
         var n2,ok =n.(*AstToken)
         if ok {
            my.dispatch.VisitAstToken(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*identifier)
         if ok {
            my.dispatch.Visitidentifier(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimitiveType)
         if ok {
            my.dispatch.VisitPrimitiveType(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassType)
         if ok {
            my.dispatch.VisitClassType(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceType)
         if ok {
            my.dispatch.VisitInterfaceType(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeName)
         if ok {
            my.dispatch.VisitTypeName(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayType)
         if ok {
            my.dispatch.VisitArrayType(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeParameter)
         if ok {
            my.dispatch.VisitTypeParameter(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeBound)
         if ok {
            my.dispatch.VisitTypeBound(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AdditionalBoundList)
         if ok {
            my.dispatch.VisitAdditionalBoundList(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AdditionalBound)
         if ok {
            my.dispatch.VisitAdditionalBound(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeArguments)
         if ok {
            my.dispatch.VisitTypeArguments(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ActualTypeArgumentList)
         if ok {
            my.dispatch.VisitActualTypeArgumentList(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Wildcard)
         if ok {
            my.dispatch.VisitWildcard(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PackageName)
         if ok {
            my.dispatch.VisitPackageName(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExpressionName)
         if ok {
            my.dispatch.VisitExpressionName(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodName)
         if ok {
            my.dispatch.VisitMethodName(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PackageOrTypeName)
         if ok {
            my.dispatch.VisitPackageOrTypeName(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AmbiguousName)
         if ok {
            my.dispatch.VisitAmbiguousName(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*CompilationUnit)
         if ok {
            my.dispatch.VisitCompilationUnit(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ImportDeclarations)
         if ok {
            my.dispatch.VisitImportDeclarations(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeDeclarations)
         if ok {
            my.dispatch.VisitTypeDeclarations(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PackageDeclaration)
         if ok {
            my.dispatch.VisitPackageDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SingleTypeImportDeclaration)
         if ok {
            my.dispatch.VisitSingleTypeImportDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeImportOnDemandDeclaration)
         if ok {
            my.dispatch.VisitTypeImportOnDemandDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SingleStaticImportDeclaration)
         if ok {
            my.dispatch.VisitSingleStaticImportDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*StaticImportOnDemandDeclaration)
         if ok {
            my.dispatch.VisitStaticImportOnDemandDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeDeclaration)
         if ok {
            my.dispatch.VisitTypeDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*NormalClassDeclaration)
         if ok {
            my.dispatch.VisitNormalClassDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifiers)
         if ok {
            my.dispatch.VisitClassModifiers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeParameters)
         if ok {
            my.dispatch.VisitTypeParameters(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeParameterList)
         if ok {
            my.dispatch.VisitTypeParameterList(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Super)
         if ok {
            my.dispatch.VisitSuper(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Interfaces)
         if ok {
            my.dispatch.VisitInterfaces(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceTypeList)
         if ok {
            my.dispatch.VisitInterfaceTypeList(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassBody)
         if ok {
            my.dispatch.VisitClassBody(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassBodyDeclarations)
         if ok {
            my.dispatch.VisitClassBodyDeclarations(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassMemberDeclaration)
         if ok {
            my.dispatch.VisitClassMemberDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldDeclaration)
         if ok {
            my.dispatch.VisitFieldDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableDeclarators)
         if ok {
            my.dispatch.VisitVariableDeclarators(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableDeclarator)
         if ok {
            my.dispatch.VisitVariableDeclarator(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableDeclaratorId)
         if ok {
            my.dispatch.VisitVariableDeclaratorId(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifiers)
         if ok {
            my.dispatch.VisitFieldModifiers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodDeclaration)
         if ok {
            my.dispatch.VisitMethodDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodHeader)
         if ok {
            my.dispatch.VisitMethodHeader(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ResultType)
         if ok {
            my.dispatch.VisitResultType(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FormalParameterList)
         if ok {
            my.dispatch.VisitFormalParameterList(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FormalParameters)
         if ok {
            my.dispatch.VisitFormalParameters(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FormalParameter)
         if ok {
            my.dispatch.VisitFormalParameter(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableModifiers)
         if ok {
            my.dispatch.VisitVariableModifiers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableModifier)
         if ok {
            my.dispatch.VisitVariableModifier(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LastFormalParameter)
         if ok {
            my.dispatch.VisitLastFormalParameter(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifiers)
         if ok {
            my.dispatch.VisitMethodModifiers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Throws)
         if ok {
            my.dispatch.VisitThrows(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExceptionTypeList)
         if ok {
            my.dispatch.VisitExceptionTypeList(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodBody)
         if ok {
            my.dispatch.VisitMethodBody(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*StaticInitializer)
         if ok {
            my.dispatch.VisitStaticInitializer(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorDeclaration)
         if ok {
            my.dispatch.VisitConstructorDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorDeclarator)
         if ok {
            my.dispatch.VisitConstructorDeclarator(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorModifiers)
         if ok {
            my.dispatch.VisitConstructorModifiers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorBody)
         if ok {
            my.dispatch.VisitConstructorBody(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumDeclaration)
         if ok {
            my.dispatch.VisitEnumDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumBody)
         if ok {
            my.dispatch.VisitEnumBody(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumConstants)
         if ok {
            my.dispatch.VisitEnumConstants(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumConstant)
         if ok {
            my.dispatch.VisitEnumConstant(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Arguments)
         if ok {
            my.dispatch.VisitArguments(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumBodyDeclarations)
         if ok {
            my.dispatch.VisitEnumBodyDeclarations(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*NormalInterfaceDeclaration)
         if ok {
            my.dispatch.VisitNormalInterfaceDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifiers)
         if ok {
            my.dispatch.VisitInterfaceModifiers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceBody)
         if ok {
            my.dispatch.VisitInterfaceBody(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceMemberDeclarations)
         if ok {
            my.dispatch.VisitInterfaceMemberDeclarations(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceMemberDeclaration)
         if ok {
            my.dispatch.VisitInterfaceMemberDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantDeclaration)
         if ok {
            my.dispatch.VisitConstantDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantModifiers)
         if ok {
            my.dispatch.VisitConstantModifiers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AbstractMethodDeclaration)
         if ok {
            my.dispatch.VisitAbstractMethodDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifiers)
         if ok {
            my.dispatch.VisitAbstractMethodModifiers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeDeclaration)
         if ok {
            my.dispatch.VisitAnnotationTypeDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeBody)
         if ok {
            my.dispatch.VisitAnnotationTypeBody(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclarations)
         if ok {
            my.dispatch.VisitAnnotationTypeElementDeclarations(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*DefaultValue)
         if ok {
            my.dispatch.VisitDefaultValue(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Annotations)
         if ok {
            my.dispatch.VisitAnnotations(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*NormalAnnotation)
         if ok {
            my.dispatch.VisitNormalAnnotation(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ElementValuePairs)
         if ok {
            my.dispatch.VisitElementValuePairs(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ElementValuePair)
         if ok {
            my.dispatch.VisitElementValuePair(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ElementValueArrayInitializer)
         if ok {
            my.dispatch.VisitElementValueArrayInitializer(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ElementValues)
         if ok {
            my.dispatch.VisitElementValues(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MarkerAnnotation)
         if ok {
            my.dispatch.VisitMarkerAnnotation(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SingleElementAnnotation)
         if ok {
            my.dispatch.VisitSingleElementAnnotation(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayInitializer)
         if ok {
            my.dispatch.VisitArrayInitializer(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableInitializers)
         if ok {
            my.dispatch.VisitVariableInitializers(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Block)
         if ok {
            my.dispatch.VisitBlock(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*BlockStatements)
         if ok {
            my.dispatch.VisitBlockStatements(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LocalVariableDeclarationStatement)
         if ok {
            my.dispatch.VisitLocalVariableDeclarationStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LocalVariableDeclaration)
         if ok {
            my.dispatch.VisitLocalVariableDeclaration(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*IfThenStatement)
         if ok {
            my.dispatch.VisitIfThenStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*IfThenElseStatement)
         if ok {
            my.dispatch.VisitIfThenElseStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*IfThenElseStatementNoShortIf)
         if ok {
            my.dispatch.VisitIfThenElseStatementNoShortIf(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EmptyStatement)
         if ok {
            my.dispatch.VisitEmptyStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LabeledStatement)
         if ok {
            my.dispatch.VisitLabeledStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LabeledStatementNoShortIf)
         if ok {
            my.dispatch.VisitLabeledStatementNoShortIf(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExpressionStatement)
         if ok {
            my.dispatch.VisitExpressionStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchStatement)
         if ok {
            my.dispatch.VisitSwitchStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchBlock)
         if ok {
            my.dispatch.VisitSwitchBlock(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchBlockStatementGroups)
         if ok {
            my.dispatch.VisitSwitchBlockStatementGroups(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchBlockStatementGroup)
         if ok {
            my.dispatch.VisitSwitchBlockStatementGroup(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchLabels)
         if ok {
            my.dispatch.VisitSwitchLabels(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*WhileStatement)
         if ok {
            my.dispatch.VisitWhileStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*WhileStatementNoShortIf)
         if ok {
            my.dispatch.VisitWhileStatementNoShortIf(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*DoStatement)
         if ok {
            my.dispatch.VisitDoStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*BasicForStatement)
         if ok {
            my.dispatch.VisitBasicForStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ForStatementNoShortIf)
         if ok {
            my.dispatch.VisitForStatementNoShortIf(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*StatementExpressionList)
         if ok {
            my.dispatch.VisitStatementExpressionList(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EnhancedForStatement)
         if ok {
            my.dispatch.VisitEnhancedForStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*BreakStatement)
         if ok {
            my.dispatch.VisitBreakStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ContinueStatement)
         if ok {
            my.dispatch.VisitContinueStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ReturnStatement)
         if ok {
            my.dispatch.VisitReturnStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ThrowStatement)
         if ok {
            my.dispatch.VisitThrowStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SynchronizedStatement)
         if ok {
            my.dispatch.VisitSynchronizedStatement(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Catches)
         if ok {
            my.dispatch.VisitCatches(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*CatchClause)
         if ok {
            my.dispatch.VisitCatchClause(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Finally)
         if ok {
            my.dispatch.VisitFinally(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArgumentList)
         if ok {
            my.dispatch.VisitArgumentList(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*DimExprs)
         if ok {
            my.dispatch.VisitDimExprs(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*DimExpr)
         if ok {
            my.dispatch.VisitDimExpr(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PostIncrementExpression)
         if ok {
            my.dispatch.VisitPostIncrementExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PostDecrementExpression)
         if ok {
            my.dispatch.VisitPostDecrementExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PreIncrementExpression)
         if ok {
            my.dispatch.VisitPreIncrementExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PreDecrementExpression)
         if ok {
            my.dispatch.VisitPreDecrementExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AndExpression)
         if ok {
            my.dispatch.VisitAndExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExclusiveOrExpression)
         if ok {
            my.dispatch.VisitExclusiveOrExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InclusiveOrExpression)
         if ok {
            my.dispatch.VisitInclusiveOrExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConditionalAndExpression)
         if ok {
            my.dispatch.VisitConditionalAndExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConditionalOrExpression)
         if ok {
            my.dispatch.VisitConditionalOrExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConditionalExpression)
         if ok {
            my.dispatch.VisitConditionalExpression(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Assignment)
         if ok {
            my.dispatch.VisitAssignment(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Commaopt)
         if ok {
            my.dispatch.VisitCommaopt(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Ellipsisopt)
         if ok {
            my.dispatch.VisitEllipsisopt(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction0)
         if ok {
            my.dispatch.VisitLPGUserAction0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction1)
         if ok {
            my.dispatch.VisitLPGUserAction1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction2)
         if ok {
            my.dispatch.VisitLPGUserAction2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction3)
         if ok {
            my.dispatch.VisitLPGUserAction3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction4)
         if ok {
            my.dispatch.VisitLPGUserAction4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType0)
         if ok {
            my.dispatch.VisitIntegralType0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType1)
         if ok {
            my.dispatch.VisitIntegralType1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType2)
         if ok {
            my.dispatch.VisitIntegralType2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType3)
         if ok {
            my.dispatch.VisitIntegralType3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType4)
         if ok {
            my.dispatch.VisitIntegralType4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FloatingPointType0)
         if ok {
            my.dispatch.VisitFloatingPointType0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FloatingPointType1)
         if ok {
            my.dispatch.VisitFloatingPointType1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*WildcardBounds0)
         if ok {
            my.dispatch.VisitWildcardBounds0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*WildcardBounds1)
         if ok {
            my.dispatch.VisitWildcardBounds1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier0)
         if ok {
            my.dispatch.VisitClassModifier0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier1)
         if ok {
            my.dispatch.VisitClassModifier1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier2)
         if ok {
            my.dispatch.VisitClassModifier2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier3)
         if ok {
            my.dispatch.VisitClassModifier3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier4)
         if ok {
            my.dispatch.VisitClassModifier4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier5)
         if ok {
            my.dispatch.VisitClassModifier5(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier6)
         if ok {
            my.dispatch.VisitClassModifier6(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier0)
         if ok {
            my.dispatch.VisitFieldModifier0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier1)
         if ok {
            my.dispatch.VisitFieldModifier1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier2)
         if ok {
            my.dispatch.VisitFieldModifier2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier3)
         if ok {
            my.dispatch.VisitFieldModifier3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier4)
         if ok {
            my.dispatch.VisitFieldModifier4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier5)
         if ok {
            my.dispatch.VisitFieldModifier5(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier6)
         if ok {
            my.dispatch.VisitFieldModifier6(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodDeclarator0)
         if ok {
            my.dispatch.VisitMethodDeclarator0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodDeclarator1)
         if ok {
            my.dispatch.VisitMethodDeclarator1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier0)
         if ok {
            my.dispatch.VisitMethodModifier0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier1)
         if ok {
            my.dispatch.VisitMethodModifier1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier2)
         if ok {
            my.dispatch.VisitMethodModifier2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier3)
         if ok {
            my.dispatch.VisitMethodModifier3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier4)
         if ok {
            my.dispatch.VisitMethodModifier4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier5)
         if ok {
            my.dispatch.VisitMethodModifier5(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier6)
         if ok {
            my.dispatch.VisitMethodModifier6(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier7)
         if ok {
            my.dispatch.VisitMethodModifier7(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier8)
         if ok {
            my.dispatch.VisitMethodModifier8(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier0)
         if ok {
            my.dispatch.VisitConstructorModifier0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier1)
         if ok {
            my.dispatch.VisitConstructorModifier1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier2)
         if ok {
            my.dispatch.VisitConstructorModifier2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation0)
         if ok {
            my.dispatch.VisitExplicitConstructorInvocation0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation1)
         if ok {
            my.dispatch.VisitExplicitConstructorInvocation1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation2)
         if ok {
            my.dispatch.VisitExplicitConstructorInvocation2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier0)
         if ok {
            my.dispatch.VisitInterfaceModifier0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier1)
         if ok {
            my.dispatch.VisitInterfaceModifier1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier2)
         if ok {
            my.dispatch.VisitInterfaceModifier2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier3)
         if ok {
            my.dispatch.VisitInterfaceModifier3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier4)
         if ok {
            my.dispatch.VisitInterfaceModifier4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier5)
         if ok {
            my.dispatch.VisitInterfaceModifier5(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExtendsInterfaces0)
         if ok {
            my.dispatch.VisitExtendsInterfaces0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ExtendsInterfaces1)
         if ok {
            my.dispatch.VisitExtendsInterfaces1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantModifier0)
         if ok {
            my.dispatch.VisitConstantModifier0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantModifier1)
         if ok {
            my.dispatch.VisitConstantModifier1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantModifier2)
         if ok {
            my.dispatch.VisitConstantModifier2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifier0)
         if ok {
            my.dispatch.VisitAbstractMethodModifier0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifier1)
         if ok {
            my.dispatch.VisitAbstractMethodModifier1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclaration0)
         if ok {
            my.dispatch.VisitAnnotationTypeElementDeclaration0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclaration1)
         if ok {
            my.dispatch.VisitAnnotationTypeElementDeclaration1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssertStatement0)
         if ok {
            my.dispatch.VisitAssertStatement0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssertStatement1)
         if ok {
            my.dispatch.VisitAssertStatement1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchLabel0)
         if ok {
            my.dispatch.VisitSwitchLabel0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchLabel1)
         if ok {
            my.dispatch.VisitSwitchLabel1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchLabel2)
         if ok {
            my.dispatch.VisitSwitchLabel2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TryStatement0)
         if ok {
            my.dispatch.VisitTryStatement0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*TryStatement1)
         if ok {
            my.dispatch.VisitTryStatement1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray0)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray1)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray2)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray3)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray4)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal0)
         if ok {
            my.dispatch.VisitLiteral0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal1)
         if ok {
            my.dispatch.VisitLiteral1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal2)
         if ok {
            my.dispatch.VisitLiteral2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal3)
         if ok {
            my.dispatch.VisitLiteral3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal4)
         if ok {
            my.dispatch.VisitLiteral4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal5)
         if ok {
            my.dispatch.VisitLiteral5(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal6)
         if ok {
            my.dispatch.VisitLiteral6(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*BooleanLiteral0)
         if ok {
            my.dispatch.VisitBooleanLiteral0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*BooleanLiteral1)
         if ok {
            my.dispatch.VisitBooleanLiteral1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassInstanceCreationExpression0)
         if ok {
            my.dispatch.VisitClassInstanceCreationExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassInstanceCreationExpression1)
         if ok {
            my.dispatch.VisitClassInstanceCreationExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression0)
         if ok {
            my.dispatch.VisitArrayCreationExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression1)
         if ok {
            my.dispatch.VisitArrayCreationExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression2)
         if ok {
            my.dispatch.VisitArrayCreationExpression2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression3)
         if ok {
            my.dispatch.VisitArrayCreationExpression3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Dims0)
         if ok {
            my.dispatch.VisitDims0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*Dims1)
         if ok {
            my.dispatch.VisitDims1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldAccess0)
         if ok {
            my.dispatch.VisitFieldAccess0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldAccess1)
         if ok {
            my.dispatch.VisitFieldAccess1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldAccess2)
         if ok {
            my.dispatch.VisitFieldAccess2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation0)
         if ok {
            my.dispatch.VisitMethodInvocation0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation1)
         if ok {
            my.dispatch.VisitMethodInvocation1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation2)
         if ok {
            my.dispatch.VisitMethodInvocation2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation3)
         if ok {
            my.dispatch.VisitMethodInvocation3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation4)
         if ok {
            my.dispatch.VisitMethodInvocation4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayAccess0)
         if ok {
            my.dispatch.VisitArrayAccess0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayAccess1)
         if ok {
            my.dispatch.VisitArrayAccess1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*UnaryExpression0)
         if ok {
            my.dispatch.VisitUnaryExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*UnaryExpression1)
         if ok {
            my.dispatch.VisitUnaryExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*UnaryExpressionNotPlusMinus0)
         if ok {
            my.dispatch.VisitUnaryExpressionNotPlusMinus0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*UnaryExpressionNotPlusMinus1)
         if ok {
            my.dispatch.VisitUnaryExpressionNotPlusMinus1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*CastExpression0)
         if ok {
            my.dispatch.VisitCastExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*CastExpression1)
         if ok {
            my.dispatch.VisitCastExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression0)
         if ok {
            my.dispatch.VisitMultiplicativeExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression1)
         if ok {
            my.dispatch.VisitMultiplicativeExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression2)
         if ok {
            my.dispatch.VisitMultiplicativeExpression2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AdditiveExpression0)
         if ok {
            my.dispatch.VisitAdditiveExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AdditiveExpression1)
         if ok {
            my.dispatch.VisitAdditiveExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ShiftExpression0)
         if ok {
            my.dispatch.VisitShiftExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ShiftExpression1)
         if ok {
            my.dispatch.VisitShiftExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*ShiftExpression2)
         if ok {
            my.dispatch.VisitShiftExpression2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression0)
         if ok {
            my.dispatch.VisitRelationalExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression1)
         if ok {
            my.dispatch.VisitRelationalExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression2)
         if ok {
            my.dispatch.VisitRelationalExpression2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression3)
         if ok {
            my.dispatch.VisitRelationalExpression3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression4)
         if ok {
            my.dispatch.VisitRelationalExpression4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EqualityExpression0)
         if ok {
            my.dispatch.VisitEqualityExpression0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*EqualityExpression1)
         if ok {
            my.dispatch.VisitEqualityExpression1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator0)
         if ok {
            my.dispatch.VisitAssignmentOperator0(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator1)
         if ok {
            my.dispatch.VisitAssignmentOperator1(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator2)
         if ok {
            my.dispatch.VisitAssignmentOperator2(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator3)
         if ok {
            my.dispatch.VisitAssignmentOperator3(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator4)
         if ok {
            my.dispatch.VisitAssignmentOperator4(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator5)
         if ok {
            my.dispatch.VisitAssignmentOperator5(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator6)
         if ok {
            my.dispatch.VisitAssignmentOperator6(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator7)
         if ok {
            my.dispatch.VisitAssignmentOperator7(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator8)
         if ok {
            my.dispatch.VisitAssignmentOperator8(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator9)
         if ok {
            my.dispatch.VisitAssignmentOperator9(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator10)
         if ok {
            my.dispatch.VisitAssignmentOperator10(n2)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator11)
         if ok {
            my.dispatch.VisitAssignmentOperator11(n2)
            return 
          }
        }
}
func (my *AbstractVisitor)     VisitWithArg(n IAst, o interface{}){
        {
         var n2,ok =n.(*AstToken)
         if ok {
            my.dispatch.VisitAstTokenWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*identifier)
         if ok {
            my.dispatch.VisitidentifierWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimitiveType)
         if ok {
            my.dispatch.VisitPrimitiveTypeWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassType)
         if ok {
            my.dispatch.VisitClassTypeWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceType)
         if ok {
            my.dispatch.VisitInterfaceTypeWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeName)
         if ok {
            my.dispatch.VisitTypeNameWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayType)
         if ok {
            my.dispatch.VisitArrayTypeWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeParameter)
         if ok {
            my.dispatch.VisitTypeParameterWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeBound)
         if ok {
            my.dispatch.VisitTypeBoundWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AdditionalBoundList)
         if ok {
            my.dispatch.VisitAdditionalBoundListWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AdditionalBound)
         if ok {
            my.dispatch.VisitAdditionalBoundWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeArguments)
         if ok {
            my.dispatch.VisitTypeArgumentsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ActualTypeArgumentList)
         if ok {
            my.dispatch.VisitActualTypeArgumentListWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Wildcard)
         if ok {
            my.dispatch.VisitWildcardWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PackageName)
         if ok {
            my.dispatch.VisitPackageNameWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExpressionName)
         if ok {
            my.dispatch.VisitExpressionNameWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodName)
         if ok {
            my.dispatch.VisitMethodNameWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PackageOrTypeName)
         if ok {
            my.dispatch.VisitPackageOrTypeNameWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AmbiguousName)
         if ok {
            my.dispatch.VisitAmbiguousNameWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*CompilationUnit)
         if ok {
            my.dispatch.VisitCompilationUnitWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ImportDeclarations)
         if ok {
            my.dispatch.VisitImportDeclarationsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeDeclarations)
         if ok {
            my.dispatch.VisitTypeDeclarationsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PackageDeclaration)
         if ok {
            my.dispatch.VisitPackageDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SingleTypeImportDeclaration)
         if ok {
            my.dispatch.VisitSingleTypeImportDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeImportOnDemandDeclaration)
         if ok {
            my.dispatch.VisitTypeImportOnDemandDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SingleStaticImportDeclaration)
         if ok {
            my.dispatch.VisitSingleStaticImportDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*StaticImportOnDemandDeclaration)
         if ok {
            my.dispatch.VisitStaticImportOnDemandDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeDeclaration)
         if ok {
            my.dispatch.VisitTypeDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*NormalClassDeclaration)
         if ok {
            my.dispatch.VisitNormalClassDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifiers)
         if ok {
            my.dispatch.VisitClassModifiersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeParameters)
         if ok {
            my.dispatch.VisitTypeParametersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TypeParameterList)
         if ok {
            my.dispatch.VisitTypeParameterListWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Super)
         if ok {
            my.dispatch.VisitSuperWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Interfaces)
         if ok {
            my.dispatch.VisitInterfacesWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceTypeList)
         if ok {
            my.dispatch.VisitInterfaceTypeListWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassBody)
         if ok {
            my.dispatch.VisitClassBodyWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassBodyDeclarations)
         if ok {
            my.dispatch.VisitClassBodyDeclarationsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassMemberDeclaration)
         if ok {
            my.dispatch.VisitClassMemberDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldDeclaration)
         if ok {
            my.dispatch.VisitFieldDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableDeclarators)
         if ok {
            my.dispatch.VisitVariableDeclaratorsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableDeclarator)
         if ok {
            my.dispatch.VisitVariableDeclaratorWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableDeclaratorId)
         if ok {
            my.dispatch.VisitVariableDeclaratorIdWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifiers)
         if ok {
            my.dispatch.VisitFieldModifiersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodDeclaration)
         if ok {
            my.dispatch.VisitMethodDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodHeader)
         if ok {
            my.dispatch.VisitMethodHeaderWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ResultType)
         if ok {
            my.dispatch.VisitResultTypeWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FormalParameterList)
         if ok {
            my.dispatch.VisitFormalParameterListWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FormalParameters)
         if ok {
            my.dispatch.VisitFormalParametersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FormalParameter)
         if ok {
            my.dispatch.VisitFormalParameterWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableModifiers)
         if ok {
            my.dispatch.VisitVariableModifiersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableModifier)
         if ok {
            my.dispatch.VisitVariableModifierWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LastFormalParameter)
         if ok {
            my.dispatch.VisitLastFormalParameterWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifiers)
         if ok {
            my.dispatch.VisitMethodModifiersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Throws)
         if ok {
            my.dispatch.VisitThrowsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExceptionTypeList)
         if ok {
            my.dispatch.VisitExceptionTypeListWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodBody)
         if ok {
            my.dispatch.VisitMethodBodyWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*StaticInitializer)
         if ok {
            my.dispatch.VisitStaticInitializerWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorDeclaration)
         if ok {
            my.dispatch.VisitConstructorDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorDeclarator)
         if ok {
            my.dispatch.VisitConstructorDeclaratorWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorModifiers)
         if ok {
            my.dispatch.VisitConstructorModifiersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorBody)
         if ok {
            my.dispatch.VisitConstructorBodyWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumDeclaration)
         if ok {
            my.dispatch.VisitEnumDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumBody)
         if ok {
            my.dispatch.VisitEnumBodyWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumConstants)
         if ok {
            my.dispatch.VisitEnumConstantsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumConstant)
         if ok {
            my.dispatch.VisitEnumConstantWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Arguments)
         if ok {
            my.dispatch.VisitArgumentsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EnumBodyDeclarations)
         if ok {
            my.dispatch.VisitEnumBodyDeclarationsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*NormalInterfaceDeclaration)
         if ok {
            my.dispatch.VisitNormalInterfaceDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifiers)
         if ok {
            my.dispatch.VisitInterfaceModifiersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceBody)
         if ok {
            my.dispatch.VisitInterfaceBodyWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceMemberDeclarations)
         if ok {
            my.dispatch.VisitInterfaceMemberDeclarationsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceMemberDeclaration)
         if ok {
            my.dispatch.VisitInterfaceMemberDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantDeclaration)
         if ok {
            my.dispatch.VisitConstantDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantModifiers)
         if ok {
            my.dispatch.VisitConstantModifiersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AbstractMethodDeclaration)
         if ok {
            my.dispatch.VisitAbstractMethodDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifiers)
         if ok {
            my.dispatch.VisitAbstractMethodModifiersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeDeclaration)
         if ok {
            my.dispatch.VisitAnnotationTypeDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeBody)
         if ok {
            my.dispatch.VisitAnnotationTypeBodyWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclarations)
         if ok {
            my.dispatch.VisitAnnotationTypeElementDeclarationsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*DefaultValue)
         if ok {
            my.dispatch.VisitDefaultValueWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Annotations)
         if ok {
            my.dispatch.VisitAnnotationsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*NormalAnnotation)
         if ok {
            my.dispatch.VisitNormalAnnotationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ElementValuePairs)
         if ok {
            my.dispatch.VisitElementValuePairsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ElementValuePair)
         if ok {
            my.dispatch.VisitElementValuePairWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ElementValueArrayInitializer)
         if ok {
            my.dispatch.VisitElementValueArrayInitializerWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ElementValues)
         if ok {
            my.dispatch.VisitElementValuesWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MarkerAnnotation)
         if ok {
            my.dispatch.VisitMarkerAnnotationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SingleElementAnnotation)
         if ok {
            my.dispatch.VisitSingleElementAnnotationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayInitializer)
         if ok {
            my.dispatch.VisitArrayInitializerWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*VariableInitializers)
         if ok {
            my.dispatch.VisitVariableInitializersWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Block)
         if ok {
            my.dispatch.VisitBlockWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*BlockStatements)
         if ok {
            my.dispatch.VisitBlockStatementsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LocalVariableDeclarationStatement)
         if ok {
            my.dispatch.VisitLocalVariableDeclarationStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LocalVariableDeclaration)
         if ok {
            my.dispatch.VisitLocalVariableDeclarationWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*IfThenStatement)
         if ok {
            my.dispatch.VisitIfThenStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*IfThenElseStatement)
         if ok {
            my.dispatch.VisitIfThenElseStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*IfThenElseStatementNoShortIf)
         if ok {
            my.dispatch.VisitIfThenElseStatementNoShortIfWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EmptyStatement)
         if ok {
            my.dispatch.VisitEmptyStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LabeledStatement)
         if ok {
            my.dispatch.VisitLabeledStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LabeledStatementNoShortIf)
         if ok {
            my.dispatch.VisitLabeledStatementNoShortIfWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExpressionStatement)
         if ok {
            my.dispatch.VisitExpressionStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchStatement)
         if ok {
            my.dispatch.VisitSwitchStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchBlock)
         if ok {
            my.dispatch.VisitSwitchBlockWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchBlockStatementGroups)
         if ok {
            my.dispatch.VisitSwitchBlockStatementGroupsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchBlockStatementGroup)
         if ok {
            my.dispatch.VisitSwitchBlockStatementGroupWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchLabels)
         if ok {
            my.dispatch.VisitSwitchLabelsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*WhileStatement)
         if ok {
            my.dispatch.VisitWhileStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*WhileStatementNoShortIf)
         if ok {
            my.dispatch.VisitWhileStatementNoShortIfWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*DoStatement)
         if ok {
            my.dispatch.VisitDoStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*BasicForStatement)
         if ok {
            my.dispatch.VisitBasicForStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ForStatementNoShortIf)
         if ok {
            my.dispatch.VisitForStatementNoShortIfWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*StatementExpressionList)
         if ok {
            my.dispatch.VisitStatementExpressionListWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EnhancedForStatement)
         if ok {
            my.dispatch.VisitEnhancedForStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*BreakStatement)
         if ok {
            my.dispatch.VisitBreakStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ContinueStatement)
         if ok {
            my.dispatch.VisitContinueStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ReturnStatement)
         if ok {
            my.dispatch.VisitReturnStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ThrowStatement)
         if ok {
            my.dispatch.VisitThrowStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SynchronizedStatement)
         if ok {
            my.dispatch.VisitSynchronizedStatementWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Catches)
         if ok {
            my.dispatch.VisitCatchesWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*CatchClause)
         if ok {
            my.dispatch.VisitCatchClauseWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Finally)
         if ok {
            my.dispatch.VisitFinallyWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArgumentList)
         if ok {
            my.dispatch.VisitArgumentListWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*DimExprs)
         if ok {
            my.dispatch.VisitDimExprsWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*DimExpr)
         if ok {
            my.dispatch.VisitDimExprWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PostIncrementExpression)
         if ok {
            my.dispatch.VisitPostIncrementExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PostDecrementExpression)
         if ok {
            my.dispatch.VisitPostDecrementExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PreIncrementExpression)
         if ok {
            my.dispatch.VisitPreIncrementExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PreDecrementExpression)
         if ok {
            my.dispatch.VisitPreDecrementExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AndExpression)
         if ok {
            my.dispatch.VisitAndExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExclusiveOrExpression)
         if ok {
            my.dispatch.VisitExclusiveOrExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InclusiveOrExpression)
         if ok {
            my.dispatch.VisitInclusiveOrExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConditionalAndExpression)
         if ok {
            my.dispatch.VisitConditionalAndExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConditionalOrExpression)
         if ok {
            my.dispatch.VisitConditionalOrExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConditionalExpression)
         if ok {
            my.dispatch.VisitConditionalExpressionWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Assignment)
         if ok {
            my.dispatch.VisitAssignmentWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Commaopt)
         if ok {
            my.dispatch.VisitCommaoptWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Ellipsisopt)
         if ok {
            my.dispatch.VisitEllipsisoptWithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction0)
         if ok {
            my.dispatch.VisitLPGUserAction0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction1)
         if ok {
            my.dispatch.VisitLPGUserAction1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction2)
         if ok {
            my.dispatch.VisitLPGUserAction2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction3)
         if ok {
            my.dispatch.VisitLPGUserAction3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*LPGUserAction4)
         if ok {
            my.dispatch.VisitLPGUserAction4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType0)
         if ok {
            my.dispatch.VisitIntegralType0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType1)
         if ok {
            my.dispatch.VisitIntegralType1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType2)
         if ok {
            my.dispatch.VisitIntegralType2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType3)
         if ok {
            my.dispatch.VisitIntegralType3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*IntegralType4)
         if ok {
            my.dispatch.VisitIntegralType4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FloatingPointType0)
         if ok {
            my.dispatch.VisitFloatingPointType0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FloatingPointType1)
         if ok {
            my.dispatch.VisitFloatingPointType1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*WildcardBounds0)
         if ok {
            my.dispatch.VisitWildcardBounds0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*WildcardBounds1)
         if ok {
            my.dispatch.VisitWildcardBounds1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier0)
         if ok {
            my.dispatch.VisitClassModifier0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier1)
         if ok {
            my.dispatch.VisitClassModifier1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier2)
         if ok {
            my.dispatch.VisitClassModifier2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier3)
         if ok {
            my.dispatch.VisitClassModifier3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier4)
         if ok {
            my.dispatch.VisitClassModifier4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier5)
         if ok {
            my.dispatch.VisitClassModifier5WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassModifier6)
         if ok {
            my.dispatch.VisitClassModifier6WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier0)
         if ok {
            my.dispatch.VisitFieldModifier0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier1)
         if ok {
            my.dispatch.VisitFieldModifier1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier2)
         if ok {
            my.dispatch.VisitFieldModifier2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier3)
         if ok {
            my.dispatch.VisitFieldModifier3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier4)
         if ok {
            my.dispatch.VisitFieldModifier4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier5)
         if ok {
            my.dispatch.VisitFieldModifier5WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldModifier6)
         if ok {
            my.dispatch.VisitFieldModifier6WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodDeclarator0)
         if ok {
            my.dispatch.VisitMethodDeclarator0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodDeclarator1)
         if ok {
            my.dispatch.VisitMethodDeclarator1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier0)
         if ok {
            my.dispatch.VisitMethodModifier0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier1)
         if ok {
            my.dispatch.VisitMethodModifier1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier2)
         if ok {
            my.dispatch.VisitMethodModifier2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier3)
         if ok {
            my.dispatch.VisitMethodModifier3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier4)
         if ok {
            my.dispatch.VisitMethodModifier4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier5)
         if ok {
            my.dispatch.VisitMethodModifier5WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier6)
         if ok {
            my.dispatch.VisitMethodModifier6WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier7)
         if ok {
            my.dispatch.VisitMethodModifier7WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodModifier8)
         if ok {
            my.dispatch.VisitMethodModifier8WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier0)
         if ok {
            my.dispatch.VisitConstructorModifier0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier1)
         if ok {
            my.dispatch.VisitConstructorModifier1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier2)
         if ok {
            my.dispatch.VisitConstructorModifier2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation0)
         if ok {
            my.dispatch.VisitExplicitConstructorInvocation0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation1)
         if ok {
            my.dispatch.VisitExplicitConstructorInvocation1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation2)
         if ok {
            my.dispatch.VisitExplicitConstructorInvocation2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier0)
         if ok {
            my.dispatch.VisitInterfaceModifier0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier1)
         if ok {
            my.dispatch.VisitInterfaceModifier1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier2)
         if ok {
            my.dispatch.VisitInterfaceModifier2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier3)
         if ok {
            my.dispatch.VisitInterfaceModifier3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier4)
         if ok {
            my.dispatch.VisitInterfaceModifier4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier5)
         if ok {
            my.dispatch.VisitInterfaceModifier5WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExtendsInterfaces0)
         if ok {
            my.dispatch.VisitExtendsInterfaces0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ExtendsInterfaces1)
         if ok {
            my.dispatch.VisitExtendsInterfaces1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantModifier0)
         if ok {
            my.dispatch.VisitConstantModifier0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantModifier1)
         if ok {
            my.dispatch.VisitConstantModifier1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ConstantModifier2)
         if ok {
            my.dispatch.VisitConstantModifier2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifier0)
         if ok {
            my.dispatch.VisitAbstractMethodModifier0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifier1)
         if ok {
            my.dispatch.VisitAbstractMethodModifier1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclaration0)
         if ok {
            my.dispatch.VisitAnnotationTypeElementDeclaration0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclaration1)
         if ok {
            my.dispatch.VisitAnnotationTypeElementDeclaration1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssertStatement0)
         if ok {
            my.dispatch.VisitAssertStatement0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssertStatement1)
         if ok {
            my.dispatch.VisitAssertStatement1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchLabel0)
         if ok {
            my.dispatch.VisitSwitchLabel0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchLabel1)
         if ok {
            my.dispatch.VisitSwitchLabel1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*SwitchLabel2)
         if ok {
            my.dispatch.VisitSwitchLabel2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TryStatement0)
         if ok {
            my.dispatch.VisitTryStatement0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*TryStatement1)
         if ok {
            my.dispatch.VisitTryStatement1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray0)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray1)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray2)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray3)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray4)
         if ok {
            my.dispatch.VisitPrimaryNoNewArray4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal0)
         if ok {
            my.dispatch.VisitLiteral0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal1)
         if ok {
            my.dispatch.VisitLiteral1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal2)
         if ok {
            my.dispatch.VisitLiteral2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal3)
         if ok {
            my.dispatch.VisitLiteral3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal4)
         if ok {
            my.dispatch.VisitLiteral4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal5)
         if ok {
            my.dispatch.VisitLiteral5WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Literal6)
         if ok {
            my.dispatch.VisitLiteral6WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*BooleanLiteral0)
         if ok {
            my.dispatch.VisitBooleanLiteral0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*BooleanLiteral1)
         if ok {
            my.dispatch.VisitBooleanLiteral1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassInstanceCreationExpression0)
         if ok {
            my.dispatch.VisitClassInstanceCreationExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ClassInstanceCreationExpression1)
         if ok {
            my.dispatch.VisitClassInstanceCreationExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression0)
         if ok {
            my.dispatch.VisitArrayCreationExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression1)
         if ok {
            my.dispatch.VisitArrayCreationExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression2)
         if ok {
            my.dispatch.VisitArrayCreationExpression2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression3)
         if ok {
            my.dispatch.VisitArrayCreationExpression3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Dims0)
         if ok {
            my.dispatch.VisitDims0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*Dims1)
         if ok {
            my.dispatch.VisitDims1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldAccess0)
         if ok {
            my.dispatch.VisitFieldAccess0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldAccess1)
         if ok {
            my.dispatch.VisitFieldAccess1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*FieldAccess2)
         if ok {
            my.dispatch.VisitFieldAccess2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation0)
         if ok {
            my.dispatch.VisitMethodInvocation0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation1)
         if ok {
            my.dispatch.VisitMethodInvocation1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation2)
         if ok {
            my.dispatch.VisitMethodInvocation2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation3)
         if ok {
            my.dispatch.VisitMethodInvocation3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MethodInvocation4)
         if ok {
            my.dispatch.VisitMethodInvocation4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayAccess0)
         if ok {
            my.dispatch.VisitArrayAccess0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ArrayAccess1)
         if ok {
            my.dispatch.VisitArrayAccess1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*UnaryExpression0)
         if ok {
            my.dispatch.VisitUnaryExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*UnaryExpression1)
         if ok {
            my.dispatch.VisitUnaryExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*UnaryExpressionNotPlusMinus0)
         if ok {
            my.dispatch.VisitUnaryExpressionNotPlusMinus0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*UnaryExpressionNotPlusMinus1)
         if ok {
            my.dispatch.VisitUnaryExpressionNotPlusMinus1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*CastExpression0)
         if ok {
            my.dispatch.VisitCastExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*CastExpression1)
         if ok {
            my.dispatch.VisitCastExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression0)
         if ok {
            my.dispatch.VisitMultiplicativeExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression1)
         if ok {
            my.dispatch.VisitMultiplicativeExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression2)
         if ok {
            my.dispatch.VisitMultiplicativeExpression2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AdditiveExpression0)
         if ok {
            my.dispatch.VisitAdditiveExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AdditiveExpression1)
         if ok {
            my.dispatch.VisitAdditiveExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ShiftExpression0)
         if ok {
            my.dispatch.VisitShiftExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ShiftExpression1)
         if ok {
            my.dispatch.VisitShiftExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*ShiftExpression2)
         if ok {
            my.dispatch.VisitShiftExpression2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression0)
         if ok {
            my.dispatch.VisitRelationalExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression1)
         if ok {
            my.dispatch.VisitRelationalExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression2)
         if ok {
            my.dispatch.VisitRelationalExpression2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression3)
         if ok {
            my.dispatch.VisitRelationalExpression3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*RelationalExpression4)
         if ok {
            my.dispatch.VisitRelationalExpression4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EqualityExpression0)
         if ok {
            my.dispatch.VisitEqualityExpression0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*EqualityExpression1)
         if ok {
            my.dispatch.VisitEqualityExpression1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator0)
         if ok {
            my.dispatch.VisitAssignmentOperator0WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator1)
         if ok {
            my.dispatch.VisitAssignmentOperator1WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator2)
         if ok {
            my.dispatch.VisitAssignmentOperator2WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator3)
         if ok {
            my.dispatch.VisitAssignmentOperator3WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator4)
         if ok {
            my.dispatch.VisitAssignmentOperator4WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator5)
         if ok {
            my.dispatch.VisitAssignmentOperator5WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator6)
         if ok {
            my.dispatch.VisitAssignmentOperator6WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator7)
         if ok {
            my.dispatch.VisitAssignmentOperator7WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator8)
         if ok {
            my.dispatch.VisitAssignmentOperator8WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator9)
         if ok {
            my.dispatch.VisitAssignmentOperator9WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator10)
         if ok {
            my.dispatch.VisitAssignmentOperator10WithArg(n2,o)
            return 
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator11)
         if ok {
            my.dispatch.VisitAssignmentOperator11WithArg(n2,o)
            return 
          }
        }
}
func AnyCastToAbstractVisitor(i interface{}) *AbstractVisitor {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractVisitor)
	}
}
type ResultVisitorResultArgumentVisitor interface{
   ResultVisitor
   ResultArgumentVisitor
   }
type AbstractResultVisitor struct{
   dispatch ResultVisitorResultArgumentVisitor
   }
func NewAbstractResultVisitor(dispatch ResultVisitorResultArgumentVisitor) *AbstractResultVisitor{
         my := new(AbstractResultVisitor)
         if dispatch != nil{
           my.dispatch = dispatch
         }else{
           my.dispatch = my
         }
        return my
}

func (my *AbstractResultVisitor)       UnimplementedVisitor(s  string) interface{}{ return nil }

func (my *AbstractResultVisitor)     VisitAstTokenWithResult(n *AstToken) interface{}{ return  my.UnimplementedVisitor("VisitAstTokenWithResult(*AstToken)")}

func (my *AbstractResultVisitor)     VisitAstTokenWithResultArgument(n *AstToken, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAstTokenWithResultArgument(*AstToken, interface{})")}

func (my *AbstractResultVisitor)     VisitidentifierWithResult(n *identifier) interface{}{ return  my.UnimplementedVisitor("VisitidentifierWithResult(*identifier)")}

func (my *AbstractResultVisitor)     VisitidentifierWithResultArgument(n *identifier, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitidentifierWithResultArgument(*identifier, interface{})")}

func (my *AbstractResultVisitor)     VisitPrimitiveTypeWithResult(n *PrimitiveType) interface{}{ return  my.UnimplementedVisitor("VisitPrimitiveTypeWithResult(*PrimitiveType)")}

func (my *AbstractResultVisitor)     VisitPrimitiveTypeWithResultArgument(n *PrimitiveType, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPrimitiveTypeWithResultArgument(*PrimitiveType, interface{})")}

func (my *AbstractResultVisitor)     VisitClassTypeWithResult(n *ClassType) interface{}{ return  my.UnimplementedVisitor("VisitClassTypeWithResult(*ClassType)")}

func (my *AbstractResultVisitor)     VisitClassTypeWithResultArgument(n *ClassType, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassTypeWithResultArgument(*ClassType, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceTypeWithResult(n *InterfaceType) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceTypeWithResult(*InterfaceType)")}

func (my *AbstractResultVisitor)     VisitInterfaceTypeWithResultArgument(n *InterfaceType, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceTypeWithResultArgument(*InterfaceType, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeNameWithResult(n *TypeName) interface{}{ return  my.UnimplementedVisitor("VisitTypeNameWithResult(*TypeName)")}

func (my *AbstractResultVisitor)     VisitTypeNameWithResultArgument(n *TypeName, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeNameWithResultArgument(*TypeName, interface{})")}

func (my *AbstractResultVisitor)     VisitArrayTypeWithResult(n *ArrayType) interface{}{ return  my.UnimplementedVisitor("VisitArrayTypeWithResult(*ArrayType)")}

func (my *AbstractResultVisitor)     VisitArrayTypeWithResultArgument(n *ArrayType, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArrayTypeWithResultArgument(*ArrayType, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeParameterWithResult(n *TypeParameter) interface{}{ return  my.UnimplementedVisitor("VisitTypeParameterWithResult(*TypeParameter)")}

func (my *AbstractResultVisitor)     VisitTypeParameterWithResultArgument(n *TypeParameter, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeParameterWithResultArgument(*TypeParameter, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeBoundWithResult(n *TypeBound) interface{}{ return  my.UnimplementedVisitor("VisitTypeBoundWithResult(*TypeBound)")}

func (my *AbstractResultVisitor)     VisitTypeBoundWithResultArgument(n *TypeBound, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeBoundWithResultArgument(*TypeBound, interface{})")}

func (my *AbstractResultVisitor)     VisitAdditionalBoundListWithResult(n *AdditionalBoundList) interface{}{ return  my.UnimplementedVisitor("VisitAdditionalBoundListWithResult(*AdditionalBoundList)")}

func (my *AbstractResultVisitor)     VisitAdditionalBoundListWithResultArgument(n *AdditionalBoundList, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAdditionalBoundListWithResultArgument(*AdditionalBoundList, interface{})")}

func (my *AbstractResultVisitor)     VisitAdditionalBoundWithResult(n *AdditionalBound) interface{}{ return  my.UnimplementedVisitor("VisitAdditionalBoundWithResult(*AdditionalBound)")}

func (my *AbstractResultVisitor)     VisitAdditionalBoundWithResultArgument(n *AdditionalBound, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAdditionalBoundWithResultArgument(*AdditionalBound, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeArgumentsWithResult(n *TypeArguments) interface{}{ return  my.UnimplementedVisitor("VisitTypeArgumentsWithResult(*TypeArguments)")}

func (my *AbstractResultVisitor)     VisitTypeArgumentsWithResultArgument(n *TypeArguments, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeArgumentsWithResultArgument(*TypeArguments, interface{})")}

func (my *AbstractResultVisitor)     VisitActualTypeArgumentListWithResult(n *ActualTypeArgumentList) interface{}{ return  my.UnimplementedVisitor("VisitActualTypeArgumentListWithResult(*ActualTypeArgumentList)")}

func (my *AbstractResultVisitor)     VisitActualTypeArgumentListWithResultArgument(n *ActualTypeArgumentList, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitActualTypeArgumentListWithResultArgument(*ActualTypeArgumentList, interface{})")}

func (my *AbstractResultVisitor)     VisitWildcardWithResult(n *Wildcard) interface{}{ return  my.UnimplementedVisitor("VisitWildcardWithResult(*Wildcard)")}

func (my *AbstractResultVisitor)     VisitWildcardWithResultArgument(n *Wildcard, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitWildcardWithResultArgument(*Wildcard, interface{})")}

func (my *AbstractResultVisitor)     VisitPackageNameWithResult(n *PackageName) interface{}{ return  my.UnimplementedVisitor("VisitPackageNameWithResult(*PackageName)")}

func (my *AbstractResultVisitor)     VisitPackageNameWithResultArgument(n *PackageName, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPackageNameWithResultArgument(*PackageName, interface{})")}

func (my *AbstractResultVisitor)     VisitExpressionNameWithResult(n *ExpressionName) interface{}{ return  my.UnimplementedVisitor("VisitExpressionNameWithResult(*ExpressionName)")}

func (my *AbstractResultVisitor)     VisitExpressionNameWithResultArgument(n *ExpressionName, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExpressionNameWithResultArgument(*ExpressionName, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodNameWithResult(n *MethodName) interface{}{ return  my.UnimplementedVisitor("VisitMethodNameWithResult(*MethodName)")}

func (my *AbstractResultVisitor)     VisitMethodNameWithResultArgument(n *MethodName, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodNameWithResultArgument(*MethodName, interface{})")}

func (my *AbstractResultVisitor)     VisitPackageOrTypeNameWithResult(n *PackageOrTypeName) interface{}{ return  my.UnimplementedVisitor("VisitPackageOrTypeNameWithResult(*PackageOrTypeName)")}

func (my *AbstractResultVisitor)     VisitPackageOrTypeNameWithResultArgument(n *PackageOrTypeName, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPackageOrTypeNameWithResultArgument(*PackageOrTypeName, interface{})")}

func (my *AbstractResultVisitor)     VisitAmbiguousNameWithResult(n *AmbiguousName) interface{}{ return  my.UnimplementedVisitor("VisitAmbiguousNameWithResult(*AmbiguousName)")}

func (my *AbstractResultVisitor)     VisitAmbiguousNameWithResultArgument(n *AmbiguousName, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAmbiguousNameWithResultArgument(*AmbiguousName, interface{})")}

func (my *AbstractResultVisitor)     VisitCompilationUnitWithResult(n *CompilationUnit) interface{}{ return  my.UnimplementedVisitor("VisitCompilationUnitWithResult(*CompilationUnit)")}

func (my *AbstractResultVisitor)     VisitCompilationUnitWithResultArgument(n *CompilationUnit, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitCompilationUnitWithResultArgument(*CompilationUnit, interface{})")}

func (my *AbstractResultVisitor)     VisitImportDeclarationsWithResult(n *ImportDeclarations) interface{}{ return  my.UnimplementedVisitor("VisitImportDeclarationsWithResult(*ImportDeclarations)")}

func (my *AbstractResultVisitor)     VisitImportDeclarationsWithResultArgument(n *ImportDeclarations, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitImportDeclarationsWithResultArgument(*ImportDeclarations, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeDeclarationsWithResult(n *TypeDeclarations) interface{}{ return  my.UnimplementedVisitor("VisitTypeDeclarationsWithResult(*TypeDeclarations)")}

func (my *AbstractResultVisitor)     VisitTypeDeclarationsWithResultArgument(n *TypeDeclarations, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeDeclarationsWithResultArgument(*TypeDeclarations, interface{})")}

func (my *AbstractResultVisitor)     VisitPackageDeclarationWithResult(n *PackageDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitPackageDeclarationWithResult(*PackageDeclaration)")}

func (my *AbstractResultVisitor)     VisitPackageDeclarationWithResultArgument(n *PackageDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPackageDeclarationWithResultArgument(*PackageDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitSingleTypeImportDeclarationWithResult(n *SingleTypeImportDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitSingleTypeImportDeclarationWithResult(*SingleTypeImportDeclaration)")}

func (my *AbstractResultVisitor)     VisitSingleTypeImportDeclarationWithResultArgument(n *SingleTypeImportDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSingleTypeImportDeclarationWithResultArgument(*SingleTypeImportDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeImportOnDemandDeclarationWithResult(n *TypeImportOnDemandDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitTypeImportOnDemandDeclarationWithResult(*TypeImportOnDemandDeclaration)")}

func (my *AbstractResultVisitor)     VisitTypeImportOnDemandDeclarationWithResultArgument(n *TypeImportOnDemandDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeImportOnDemandDeclarationWithResultArgument(*TypeImportOnDemandDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitSingleStaticImportDeclarationWithResult(n *SingleStaticImportDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitSingleStaticImportDeclarationWithResult(*SingleStaticImportDeclaration)")}

func (my *AbstractResultVisitor)     VisitSingleStaticImportDeclarationWithResultArgument(n *SingleStaticImportDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSingleStaticImportDeclarationWithResultArgument(*SingleStaticImportDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitStaticImportOnDemandDeclarationWithResult(n *StaticImportOnDemandDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitStaticImportOnDemandDeclarationWithResult(*StaticImportOnDemandDeclaration)")}

func (my *AbstractResultVisitor)     VisitStaticImportOnDemandDeclarationWithResultArgument(n *StaticImportOnDemandDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitStaticImportOnDemandDeclarationWithResultArgument(*StaticImportOnDemandDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeDeclarationWithResult(n *TypeDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitTypeDeclarationWithResult(*TypeDeclaration)")}

func (my *AbstractResultVisitor)     VisitTypeDeclarationWithResultArgument(n *TypeDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeDeclarationWithResultArgument(*TypeDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitNormalClassDeclarationWithResult(n *NormalClassDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitNormalClassDeclarationWithResult(*NormalClassDeclaration)")}

func (my *AbstractResultVisitor)     VisitNormalClassDeclarationWithResultArgument(n *NormalClassDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitNormalClassDeclarationWithResultArgument(*NormalClassDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitClassModifiersWithResult(n *ClassModifiers) interface{}{ return  my.UnimplementedVisitor("VisitClassModifiersWithResult(*ClassModifiers)")}

func (my *AbstractResultVisitor)     VisitClassModifiersWithResultArgument(n *ClassModifiers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassModifiersWithResultArgument(*ClassModifiers, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeParametersWithResult(n *TypeParameters) interface{}{ return  my.UnimplementedVisitor("VisitTypeParametersWithResult(*TypeParameters)")}

func (my *AbstractResultVisitor)     VisitTypeParametersWithResultArgument(n *TypeParameters, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeParametersWithResultArgument(*TypeParameters, interface{})")}

func (my *AbstractResultVisitor)     VisitTypeParameterListWithResult(n *TypeParameterList) interface{}{ return  my.UnimplementedVisitor("VisitTypeParameterListWithResult(*TypeParameterList)")}

func (my *AbstractResultVisitor)     VisitTypeParameterListWithResultArgument(n *TypeParameterList, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTypeParameterListWithResultArgument(*TypeParameterList, interface{})")}

func (my *AbstractResultVisitor)     VisitSuperWithResult(n *Super) interface{}{ return  my.UnimplementedVisitor("VisitSuperWithResult(*Super)")}

func (my *AbstractResultVisitor)     VisitSuperWithResultArgument(n *Super, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSuperWithResultArgument(*Super, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfacesWithResult(n *Interfaces) interface{}{ return  my.UnimplementedVisitor("VisitInterfacesWithResult(*Interfaces)")}

func (my *AbstractResultVisitor)     VisitInterfacesWithResultArgument(n *Interfaces, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfacesWithResultArgument(*Interfaces, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceTypeListWithResult(n *InterfaceTypeList) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceTypeListWithResult(*InterfaceTypeList)")}

func (my *AbstractResultVisitor)     VisitInterfaceTypeListWithResultArgument(n *InterfaceTypeList, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceTypeListWithResultArgument(*InterfaceTypeList, interface{})")}

func (my *AbstractResultVisitor)     VisitClassBodyWithResult(n *ClassBody) interface{}{ return  my.UnimplementedVisitor("VisitClassBodyWithResult(*ClassBody)")}

func (my *AbstractResultVisitor)     VisitClassBodyWithResultArgument(n *ClassBody, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassBodyWithResultArgument(*ClassBody, interface{})")}

func (my *AbstractResultVisitor)     VisitClassBodyDeclarationsWithResult(n *ClassBodyDeclarations) interface{}{ return  my.UnimplementedVisitor("VisitClassBodyDeclarationsWithResult(*ClassBodyDeclarations)")}

func (my *AbstractResultVisitor)     VisitClassBodyDeclarationsWithResultArgument(n *ClassBodyDeclarations, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassBodyDeclarationsWithResultArgument(*ClassBodyDeclarations, interface{})")}

func (my *AbstractResultVisitor)     VisitClassMemberDeclarationWithResult(n *ClassMemberDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitClassMemberDeclarationWithResult(*ClassMemberDeclaration)")}

func (my *AbstractResultVisitor)     VisitClassMemberDeclarationWithResultArgument(n *ClassMemberDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassMemberDeclarationWithResultArgument(*ClassMemberDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldDeclarationWithResult(n *FieldDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitFieldDeclarationWithResult(*FieldDeclaration)")}

func (my *AbstractResultVisitor)     VisitFieldDeclarationWithResultArgument(n *FieldDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldDeclarationWithResultArgument(*FieldDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitVariableDeclaratorsWithResult(n *VariableDeclarators) interface{}{ return  my.UnimplementedVisitor("VisitVariableDeclaratorsWithResult(*VariableDeclarators)")}

func (my *AbstractResultVisitor)     VisitVariableDeclaratorsWithResultArgument(n *VariableDeclarators, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitVariableDeclaratorsWithResultArgument(*VariableDeclarators, interface{})")}

func (my *AbstractResultVisitor)     VisitVariableDeclaratorWithResult(n *VariableDeclarator) interface{}{ return  my.UnimplementedVisitor("VisitVariableDeclaratorWithResult(*VariableDeclarator)")}

func (my *AbstractResultVisitor)     VisitVariableDeclaratorWithResultArgument(n *VariableDeclarator, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitVariableDeclaratorWithResultArgument(*VariableDeclarator, interface{})")}

func (my *AbstractResultVisitor)     VisitVariableDeclaratorIdWithResult(n *VariableDeclaratorId) interface{}{ return  my.UnimplementedVisitor("VisitVariableDeclaratorIdWithResult(*VariableDeclaratorId)")}

func (my *AbstractResultVisitor)     VisitVariableDeclaratorIdWithResultArgument(n *VariableDeclaratorId, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitVariableDeclaratorIdWithResultArgument(*VariableDeclaratorId, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldModifiersWithResult(n *FieldModifiers) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifiersWithResult(*FieldModifiers)")}

func (my *AbstractResultVisitor)     VisitFieldModifiersWithResultArgument(n *FieldModifiers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifiersWithResultArgument(*FieldModifiers, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodDeclarationWithResult(n *MethodDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitMethodDeclarationWithResult(*MethodDeclaration)")}

func (my *AbstractResultVisitor)     VisitMethodDeclarationWithResultArgument(n *MethodDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodDeclarationWithResultArgument(*MethodDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodHeaderWithResult(n *MethodHeader) interface{}{ return  my.UnimplementedVisitor("VisitMethodHeaderWithResult(*MethodHeader)")}

func (my *AbstractResultVisitor)     VisitMethodHeaderWithResultArgument(n *MethodHeader, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodHeaderWithResultArgument(*MethodHeader, interface{})")}

func (my *AbstractResultVisitor)     VisitResultTypeWithResult(n *ResultType) interface{}{ return  my.UnimplementedVisitor("VisitResultTypeWithResult(*ResultType)")}

func (my *AbstractResultVisitor)     VisitResultTypeWithResultArgument(n *ResultType, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitResultTypeWithResultArgument(*ResultType, interface{})")}

func (my *AbstractResultVisitor)     VisitFormalParameterListWithResult(n *FormalParameterList) interface{}{ return  my.UnimplementedVisitor("VisitFormalParameterListWithResult(*FormalParameterList)")}

func (my *AbstractResultVisitor)     VisitFormalParameterListWithResultArgument(n *FormalParameterList, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFormalParameterListWithResultArgument(*FormalParameterList, interface{})")}

func (my *AbstractResultVisitor)     VisitFormalParametersWithResult(n *FormalParameters) interface{}{ return  my.UnimplementedVisitor("VisitFormalParametersWithResult(*FormalParameters)")}

func (my *AbstractResultVisitor)     VisitFormalParametersWithResultArgument(n *FormalParameters, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFormalParametersWithResultArgument(*FormalParameters, interface{})")}

func (my *AbstractResultVisitor)     VisitFormalParameterWithResult(n *FormalParameter) interface{}{ return  my.UnimplementedVisitor("VisitFormalParameterWithResult(*FormalParameter)")}

func (my *AbstractResultVisitor)     VisitFormalParameterWithResultArgument(n *FormalParameter, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFormalParameterWithResultArgument(*FormalParameter, interface{})")}

func (my *AbstractResultVisitor)     VisitVariableModifiersWithResult(n *VariableModifiers) interface{}{ return  my.UnimplementedVisitor("VisitVariableModifiersWithResult(*VariableModifiers)")}

func (my *AbstractResultVisitor)     VisitVariableModifiersWithResultArgument(n *VariableModifiers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitVariableModifiersWithResultArgument(*VariableModifiers, interface{})")}

func (my *AbstractResultVisitor)     VisitVariableModifierWithResult(n *VariableModifier) interface{}{ return  my.UnimplementedVisitor("VisitVariableModifierWithResult(*VariableModifier)")}

func (my *AbstractResultVisitor)     VisitVariableModifierWithResultArgument(n *VariableModifier, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitVariableModifierWithResultArgument(*VariableModifier, interface{})")}

func (my *AbstractResultVisitor)     VisitLastFormalParameterWithResult(n *LastFormalParameter) interface{}{ return  my.UnimplementedVisitor("VisitLastFormalParameterWithResult(*LastFormalParameter)")}

func (my *AbstractResultVisitor)     VisitLastFormalParameterWithResultArgument(n *LastFormalParameter, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLastFormalParameterWithResultArgument(*LastFormalParameter, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifiersWithResult(n *MethodModifiers) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifiersWithResult(*MethodModifiers)")}

func (my *AbstractResultVisitor)     VisitMethodModifiersWithResultArgument(n *MethodModifiers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifiersWithResultArgument(*MethodModifiers, interface{})")}

func (my *AbstractResultVisitor)     VisitThrowsWithResult(n *Throws) interface{}{ return  my.UnimplementedVisitor("VisitThrowsWithResult(*Throws)")}

func (my *AbstractResultVisitor)     VisitThrowsWithResultArgument(n *Throws, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitThrowsWithResultArgument(*Throws, interface{})")}

func (my *AbstractResultVisitor)     VisitExceptionTypeListWithResult(n *ExceptionTypeList) interface{}{ return  my.UnimplementedVisitor("VisitExceptionTypeListWithResult(*ExceptionTypeList)")}

func (my *AbstractResultVisitor)     VisitExceptionTypeListWithResultArgument(n *ExceptionTypeList, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExceptionTypeListWithResultArgument(*ExceptionTypeList, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodBodyWithResult(n *MethodBody) interface{}{ return  my.UnimplementedVisitor("VisitMethodBodyWithResult(*MethodBody)")}

func (my *AbstractResultVisitor)     VisitMethodBodyWithResultArgument(n *MethodBody, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodBodyWithResultArgument(*MethodBody, interface{})")}

func (my *AbstractResultVisitor)     VisitStaticInitializerWithResult(n *StaticInitializer) interface{}{ return  my.UnimplementedVisitor("VisitStaticInitializerWithResult(*StaticInitializer)")}

func (my *AbstractResultVisitor)     VisitStaticInitializerWithResultArgument(n *StaticInitializer, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitStaticInitializerWithResultArgument(*StaticInitializer, interface{})")}

func (my *AbstractResultVisitor)     VisitConstructorDeclarationWithResult(n *ConstructorDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitConstructorDeclarationWithResult(*ConstructorDeclaration)")}

func (my *AbstractResultVisitor)     VisitConstructorDeclarationWithResultArgument(n *ConstructorDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstructorDeclarationWithResultArgument(*ConstructorDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitConstructorDeclaratorWithResult(n *ConstructorDeclarator) interface{}{ return  my.UnimplementedVisitor("VisitConstructorDeclaratorWithResult(*ConstructorDeclarator)")}

func (my *AbstractResultVisitor)     VisitConstructorDeclaratorWithResultArgument(n *ConstructorDeclarator, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstructorDeclaratorWithResultArgument(*ConstructorDeclarator, interface{})")}

func (my *AbstractResultVisitor)     VisitConstructorModifiersWithResult(n *ConstructorModifiers) interface{}{ return  my.UnimplementedVisitor("VisitConstructorModifiersWithResult(*ConstructorModifiers)")}

func (my *AbstractResultVisitor)     VisitConstructorModifiersWithResultArgument(n *ConstructorModifiers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstructorModifiersWithResultArgument(*ConstructorModifiers, interface{})")}

func (my *AbstractResultVisitor)     VisitConstructorBodyWithResult(n *ConstructorBody) interface{}{ return  my.UnimplementedVisitor("VisitConstructorBodyWithResult(*ConstructorBody)")}

func (my *AbstractResultVisitor)     VisitConstructorBodyWithResultArgument(n *ConstructorBody, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstructorBodyWithResultArgument(*ConstructorBody, interface{})")}

func (my *AbstractResultVisitor)     VisitEnumDeclarationWithResult(n *EnumDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitEnumDeclarationWithResult(*EnumDeclaration)")}

func (my *AbstractResultVisitor)     VisitEnumDeclarationWithResultArgument(n *EnumDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEnumDeclarationWithResultArgument(*EnumDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitEnumBodyWithResult(n *EnumBody) interface{}{ return  my.UnimplementedVisitor("VisitEnumBodyWithResult(*EnumBody)")}

func (my *AbstractResultVisitor)     VisitEnumBodyWithResultArgument(n *EnumBody, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEnumBodyWithResultArgument(*EnumBody, interface{})")}

func (my *AbstractResultVisitor)     VisitEnumConstantsWithResult(n *EnumConstants) interface{}{ return  my.UnimplementedVisitor("VisitEnumConstantsWithResult(*EnumConstants)")}

func (my *AbstractResultVisitor)     VisitEnumConstantsWithResultArgument(n *EnumConstants, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEnumConstantsWithResultArgument(*EnumConstants, interface{})")}

func (my *AbstractResultVisitor)     VisitEnumConstantWithResult(n *EnumConstant) interface{}{ return  my.UnimplementedVisitor("VisitEnumConstantWithResult(*EnumConstant)")}

func (my *AbstractResultVisitor)     VisitEnumConstantWithResultArgument(n *EnumConstant, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEnumConstantWithResultArgument(*EnumConstant, interface{})")}

func (my *AbstractResultVisitor)     VisitArgumentsWithResult(n *Arguments) interface{}{ return  my.UnimplementedVisitor("VisitArgumentsWithResult(*Arguments)")}

func (my *AbstractResultVisitor)     VisitArgumentsWithResultArgument(n *Arguments, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArgumentsWithResultArgument(*Arguments, interface{})")}

func (my *AbstractResultVisitor)     VisitEnumBodyDeclarationsWithResult(n *EnumBodyDeclarations) interface{}{ return  my.UnimplementedVisitor("VisitEnumBodyDeclarationsWithResult(*EnumBodyDeclarations)")}

func (my *AbstractResultVisitor)     VisitEnumBodyDeclarationsWithResultArgument(n *EnumBodyDeclarations, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEnumBodyDeclarationsWithResultArgument(*EnumBodyDeclarations, interface{})")}

func (my *AbstractResultVisitor)     VisitNormalInterfaceDeclarationWithResult(n *NormalInterfaceDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitNormalInterfaceDeclarationWithResult(*NormalInterfaceDeclaration)")}

func (my *AbstractResultVisitor)     VisitNormalInterfaceDeclarationWithResultArgument(n *NormalInterfaceDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitNormalInterfaceDeclarationWithResultArgument(*NormalInterfaceDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceModifiersWithResult(n *InterfaceModifiers) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifiersWithResult(*InterfaceModifiers)")}

func (my *AbstractResultVisitor)     VisitInterfaceModifiersWithResultArgument(n *InterfaceModifiers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifiersWithResultArgument(*InterfaceModifiers, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceBodyWithResult(n *InterfaceBody) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceBodyWithResult(*InterfaceBody)")}

func (my *AbstractResultVisitor)     VisitInterfaceBodyWithResultArgument(n *InterfaceBody, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceBodyWithResultArgument(*InterfaceBody, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceMemberDeclarationsWithResult(n *InterfaceMemberDeclarations) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceMemberDeclarationsWithResult(*InterfaceMemberDeclarations)")}

func (my *AbstractResultVisitor)     VisitInterfaceMemberDeclarationsWithResultArgument(n *InterfaceMemberDeclarations, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceMemberDeclarationsWithResultArgument(*InterfaceMemberDeclarations, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceMemberDeclarationWithResult(n *InterfaceMemberDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceMemberDeclarationWithResult(*InterfaceMemberDeclaration)")}

func (my *AbstractResultVisitor)     VisitInterfaceMemberDeclarationWithResultArgument(n *InterfaceMemberDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceMemberDeclarationWithResultArgument(*InterfaceMemberDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitConstantDeclarationWithResult(n *ConstantDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitConstantDeclarationWithResult(*ConstantDeclaration)")}

func (my *AbstractResultVisitor)     VisitConstantDeclarationWithResultArgument(n *ConstantDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstantDeclarationWithResultArgument(*ConstantDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitConstantModifiersWithResult(n *ConstantModifiers) interface{}{ return  my.UnimplementedVisitor("VisitConstantModifiersWithResult(*ConstantModifiers)")}

func (my *AbstractResultVisitor)     VisitConstantModifiersWithResultArgument(n *ConstantModifiers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstantModifiersWithResultArgument(*ConstantModifiers, interface{})")}

func (my *AbstractResultVisitor)     VisitAbstractMethodDeclarationWithResult(n *AbstractMethodDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitAbstractMethodDeclarationWithResult(*AbstractMethodDeclaration)")}

func (my *AbstractResultVisitor)     VisitAbstractMethodDeclarationWithResultArgument(n *AbstractMethodDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAbstractMethodDeclarationWithResultArgument(*AbstractMethodDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitAbstractMethodModifiersWithResult(n *AbstractMethodModifiers) interface{}{ return  my.UnimplementedVisitor("VisitAbstractMethodModifiersWithResult(*AbstractMethodModifiers)")}

func (my *AbstractResultVisitor)     VisitAbstractMethodModifiersWithResultArgument(n *AbstractMethodModifiers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAbstractMethodModifiersWithResultArgument(*AbstractMethodModifiers, interface{})")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeDeclarationWithResult(n *AnnotationTypeDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeDeclarationWithResult(*AnnotationTypeDeclaration)")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeDeclarationWithResultArgument(n *AnnotationTypeDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeDeclarationWithResultArgument(*AnnotationTypeDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeBodyWithResult(n *AnnotationTypeBody) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeBodyWithResult(*AnnotationTypeBody)")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeBodyWithResultArgument(n *AnnotationTypeBody, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeBodyWithResultArgument(*AnnotationTypeBody, interface{})")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeElementDeclarationsWithResult(n *AnnotationTypeElementDeclarations) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeElementDeclarationsWithResult(*AnnotationTypeElementDeclarations)")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeElementDeclarationsWithResultArgument(n *AnnotationTypeElementDeclarations, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeElementDeclarationsWithResultArgument(*AnnotationTypeElementDeclarations, interface{})")}

func (my *AbstractResultVisitor)     VisitDefaultValueWithResult(n *DefaultValue) interface{}{ return  my.UnimplementedVisitor("VisitDefaultValueWithResult(*DefaultValue)")}

func (my *AbstractResultVisitor)     VisitDefaultValueWithResultArgument(n *DefaultValue, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitDefaultValueWithResultArgument(*DefaultValue, interface{})")}

func (my *AbstractResultVisitor)     VisitAnnotationsWithResult(n *Annotations) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationsWithResult(*Annotations)")}

func (my *AbstractResultVisitor)     VisitAnnotationsWithResultArgument(n *Annotations, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationsWithResultArgument(*Annotations, interface{})")}

func (my *AbstractResultVisitor)     VisitNormalAnnotationWithResult(n *NormalAnnotation) interface{}{ return  my.UnimplementedVisitor("VisitNormalAnnotationWithResult(*NormalAnnotation)")}

func (my *AbstractResultVisitor)     VisitNormalAnnotationWithResultArgument(n *NormalAnnotation, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitNormalAnnotationWithResultArgument(*NormalAnnotation, interface{})")}

func (my *AbstractResultVisitor)     VisitElementValuePairsWithResult(n *ElementValuePairs) interface{}{ return  my.UnimplementedVisitor("VisitElementValuePairsWithResult(*ElementValuePairs)")}

func (my *AbstractResultVisitor)     VisitElementValuePairsWithResultArgument(n *ElementValuePairs, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitElementValuePairsWithResultArgument(*ElementValuePairs, interface{})")}

func (my *AbstractResultVisitor)     VisitElementValuePairWithResult(n *ElementValuePair) interface{}{ return  my.UnimplementedVisitor("VisitElementValuePairWithResult(*ElementValuePair)")}

func (my *AbstractResultVisitor)     VisitElementValuePairWithResultArgument(n *ElementValuePair, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitElementValuePairWithResultArgument(*ElementValuePair, interface{})")}

func (my *AbstractResultVisitor)     VisitElementValueArrayInitializerWithResult(n *ElementValueArrayInitializer) interface{}{ return  my.UnimplementedVisitor("VisitElementValueArrayInitializerWithResult(*ElementValueArrayInitializer)")}

func (my *AbstractResultVisitor)     VisitElementValueArrayInitializerWithResultArgument(n *ElementValueArrayInitializer, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitElementValueArrayInitializerWithResultArgument(*ElementValueArrayInitializer, interface{})")}

func (my *AbstractResultVisitor)     VisitElementValuesWithResult(n *ElementValues) interface{}{ return  my.UnimplementedVisitor("VisitElementValuesWithResult(*ElementValues)")}

func (my *AbstractResultVisitor)     VisitElementValuesWithResultArgument(n *ElementValues, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitElementValuesWithResultArgument(*ElementValues, interface{})")}

func (my *AbstractResultVisitor)     VisitMarkerAnnotationWithResult(n *MarkerAnnotation) interface{}{ return  my.UnimplementedVisitor("VisitMarkerAnnotationWithResult(*MarkerAnnotation)")}

func (my *AbstractResultVisitor)     VisitMarkerAnnotationWithResultArgument(n *MarkerAnnotation, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMarkerAnnotationWithResultArgument(*MarkerAnnotation, interface{})")}

func (my *AbstractResultVisitor)     VisitSingleElementAnnotationWithResult(n *SingleElementAnnotation) interface{}{ return  my.UnimplementedVisitor("VisitSingleElementAnnotationWithResult(*SingleElementAnnotation)")}

func (my *AbstractResultVisitor)     VisitSingleElementAnnotationWithResultArgument(n *SingleElementAnnotation, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSingleElementAnnotationWithResultArgument(*SingleElementAnnotation, interface{})")}

func (my *AbstractResultVisitor)     VisitArrayInitializerWithResult(n *ArrayInitializer) interface{}{ return  my.UnimplementedVisitor("VisitArrayInitializerWithResult(*ArrayInitializer)")}

func (my *AbstractResultVisitor)     VisitArrayInitializerWithResultArgument(n *ArrayInitializer, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArrayInitializerWithResultArgument(*ArrayInitializer, interface{})")}

func (my *AbstractResultVisitor)     VisitVariableInitializersWithResult(n *VariableInitializers) interface{}{ return  my.UnimplementedVisitor("VisitVariableInitializersWithResult(*VariableInitializers)")}

func (my *AbstractResultVisitor)     VisitVariableInitializersWithResultArgument(n *VariableInitializers, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitVariableInitializersWithResultArgument(*VariableInitializers, interface{})")}

func (my *AbstractResultVisitor)     VisitBlockWithResult(n *Block) interface{}{ return  my.UnimplementedVisitor("VisitBlockWithResult(*Block)")}

func (my *AbstractResultVisitor)     VisitBlockWithResultArgument(n *Block, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitBlockWithResultArgument(*Block, interface{})")}

func (my *AbstractResultVisitor)     VisitBlockStatementsWithResult(n *BlockStatements) interface{}{ return  my.UnimplementedVisitor("VisitBlockStatementsWithResult(*BlockStatements)")}

func (my *AbstractResultVisitor)     VisitBlockStatementsWithResultArgument(n *BlockStatements, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitBlockStatementsWithResultArgument(*BlockStatements, interface{})")}

func (my *AbstractResultVisitor)     VisitLocalVariableDeclarationStatementWithResult(n *LocalVariableDeclarationStatement) interface{}{ return  my.UnimplementedVisitor("VisitLocalVariableDeclarationStatementWithResult(*LocalVariableDeclarationStatement)")}

func (my *AbstractResultVisitor)     VisitLocalVariableDeclarationStatementWithResultArgument(n *LocalVariableDeclarationStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLocalVariableDeclarationStatementWithResultArgument(*LocalVariableDeclarationStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitLocalVariableDeclarationWithResult(n *LocalVariableDeclaration) interface{}{ return  my.UnimplementedVisitor("VisitLocalVariableDeclarationWithResult(*LocalVariableDeclaration)")}

func (my *AbstractResultVisitor)     VisitLocalVariableDeclarationWithResultArgument(n *LocalVariableDeclaration, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLocalVariableDeclarationWithResultArgument(*LocalVariableDeclaration, interface{})")}

func (my *AbstractResultVisitor)     VisitIfThenStatementWithResult(n *IfThenStatement) interface{}{ return  my.UnimplementedVisitor("VisitIfThenStatementWithResult(*IfThenStatement)")}

func (my *AbstractResultVisitor)     VisitIfThenStatementWithResultArgument(n *IfThenStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitIfThenStatementWithResultArgument(*IfThenStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitIfThenElseStatementWithResult(n *IfThenElseStatement) interface{}{ return  my.UnimplementedVisitor("VisitIfThenElseStatementWithResult(*IfThenElseStatement)")}

func (my *AbstractResultVisitor)     VisitIfThenElseStatementWithResultArgument(n *IfThenElseStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitIfThenElseStatementWithResultArgument(*IfThenElseStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitIfThenElseStatementNoShortIfWithResult(n *IfThenElseStatementNoShortIf) interface{}{ return  my.UnimplementedVisitor("VisitIfThenElseStatementNoShortIfWithResult(*IfThenElseStatementNoShortIf)")}

func (my *AbstractResultVisitor)     VisitIfThenElseStatementNoShortIfWithResultArgument(n *IfThenElseStatementNoShortIf, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitIfThenElseStatementNoShortIfWithResultArgument(*IfThenElseStatementNoShortIf, interface{})")}

func (my *AbstractResultVisitor)     VisitEmptyStatementWithResult(n *EmptyStatement) interface{}{ return  my.UnimplementedVisitor("VisitEmptyStatementWithResult(*EmptyStatement)")}

func (my *AbstractResultVisitor)     VisitEmptyStatementWithResultArgument(n *EmptyStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEmptyStatementWithResultArgument(*EmptyStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitLabeledStatementWithResult(n *LabeledStatement) interface{}{ return  my.UnimplementedVisitor("VisitLabeledStatementWithResult(*LabeledStatement)")}

func (my *AbstractResultVisitor)     VisitLabeledStatementWithResultArgument(n *LabeledStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLabeledStatementWithResultArgument(*LabeledStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitLabeledStatementNoShortIfWithResult(n *LabeledStatementNoShortIf) interface{}{ return  my.UnimplementedVisitor("VisitLabeledStatementNoShortIfWithResult(*LabeledStatementNoShortIf)")}

func (my *AbstractResultVisitor)     VisitLabeledStatementNoShortIfWithResultArgument(n *LabeledStatementNoShortIf, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLabeledStatementNoShortIfWithResultArgument(*LabeledStatementNoShortIf, interface{})")}

func (my *AbstractResultVisitor)     VisitExpressionStatementWithResult(n *ExpressionStatement) interface{}{ return  my.UnimplementedVisitor("VisitExpressionStatementWithResult(*ExpressionStatement)")}

func (my *AbstractResultVisitor)     VisitExpressionStatementWithResultArgument(n *ExpressionStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExpressionStatementWithResultArgument(*ExpressionStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitSwitchStatementWithResult(n *SwitchStatement) interface{}{ return  my.UnimplementedVisitor("VisitSwitchStatementWithResult(*SwitchStatement)")}

func (my *AbstractResultVisitor)     VisitSwitchStatementWithResultArgument(n *SwitchStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSwitchStatementWithResultArgument(*SwitchStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitSwitchBlockWithResult(n *SwitchBlock) interface{}{ return  my.UnimplementedVisitor("VisitSwitchBlockWithResult(*SwitchBlock)")}

func (my *AbstractResultVisitor)     VisitSwitchBlockWithResultArgument(n *SwitchBlock, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSwitchBlockWithResultArgument(*SwitchBlock, interface{})")}

func (my *AbstractResultVisitor)     VisitSwitchBlockStatementGroupsWithResult(n *SwitchBlockStatementGroups) interface{}{ return  my.UnimplementedVisitor("VisitSwitchBlockStatementGroupsWithResult(*SwitchBlockStatementGroups)")}

func (my *AbstractResultVisitor)     VisitSwitchBlockStatementGroupsWithResultArgument(n *SwitchBlockStatementGroups, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSwitchBlockStatementGroupsWithResultArgument(*SwitchBlockStatementGroups, interface{})")}

func (my *AbstractResultVisitor)     VisitSwitchBlockStatementGroupWithResult(n *SwitchBlockStatementGroup) interface{}{ return  my.UnimplementedVisitor("VisitSwitchBlockStatementGroupWithResult(*SwitchBlockStatementGroup)")}

func (my *AbstractResultVisitor)     VisitSwitchBlockStatementGroupWithResultArgument(n *SwitchBlockStatementGroup, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSwitchBlockStatementGroupWithResultArgument(*SwitchBlockStatementGroup, interface{})")}

func (my *AbstractResultVisitor)     VisitSwitchLabelsWithResult(n *SwitchLabels) interface{}{ return  my.UnimplementedVisitor("VisitSwitchLabelsWithResult(*SwitchLabels)")}

func (my *AbstractResultVisitor)     VisitSwitchLabelsWithResultArgument(n *SwitchLabels, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSwitchLabelsWithResultArgument(*SwitchLabels, interface{})")}

func (my *AbstractResultVisitor)     VisitWhileStatementWithResult(n *WhileStatement) interface{}{ return  my.UnimplementedVisitor("VisitWhileStatementWithResult(*WhileStatement)")}

func (my *AbstractResultVisitor)     VisitWhileStatementWithResultArgument(n *WhileStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitWhileStatementWithResultArgument(*WhileStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitWhileStatementNoShortIfWithResult(n *WhileStatementNoShortIf) interface{}{ return  my.UnimplementedVisitor("VisitWhileStatementNoShortIfWithResult(*WhileStatementNoShortIf)")}

func (my *AbstractResultVisitor)     VisitWhileStatementNoShortIfWithResultArgument(n *WhileStatementNoShortIf, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitWhileStatementNoShortIfWithResultArgument(*WhileStatementNoShortIf, interface{})")}

func (my *AbstractResultVisitor)     VisitDoStatementWithResult(n *DoStatement) interface{}{ return  my.UnimplementedVisitor("VisitDoStatementWithResult(*DoStatement)")}

func (my *AbstractResultVisitor)     VisitDoStatementWithResultArgument(n *DoStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitDoStatementWithResultArgument(*DoStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitBasicForStatementWithResult(n *BasicForStatement) interface{}{ return  my.UnimplementedVisitor("VisitBasicForStatementWithResult(*BasicForStatement)")}

func (my *AbstractResultVisitor)     VisitBasicForStatementWithResultArgument(n *BasicForStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitBasicForStatementWithResultArgument(*BasicForStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitForStatementNoShortIfWithResult(n *ForStatementNoShortIf) interface{}{ return  my.UnimplementedVisitor("VisitForStatementNoShortIfWithResult(*ForStatementNoShortIf)")}

func (my *AbstractResultVisitor)     VisitForStatementNoShortIfWithResultArgument(n *ForStatementNoShortIf, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitForStatementNoShortIfWithResultArgument(*ForStatementNoShortIf, interface{})")}

func (my *AbstractResultVisitor)     VisitStatementExpressionListWithResult(n *StatementExpressionList) interface{}{ return  my.UnimplementedVisitor("VisitStatementExpressionListWithResult(*StatementExpressionList)")}

func (my *AbstractResultVisitor)     VisitStatementExpressionListWithResultArgument(n *StatementExpressionList, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitStatementExpressionListWithResultArgument(*StatementExpressionList, interface{})")}

func (my *AbstractResultVisitor)     VisitEnhancedForStatementWithResult(n *EnhancedForStatement) interface{}{ return  my.UnimplementedVisitor("VisitEnhancedForStatementWithResult(*EnhancedForStatement)")}

func (my *AbstractResultVisitor)     VisitEnhancedForStatementWithResultArgument(n *EnhancedForStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEnhancedForStatementWithResultArgument(*EnhancedForStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitBreakStatementWithResult(n *BreakStatement) interface{}{ return  my.UnimplementedVisitor("VisitBreakStatementWithResult(*BreakStatement)")}

func (my *AbstractResultVisitor)     VisitBreakStatementWithResultArgument(n *BreakStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitBreakStatementWithResultArgument(*BreakStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitContinueStatementWithResult(n *ContinueStatement) interface{}{ return  my.UnimplementedVisitor("VisitContinueStatementWithResult(*ContinueStatement)")}

func (my *AbstractResultVisitor)     VisitContinueStatementWithResultArgument(n *ContinueStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitContinueStatementWithResultArgument(*ContinueStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitReturnStatementWithResult(n *ReturnStatement) interface{}{ return  my.UnimplementedVisitor("VisitReturnStatementWithResult(*ReturnStatement)")}

func (my *AbstractResultVisitor)     VisitReturnStatementWithResultArgument(n *ReturnStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitReturnStatementWithResultArgument(*ReturnStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitThrowStatementWithResult(n *ThrowStatement) interface{}{ return  my.UnimplementedVisitor("VisitThrowStatementWithResult(*ThrowStatement)")}

func (my *AbstractResultVisitor)     VisitThrowStatementWithResultArgument(n *ThrowStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitThrowStatementWithResultArgument(*ThrowStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitSynchronizedStatementWithResult(n *SynchronizedStatement) interface{}{ return  my.UnimplementedVisitor("VisitSynchronizedStatementWithResult(*SynchronizedStatement)")}

func (my *AbstractResultVisitor)     VisitSynchronizedStatementWithResultArgument(n *SynchronizedStatement, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSynchronizedStatementWithResultArgument(*SynchronizedStatement, interface{})")}

func (my *AbstractResultVisitor)     VisitCatchesWithResult(n *Catches) interface{}{ return  my.UnimplementedVisitor("VisitCatchesWithResult(*Catches)")}

func (my *AbstractResultVisitor)     VisitCatchesWithResultArgument(n *Catches, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitCatchesWithResultArgument(*Catches, interface{})")}

func (my *AbstractResultVisitor)     VisitCatchClauseWithResult(n *CatchClause) interface{}{ return  my.UnimplementedVisitor("VisitCatchClauseWithResult(*CatchClause)")}

func (my *AbstractResultVisitor)     VisitCatchClauseWithResultArgument(n *CatchClause, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitCatchClauseWithResultArgument(*CatchClause, interface{})")}

func (my *AbstractResultVisitor)     VisitFinallyWithResult(n *Finally) interface{}{ return  my.UnimplementedVisitor("VisitFinallyWithResult(*Finally)")}

func (my *AbstractResultVisitor)     VisitFinallyWithResultArgument(n *Finally, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFinallyWithResultArgument(*Finally, interface{})")}

func (my *AbstractResultVisitor)     VisitArgumentListWithResult(n *ArgumentList) interface{}{ return  my.UnimplementedVisitor("VisitArgumentListWithResult(*ArgumentList)")}

func (my *AbstractResultVisitor)     VisitArgumentListWithResultArgument(n *ArgumentList, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArgumentListWithResultArgument(*ArgumentList, interface{})")}

func (my *AbstractResultVisitor)     VisitDimExprsWithResult(n *DimExprs) interface{}{ return  my.UnimplementedVisitor("VisitDimExprsWithResult(*DimExprs)")}

func (my *AbstractResultVisitor)     VisitDimExprsWithResultArgument(n *DimExprs, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitDimExprsWithResultArgument(*DimExprs, interface{})")}

func (my *AbstractResultVisitor)     VisitDimExprWithResult(n *DimExpr) interface{}{ return  my.UnimplementedVisitor("VisitDimExprWithResult(*DimExpr)")}

func (my *AbstractResultVisitor)     VisitDimExprWithResultArgument(n *DimExpr, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitDimExprWithResultArgument(*DimExpr, interface{})")}

func (my *AbstractResultVisitor)     VisitPostIncrementExpressionWithResult(n *PostIncrementExpression) interface{}{ return  my.UnimplementedVisitor("VisitPostIncrementExpressionWithResult(*PostIncrementExpression)")}

func (my *AbstractResultVisitor)     VisitPostIncrementExpressionWithResultArgument(n *PostIncrementExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPostIncrementExpressionWithResultArgument(*PostIncrementExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitPostDecrementExpressionWithResult(n *PostDecrementExpression) interface{}{ return  my.UnimplementedVisitor("VisitPostDecrementExpressionWithResult(*PostDecrementExpression)")}

func (my *AbstractResultVisitor)     VisitPostDecrementExpressionWithResultArgument(n *PostDecrementExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPostDecrementExpressionWithResultArgument(*PostDecrementExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitPreIncrementExpressionWithResult(n *PreIncrementExpression) interface{}{ return  my.UnimplementedVisitor("VisitPreIncrementExpressionWithResult(*PreIncrementExpression)")}

func (my *AbstractResultVisitor)     VisitPreIncrementExpressionWithResultArgument(n *PreIncrementExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPreIncrementExpressionWithResultArgument(*PreIncrementExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitPreDecrementExpressionWithResult(n *PreDecrementExpression) interface{}{ return  my.UnimplementedVisitor("VisitPreDecrementExpressionWithResult(*PreDecrementExpression)")}

func (my *AbstractResultVisitor)     VisitPreDecrementExpressionWithResultArgument(n *PreDecrementExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPreDecrementExpressionWithResultArgument(*PreDecrementExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitAndExpressionWithResult(n *AndExpression) interface{}{ return  my.UnimplementedVisitor("VisitAndExpressionWithResult(*AndExpression)")}

func (my *AbstractResultVisitor)     VisitAndExpressionWithResultArgument(n *AndExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAndExpressionWithResultArgument(*AndExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitExclusiveOrExpressionWithResult(n *ExclusiveOrExpression) interface{}{ return  my.UnimplementedVisitor("VisitExclusiveOrExpressionWithResult(*ExclusiveOrExpression)")}

func (my *AbstractResultVisitor)     VisitExclusiveOrExpressionWithResultArgument(n *ExclusiveOrExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExclusiveOrExpressionWithResultArgument(*ExclusiveOrExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitInclusiveOrExpressionWithResult(n *InclusiveOrExpression) interface{}{ return  my.UnimplementedVisitor("VisitInclusiveOrExpressionWithResult(*InclusiveOrExpression)")}

func (my *AbstractResultVisitor)     VisitInclusiveOrExpressionWithResultArgument(n *InclusiveOrExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInclusiveOrExpressionWithResultArgument(*InclusiveOrExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitConditionalAndExpressionWithResult(n *ConditionalAndExpression) interface{}{ return  my.UnimplementedVisitor("VisitConditionalAndExpressionWithResult(*ConditionalAndExpression)")}

func (my *AbstractResultVisitor)     VisitConditionalAndExpressionWithResultArgument(n *ConditionalAndExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConditionalAndExpressionWithResultArgument(*ConditionalAndExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitConditionalOrExpressionWithResult(n *ConditionalOrExpression) interface{}{ return  my.UnimplementedVisitor("VisitConditionalOrExpressionWithResult(*ConditionalOrExpression)")}

func (my *AbstractResultVisitor)     VisitConditionalOrExpressionWithResultArgument(n *ConditionalOrExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConditionalOrExpressionWithResultArgument(*ConditionalOrExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitConditionalExpressionWithResult(n *ConditionalExpression) interface{}{ return  my.UnimplementedVisitor("VisitConditionalExpressionWithResult(*ConditionalExpression)")}

func (my *AbstractResultVisitor)     VisitConditionalExpressionWithResultArgument(n *ConditionalExpression, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConditionalExpressionWithResultArgument(*ConditionalExpression, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentWithResult(n *Assignment) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentWithResult(*Assignment)")}

func (my *AbstractResultVisitor)     VisitAssignmentWithResultArgument(n *Assignment, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentWithResultArgument(*Assignment, interface{})")}

func (my *AbstractResultVisitor)     VisitCommaoptWithResult(n *Commaopt) interface{}{ return  my.UnimplementedVisitor("VisitCommaoptWithResult(*Commaopt)")}

func (my *AbstractResultVisitor)     VisitCommaoptWithResultArgument(n *Commaopt, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitCommaoptWithResultArgument(*Commaopt, interface{})")}

func (my *AbstractResultVisitor)     VisitEllipsisoptWithResult(n *Ellipsisopt) interface{}{ return  my.UnimplementedVisitor("VisitEllipsisoptWithResult(*Ellipsisopt)")}

func (my *AbstractResultVisitor)     VisitEllipsisoptWithResultArgument(n *Ellipsisopt, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEllipsisoptWithResultArgument(*Ellipsisopt, interface{})")}

func (my *AbstractResultVisitor)     VisitLPGUserAction0WithResult(n *LPGUserAction0) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction0WithResult(*LPGUserAction0)")}

func (my *AbstractResultVisitor)     VisitLPGUserAction0WithResultArgument(n *LPGUserAction0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction0WithResultArgument(*LPGUserAction0, interface{})")}

func (my *AbstractResultVisitor)     VisitLPGUserAction1WithResult(n *LPGUserAction1) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction1WithResult(*LPGUserAction1)")}

func (my *AbstractResultVisitor)     VisitLPGUserAction1WithResultArgument(n *LPGUserAction1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction1WithResultArgument(*LPGUserAction1, interface{})")}

func (my *AbstractResultVisitor)     VisitLPGUserAction2WithResult(n *LPGUserAction2) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction2WithResult(*LPGUserAction2)")}

func (my *AbstractResultVisitor)     VisitLPGUserAction2WithResultArgument(n *LPGUserAction2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction2WithResultArgument(*LPGUserAction2, interface{})")}

func (my *AbstractResultVisitor)     VisitLPGUserAction3WithResult(n *LPGUserAction3) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction3WithResult(*LPGUserAction3)")}

func (my *AbstractResultVisitor)     VisitLPGUserAction3WithResultArgument(n *LPGUserAction3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction3WithResultArgument(*LPGUserAction3, interface{})")}

func (my *AbstractResultVisitor)     VisitLPGUserAction4WithResult(n *LPGUserAction4) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction4WithResult(*LPGUserAction4)")}

func (my *AbstractResultVisitor)     VisitLPGUserAction4WithResultArgument(n *LPGUserAction4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLPGUserAction4WithResultArgument(*LPGUserAction4, interface{})")}

func (my *AbstractResultVisitor)     VisitIntegralType0WithResult(n *IntegralType0) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType0WithResult(*IntegralType0)")}

func (my *AbstractResultVisitor)     VisitIntegralType0WithResultArgument(n *IntegralType0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType0WithResultArgument(*IntegralType0, interface{})")}

func (my *AbstractResultVisitor)     VisitIntegralType1WithResult(n *IntegralType1) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType1WithResult(*IntegralType1)")}

func (my *AbstractResultVisitor)     VisitIntegralType1WithResultArgument(n *IntegralType1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType1WithResultArgument(*IntegralType1, interface{})")}

func (my *AbstractResultVisitor)     VisitIntegralType2WithResult(n *IntegralType2) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType2WithResult(*IntegralType2)")}

func (my *AbstractResultVisitor)     VisitIntegralType2WithResultArgument(n *IntegralType2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType2WithResultArgument(*IntegralType2, interface{})")}

func (my *AbstractResultVisitor)     VisitIntegralType3WithResult(n *IntegralType3) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType3WithResult(*IntegralType3)")}

func (my *AbstractResultVisitor)     VisitIntegralType3WithResultArgument(n *IntegralType3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType3WithResultArgument(*IntegralType3, interface{})")}

func (my *AbstractResultVisitor)     VisitIntegralType4WithResult(n *IntegralType4) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType4WithResult(*IntegralType4)")}

func (my *AbstractResultVisitor)     VisitIntegralType4WithResultArgument(n *IntegralType4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitIntegralType4WithResultArgument(*IntegralType4, interface{})")}

func (my *AbstractResultVisitor)     VisitFloatingPointType0WithResult(n *FloatingPointType0) interface{}{ return  my.UnimplementedVisitor("VisitFloatingPointType0WithResult(*FloatingPointType0)")}

func (my *AbstractResultVisitor)     VisitFloatingPointType0WithResultArgument(n *FloatingPointType0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFloatingPointType0WithResultArgument(*FloatingPointType0, interface{})")}

func (my *AbstractResultVisitor)     VisitFloatingPointType1WithResult(n *FloatingPointType1) interface{}{ return  my.UnimplementedVisitor("VisitFloatingPointType1WithResult(*FloatingPointType1)")}

func (my *AbstractResultVisitor)     VisitFloatingPointType1WithResultArgument(n *FloatingPointType1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFloatingPointType1WithResultArgument(*FloatingPointType1, interface{})")}

func (my *AbstractResultVisitor)     VisitWildcardBounds0WithResult(n *WildcardBounds0) interface{}{ return  my.UnimplementedVisitor("VisitWildcardBounds0WithResult(*WildcardBounds0)")}

func (my *AbstractResultVisitor)     VisitWildcardBounds0WithResultArgument(n *WildcardBounds0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitWildcardBounds0WithResultArgument(*WildcardBounds0, interface{})")}

func (my *AbstractResultVisitor)     VisitWildcardBounds1WithResult(n *WildcardBounds1) interface{}{ return  my.UnimplementedVisitor("VisitWildcardBounds1WithResult(*WildcardBounds1)")}

func (my *AbstractResultVisitor)     VisitWildcardBounds1WithResultArgument(n *WildcardBounds1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitWildcardBounds1WithResultArgument(*WildcardBounds1, interface{})")}

func (my *AbstractResultVisitor)     VisitClassModifier0WithResult(n *ClassModifier0) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier0WithResult(*ClassModifier0)")}

func (my *AbstractResultVisitor)     VisitClassModifier0WithResultArgument(n *ClassModifier0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier0WithResultArgument(*ClassModifier0, interface{})")}

func (my *AbstractResultVisitor)     VisitClassModifier1WithResult(n *ClassModifier1) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier1WithResult(*ClassModifier1)")}

func (my *AbstractResultVisitor)     VisitClassModifier1WithResultArgument(n *ClassModifier1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier1WithResultArgument(*ClassModifier1, interface{})")}

func (my *AbstractResultVisitor)     VisitClassModifier2WithResult(n *ClassModifier2) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier2WithResult(*ClassModifier2)")}

func (my *AbstractResultVisitor)     VisitClassModifier2WithResultArgument(n *ClassModifier2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier2WithResultArgument(*ClassModifier2, interface{})")}

func (my *AbstractResultVisitor)     VisitClassModifier3WithResult(n *ClassModifier3) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier3WithResult(*ClassModifier3)")}

func (my *AbstractResultVisitor)     VisitClassModifier3WithResultArgument(n *ClassModifier3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier3WithResultArgument(*ClassModifier3, interface{})")}

func (my *AbstractResultVisitor)     VisitClassModifier4WithResult(n *ClassModifier4) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier4WithResult(*ClassModifier4)")}

func (my *AbstractResultVisitor)     VisitClassModifier4WithResultArgument(n *ClassModifier4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier4WithResultArgument(*ClassModifier4, interface{})")}

func (my *AbstractResultVisitor)     VisitClassModifier5WithResult(n *ClassModifier5) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier5WithResult(*ClassModifier5)")}

func (my *AbstractResultVisitor)     VisitClassModifier5WithResultArgument(n *ClassModifier5, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier5WithResultArgument(*ClassModifier5, interface{})")}

func (my *AbstractResultVisitor)     VisitClassModifier6WithResult(n *ClassModifier6) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier6WithResult(*ClassModifier6)")}

func (my *AbstractResultVisitor)     VisitClassModifier6WithResultArgument(n *ClassModifier6, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassModifier6WithResultArgument(*ClassModifier6, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldModifier0WithResult(n *FieldModifier0) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier0WithResult(*FieldModifier0)")}

func (my *AbstractResultVisitor)     VisitFieldModifier0WithResultArgument(n *FieldModifier0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier0WithResultArgument(*FieldModifier0, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldModifier1WithResult(n *FieldModifier1) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier1WithResult(*FieldModifier1)")}

func (my *AbstractResultVisitor)     VisitFieldModifier1WithResultArgument(n *FieldModifier1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier1WithResultArgument(*FieldModifier1, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldModifier2WithResult(n *FieldModifier2) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier2WithResult(*FieldModifier2)")}

func (my *AbstractResultVisitor)     VisitFieldModifier2WithResultArgument(n *FieldModifier2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier2WithResultArgument(*FieldModifier2, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldModifier3WithResult(n *FieldModifier3) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier3WithResult(*FieldModifier3)")}

func (my *AbstractResultVisitor)     VisitFieldModifier3WithResultArgument(n *FieldModifier3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier3WithResultArgument(*FieldModifier3, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldModifier4WithResult(n *FieldModifier4) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier4WithResult(*FieldModifier4)")}

func (my *AbstractResultVisitor)     VisitFieldModifier4WithResultArgument(n *FieldModifier4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier4WithResultArgument(*FieldModifier4, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldModifier5WithResult(n *FieldModifier5) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier5WithResult(*FieldModifier5)")}

func (my *AbstractResultVisitor)     VisitFieldModifier5WithResultArgument(n *FieldModifier5, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier5WithResultArgument(*FieldModifier5, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldModifier6WithResult(n *FieldModifier6) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier6WithResult(*FieldModifier6)")}

func (my *AbstractResultVisitor)     VisitFieldModifier6WithResultArgument(n *FieldModifier6, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldModifier6WithResultArgument(*FieldModifier6, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodDeclarator0WithResult(n *MethodDeclarator0) interface{}{ return  my.UnimplementedVisitor("VisitMethodDeclarator0WithResult(*MethodDeclarator0)")}

func (my *AbstractResultVisitor)     VisitMethodDeclarator0WithResultArgument(n *MethodDeclarator0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodDeclarator0WithResultArgument(*MethodDeclarator0, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodDeclarator1WithResult(n *MethodDeclarator1) interface{}{ return  my.UnimplementedVisitor("VisitMethodDeclarator1WithResult(*MethodDeclarator1)")}

func (my *AbstractResultVisitor)     VisitMethodDeclarator1WithResultArgument(n *MethodDeclarator1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodDeclarator1WithResultArgument(*MethodDeclarator1, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier0WithResult(n *MethodModifier0) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier0WithResult(*MethodModifier0)")}

func (my *AbstractResultVisitor)     VisitMethodModifier0WithResultArgument(n *MethodModifier0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier0WithResultArgument(*MethodModifier0, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier1WithResult(n *MethodModifier1) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier1WithResult(*MethodModifier1)")}

func (my *AbstractResultVisitor)     VisitMethodModifier1WithResultArgument(n *MethodModifier1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier1WithResultArgument(*MethodModifier1, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier2WithResult(n *MethodModifier2) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier2WithResult(*MethodModifier2)")}

func (my *AbstractResultVisitor)     VisitMethodModifier2WithResultArgument(n *MethodModifier2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier2WithResultArgument(*MethodModifier2, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier3WithResult(n *MethodModifier3) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier3WithResult(*MethodModifier3)")}

func (my *AbstractResultVisitor)     VisitMethodModifier3WithResultArgument(n *MethodModifier3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier3WithResultArgument(*MethodModifier3, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier4WithResult(n *MethodModifier4) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier4WithResult(*MethodModifier4)")}

func (my *AbstractResultVisitor)     VisitMethodModifier4WithResultArgument(n *MethodModifier4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier4WithResultArgument(*MethodModifier4, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier5WithResult(n *MethodModifier5) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier5WithResult(*MethodModifier5)")}

func (my *AbstractResultVisitor)     VisitMethodModifier5WithResultArgument(n *MethodModifier5, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier5WithResultArgument(*MethodModifier5, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier6WithResult(n *MethodModifier6) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier6WithResult(*MethodModifier6)")}

func (my *AbstractResultVisitor)     VisitMethodModifier6WithResultArgument(n *MethodModifier6, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier6WithResultArgument(*MethodModifier6, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier7WithResult(n *MethodModifier7) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier7WithResult(*MethodModifier7)")}

func (my *AbstractResultVisitor)     VisitMethodModifier7WithResultArgument(n *MethodModifier7, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier7WithResultArgument(*MethodModifier7, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodModifier8WithResult(n *MethodModifier8) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier8WithResult(*MethodModifier8)")}

func (my *AbstractResultVisitor)     VisitMethodModifier8WithResultArgument(n *MethodModifier8, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodModifier8WithResultArgument(*MethodModifier8, interface{})")}

func (my *AbstractResultVisitor)     VisitConstructorModifier0WithResult(n *ConstructorModifier0) interface{}{ return  my.UnimplementedVisitor("VisitConstructorModifier0WithResult(*ConstructorModifier0)")}

func (my *AbstractResultVisitor)     VisitConstructorModifier0WithResultArgument(n *ConstructorModifier0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstructorModifier0WithResultArgument(*ConstructorModifier0, interface{})")}

func (my *AbstractResultVisitor)     VisitConstructorModifier1WithResult(n *ConstructorModifier1) interface{}{ return  my.UnimplementedVisitor("VisitConstructorModifier1WithResult(*ConstructorModifier1)")}

func (my *AbstractResultVisitor)     VisitConstructorModifier1WithResultArgument(n *ConstructorModifier1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstructorModifier1WithResultArgument(*ConstructorModifier1, interface{})")}

func (my *AbstractResultVisitor)     VisitConstructorModifier2WithResult(n *ConstructorModifier2) interface{}{ return  my.UnimplementedVisitor("VisitConstructorModifier2WithResult(*ConstructorModifier2)")}

func (my *AbstractResultVisitor)     VisitConstructorModifier2WithResultArgument(n *ConstructorModifier2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstructorModifier2WithResultArgument(*ConstructorModifier2, interface{})")}

func (my *AbstractResultVisitor)     VisitExplicitConstructorInvocation0WithResult(n *ExplicitConstructorInvocation0) interface{}{ return  my.UnimplementedVisitor("VisitExplicitConstructorInvocation0WithResult(*ExplicitConstructorInvocation0)")}

func (my *AbstractResultVisitor)     VisitExplicitConstructorInvocation0WithResultArgument(n *ExplicitConstructorInvocation0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExplicitConstructorInvocation0WithResultArgument(*ExplicitConstructorInvocation0, interface{})")}

func (my *AbstractResultVisitor)     VisitExplicitConstructorInvocation1WithResult(n *ExplicitConstructorInvocation1) interface{}{ return  my.UnimplementedVisitor("VisitExplicitConstructorInvocation1WithResult(*ExplicitConstructorInvocation1)")}

func (my *AbstractResultVisitor)     VisitExplicitConstructorInvocation1WithResultArgument(n *ExplicitConstructorInvocation1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExplicitConstructorInvocation1WithResultArgument(*ExplicitConstructorInvocation1, interface{})")}

func (my *AbstractResultVisitor)     VisitExplicitConstructorInvocation2WithResult(n *ExplicitConstructorInvocation2) interface{}{ return  my.UnimplementedVisitor("VisitExplicitConstructorInvocation2WithResult(*ExplicitConstructorInvocation2)")}

func (my *AbstractResultVisitor)     VisitExplicitConstructorInvocation2WithResultArgument(n *ExplicitConstructorInvocation2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExplicitConstructorInvocation2WithResultArgument(*ExplicitConstructorInvocation2, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier0WithResult(n *InterfaceModifier0) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier0WithResult(*InterfaceModifier0)")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier0WithResultArgument(n *InterfaceModifier0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier0WithResultArgument(*InterfaceModifier0, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier1WithResult(n *InterfaceModifier1) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier1WithResult(*InterfaceModifier1)")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier1WithResultArgument(n *InterfaceModifier1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier1WithResultArgument(*InterfaceModifier1, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier2WithResult(n *InterfaceModifier2) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier2WithResult(*InterfaceModifier2)")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier2WithResultArgument(n *InterfaceModifier2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier2WithResultArgument(*InterfaceModifier2, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier3WithResult(n *InterfaceModifier3) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier3WithResult(*InterfaceModifier3)")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier3WithResultArgument(n *InterfaceModifier3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier3WithResultArgument(*InterfaceModifier3, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier4WithResult(n *InterfaceModifier4) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier4WithResult(*InterfaceModifier4)")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier4WithResultArgument(n *InterfaceModifier4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier4WithResultArgument(*InterfaceModifier4, interface{})")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier5WithResult(n *InterfaceModifier5) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier5WithResult(*InterfaceModifier5)")}

func (my *AbstractResultVisitor)     VisitInterfaceModifier5WithResultArgument(n *InterfaceModifier5, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitInterfaceModifier5WithResultArgument(*InterfaceModifier5, interface{})")}

func (my *AbstractResultVisitor)     VisitExtendsInterfaces0WithResult(n *ExtendsInterfaces0) interface{}{ return  my.UnimplementedVisitor("VisitExtendsInterfaces0WithResult(*ExtendsInterfaces0)")}

func (my *AbstractResultVisitor)     VisitExtendsInterfaces0WithResultArgument(n *ExtendsInterfaces0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExtendsInterfaces0WithResultArgument(*ExtendsInterfaces0, interface{})")}

func (my *AbstractResultVisitor)     VisitExtendsInterfaces1WithResult(n *ExtendsInterfaces1) interface{}{ return  my.UnimplementedVisitor("VisitExtendsInterfaces1WithResult(*ExtendsInterfaces1)")}

func (my *AbstractResultVisitor)     VisitExtendsInterfaces1WithResultArgument(n *ExtendsInterfaces1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitExtendsInterfaces1WithResultArgument(*ExtendsInterfaces1, interface{})")}

func (my *AbstractResultVisitor)     VisitConstantModifier0WithResult(n *ConstantModifier0) interface{}{ return  my.UnimplementedVisitor("VisitConstantModifier0WithResult(*ConstantModifier0)")}

func (my *AbstractResultVisitor)     VisitConstantModifier0WithResultArgument(n *ConstantModifier0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstantModifier0WithResultArgument(*ConstantModifier0, interface{})")}

func (my *AbstractResultVisitor)     VisitConstantModifier1WithResult(n *ConstantModifier1) interface{}{ return  my.UnimplementedVisitor("VisitConstantModifier1WithResult(*ConstantModifier1)")}

func (my *AbstractResultVisitor)     VisitConstantModifier1WithResultArgument(n *ConstantModifier1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstantModifier1WithResultArgument(*ConstantModifier1, interface{})")}

func (my *AbstractResultVisitor)     VisitConstantModifier2WithResult(n *ConstantModifier2) interface{}{ return  my.UnimplementedVisitor("VisitConstantModifier2WithResult(*ConstantModifier2)")}

func (my *AbstractResultVisitor)     VisitConstantModifier2WithResultArgument(n *ConstantModifier2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitConstantModifier2WithResultArgument(*ConstantModifier2, interface{})")}

func (my *AbstractResultVisitor)     VisitAbstractMethodModifier0WithResult(n *AbstractMethodModifier0) interface{}{ return  my.UnimplementedVisitor("VisitAbstractMethodModifier0WithResult(*AbstractMethodModifier0)")}

func (my *AbstractResultVisitor)     VisitAbstractMethodModifier0WithResultArgument(n *AbstractMethodModifier0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAbstractMethodModifier0WithResultArgument(*AbstractMethodModifier0, interface{})")}

func (my *AbstractResultVisitor)     VisitAbstractMethodModifier1WithResult(n *AbstractMethodModifier1) interface{}{ return  my.UnimplementedVisitor("VisitAbstractMethodModifier1WithResult(*AbstractMethodModifier1)")}

func (my *AbstractResultVisitor)     VisitAbstractMethodModifier1WithResultArgument(n *AbstractMethodModifier1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAbstractMethodModifier1WithResultArgument(*AbstractMethodModifier1, interface{})")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeElementDeclaration0WithResult(n *AnnotationTypeElementDeclaration0) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeElementDeclaration0WithResult(*AnnotationTypeElementDeclaration0)")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeElementDeclaration0WithResultArgument(n *AnnotationTypeElementDeclaration0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeElementDeclaration0WithResultArgument(*AnnotationTypeElementDeclaration0, interface{})")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeElementDeclaration1WithResult(n *AnnotationTypeElementDeclaration1) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeElementDeclaration1WithResult(*AnnotationTypeElementDeclaration1)")}

func (my *AbstractResultVisitor)     VisitAnnotationTypeElementDeclaration1WithResultArgument(n *AnnotationTypeElementDeclaration1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAnnotationTypeElementDeclaration1WithResultArgument(*AnnotationTypeElementDeclaration1, interface{})")}

func (my *AbstractResultVisitor)     VisitAssertStatement0WithResult(n *AssertStatement0) interface{}{ return  my.UnimplementedVisitor("VisitAssertStatement0WithResult(*AssertStatement0)")}

func (my *AbstractResultVisitor)     VisitAssertStatement0WithResultArgument(n *AssertStatement0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssertStatement0WithResultArgument(*AssertStatement0, interface{})")}

func (my *AbstractResultVisitor)     VisitAssertStatement1WithResult(n *AssertStatement1) interface{}{ return  my.UnimplementedVisitor("VisitAssertStatement1WithResult(*AssertStatement1)")}

func (my *AbstractResultVisitor)     VisitAssertStatement1WithResultArgument(n *AssertStatement1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssertStatement1WithResultArgument(*AssertStatement1, interface{})")}

func (my *AbstractResultVisitor)     VisitSwitchLabel0WithResult(n *SwitchLabel0) interface{}{ return  my.UnimplementedVisitor("VisitSwitchLabel0WithResult(*SwitchLabel0)")}

func (my *AbstractResultVisitor)     VisitSwitchLabel0WithResultArgument(n *SwitchLabel0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSwitchLabel0WithResultArgument(*SwitchLabel0, interface{})")}

func (my *AbstractResultVisitor)     VisitSwitchLabel1WithResult(n *SwitchLabel1) interface{}{ return  my.UnimplementedVisitor("VisitSwitchLabel1WithResult(*SwitchLabel1)")}

func (my *AbstractResultVisitor)     VisitSwitchLabel1WithResultArgument(n *SwitchLabel1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSwitchLabel1WithResultArgument(*SwitchLabel1, interface{})")}

func (my *AbstractResultVisitor)     VisitSwitchLabel2WithResult(n *SwitchLabel2) interface{}{ return  my.UnimplementedVisitor("VisitSwitchLabel2WithResult(*SwitchLabel2)")}

func (my *AbstractResultVisitor)     VisitSwitchLabel2WithResultArgument(n *SwitchLabel2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitSwitchLabel2WithResultArgument(*SwitchLabel2, interface{})")}

func (my *AbstractResultVisitor)     VisitTryStatement0WithResult(n *TryStatement0) interface{}{ return  my.UnimplementedVisitor("VisitTryStatement0WithResult(*TryStatement0)")}

func (my *AbstractResultVisitor)     VisitTryStatement0WithResultArgument(n *TryStatement0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTryStatement0WithResultArgument(*TryStatement0, interface{})")}

func (my *AbstractResultVisitor)     VisitTryStatement1WithResult(n *TryStatement1) interface{}{ return  my.UnimplementedVisitor("VisitTryStatement1WithResult(*TryStatement1)")}

func (my *AbstractResultVisitor)     VisitTryStatement1WithResultArgument(n *TryStatement1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitTryStatement1WithResultArgument(*TryStatement1, interface{})")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray0WithResult(n *PrimaryNoNewArray0) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray0WithResult(*PrimaryNoNewArray0)")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray0WithResultArgument(n *PrimaryNoNewArray0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray0WithResultArgument(*PrimaryNoNewArray0, interface{})")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray1WithResult(n *PrimaryNoNewArray1) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray1WithResult(*PrimaryNoNewArray1)")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray1WithResultArgument(n *PrimaryNoNewArray1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray1WithResultArgument(*PrimaryNoNewArray1, interface{})")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray2WithResult(n *PrimaryNoNewArray2) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray2WithResult(*PrimaryNoNewArray2)")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray2WithResultArgument(n *PrimaryNoNewArray2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray2WithResultArgument(*PrimaryNoNewArray2, interface{})")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray3WithResult(n *PrimaryNoNewArray3) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray3WithResult(*PrimaryNoNewArray3)")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray3WithResultArgument(n *PrimaryNoNewArray3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray3WithResultArgument(*PrimaryNoNewArray3, interface{})")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray4WithResult(n *PrimaryNoNewArray4) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray4WithResult(*PrimaryNoNewArray4)")}

func (my *AbstractResultVisitor)     VisitPrimaryNoNewArray4WithResultArgument(n *PrimaryNoNewArray4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitPrimaryNoNewArray4WithResultArgument(*PrimaryNoNewArray4, interface{})")}

func (my *AbstractResultVisitor)     VisitLiteral0WithResult(n *Literal0) interface{}{ return  my.UnimplementedVisitor("VisitLiteral0WithResult(*Literal0)")}

func (my *AbstractResultVisitor)     VisitLiteral0WithResultArgument(n *Literal0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLiteral0WithResultArgument(*Literal0, interface{})")}

func (my *AbstractResultVisitor)     VisitLiteral1WithResult(n *Literal1) interface{}{ return  my.UnimplementedVisitor("VisitLiteral1WithResult(*Literal1)")}

func (my *AbstractResultVisitor)     VisitLiteral1WithResultArgument(n *Literal1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLiteral1WithResultArgument(*Literal1, interface{})")}

func (my *AbstractResultVisitor)     VisitLiteral2WithResult(n *Literal2) interface{}{ return  my.UnimplementedVisitor("VisitLiteral2WithResult(*Literal2)")}

func (my *AbstractResultVisitor)     VisitLiteral2WithResultArgument(n *Literal2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLiteral2WithResultArgument(*Literal2, interface{})")}

func (my *AbstractResultVisitor)     VisitLiteral3WithResult(n *Literal3) interface{}{ return  my.UnimplementedVisitor("VisitLiteral3WithResult(*Literal3)")}

func (my *AbstractResultVisitor)     VisitLiteral3WithResultArgument(n *Literal3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLiteral3WithResultArgument(*Literal3, interface{})")}

func (my *AbstractResultVisitor)     VisitLiteral4WithResult(n *Literal4) interface{}{ return  my.UnimplementedVisitor("VisitLiteral4WithResult(*Literal4)")}

func (my *AbstractResultVisitor)     VisitLiteral4WithResultArgument(n *Literal4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLiteral4WithResultArgument(*Literal4, interface{})")}

func (my *AbstractResultVisitor)     VisitLiteral5WithResult(n *Literal5) interface{}{ return  my.UnimplementedVisitor("VisitLiteral5WithResult(*Literal5)")}

func (my *AbstractResultVisitor)     VisitLiteral5WithResultArgument(n *Literal5, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLiteral5WithResultArgument(*Literal5, interface{})")}

func (my *AbstractResultVisitor)     VisitLiteral6WithResult(n *Literal6) interface{}{ return  my.UnimplementedVisitor("VisitLiteral6WithResult(*Literal6)")}

func (my *AbstractResultVisitor)     VisitLiteral6WithResultArgument(n *Literal6, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitLiteral6WithResultArgument(*Literal6, interface{})")}

func (my *AbstractResultVisitor)     VisitBooleanLiteral0WithResult(n *BooleanLiteral0) interface{}{ return  my.UnimplementedVisitor("VisitBooleanLiteral0WithResult(*BooleanLiteral0)")}

func (my *AbstractResultVisitor)     VisitBooleanLiteral0WithResultArgument(n *BooleanLiteral0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitBooleanLiteral0WithResultArgument(*BooleanLiteral0, interface{})")}

func (my *AbstractResultVisitor)     VisitBooleanLiteral1WithResult(n *BooleanLiteral1) interface{}{ return  my.UnimplementedVisitor("VisitBooleanLiteral1WithResult(*BooleanLiteral1)")}

func (my *AbstractResultVisitor)     VisitBooleanLiteral1WithResultArgument(n *BooleanLiteral1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitBooleanLiteral1WithResultArgument(*BooleanLiteral1, interface{})")}

func (my *AbstractResultVisitor)     VisitClassInstanceCreationExpression0WithResult(n *ClassInstanceCreationExpression0) interface{}{ return  my.UnimplementedVisitor("VisitClassInstanceCreationExpression0WithResult(*ClassInstanceCreationExpression0)")}

func (my *AbstractResultVisitor)     VisitClassInstanceCreationExpression0WithResultArgument(n *ClassInstanceCreationExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassInstanceCreationExpression0WithResultArgument(*ClassInstanceCreationExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitClassInstanceCreationExpression1WithResult(n *ClassInstanceCreationExpression1) interface{}{ return  my.UnimplementedVisitor("VisitClassInstanceCreationExpression1WithResult(*ClassInstanceCreationExpression1)")}

func (my *AbstractResultVisitor)     VisitClassInstanceCreationExpression1WithResultArgument(n *ClassInstanceCreationExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitClassInstanceCreationExpression1WithResultArgument(*ClassInstanceCreationExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitArrayCreationExpression0WithResult(n *ArrayCreationExpression0) interface{}{ return  my.UnimplementedVisitor("VisitArrayCreationExpression0WithResult(*ArrayCreationExpression0)")}

func (my *AbstractResultVisitor)     VisitArrayCreationExpression0WithResultArgument(n *ArrayCreationExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArrayCreationExpression0WithResultArgument(*ArrayCreationExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitArrayCreationExpression1WithResult(n *ArrayCreationExpression1) interface{}{ return  my.UnimplementedVisitor("VisitArrayCreationExpression1WithResult(*ArrayCreationExpression1)")}

func (my *AbstractResultVisitor)     VisitArrayCreationExpression1WithResultArgument(n *ArrayCreationExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArrayCreationExpression1WithResultArgument(*ArrayCreationExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitArrayCreationExpression2WithResult(n *ArrayCreationExpression2) interface{}{ return  my.UnimplementedVisitor("VisitArrayCreationExpression2WithResult(*ArrayCreationExpression2)")}

func (my *AbstractResultVisitor)     VisitArrayCreationExpression2WithResultArgument(n *ArrayCreationExpression2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArrayCreationExpression2WithResultArgument(*ArrayCreationExpression2, interface{})")}

func (my *AbstractResultVisitor)     VisitArrayCreationExpression3WithResult(n *ArrayCreationExpression3) interface{}{ return  my.UnimplementedVisitor("VisitArrayCreationExpression3WithResult(*ArrayCreationExpression3)")}

func (my *AbstractResultVisitor)     VisitArrayCreationExpression3WithResultArgument(n *ArrayCreationExpression3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArrayCreationExpression3WithResultArgument(*ArrayCreationExpression3, interface{})")}

func (my *AbstractResultVisitor)     VisitDims0WithResult(n *Dims0) interface{}{ return  my.UnimplementedVisitor("VisitDims0WithResult(*Dims0)")}

func (my *AbstractResultVisitor)     VisitDims0WithResultArgument(n *Dims0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitDims0WithResultArgument(*Dims0, interface{})")}

func (my *AbstractResultVisitor)     VisitDims1WithResult(n *Dims1) interface{}{ return  my.UnimplementedVisitor("VisitDims1WithResult(*Dims1)")}

func (my *AbstractResultVisitor)     VisitDims1WithResultArgument(n *Dims1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitDims1WithResultArgument(*Dims1, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldAccess0WithResult(n *FieldAccess0) interface{}{ return  my.UnimplementedVisitor("VisitFieldAccess0WithResult(*FieldAccess0)")}

func (my *AbstractResultVisitor)     VisitFieldAccess0WithResultArgument(n *FieldAccess0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldAccess0WithResultArgument(*FieldAccess0, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldAccess1WithResult(n *FieldAccess1) interface{}{ return  my.UnimplementedVisitor("VisitFieldAccess1WithResult(*FieldAccess1)")}

func (my *AbstractResultVisitor)     VisitFieldAccess1WithResultArgument(n *FieldAccess1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldAccess1WithResultArgument(*FieldAccess1, interface{})")}

func (my *AbstractResultVisitor)     VisitFieldAccess2WithResult(n *FieldAccess2) interface{}{ return  my.UnimplementedVisitor("VisitFieldAccess2WithResult(*FieldAccess2)")}

func (my *AbstractResultVisitor)     VisitFieldAccess2WithResultArgument(n *FieldAccess2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitFieldAccess2WithResultArgument(*FieldAccess2, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodInvocation0WithResult(n *MethodInvocation0) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation0WithResult(*MethodInvocation0)")}

func (my *AbstractResultVisitor)     VisitMethodInvocation0WithResultArgument(n *MethodInvocation0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation0WithResultArgument(*MethodInvocation0, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodInvocation1WithResult(n *MethodInvocation1) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation1WithResult(*MethodInvocation1)")}

func (my *AbstractResultVisitor)     VisitMethodInvocation1WithResultArgument(n *MethodInvocation1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation1WithResultArgument(*MethodInvocation1, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodInvocation2WithResult(n *MethodInvocation2) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation2WithResult(*MethodInvocation2)")}

func (my *AbstractResultVisitor)     VisitMethodInvocation2WithResultArgument(n *MethodInvocation2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation2WithResultArgument(*MethodInvocation2, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodInvocation3WithResult(n *MethodInvocation3) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation3WithResult(*MethodInvocation3)")}

func (my *AbstractResultVisitor)     VisitMethodInvocation3WithResultArgument(n *MethodInvocation3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation3WithResultArgument(*MethodInvocation3, interface{})")}

func (my *AbstractResultVisitor)     VisitMethodInvocation4WithResult(n *MethodInvocation4) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation4WithResult(*MethodInvocation4)")}

func (my *AbstractResultVisitor)     VisitMethodInvocation4WithResultArgument(n *MethodInvocation4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMethodInvocation4WithResultArgument(*MethodInvocation4, interface{})")}

func (my *AbstractResultVisitor)     VisitArrayAccess0WithResult(n *ArrayAccess0) interface{}{ return  my.UnimplementedVisitor("VisitArrayAccess0WithResult(*ArrayAccess0)")}

func (my *AbstractResultVisitor)     VisitArrayAccess0WithResultArgument(n *ArrayAccess0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArrayAccess0WithResultArgument(*ArrayAccess0, interface{})")}

func (my *AbstractResultVisitor)     VisitArrayAccess1WithResult(n *ArrayAccess1) interface{}{ return  my.UnimplementedVisitor("VisitArrayAccess1WithResult(*ArrayAccess1)")}

func (my *AbstractResultVisitor)     VisitArrayAccess1WithResultArgument(n *ArrayAccess1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitArrayAccess1WithResultArgument(*ArrayAccess1, interface{})")}

func (my *AbstractResultVisitor)     VisitUnaryExpression0WithResult(n *UnaryExpression0) interface{}{ return  my.UnimplementedVisitor("VisitUnaryExpression0WithResult(*UnaryExpression0)")}

func (my *AbstractResultVisitor)     VisitUnaryExpression0WithResultArgument(n *UnaryExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitUnaryExpression0WithResultArgument(*UnaryExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitUnaryExpression1WithResult(n *UnaryExpression1) interface{}{ return  my.UnimplementedVisitor("VisitUnaryExpression1WithResult(*UnaryExpression1)")}

func (my *AbstractResultVisitor)     VisitUnaryExpression1WithResultArgument(n *UnaryExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitUnaryExpression1WithResultArgument(*UnaryExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitUnaryExpressionNotPlusMinus0WithResult(n *UnaryExpressionNotPlusMinus0) interface{}{ return  my.UnimplementedVisitor("VisitUnaryExpressionNotPlusMinus0WithResult(*UnaryExpressionNotPlusMinus0)")}

func (my *AbstractResultVisitor)     VisitUnaryExpressionNotPlusMinus0WithResultArgument(n *UnaryExpressionNotPlusMinus0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitUnaryExpressionNotPlusMinus0WithResultArgument(*UnaryExpressionNotPlusMinus0, interface{})")}

func (my *AbstractResultVisitor)     VisitUnaryExpressionNotPlusMinus1WithResult(n *UnaryExpressionNotPlusMinus1) interface{}{ return  my.UnimplementedVisitor("VisitUnaryExpressionNotPlusMinus1WithResult(*UnaryExpressionNotPlusMinus1)")}

func (my *AbstractResultVisitor)     VisitUnaryExpressionNotPlusMinus1WithResultArgument(n *UnaryExpressionNotPlusMinus1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitUnaryExpressionNotPlusMinus1WithResultArgument(*UnaryExpressionNotPlusMinus1, interface{})")}

func (my *AbstractResultVisitor)     VisitCastExpression0WithResult(n *CastExpression0) interface{}{ return  my.UnimplementedVisitor("VisitCastExpression0WithResult(*CastExpression0)")}

func (my *AbstractResultVisitor)     VisitCastExpression0WithResultArgument(n *CastExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitCastExpression0WithResultArgument(*CastExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitCastExpression1WithResult(n *CastExpression1) interface{}{ return  my.UnimplementedVisitor("VisitCastExpression1WithResult(*CastExpression1)")}

func (my *AbstractResultVisitor)     VisitCastExpression1WithResultArgument(n *CastExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitCastExpression1WithResultArgument(*CastExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitMultiplicativeExpression0WithResult(n *MultiplicativeExpression0) interface{}{ return  my.UnimplementedVisitor("VisitMultiplicativeExpression0WithResult(*MultiplicativeExpression0)")}

func (my *AbstractResultVisitor)     VisitMultiplicativeExpression0WithResultArgument(n *MultiplicativeExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMultiplicativeExpression0WithResultArgument(*MultiplicativeExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitMultiplicativeExpression1WithResult(n *MultiplicativeExpression1) interface{}{ return  my.UnimplementedVisitor("VisitMultiplicativeExpression1WithResult(*MultiplicativeExpression1)")}

func (my *AbstractResultVisitor)     VisitMultiplicativeExpression1WithResultArgument(n *MultiplicativeExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMultiplicativeExpression1WithResultArgument(*MultiplicativeExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitMultiplicativeExpression2WithResult(n *MultiplicativeExpression2) interface{}{ return  my.UnimplementedVisitor("VisitMultiplicativeExpression2WithResult(*MultiplicativeExpression2)")}

func (my *AbstractResultVisitor)     VisitMultiplicativeExpression2WithResultArgument(n *MultiplicativeExpression2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitMultiplicativeExpression2WithResultArgument(*MultiplicativeExpression2, interface{})")}

func (my *AbstractResultVisitor)     VisitAdditiveExpression0WithResult(n *AdditiveExpression0) interface{}{ return  my.UnimplementedVisitor("VisitAdditiveExpression0WithResult(*AdditiveExpression0)")}

func (my *AbstractResultVisitor)     VisitAdditiveExpression0WithResultArgument(n *AdditiveExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAdditiveExpression0WithResultArgument(*AdditiveExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitAdditiveExpression1WithResult(n *AdditiveExpression1) interface{}{ return  my.UnimplementedVisitor("VisitAdditiveExpression1WithResult(*AdditiveExpression1)")}

func (my *AbstractResultVisitor)     VisitAdditiveExpression1WithResultArgument(n *AdditiveExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAdditiveExpression1WithResultArgument(*AdditiveExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitShiftExpression0WithResult(n *ShiftExpression0) interface{}{ return  my.UnimplementedVisitor("VisitShiftExpression0WithResult(*ShiftExpression0)")}

func (my *AbstractResultVisitor)     VisitShiftExpression0WithResultArgument(n *ShiftExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitShiftExpression0WithResultArgument(*ShiftExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitShiftExpression1WithResult(n *ShiftExpression1) interface{}{ return  my.UnimplementedVisitor("VisitShiftExpression1WithResult(*ShiftExpression1)")}

func (my *AbstractResultVisitor)     VisitShiftExpression1WithResultArgument(n *ShiftExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitShiftExpression1WithResultArgument(*ShiftExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitShiftExpression2WithResult(n *ShiftExpression2) interface{}{ return  my.UnimplementedVisitor("VisitShiftExpression2WithResult(*ShiftExpression2)")}

func (my *AbstractResultVisitor)     VisitShiftExpression2WithResultArgument(n *ShiftExpression2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitShiftExpression2WithResultArgument(*ShiftExpression2, interface{})")}

func (my *AbstractResultVisitor)     VisitRelationalExpression0WithResult(n *RelationalExpression0) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression0WithResult(*RelationalExpression0)")}

func (my *AbstractResultVisitor)     VisitRelationalExpression0WithResultArgument(n *RelationalExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression0WithResultArgument(*RelationalExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitRelationalExpression1WithResult(n *RelationalExpression1) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression1WithResult(*RelationalExpression1)")}

func (my *AbstractResultVisitor)     VisitRelationalExpression1WithResultArgument(n *RelationalExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression1WithResultArgument(*RelationalExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitRelationalExpression2WithResult(n *RelationalExpression2) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression2WithResult(*RelationalExpression2)")}

func (my *AbstractResultVisitor)     VisitRelationalExpression2WithResultArgument(n *RelationalExpression2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression2WithResultArgument(*RelationalExpression2, interface{})")}

func (my *AbstractResultVisitor)     VisitRelationalExpression3WithResult(n *RelationalExpression3) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression3WithResult(*RelationalExpression3)")}

func (my *AbstractResultVisitor)     VisitRelationalExpression3WithResultArgument(n *RelationalExpression3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression3WithResultArgument(*RelationalExpression3, interface{})")}

func (my *AbstractResultVisitor)     VisitRelationalExpression4WithResult(n *RelationalExpression4) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression4WithResult(*RelationalExpression4)")}

func (my *AbstractResultVisitor)     VisitRelationalExpression4WithResultArgument(n *RelationalExpression4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitRelationalExpression4WithResultArgument(*RelationalExpression4, interface{})")}

func (my *AbstractResultVisitor)     VisitEqualityExpression0WithResult(n *EqualityExpression0) interface{}{ return  my.UnimplementedVisitor("VisitEqualityExpression0WithResult(*EqualityExpression0)")}

func (my *AbstractResultVisitor)     VisitEqualityExpression0WithResultArgument(n *EqualityExpression0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEqualityExpression0WithResultArgument(*EqualityExpression0, interface{})")}

func (my *AbstractResultVisitor)     VisitEqualityExpression1WithResult(n *EqualityExpression1) interface{}{ return  my.UnimplementedVisitor("VisitEqualityExpression1WithResult(*EqualityExpression1)")}

func (my *AbstractResultVisitor)     VisitEqualityExpression1WithResultArgument(n *EqualityExpression1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitEqualityExpression1WithResultArgument(*EqualityExpression1, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator0WithResult(n *AssignmentOperator0) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator0WithResult(*AssignmentOperator0)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator0WithResultArgument(n *AssignmentOperator0, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator0WithResultArgument(*AssignmentOperator0, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator1WithResult(n *AssignmentOperator1) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator1WithResult(*AssignmentOperator1)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator1WithResultArgument(n *AssignmentOperator1, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator1WithResultArgument(*AssignmentOperator1, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator2WithResult(n *AssignmentOperator2) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator2WithResult(*AssignmentOperator2)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator2WithResultArgument(n *AssignmentOperator2, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator2WithResultArgument(*AssignmentOperator2, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator3WithResult(n *AssignmentOperator3) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator3WithResult(*AssignmentOperator3)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator3WithResultArgument(n *AssignmentOperator3, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator3WithResultArgument(*AssignmentOperator3, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator4WithResult(n *AssignmentOperator4) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator4WithResult(*AssignmentOperator4)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator4WithResultArgument(n *AssignmentOperator4, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator4WithResultArgument(*AssignmentOperator4, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator5WithResult(n *AssignmentOperator5) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator5WithResult(*AssignmentOperator5)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator5WithResultArgument(n *AssignmentOperator5, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator5WithResultArgument(*AssignmentOperator5, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator6WithResult(n *AssignmentOperator6) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator6WithResult(*AssignmentOperator6)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator6WithResultArgument(n *AssignmentOperator6, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator6WithResultArgument(*AssignmentOperator6, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator7WithResult(n *AssignmentOperator7) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator7WithResult(*AssignmentOperator7)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator7WithResultArgument(n *AssignmentOperator7, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator7WithResultArgument(*AssignmentOperator7, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator8WithResult(n *AssignmentOperator8) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator8WithResult(*AssignmentOperator8)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator8WithResultArgument(n *AssignmentOperator8, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator8WithResultArgument(*AssignmentOperator8, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator9WithResult(n *AssignmentOperator9) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator9WithResult(*AssignmentOperator9)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator9WithResultArgument(n *AssignmentOperator9, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator9WithResultArgument(*AssignmentOperator9, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator10WithResult(n *AssignmentOperator10) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator10WithResult(*AssignmentOperator10)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator10WithResultArgument(n *AssignmentOperator10, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator10WithResultArgument(*AssignmentOperator10, interface{})")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator11WithResult(n *AssignmentOperator11) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator11WithResult(*AssignmentOperator11)")}

func (my *AbstractResultVisitor)     VisitAssignmentOperator11WithResultArgument(n *AssignmentOperator11, o interface{}) interface{}{ return  my.UnimplementedVisitor("VisitAssignmentOperator11WithResultArgument(*AssignmentOperator11, interface{})")}


func (my *AbstractResultVisitor)     VisitWithResult(n IAst) interface{}{
        {
         var n2,ok =n.(*AstToken)
         if ok {
            return my.dispatch.VisitAstTokenWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*identifier)
         if ok {
            return my.dispatch.VisitidentifierWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PrimitiveType)
         if ok {
            return my.dispatch.VisitPrimitiveTypeWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassType)
         if ok {
            return my.dispatch.VisitClassTypeWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceType)
         if ok {
            return my.dispatch.VisitInterfaceTypeWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeName)
         if ok {
            return my.dispatch.VisitTypeNameWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArrayType)
         if ok {
            return my.dispatch.VisitArrayTypeWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeParameter)
         if ok {
            return my.dispatch.VisitTypeParameterWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeBound)
         if ok {
            return my.dispatch.VisitTypeBoundWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AdditionalBoundList)
         if ok {
            return my.dispatch.VisitAdditionalBoundListWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AdditionalBound)
         if ok {
            return my.dispatch.VisitAdditionalBoundWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeArguments)
         if ok {
            return my.dispatch.VisitTypeArgumentsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ActualTypeArgumentList)
         if ok {
            return my.dispatch.VisitActualTypeArgumentListWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Wildcard)
         if ok {
            return my.dispatch.VisitWildcardWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PackageName)
         if ok {
            return my.dispatch.VisitPackageNameWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExpressionName)
         if ok {
            return my.dispatch.VisitExpressionNameWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodName)
         if ok {
            return my.dispatch.VisitMethodNameWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PackageOrTypeName)
         if ok {
            return my.dispatch.VisitPackageOrTypeNameWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AmbiguousName)
         if ok {
            return my.dispatch.VisitAmbiguousNameWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*CompilationUnit)
         if ok {
            return my.dispatch.VisitCompilationUnitWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ImportDeclarations)
         if ok {
            return my.dispatch.VisitImportDeclarationsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeDeclarations)
         if ok {
            return my.dispatch.VisitTypeDeclarationsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PackageDeclaration)
         if ok {
            return my.dispatch.VisitPackageDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SingleTypeImportDeclaration)
         if ok {
            return my.dispatch.VisitSingleTypeImportDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeImportOnDemandDeclaration)
         if ok {
            return my.dispatch.VisitTypeImportOnDemandDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SingleStaticImportDeclaration)
         if ok {
            return my.dispatch.VisitSingleStaticImportDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*StaticImportOnDemandDeclaration)
         if ok {
            return my.dispatch.VisitStaticImportOnDemandDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeDeclaration)
         if ok {
            return my.dispatch.VisitTypeDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*NormalClassDeclaration)
         if ok {
            return my.dispatch.VisitNormalClassDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassModifiers)
         if ok {
            return my.dispatch.VisitClassModifiersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeParameters)
         if ok {
            return my.dispatch.VisitTypeParametersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TypeParameterList)
         if ok {
            return my.dispatch.VisitTypeParameterListWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Super)
         if ok {
            return my.dispatch.VisitSuperWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Interfaces)
         if ok {
            return my.dispatch.VisitInterfacesWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceTypeList)
         if ok {
            return my.dispatch.VisitInterfaceTypeListWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassBody)
         if ok {
            return my.dispatch.VisitClassBodyWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassBodyDeclarations)
         if ok {
            return my.dispatch.VisitClassBodyDeclarationsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassMemberDeclaration)
         if ok {
            return my.dispatch.VisitClassMemberDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldDeclaration)
         if ok {
            return my.dispatch.VisitFieldDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*VariableDeclarators)
         if ok {
            return my.dispatch.VisitVariableDeclaratorsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*VariableDeclarator)
         if ok {
            return my.dispatch.VisitVariableDeclaratorWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*VariableDeclaratorId)
         if ok {
            return my.dispatch.VisitVariableDeclaratorIdWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldModifiers)
         if ok {
            return my.dispatch.VisitFieldModifiersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodDeclaration)
         if ok {
            return my.dispatch.VisitMethodDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodHeader)
         if ok {
            return my.dispatch.VisitMethodHeaderWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ResultType)
         if ok {
            return my.dispatch.VisitResultTypeWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FormalParameterList)
         if ok {
            return my.dispatch.VisitFormalParameterListWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FormalParameters)
         if ok {
            return my.dispatch.VisitFormalParametersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FormalParameter)
         if ok {
            return my.dispatch.VisitFormalParameterWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*VariableModifiers)
         if ok {
            return my.dispatch.VisitVariableModifiersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*VariableModifier)
         if ok {
            return my.dispatch.VisitVariableModifierWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LastFormalParameter)
         if ok {
            return my.dispatch.VisitLastFormalParameterWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifiers)
         if ok {
            return my.dispatch.VisitMethodModifiersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Throws)
         if ok {
            return my.dispatch.VisitThrowsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExceptionTypeList)
         if ok {
            return my.dispatch.VisitExceptionTypeListWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodBody)
         if ok {
            return my.dispatch.VisitMethodBodyWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*StaticInitializer)
         if ok {
            return my.dispatch.VisitStaticInitializerWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstructorDeclaration)
         if ok {
            return my.dispatch.VisitConstructorDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstructorDeclarator)
         if ok {
            return my.dispatch.VisitConstructorDeclaratorWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstructorModifiers)
         if ok {
            return my.dispatch.VisitConstructorModifiersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstructorBody)
         if ok {
            return my.dispatch.VisitConstructorBodyWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EnumDeclaration)
         if ok {
            return my.dispatch.VisitEnumDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EnumBody)
         if ok {
            return my.dispatch.VisitEnumBodyWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EnumConstants)
         if ok {
            return my.dispatch.VisitEnumConstantsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EnumConstant)
         if ok {
            return my.dispatch.VisitEnumConstantWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Arguments)
         if ok {
            return my.dispatch.VisitArgumentsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EnumBodyDeclarations)
         if ok {
            return my.dispatch.VisitEnumBodyDeclarationsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*NormalInterfaceDeclaration)
         if ok {
            return my.dispatch.VisitNormalInterfaceDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifiers)
         if ok {
            return my.dispatch.VisitInterfaceModifiersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceBody)
         if ok {
            return my.dispatch.VisitInterfaceBodyWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceMemberDeclarations)
         if ok {
            return my.dispatch.VisitInterfaceMemberDeclarationsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceMemberDeclaration)
         if ok {
            return my.dispatch.VisitInterfaceMemberDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstantDeclaration)
         if ok {
            return my.dispatch.VisitConstantDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstantModifiers)
         if ok {
            return my.dispatch.VisitConstantModifiersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AbstractMethodDeclaration)
         if ok {
            return my.dispatch.VisitAbstractMethodDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifiers)
         if ok {
            return my.dispatch.VisitAbstractMethodModifiersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeDeclaration)
         if ok {
            return my.dispatch.VisitAnnotationTypeDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeBody)
         if ok {
            return my.dispatch.VisitAnnotationTypeBodyWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclarations)
         if ok {
            return my.dispatch.VisitAnnotationTypeElementDeclarationsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*DefaultValue)
         if ok {
            return my.dispatch.VisitDefaultValueWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Annotations)
         if ok {
            return my.dispatch.VisitAnnotationsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*NormalAnnotation)
         if ok {
            return my.dispatch.VisitNormalAnnotationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ElementValuePairs)
         if ok {
            return my.dispatch.VisitElementValuePairsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ElementValuePair)
         if ok {
            return my.dispatch.VisitElementValuePairWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ElementValueArrayInitializer)
         if ok {
            return my.dispatch.VisitElementValueArrayInitializerWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ElementValues)
         if ok {
            return my.dispatch.VisitElementValuesWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MarkerAnnotation)
         if ok {
            return my.dispatch.VisitMarkerAnnotationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SingleElementAnnotation)
         if ok {
            return my.dispatch.VisitSingleElementAnnotationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArrayInitializer)
         if ok {
            return my.dispatch.VisitArrayInitializerWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*VariableInitializers)
         if ok {
            return my.dispatch.VisitVariableInitializersWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Block)
         if ok {
            return my.dispatch.VisitBlockWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*BlockStatements)
         if ok {
            return my.dispatch.VisitBlockStatementsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LocalVariableDeclarationStatement)
         if ok {
            return my.dispatch.VisitLocalVariableDeclarationStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LocalVariableDeclaration)
         if ok {
            return my.dispatch.VisitLocalVariableDeclarationWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*IfThenStatement)
         if ok {
            return my.dispatch.VisitIfThenStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*IfThenElseStatement)
         if ok {
            return my.dispatch.VisitIfThenElseStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*IfThenElseStatementNoShortIf)
         if ok {
            return my.dispatch.VisitIfThenElseStatementNoShortIfWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EmptyStatement)
         if ok {
            return my.dispatch.VisitEmptyStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LabeledStatement)
         if ok {
            return my.dispatch.VisitLabeledStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LabeledStatementNoShortIf)
         if ok {
            return my.dispatch.VisitLabeledStatementNoShortIfWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExpressionStatement)
         if ok {
            return my.dispatch.VisitExpressionStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SwitchStatement)
         if ok {
            return my.dispatch.VisitSwitchStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SwitchBlock)
         if ok {
            return my.dispatch.VisitSwitchBlockWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SwitchBlockStatementGroups)
         if ok {
            return my.dispatch.VisitSwitchBlockStatementGroupsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SwitchBlockStatementGroup)
         if ok {
            return my.dispatch.VisitSwitchBlockStatementGroupWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SwitchLabels)
         if ok {
            return my.dispatch.VisitSwitchLabelsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*WhileStatement)
         if ok {
            return my.dispatch.VisitWhileStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*WhileStatementNoShortIf)
         if ok {
            return my.dispatch.VisitWhileStatementNoShortIfWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*DoStatement)
         if ok {
            return my.dispatch.VisitDoStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*BasicForStatement)
         if ok {
            return my.dispatch.VisitBasicForStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ForStatementNoShortIf)
         if ok {
            return my.dispatch.VisitForStatementNoShortIfWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*StatementExpressionList)
         if ok {
            return my.dispatch.VisitStatementExpressionListWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EnhancedForStatement)
         if ok {
            return my.dispatch.VisitEnhancedForStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*BreakStatement)
         if ok {
            return my.dispatch.VisitBreakStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ContinueStatement)
         if ok {
            return my.dispatch.VisitContinueStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ReturnStatement)
         if ok {
            return my.dispatch.VisitReturnStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ThrowStatement)
         if ok {
            return my.dispatch.VisitThrowStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SynchronizedStatement)
         if ok {
            return my.dispatch.VisitSynchronizedStatementWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Catches)
         if ok {
            return my.dispatch.VisitCatchesWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*CatchClause)
         if ok {
            return my.dispatch.VisitCatchClauseWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Finally)
         if ok {
            return my.dispatch.VisitFinallyWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArgumentList)
         if ok {
            return my.dispatch.VisitArgumentListWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*DimExprs)
         if ok {
            return my.dispatch.VisitDimExprsWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*DimExpr)
         if ok {
            return my.dispatch.VisitDimExprWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PostIncrementExpression)
         if ok {
            return my.dispatch.VisitPostIncrementExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PostDecrementExpression)
         if ok {
            return my.dispatch.VisitPostDecrementExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PreIncrementExpression)
         if ok {
            return my.dispatch.VisitPreIncrementExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PreDecrementExpression)
         if ok {
            return my.dispatch.VisitPreDecrementExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AndExpression)
         if ok {
            return my.dispatch.VisitAndExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExclusiveOrExpression)
         if ok {
            return my.dispatch.VisitExclusiveOrExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InclusiveOrExpression)
         if ok {
            return my.dispatch.VisitInclusiveOrExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConditionalAndExpression)
         if ok {
            return my.dispatch.VisitConditionalAndExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConditionalOrExpression)
         if ok {
            return my.dispatch.VisitConditionalOrExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConditionalExpression)
         if ok {
            return my.dispatch.VisitConditionalExpressionWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Assignment)
         if ok {
            return my.dispatch.VisitAssignmentWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Commaopt)
         if ok {
            return my.dispatch.VisitCommaoptWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Ellipsisopt)
         if ok {
            return my.dispatch.VisitEllipsisoptWithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction0)
         if ok {
            return my.dispatch.VisitLPGUserAction0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction1)
         if ok {
            return my.dispatch.VisitLPGUserAction1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction2)
         if ok {
            return my.dispatch.VisitLPGUserAction2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction3)
         if ok {
            return my.dispatch.VisitLPGUserAction3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction4)
         if ok {
            return my.dispatch.VisitLPGUserAction4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*IntegralType0)
         if ok {
            return my.dispatch.VisitIntegralType0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*IntegralType1)
         if ok {
            return my.dispatch.VisitIntegralType1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*IntegralType2)
         if ok {
            return my.dispatch.VisitIntegralType2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*IntegralType3)
         if ok {
            return my.dispatch.VisitIntegralType3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*IntegralType4)
         if ok {
            return my.dispatch.VisitIntegralType4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FloatingPointType0)
         if ok {
            return my.dispatch.VisitFloatingPointType0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FloatingPointType1)
         if ok {
            return my.dispatch.VisitFloatingPointType1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*WildcardBounds0)
         if ok {
            return my.dispatch.VisitWildcardBounds0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*WildcardBounds1)
         if ok {
            return my.dispatch.VisitWildcardBounds1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassModifier0)
         if ok {
            return my.dispatch.VisitClassModifier0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassModifier1)
         if ok {
            return my.dispatch.VisitClassModifier1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassModifier2)
         if ok {
            return my.dispatch.VisitClassModifier2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassModifier3)
         if ok {
            return my.dispatch.VisitClassModifier3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassModifier4)
         if ok {
            return my.dispatch.VisitClassModifier4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassModifier5)
         if ok {
            return my.dispatch.VisitClassModifier5WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassModifier6)
         if ok {
            return my.dispatch.VisitClassModifier6WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldModifier0)
         if ok {
            return my.dispatch.VisitFieldModifier0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldModifier1)
         if ok {
            return my.dispatch.VisitFieldModifier1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldModifier2)
         if ok {
            return my.dispatch.VisitFieldModifier2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldModifier3)
         if ok {
            return my.dispatch.VisitFieldModifier3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldModifier4)
         if ok {
            return my.dispatch.VisitFieldModifier4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldModifier5)
         if ok {
            return my.dispatch.VisitFieldModifier5WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldModifier6)
         if ok {
            return my.dispatch.VisitFieldModifier6WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodDeclarator0)
         if ok {
            return my.dispatch.VisitMethodDeclarator0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodDeclarator1)
         if ok {
            return my.dispatch.VisitMethodDeclarator1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier0)
         if ok {
            return my.dispatch.VisitMethodModifier0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier1)
         if ok {
            return my.dispatch.VisitMethodModifier1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier2)
         if ok {
            return my.dispatch.VisitMethodModifier2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier3)
         if ok {
            return my.dispatch.VisitMethodModifier3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier4)
         if ok {
            return my.dispatch.VisitMethodModifier4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier5)
         if ok {
            return my.dispatch.VisitMethodModifier5WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier6)
         if ok {
            return my.dispatch.VisitMethodModifier6WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier7)
         if ok {
            return my.dispatch.VisitMethodModifier7WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodModifier8)
         if ok {
            return my.dispatch.VisitMethodModifier8WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier0)
         if ok {
            return my.dispatch.VisitConstructorModifier0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier1)
         if ok {
            return my.dispatch.VisitConstructorModifier1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier2)
         if ok {
            return my.dispatch.VisitConstructorModifier2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation0)
         if ok {
            return my.dispatch.VisitExplicitConstructorInvocation0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation1)
         if ok {
            return my.dispatch.VisitExplicitConstructorInvocation1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation2)
         if ok {
            return my.dispatch.VisitExplicitConstructorInvocation2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier0)
         if ok {
            return my.dispatch.VisitInterfaceModifier0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier1)
         if ok {
            return my.dispatch.VisitInterfaceModifier1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier2)
         if ok {
            return my.dispatch.VisitInterfaceModifier2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier3)
         if ok {
            return my.dispatch.VisitInterfaceModifier3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier4)
         if ok {
            return my.dispatch.VisitInterfaceModifier4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier5)
         if ok {
            return my.dispatch.VisitInterfaceModifier5WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExtendsInterfaces0)
         if ok {
            return my.dispatch.VisitExtendsInterfaces0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ExtendsInterfaces1)
         if ok {
            return my.dispatch.VisitExtendsInterfaces1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstantModifier0)
         if ok {
            return my.dispatch.VisitConstantModifier0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstantModifier1)
         if ok {
            return my.dispatch.VisitConstantModifier1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ConstantModifier2)
         if ok {
            return my.dispatch.VisitConstantModifier2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifier0)
         if ok {
            return my.dispatch.VisitAbstractMethodModifier0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifier1)
         if ok {
            return my.dispatch.VisitAbstractMethodModifier1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclaration0)
         if ok {
            return my.dispatch.VisitAnnotationTypeElementDeclaration0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclaration1)
         if ok {
            return my.dispatch.VisitAnnotationTypeElementDeclaration1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssertStatement0)
         if ok {
            return my.dispatch.VisitAssertStatement0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssertStatement1)
         if ok {
            return my.dispatch.VisitAssertStatement1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SwitchLabel0)
         if ok {
            return my.dispatch.VisitSwitchLabel0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SwitchLabel1)
         if ok {
            return my.dispatch.VisitSwitchLabel1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*SwitchLabel2)
         if ok {
            return my.dispatch.VisitSwitchLabel2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TryStatement0)
         if ok {
            return my.dispatch.VisitTryStatement0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*TryStatement1)
         if ok {
            return my.dispatch.VisitTryStatement1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray0)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray1)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray2)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray3)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray4)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Literal0)
         if ok {
            return my.dispatch.VisitLiteral0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Literal1)
         if ok {
            return my.dispatch.VisitLiteral1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Literal2)
         if ok {
            return my.dispatch.VisitLiteral2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Literal3)
         if ok {
            return my.dispatch.VisitLiteral3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Literal4)
         if ok {
            return my.dispatch.VisitLiteral4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Literal5)
         if ok {
            return my.dispatch.VisitLiteral5WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Literal6)
         if ok {
            return my.dispatch.VisitLiteral6WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*BooleanLiteral0)
         if ok {
            return my.dispatch.VisitBooleanLiteral0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*BooleanLiteral1)
         if ok {
            return my.dispatch.VisitBooleanLiteral1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassInstanceCreationExpression0)
         if ok {
            return my.dispatch.VisitClassInstanceCreationExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ClassInstanceCreationExpression1)
         if ok {
            return my.dispatch.VisitClassInstanceCreationExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression0)
         if ok {
            return my.dispatch.VisitArrayCreationExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression1)
         if ok {
            return my.dispatch.VisitArrayCreationExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression2)
         if ok {
            return my.dispatch.VisitArrayCreationExpression2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression3)
         if ok {
            return my.dispatch.VisitArrayCreationExpression3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Dims0)
         if ok {
            return my.dispatch.VisitDims0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*Dims1)
         if ok {
            return my.dispatch.VisitDims1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldAccess0)
         if ok {
            return my.dispatch.VisitFieldAccess0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldAccess1)
         if ok {
            return my.dispatch.VisitFieldAccess1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*FieldAccess2)
         if ok {
            return my.dispatch.VisitFieldAccess2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation0)
         if ok {
            return my.dispatch.VisitMethodInvocation0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation1)
         if ok {
            return my.dispatch.VisitMethodInvocation1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation2)
         if ok {
            return my.dispatch.VisitMethodInvocation2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation3)
         if ok {
            return my.dispatch.VisitMethodInvocation3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation4)
         if ok {
            return my.dispatch.VisitMethodInvocation4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArrayAccess0)
         if ok {
            return my.dispatch.VisitArrayAccess0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ArrayAccess1)
         if ok {
            return my.dispatch.VisitArrayAccess1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*UnaryExpression0)
         if ok {
            return my.dispatch.VisitUnaryExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*UnaryExpression1)
         if ok {
            return my.dispatch.VisitUnaryExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*UnaryExpressionNotPlusMinus0)
         if ok {
            return my.dispatch.VisitUnaryExpressionNotPlusMinus0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*UnaryExpressionNotPlusMinus1)
         if ok {
            return my.dispatch.VisitUnaryExpressionNotPlusMinus1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*CastExpression0)
         if ok {
            return my.dispatch.VisitCastExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*CastExpression1)
         if ok {
            return my.dispatch.VisitCastExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression0)
         if ok {
            return my.dispatch.VisitMultiplicativeExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression1)
         if ok {
            return my.dispatch.VisitMultiplicativeExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression2)
         if ok {
            return my.dispatch.VisitMultiplicativeExpression2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AdditiveExpression0)
         if ok {
            return my.dispatch.VisitAdditiveExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AdditiveExpression1)
         if ok {
            return my.dispatch.VisitAdditiveExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ShiftExpression0)
         if ok {
            return my.dispatch.VisitShiftExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ShiftExpression1)
         if ok {
            return my.dispatch.VisitShiftExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*ShiftExpression2)
         if ok {
            return my.dispatch.VisitShiftExpression2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression0)
         if ok {
            return my.dispatch.VisitRelationalExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression1)
         if ok {
            return my.dispatch.VisitRelationalExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression2)
         if ok {
            return my.dispatch.VisitRelationalExpression2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression3)
         if ok {
            return my.dispatch.VisitRelationalExpression3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression4)
         if ok {
            return my.dispatch.VisitRelationalExpression4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EqualityExpression0)
         if ok {
            return my.dispatch.VisitEqualityExpression0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*EqualityExpression1)
         if ok {
            return my.dispatch.VisitEqualityExpression1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator0)
         if ok {
            return my.dispatch.VisitAssignmentOperator0WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator1)
         if ok {
            return my.dispatch.VisitAssignmentOperator1WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator2)
         if ok {
            return my.dispatch.VisitAssignmentOperator2WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator3)
         if ok {
            return my.dispatch.VisitAssignmentOperator3WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator4)
         if ok {
            return my.dispatch.VisitAssignmentOperator4WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator5)
         if ok {
            return my.dispatch.VisitAssignmentOperator5WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator6)
         if ok {
            return my.dispatch.VisitAssignmentOperator6WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator7)
         if ok {
            return my.dispatch.VisitAssignmentOperator7WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator8)
         if ok {
            return my.dispatch.VisitAssignmentOperator8WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator9)
         if ok {
            return my.dispatch.VisitAssignmentOperator9WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator10)
         if ok {
            return my.dispatch.VisitAssignmentOperator10WithResult(n2)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator11)
         if ok {
            return my.dispatch.VisitAssignmentOperator11WithResult(n2)
          }
        }
    return nil
    }
func (my *AbstractResultVisitor)     VisitWithResultArgument(n IAst, o interface{}) interface{}{
        {
         var n2,ok =n.(*AstToken)
         if ok {
            return my.dispatch.VisitAstTokenWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*identifier)
         if ok {
            return my.dispatch.VisitidentifierWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PrimitiveType)
         if ok {
            return my.dispatch.VisitPrimitiveTypeWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassType)
         if ok {
            return my.dispatch.VisitClassTypeWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceType)
         if ok {
            return my.dispatch.VisitInterfaceTypeWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeName)
         if ok {
            return my.dispatch.VisitTypeNameWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArrayType)
         if ok {
            return my.dispatch.VisitArrayTypeWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeParameter)
         if ok {
            return my.dispatch.VisitTypeParameterWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeBound)
         if ok {
            return my.dispatch.VisitTypeBoundWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AdditionalBoundList)
         if ok {
            return my.dispatch.VisitAdditionalBoundListWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AdditionalBound)
         if ok {
            return my.dispatch.VisitAdditionalBoundWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeArguments)
         if ok {
            return my.dispatch.VisitTypeArgumentsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ActualTypeArgumentList)
         if ok {
            return my.dispatch.VisitActualTypeArgumentListWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Wildcard)
         if ok {
            return my.dispatch.VisitWildcardWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PackageName)
         if ok {
            return my.dispatch.VisitPackageNameWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExpressionName)
         if ok {
            return my.dispatch.VisitExpressionNameWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodName)
         if ok {
            return my.dispatch.VisitMethodNameWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PackageOrTypeName)
         if ok {
            return my.dispatch.VisitPackageOrTypeNameWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AmbiguousName)
         if ok {
            return my.dispatch.VisitAmbiguousNameWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*CompilationUnit)
         if ok {
            return my.dispatch.VisitCompilationUnitWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ImportDeclarations)
         if ok {
            return my.dispatch.VisitImportDeclarationsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeDeclarations)
         if ok {
            return my.dispatch.VisitTypeDeclarationsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PackageDeclaration)
         if ok {
            return my.dispatch.VisitPackageDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SingleTypeImportDeclaration)
         if ok {
            return my.dispatch.VisitSingleTypeImportDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeImportOnDemandDeclaration)
         if ok {
            return my.dispatch.VisitTypeImportOnDemandDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SingleStaticImportDeclaration)
         if ok {
            return my.dispatch.VisitSingleStaticImportDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*StaticImportOnDemandDeclaration)
         if ok {
            return my.dispatch.VisitStaticImportOnDemandDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeDeclaration)
         if ok {
            return my.dispatch.VisitTypeDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*NormalClassDeclaration)
         if ok {
            return my.dispatch.VisitNormalClassDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassModifiers)
         if ok {
            return my.dispatch.VisitClassModifiersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeParameters)
         if ok {
            return my.dispatch.VisitTypeParametersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TypeParameterList)
         if ok {
            return my.dispatch.VisitTypeParameterListWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Super)
         if ok {
            return my.dispatch.VisitSuperWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Interfaces)
         if ok {
            return my.dispatch.VisitInterfacesWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceTypeList)
         if ok {
            return my.dispatch.VisitInterfaceTypeListWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassBody)
         if ok {
            return my.dispatch.VisitClassBodyWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassBodyDeclarations)
         if ok {
            return my.dispatch.VisitClassBodyDeclarationsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassMemberDeclaration)
         if ok {
            return my.dispatch.VisitClassMemberDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldDeclaration)
         if ok {
            return my.dispatch.VisitFieldDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*VariableDeclarators)
         if ok {
            return my.dispatch.VisitVariableDeclaratorsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*VariableDeclarator)
         if ok {
            return my.dispatch.VisitVariableDeclaratorWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*VariableDeclaratorId)
         if ok {
            return my.dispatch.VisitVariableDeclaratorIdWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldModifiers)
         if ok {
            return my.dispatch.VisitFieldModifiersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodDeclaration)
         if ok {
            return my.dispatch.VisitMethodDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodHeader)
         if ok {
            return my.dispatch.VisitMethodHeaderWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ResultType)
         if ok {
            return my.dispatch.VisitResultTypeWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FormalParameterList)
         if ok {
            return my.dispatch.VisitFormalParameterListWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FormalParameters)
         if ok {
            return my.dispatch.VisitFormalParametersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FormalParameter)
         if ok {
            return my.dispatch.VisitFormalParameterWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*VariableModifiers)
         if ok {
            return my.dispatch.VisitVariableModifiersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*VariableModifier)
         if ok {
            return my.dispatch.VisitVariableModifierWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LastFormalParameter)
         if ok {
            return my.dispatch.VisitLastFormalParameterWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifiers)
         if ok {
            return my.dispatch.VisitMethodModifiersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Throws)
         if ok {
            return my.dispatch.VisitThrowsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExceptionTypeList)
         if ok {
            return my.dispatch.VisitExceptionTypeListWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodBody)
         if ok {
            return my.dispatch.VisitMethodBodyWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*StaticInitializer)
         if ok {
            return my.dispatch.VisitStaticInitializerWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstructorDeclaration)
         if ok {
            return my.dispatch.VisitConstructorDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstructorDeclarator)
         if ok {
            return my.dispatch.VisitConstructorDeclaratorWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstructorModifiers)
         if ok {
            return my.dispatch.VisitConstructorModifiersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstructorBody)
         if ok {
            return my.dispatch.VisitConstructorBodyWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EnumDeclaration)
         if ok {
            return my.dispatch.VisitEnumDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EnumBody)
         if ok {
            return my.dispatch.VisitEnumBodyWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EnumConstants)
         if ok {
            return my.dispatch.VisitEnumConstantsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EnumConstant)
         if ok {
            return my.dispatch.VisitEnumConstantWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Arguments)
         if ok {
            return my.dispatch.VisitArgumentsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EnumBodyDeclarations)
         if ok {
            return my.dispatch.VisitEnumBodyDeclarationsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*NormalInterfaceDeclaration)
         if ok {
            return my.dispatch.VisitNormalInterfaceDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifiers)
         if ok {
            return my.dispatch.VisitInterfaceModifiersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceBody)
         if ok {
            return my.dispatch.VisitInterfaceBodyWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceMemberDeclarations)
         if ok {
            return my.dispatch.VisitInterfaceMemberDeclarationsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceMemberDeclaration)
         if ok {
            return my.dispatch.VisitInterfaceMemberDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstantDeclaration)
         if ok {
            return my.dispatch.VisitConstantDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstantModifiers)
         if ok {
            return my.dispatch.VisitConstantModifiersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AbstractMethodDeclaration)
         if ok {
            return my.dispatch.VisitAbstractMethodDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifiers)
         if ok {
            return my.dispatch.VisitAbstractMethodModifiersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeDeclaration)
         if ok {
            return my.dispatch.VisitAnnotationTypeDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeBody)
         if ok {
            return my.dispatch.VisitAnnotationTypeBodyWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclarations)
         if ok {
            return my.dispatch.VisitAnnotationTypeElementDeclarationsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*DefaultValue)
         if ok {
            return my.dispatch.VisitDefaultValueWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Annotations)
         if ok {
            return my.dispatch.VisitAnnotationsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*NormalAnnotation)
         if ok {
            return my.dispatch.VisitNormalAnnotationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ElementValuePairs)
         if ok {
            return my.dispatch.VisitElementValuePairsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ElementValuePair)
         if ok {
            return my.dispatch.VisitElementValuePairWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ElementValueArrayInitializer)
         if ok {
            return my.dispatch.VisitElementValueArrayInitializerWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ElementValues)
         if ok {
            return my.dispatch.VisitElementValuesWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MarkerAnnotation)
         if ok {
            return my.dispatch.VisitMarkerAnnotationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SingleElementAnnotation)
         if ok {
            return my.dispatch.VisitSingleElementAnnotationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArrayInitializer)
         if ok {
            return my.dispatch.VisitArrayInitializerWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*VariableInitializers)
         if ok {
            return my.dispatch.VisitVariableInitializersWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Block)
         if ok {
            return my.dispatch.VisitBlockWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*BlockStatements)
         if ok {
            return my.dispatch.VisitBlockStatementsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LocalVariableDeclarationStatement)
         if ok {
            return my.dispatch.VisitLocalVariableDeclarationStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LocalVariableDeclaration)
         if ok {
            return my.dispatch.VisitLocalVariableDeclarationWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*IfThenStatement)
         if ok {
            return my.dispatch.VisitIfThenStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*IfThenElseStatement)
         if ok {
            return my.dispatch.VisitIfThenElseStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*IfThenElseStatementNoShortIf)
         if ok {
            return my.dispatch.VisitIfThenElseStatementNoShortIfWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EmptyStatement)
         if ok {
            return my.dispatch.VisitEmptyStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LabeledStatement)
         if ok {
            return my.dispatch.VisitLabeledStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LabeledStatementNoShortIf)
         if ok {
            return my.dispatch.VisitLabeledStatementNoShortIfWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExpressionStatement)
         if ok {
            return my.dispatch.VisitExpressionStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SwitchStatement)
         if ok {
            return my.dispatch.VisitSwitchStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SwitchBlock)
         if ok {
            return my.dispatch.VisitSwitchBlockWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SwitchBlockStatementGroups)
         if ok {
            return my.dispatch.VisitSwitchBlockStatementGroupsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SwitchBlockStatementGroup)
         if ok {
            return my.dispatch.VisitSwitchBlockStatementGroupWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SwitchLabels)
         if ok {
            return my.dispatch.VisitSwitchLabelsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*WhileStatement)
         if ok {
            return my.dispatch.VisitWhileStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*WhileStatementNoShortIf)
         if ok {
            return my.dispatch.VisitWhileStatementNoShortIfWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*DoStatement)
         if ok {
            return my.dispatch.VisitDoStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*BasicForStatement)
         if ok {
            return my.dispatch.VisitBasicForStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ForStatementNoShortIf)
         if ok {
            return my.dispatch.VisitForStatementNoShortIfWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*StatementExpressionList)
         if ok {
            return my.dispatch.VisitStatementExpressionListWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EnhancedForStatement)
         if ok {
            return my.dispatch.VisitEnhancedForStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*BreakStatement)
         if ok {
            return my.dispatch.VisitBreakStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ContinueStatement)
         if ok {
            return my.dispatch.VisitContinueStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ReturnStatement)
         if ok {
            return my.dispatch.VisitReturnStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ThrowStatement)
         if ok {
            return my.dispatch.VisitThrowStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SynchronizedStatement)
         if ok {
            return my.dispatch.VisitSynchronizedStatementWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Catches)
         if ok {
            return my.dispatch.VisitCatchesWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*CatchClause)
         if ok {
            return my.dispatch.VisitCatchClauseWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Finally)
         if ok {
            return my.dispatch.VisitFinallyWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArgumentList)
         if ok {
            return my.dispatch.VisitArgumentListWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*DimExprs)
         if ok {
            return my.dispatch.VisitDimExprsWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*DimExpr)
         if ok {
            return my.dispatch.VisitDimExprWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PostIncrementExpression)
         if ok {
            return my.dispatch.VisitPostIncrementExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PostDecrementExpression)
         if ok {
            return my.dispatch.VisitPostDecrementExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PreIncrementExpression)
         if ok {
            return my.dispatch.VisitPreIncrementExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PreDecrementExpression)
         if ok {
            return my.dispatch.VisitPreDecrementExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AndExpression)
         if ok {
            return my.dispatch.VisitAndExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExclusiveOrExpression)
         if ok {
            return my.dispatch.VisitExclusiveOrExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InclusiveOrExpression)
         if ok {
            return my.dispatch.VisitInclusiveOrExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConditionalAndExpression)
         if ok {
            return my.dispatch.VisitConditionalAndExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConditionalOrExpression)
         if ok {
            return my.dispatch.VisitConditionalOrExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConditionalExpression)
         if ok {
            return my.dispatch.VisitConditionalExpressionWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Assignment)
         if ok {
            return my.dispatch.VisitAssignmentWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Commaopt)
         if ok {
            return my.dispatch.VisitCommaoptWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Ellipsisopt)
         if ok {
            return my.dispatch.VisitEllipsisoptWithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction0)
         if ok {
            return my.dispatch.VisitLPGUserAction0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction1)
         if ok {
            return my.dispatch.VisitLPGUserAction1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction2)
         if ok {
            return my.dispatch.VisitLPGUserAction2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction3)
         if ok {
            return my.dispatch.VisitLPGUserAction3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*LPGUserAction4)
         if ok {
            return my.dispatch.VisitLPGUserAction4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*IntegralType0)
         if ok {
            return my.dispatch.VisitIntegralType0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*IntegralType1)
         if ok {
            return my.dispatch.VisitIntegralType1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*IntegralType2)
         if ok {
            return my.dispatch.VisitIntegralType2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*IntegralType3)
         if ok {
            return my.dispatch.VisitIntegralType3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*IntegralType4)
         if ok {
            return my.dispatch.VisitIntegralType4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FloatingPointType0)
         if ok {
            return my.dispatch.VisitFloatingPointType0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FloatingPointType1)
         if ok {
            return my.dispatch.VisitFloatingPointType1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*WildcardBounds0)
         if ok {
            return my.dispatch.VisitWildcardBounds0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*WildcardBounds1)
         if ok {
            return my.dispatch.VisitWildcardBounds1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassModifier0)
         if ok {
            return my.dispatch.VisitClassModifier0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassModifier1)
         if ok {
            return my.dispatch.VisitClassModifier1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassModifier2)
         if ok {
            return my.dispatch.VisitClassModifier2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassModifier3)
         if ok {
            return my.dispatch.VisitClassModifier3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassModifier4)
         if ok {
            return my.dispatch.VisitClassModifier4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassModifier5)
         if ok {
            return my.dispatch.VisitClassModifier5WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassModifier6)
         if ok {
            return my.dispatch.VisitClassModifier6WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldModifier0)
         if ok {
            return my.dispatch.VisitFieldModifier0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldModifier1)
         if ok {
            return my.dispatch.VisitFieldModifier1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldModifier2)
         if ok {
            return my.dispatch.VisitFieldModifier2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldModifier3)
         if ok {
            return my.dispatch.VisitFieldModifier3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldModifier4)
         if ok {
            return my.dispatch.VisitFieldModifier4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldModifier5)
         if ok {
            return my.dispatch.VisitFieldModifier5WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldModifier6)
         if ok {
            return my.dispatch.VisitFieldModifier6WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodDeclarator0)
         if ok {
            return my.dispatch.VisitMethodDeclarator0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodDeclarator1)
         if ok {
            return my.dispatch.VisitMethodDeclarator1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier0)
         if ok {
            return my.dispatch.VisitMethodModifier0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier1)
         if ok {
            return my.dispatch.VisitMethodModifier1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier2)
         if ok {
            return my.dispatch.VisitMethodModifier2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier3)
         if ok {
            return my.dispatch.VisitMethodModifier3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier4)
         if ok {
            return my.dispatch.VisitMethodModifier4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier5)
         if ok {
            return my.dispatch.VisitMethodModifier5WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier6)
         if ok {
            return my.dispatch.VisitMethodModifier6WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier7)
         if ok {
            return my.dispatch.VisitMethodModifier7WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodModifier8)
         if ok {
            return my.dispatch.VisitMethodModifier8WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier0)
         if ok {
            return my.dispatch.VisitConstructorModifier0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier1)
         if ok {
            return my.dispatch.VisitConstructorModifier1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstructorModifier2)
         if ok {
            return my.dispatch.VisitConstructorModifier2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation0)
         if ok {
            return my.dispatch.VisitExplicitConstructorInvocation0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation1)
         if ok {
            return my.dispatch.VisitExplicitConstructorInvocation1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExplicitConstructorInvocation2)
         if ok {
            return my.dispatch.VisitExplicitConstructorInvocation2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier0)
         if ok {
            return my.dispatch.VisitInterfaceModifier0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier1)
         if ok {
            return my.dispatch.VisitInterfaceModifier1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier2)
         if ok {
            return my.dispatch.VisitInterfaceModifier2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier3)
         if ok {
            return my.dispatch.VisitInterfaceModifier3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier4)
         if ok {
            return my.dispatch.VisitInterfaceModifier4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*InterfaceModifier5)
         if ok {
            return my.dispatch.VisitInterfaceModifier5WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExtendsInterfaces0)
         if ok {
            return my.dispatch.VisitExtendsInterfaces0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ExtendsInterfaces1)
         if ok {
            return my.dispatch.VisitExtendsInterfaces1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstantModifier0)
         if ok {
            return my.dispatch.VisitConstantModifier0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstantModifier1)
         if ok {
            return my.dispatch.VisitConstantModifier1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ConstantModifier2)
         if ok {
            return my.dispatch.VisitConstantModifier2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifier0)
         if ok {
            return my.dispatch.VisitAbstractMethodModifier0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AbstractMethodModifier1)
         if ok {
            return my.dispatch.VisitAbstractMethodModifier1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclaration0)
         if ok {
            return my.dispatch.VisitAnnotationTypeElementDeclaration0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AnnotationTypeElementDeclaration1)
         if ok {
            return my.dispatch.VisitAnnotationTypeElementDeclaration1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssertStatement0)
         if ok {
            return my.dispatch.VisitAssertStatement0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssertStatement1)
         if ok {
            return my.dispatch.VisitAssertStatement1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SwitchLabel0)
         if ok {
            return my.dispatch.VisitSwitchLabel0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SwitchLabel1)
         if ok {
            return my.dispatch.VisitSwitchLabel1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*SwitchLabel2)
         if ok {
            return my.dispatch.VisitSwitchLabel2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TryStatement0)
         if ok {
            return my.dispatch.VisitTryStatement0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*TryStatement1)
         if ok {
            return my.dispatch.VisitTryStatement1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray0)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray1)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray2)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray3)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*PrimaryNoNewArray4)
         if ok {
            return my.dispatch.VisitPrimaryNoNewArray4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Literal0)
         if ok {
            return my.dispatch.VisitLiteral0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Literal1)
         if ok {
            return my.dispatch.VisitLiteral1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Literal2)
         if ok {
            return my.dispatch.VisitLiteral2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Literal3)
         if ok {
            return my.dispatch.VisitLiteral3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Literal4)
         if ok {
            return my.dispatch.VisitLiteral4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Literal5)
         if ok {
            return my.dispatch.VisitLiteral5WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Literal6)
         if ok {
            return my.dispatch.VisitLiteral6WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*BooleanLiteral0)
         if ok {
            return my.dispatch.VisitBooleanLiteral0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*BooleanLiteral1)
         if ok {
            return my.dispatch.VisitBooleanLiteral1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassInstanceCreationExpression0)
         if ok {
            return my.dispatch.VisitClassInstanceCreationExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ClassInstanceCreationExpression1)
         if ok {
            return my.dispatch.VisitClassInstanceCreationExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression0)
         if ok {
            return my.dispatch.VisitArrayCreationExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression1)
         if ok {
            return my.dispatch.VisitArrayCreationExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression2)
         if ok {
            return my.dispatch.VisitArrayCreationExpression2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArrayCreationExpression3)
         if ok {
            return my.dispatch.VisitArrayCreationExpression3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Dims0)
         if ok {
            return my.dispatch.VisitDims0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*Dims1)
         if ok {
            return my.dispatch.VisitDims1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldAccess0)
         if ok {
            return my.dispatch.VisitFieldAccess0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldAccess1)
         if ok {
            return my.dispatch.VisitFieldAccess1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*FieldAccess2)
         if ok {
            return my.dispatch.VisitFieldAccess2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation0)
         if ok {
            return my.dispatch.VisitMethodInvocation0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation1)
         if ok {
            return my.dispatch.VisitMethodInvocation1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation2)
         if ok {
            return my.dispatch.VisitMethodInvocation2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation3)
         if ok {
            return my.dispatch.VisitMethodInvocation3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MethodInvocation4)
         if ok {
            return my.dispatch.VisitMethodInvocation4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArrayAccess0)
         if ok {
            return my.dispatch.VisitArrayAccess0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ArrayAccess1)
         if ok {
            return my.dispatch.VisitArrayAccess1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*UnaryExpression0)
         if ok {
            return my.dispatch.VisitUnaryExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*UnaryExpression1)
         if ok {
            return my.dispatch.VisitUnaryExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*UnaryExpressionNotPlusMinus0)
         if ok {
            return my.dispatch.VisitUnaryExpressionNotPlusMinus0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*UnaryExpressionNotPlusMinus1)
         if ok {
            return my.dispatch.VisitUnaryExpressionNotPlusMinus1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*CastExpression0)
         if ok {
            return my.dispatch.VisitCastExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*CastExpression1)
         if ok {
            return my.dispatch.VisitCastExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression0)
         if ok {
            return my.dispatch.VisitMultiplicativeExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression1)
         if ok {
            return my.dispatch.VisitMultiplicativeExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*MultiplicativeExpression2)
         if ok {
            return my.dispatch.VisitMultiplicativeExpression2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AdditiveExpression0)
         if ok {
            return my.dispatch.VisitAdditiveExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AdditiveExpression1)
         if ok {
            return my.dispatch.VisitAdditiveExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ShiftExpression0)
         if ok {
            return my.dispatch.VisitShiftExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ShiftExpression1)
         if ok {
            return my.dispatch.VisitShiftExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*ShiftExpression2)
         if ok {
            return my.dispatch.VisitShiftExpression2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression0)
         if ok {
            return my.dispatch.VisitRelationalExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression1)
         if ok {
            return my.dispatch.VisitRelationalExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression2)
         if ok {
            return my.dispatch.VisitRelationalExpression2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression3)
         if ok {
            return my.dispatch.VisitRelationalExpression3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*RelationalExpression4)
         if ok {
            return my.dispatch.VisitRelationalExpression4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EqualityExpression0)
         if ok {
            return my.dispatch.VisitEqualityExpression0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*EqualityExpression1)
         if ok {
            return my.dispatch.VisitEqualityExpression1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator0)
         if ok {
            return my.dispatch.VisitAssignmentOperator0WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator1)
         if ok {
            return my.dispatch.VisitAssignmentOperator1WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator2)
         if ok {
            return my.dispatch.VisitAssignmentOperator2WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator3)
         if ok {
            return my.dispatch.VisitAssignmentOperator3WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator4)
         if ok {
            return my.dispatch.VisitAssignmentOperator4WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator5)
         if ok {
            return my.dispatch.VisitAssignmentOperator5WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator6)
         if ok {
            return my.dispatch.VisitAssignmentOperator6WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator7)
         if ok {
            return my.dispatch.VisitAssignmentOperator7WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator8)
         if ok {
            return my.dispatch.VisitAssignmentOperator8WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator9)
         if ok {
            return my.dispatch.VisitAssignmentOperator9WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator10)
         if ok {
            return my.dispatch.VisitAssignmentOperator10WithResultArgument(n2,o)
          }
        }
        {
         var n2,ok =n.(*AssignmentOperator11)
         if ok {
            return my.dispatch.VisitAssignmentOperator11WithResultArgument(n2,o)
          }
        }
    return nil
    }
func AnyCastToAbstractResultVisitor(i interface{}) *AbstractResultVisitor {
	if nil == i{
		return nil
	}else{
		return i.(*AbstractResultVisitor)
	}
}

